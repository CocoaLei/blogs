<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/blogs/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blogs/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/blogs/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/blogs/images/logo.svg" color="#222">

<link rel="stylesheet" href="/blogs/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/blogs/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"blog.chenglei.tech","root":"/blogs/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="JavaScript 简介JavaScript 诞生于 1995 年，当时， 它的主要目的是处理以前由服务器端语言负责的一些输入验证操作。而今，JavaScript 已经从一个简单的输入验证器发展成为一门强大的编程语言：功能全面，能够处理复杂的计算和交互，拥有了闭包、匿名函数，甚至元编程等特性。 虽然 JavaScript 和 ECMAScript 通常被人们用来表达相同的含义，但 JavaScr">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaScript 高级程序设计 - 基础概念篇">
<meta property="og:url" content="https://blog.chenglei.tech/blogs/2017/05/01/javascript-advanced-programming-basic/index.html">
<meta property="og:site_name" content="CocoaLei">
<meta property="og:description" content="JavaScript 简介JavaScript 诞生于 1995 年，当时， 它的主要目的是处理以前由服务器端语言负责的一些输入验证操作。而今，JavaScript 已经从一个简单的输入验证器发展成为一门强大的编程语言：功能全面，能够处理复杂的计算和交互，拥有了闭包、匿名函数，甚至元编程等特性。 虽然 JavaScript 和 ECMAScript 通常被人们用来表达相同的含义，但 JavaScr">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2017-04-30T16:00:00.000Z">
<meta property="article:modified_time" content="2018-08-08T07:26:49.000Z">
<meta property="article:author" content="CocoaLei">
<meta property="article:tag" content="Web">
<meta property="article:tag" content=" JavaScript">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://blog.chenglei.tech/blogs/2017/05/01/javascript-advanced-programming-basic/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>JavaScript 高级程序设计 - 基础概念篇 | CocoaLei</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/blogs/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">CocoaLei</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/blogs/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/blogs/categories" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/blogs/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.chenglei.tech/blogs/2017/05/01/javascript-advanced-programming-basic/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blogs/images/avatar.gif">
      <meta itemprop="name" content="CocoaLei">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CocoaLei">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          JavaScript 高级程序设计 - 基础概念篇
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-05-01 00:00:00" itemprop="dateCreated datePublished" datetime="2017-05-01T00:00:00+08:00">2017-05-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2018-08-08 15:26:49" itemprop="dateModified" datetime="2018-08-08T15:26:49+08:00">2018-08-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/Web/" itemprop="url" rel="index"><span itemprop="name">Web</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="JavaScript-简介"><a href="#JavaScript-简介" class="headerlink" title="JavaScript 简介"></a>JavaScript 简介</h2><p>JavaScript 诞生于 1995 年，当时， 它的主要目的是处理以前由服务器端语言负责的一些输入验证操作。而今，JavaScript 已经从一个简单的输入验证器发展成为一门强大的编程语言：功能全面，能够处理复杂的计算和交互，拥有了闭包、匿名函数，甚至元编程等特性。</p>
<p>虽然 JavaScript 和 ECMAScript 通常被人们用来表达相同的含义，但 JavaScript 的含义却又要多得多。一个完整的 JavaScript 实例由 ECMAScript、DOM 和 BOM 组成。</p>
<h3 id="ECMAScript"><a href="#ECMAScript" class="headerlink" title="ECMAScript"></a>ECMAScript</h3><p>ECMAScript-262 定义的 ECMAScript 与 Web 浏览器没有依赖关系，它定义的只是这门语言的基础，而在此基础上可以构建更完善的脚本语言。常见的 Web 浏览器只是 ECMAScript 实现可能的宿主环境之一 ： 宿主环境提供基本的 ECMAScript 实现，同时也会提供该语言的扩展，以便语言与环境之间对接交互。</p>
<h3 id="文档对象模型-DOM"><a href="#文档对象模型-DOM" class="headerlink" title="文档对象模型 DOM"></a>文档对象模型 DOM</h3><p>文档对象模型（DOM，Document Object Model）是针对 XML 但经过扩展用于 HTML 的应用程序编程接口。DOM 把整个页面映射为一个多层节点结构。即 HTML 或 XML 页面中的每个组成部分都是某种类型的节点，这些节点又包含着不同类型的数据。而开发人员通过 DOM 提供的 API 可以轻松自如的删除、添加或修改任何节点。</p>
<h3 id="浏览器对象模型-BOM"><a href="#浏览器对象模型-BOM" class="headerlink" title="浏览器对象模型 BOM"></a>浏览器对象模型 BOM</h3><p>浏览器对象模型使开发人员可以控制浏览器显示的页面以外的部分。从根本上讲，BOM 只处理浏览器窗口和框架，但是人们习惯上也把所有针对浏览器的 JavaScript· 扩展算作 BOM 的一部分。</p>
<h2 id="在-HTML-中使用-JavaScript"><a href="#在-HTML-中使用-JavaScript" class="headerlink" title="在 HTML 中使用 JavaScript"></a>在 HTML 中使用 JavaScript</h2><p>向 HTML 页面中插入 JavaScript 的主要方法，就是使用 <code>&lt;script&gt;</code> 元素。这个元素由 Netscape 创造并在 Netscape Navigator 2 中首先实现。后来，这个元素被加入到正式的 HTML 规范中。HTML 4.01 为 <code>&lt;script&gt;</code> 定义了6个属性</p>
<ul>
<li><code>async</code> : 表示应该立即下载脚本，但不应妨碍页面中的其它操作。这是一个可选属性，只对外部脚本文件有效。</li>
<li><code>charset</code> : 可选。表示通过 <code>src</code> 属性指定的代码的字符集。</li>
<li><code>defer</code> : 可选。表示脚本可以延迟到文档完全被解析和显示之后再执行。只对外部脚本文件有效。</li>
<li><code>language</code> : 已废弃。原来用于表示编写代码使用的脚本语言。</li>
<li><code>src</code> ：可选。表示包含要执行代码的外部文件。</li>
<li><code>type</code> : 可选。可以看成是 <code>language</code> 的替代属性；表示编写代码使用的脚本语言的内容类型（MIME 类型）。虽然 <code>text/javscript</code> 和 <code>text/ecmascript</code> 都已经不被推荐使用，但人们一直以来使用的都还是 <code>text/javascript</code> 。实际上，服务器在传送 JavaScript 文件时使用的是 MIME 类型通常是 <code>application/x-javascript</code> , 但在 <code>type</code> 中设置这个值却可能导致脚本被忽略。考虑到约定俗成和最大限度的浏览器兼容性，目前 <code>type</code> 属性的默认值依旧还是 <code>text/javascript</code>。</li>
</ul>
<p>使用 <code>&lt;script&gt;</code> 元素的方式有两种 ：直接在页面中嵌入 JavaScript 代码和包含外部 JavaScript 文件。</p>
<p>在使用 <code>&lt;script&gt;</code> 元素嵌入 JavaScript 代码时，只需为 <code>&lt;script&gt;</code> 指定 <code>type</code> 属性，然后直接把 JavaScript 代码放在元素内部即可。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">	<span class="comment">// JavaScript Code</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>包含在 <code>&lt;script&gt;</code> 元素内部的 JavaScript 代码将被从上到下依次解释。在解释器对 <code>&lt;scirpt&gt;</code> 元素内部的所有代码求值完毕以前，页面中的其余内容都不会被浏览器加载或显示。</p>
<p>如果要通过 <code>&lt;script&gt;</code> 元素来包含外部 JavaScript 文件，那么 <code>src</code> 属性就是必须的。这个属性的值是一个指向外部 JavaScript 文件的链接。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript src="</span><span class="attr">example.js</span>"&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>与解析嵌入式 JavaScript 代码一样，在解析外部 JavaScript 文件（包括下载该文件）时，页面的处理也会暂时停止。</p>
<p>无论如何包含代码，只要不存在 <code>defer</code> 和 <code>async</code> 属性，浏览器都会按照 <code>&lt;script&gt;</code> 元素在页面中出现的先后顺序对它们依次进行解析。</p>
<p>因此，在包含较多外部 JavaScript 文件的 HTML 页面中，将 <code>&lt;script&gt;</code> 标签放在 <code>&lt;head&gt;</code> 元素中，可能会造成严重的延迟。一般通过将全部 JavaScript 引用放在 <code>&lt;body&gt;</code> 元素中页面内容的后面。</p>
<p>在 HTML 中嵌入 JavaScript 代码虽然没有问题，但一般认为最好的做法还是尽可能使用外部文件来包含 JavaScript 代码。</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>任何语言的核心都必然会描述这门语言最基本的工作原理，而描述的内容通常都要涉及这门语言的语法、操作符、数据类型、内置功能等用于构建复杂解决方案的基本概念。</p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>ECMAScript 的语法大量借鉴了 C 及其它类 C 语言的语法。</p>
<h4 id="区分大小写"><a href="#区分大小写" class="headerlink" title="区分大小写"></a>区分大小写</h4><p>ECMAScript 中的一切都区分大小写（变量、函数名和操作符）。</p>
<h4 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h4><p>所谓标识符，就是指变量、函数、属性的名字，或者函数的参数。标识符的组合规则如下：</p>
<ul>
<li>第一个字符必须是一个字母、下划线或一个美元符号；</li>
<li>其它字符可以是字母、下划线、美元符号或数字。</li>
</ul>
<p>按照惯例，ECMAScript 标识符采用驼峰大小写格式，也就是第一个字母小写，剩下的每个单词的首字母大写。</p>
<h4 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h4><p>ECMAScript 5 引入了严格模式的概念。严格模式是为 JavaScript 定义了一种不同的解析与执行模型。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;	<span class="comment">// 这是一个编译指示，用于告诉支持的 JavaScript 引擎切换到严格模式</span></span><br></pre></td></tr></table></figure>

<h4 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h4><p>ECMAScript 中的语句以一个分号结尾；如果省略分号，则由解析器确定语句的末尾。虽然语句末尾的分号不是必须的，但建议任何时候都不要省略它。</p>
<h3 id="关键字和保留字"><a href="#关键字和保留字" class="headerlink" title="关键字和保留字"></a>关键字和保留字</h3><p>ECMAScript 描述了一组具有特定用途的关键字，这些关键字可用于表示控制语句的开始或结束，或者用于执行特定操作，它们不能用作标识符。 ECMAScript 还描述了一组将来可能被用作关键字的保留字。</p>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>ECMAScript 的变量是松散类型的，所谓松散类型就死可以用来保存任何类型的数据。即每个变量仅仅是一个用于保存值得占位符。未被初始化的变量会保存一个特殊的值 ：<code>undefined</code> 。ECMAScript 也支持直接初始化变量。</p>
<p>修改变量的值得同时也可以同时修改值得类型，虽然这样做是可行而且有效的，但是并不推荐。</p>
<p>如果定义变量时省略了 var 操作符，变量将会被定义为全局变量。给未经声明的变量赋值在严格模式下会导致抛出 ReferenceError 错误。</p>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>ECMAScript 中有 5 中简单数据类型 ：Undefined、Null、Boolean、Number 和 String。还有一种复杂数据类型 - Object。ECMAScript 不支持任何创建自定义类型的机制，所有值最终都将是上述 6 种数据类型之一。</p>
<h4 id="typeof-操作符"><a href="#typeof-操作符" class="headerlink" title="typeof 操作符"></a><code>typeof</code> 操作符</h4><p>ECMAScript 是松散类型的，因此需要有一种手段来监测给定变量的数据类型，使用 <code>typeof</code> 可以完成这个目的。</p>
<ul>
<li>“undefined” : 未定义</li>
<li>“boolean” ：布尔值</li>
<li>“string” ：字符串</li>
<li>“number” ：数值</li>
<li>“object” ： 对象或 null</li>
<li>“function” ： 函数</li>
</ul>
<h4 id="Undefined-类型"><a href="#Undefined-类型" class="headerlink" title="Undefined 类型"></a><code>Undefined</code> 类型</h4><p>如果使用 var 声明变量但未对其加以初始化时，这个变量的值就是 <code>undefined</code> 。</p>
<p>值得注意的是，对未初始化的变量执行 <code>typeof</code> 操作符会返回 <code>undefined</code> 值，而对未声明的变量执行 <code>typeof</code> 同样也会返回 <code>undefined</code> 值。这两种变量虽然从技术角度上看有本质区别，但实际上无论对哪种变量也不可能执行真正的操作。</p>
<p>即便未初始化的变量会被自动赋予 <code>undefined</code> 值，但显式地初始化变量依然是明智的选择。如果能够做到这一点，那么当 <code>typeof</code> 返回 <code>undefined</code> 值时，我们就知道被检测的变量还没有被生命，而不是尚未初始化。</p>
<h3 id="Null-类型"><a href="#Null-类型" class="headerlink" title="Null 类型"></a><code>Null</code> 类型</h3><p>从逻辑角度来看，null 值表示一个空对象指针，而这也正是使用 <code>typeof</code> 操作符检测 <code>null</code> 值时会返回 “object” 的原因。</p>
<p>如果定义的变量准备在将来用于保存对象，那么最好将该变量初始化为 <code>null</code> 而不是其它值。这样一来，只要直接检查 <code>null</code> 值就可以知道相应的变量是否已经保存了一个对象对的引用。</p>
<p>实际上，<code>undefined</code> 是派生自 <code>null</code> 值得，因此规定它们的相等性测试返回 <code>true</code> 。</p>
<h4 id="Boolean-类型"><a href="#Boolean-类型" class="headerlink" title="Boolean 类型"></a><code>Boolean</code> 类型</h4><p>ECMAScript 中的 <code>Boolean</code> 类型只有两个字面值 ：<code>true</code> 和 <code>false</code> 。这两个值与数字值不是一回事，因此 <code>true</code> 不一定等于 1，而 <code>false</code> 也不一定等于 0 。</p>
<p>虽然 <code>Boolean</code> 类型的字面值只有两个，但 ECMAScript 中所有类型的值都有与这两个 <code>Boolean</code> 值等价的值。使用转型函数 <code>Boolean()</code> 可以将一个值转换为其对应的 <code>Boolean</code> 值。</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>转换为 <code>true</code> 的值</th>
<th>转换为 <code>false</code> 的值</th>
</tr>
</thead>
<tbody><tr>
<td>Boolean</td>
<td>true</td>
<td>false</td>
</tr>
<tr>
<td>String</td>
<td>任何非空字符串</td>
<td>“”（空字符串）</td>
</tr>
<tr>
<td>Number</td>
<td>任何非零数字值</td>
<td>0 和 NaN</td>
</tr>
<tr>
<td>Object</td>
<td>任何对象</td>
<td>null</td>
</tr>
<tr>
<td>Undefined</td>
<td>n/a</td>
<td>undefined</td>
</tr>
</tbody></table>
<h4 id="Number-类型"><a href="#Number-类型" class="headerlink" title="Number 类型"></a><code>Number</code> 类型</h4><p>ECMAScript 中的 <code>Number</code> 类型使用 IEEE754 格式来表示整数和浮点数值。为了支持各种数值类型，ECMA 定义了不同的数值字面量格式。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> intNum = <span class="number">55</span>;	<span class="comment">// 整数</span></span><br><span class="line"><span class="keyword">var</span> octalNum = <span class="number">070</span>;	<span class="comment">// 八进制整数 56</span></span><br><span class="line"><span class="keyword">var</span> hexNum = <span class="number">0xA</span>;	<span class="comment">// 十六进制整数 10</span></span><br></pre></td></tr></table></figure>

<p>需要注意的是，八进制字面量在严格模式下是无效的，会导致支持的 JavaScript 引擎抛出错误。</p>
<p>在进行算数运算时，所有以八进制和十六进制表示的数值最终都将被转换为十进制数值。</p>
<h5 id="浮点数值"><a href="#浮点数值" class="headerlink" title="浮点数值"></a>浮点数值</h5><p>保存浮点数值需要的内存空间是保存整数值的两倍，ECMAScript 会不失时机的将浮点数值转换为整数值。</p>
<p>对于那些极大或极小的数值，可以用科学表示法表示的浮点数值表示。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> floatNum = <span class="number">3.14e7</span>;	<span class="comment">// 等价于 3.14 * 10^7</span></span><br></pre></td></tr></table></figure>

<p>浮点数值的最高精度是17位小数，但在进行算数运算时其精确度远远不如整数。例如，0.1 加 0.2 的结果不是 0.3， 而是 0.30000000000000004 。这个舍入误差会导致无法测试特定的浮点数值。</p>
<h5 id="数值范围"><a href="#数值范围" class="headerlink" title="数值范围"></a>数值范围</h5><p>由于内存的限制，ECMAScript 并不能保存所有的数值。它能够表示的最小数值为 <code>Number.MIN_VALUE</code> ，在大多数浏览器中，这个值是 <code>5e-234</code> 。能够表示的最大数值为 <code>Number.MAX_VALUE</code> ，在大多数浏览器中，这个值是 <code>1.976931348623157e+308</code> 。如果某次计算的结果得到了一个 超出 JavaScript 数值范围的值，那么这个数值将被自动转换为特殊的 <code>Infinity</code> 值。如果某次计算返回了正或负的 <code>Infinity</code> 值，那么该值将无法继续参与下一次的计算，因为 <code>Infinity</code> 不是能够参与计算的数值。</p>
<p>可以使用 <code>isFinite()</code> 函数确定一个数值是不是无穷的。</p>
<h5 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a>NaN</h5><p>NaN，即非数值，它是一个特殊的数值，这个数值用于表示一个本来要返回数值的操作数未返回数值的情况。比如在 ECMAScript 中，0 除以 0 会返回 NaN，正数除以 0 会返回 <code>Infinity</code> ，负数除以 0 返回 <code>-Infinity</code>。</p>
<p>NaN 本省有两个非同寻常的特点。</p>
<p>首先，任何涉及 NaN 的操作都会返回 NaN，这个特点在多步计算中可能导致问题。</p>
<p>其次，NaN 与任何值都不相等，包括 NaN 本身。</p>
<p>针对 NaN 的特点，ECMAScript 定义了 <code>isNaN()</code> 函数。这个函数接受一个参数，该参数可以是任何类型，而函数会帮我们确定这个参数是否 “不是数值”。 <code>isNaN()</code> 在接收到一个值后，会尝试将这个值转换为数值。某些不是数值的值会直接转换为数值，而任何不能被转换为数值的值都会导致这个函数返回 <code>true</code> 。</p>
<h5 id="数值转换"><a href="#数值转换" class="headerlink" title="数值转换"></a>数值转换</h5><p>有三个函数可以将非数值转换为数值 ：<code>Number()</code> , <code>paresInt()</code> , <code>parseFloat()</code> 。<code>Number()</code> 可以用于任何数据类型，而 <code>parseInt()</code> , <code>parseFloat()</code> 则用于把字符串转换成数值。</p>
<p><code>Number()</code> 函数的转换规则如下 ：</p>
<ul>
<li><code>true</code> 和 <code>false</code> 将分别转换为 1 和 0</li>
<li><code>null</code> 返回 0</li>
<li><code>undefined</code> 返回 NaN</li>
<li>如果是字符串，则<ul>
<li>如果只包含数字，返回十进制数值</li>
<li>如果为十六进制格式，返回相同大小的十进制数值</li>
<li>如果是空字符串，则返回 0</li>
<li>如果包含除上述格式之外的字符，返回 NaN</li>
</ul>
</li>
</ul>
<p>由于 <code>Number()</code> 函数在转换字符串时比较复杂而且不够合理，因此处理整数的时候更常用的是 <code>parseInt()</code> 函数。它会忽略字符串前面的空格，直到找到第一个非空格字符。如果第一个字符不是数字字符或者负号，则返回 NaN。如果第一个字符是数字字符，<code>parseInt()</code> 会继续解析第二个字符，直到解析玩所有后续字符或者遇到了一个非数字字符。</p>
<p>需要注意的是，”1.1” 这样的字符串会被 <code>parseInt()</code> 转换为 1 ，因为小数点并不是有效的数字字符。</p>
<p>还可以为 <code>parseInt()</code> 函数指定第二个参数 ：转换时使用的基数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="built_in">parseInt</span>(<span class="string">"0xAF"</span>, <span class="number">16</span>);	<span class="comment">// 以十六进制转换字符串</span></span><br></pre></td></tr></table></figure>

<p>与 <code>parseInt()</code> 不同的是，<code>parseFloat()</code> 只解析十进制值。</p>
<h4 id="String-类型"><a href="#String-类型" class="headerlink" title="String 类型"></a>String 类型</h4><p>String 类型用于表示由零活多个 16 位 Unicode 字符组成的字符序列，即字符串。字符串可以由双引号或单引号表示。</p>
<h5 id="字符字面量"><a href="#字符字面量" class="headerlink" title="字符字面量"></a>字符字面量</h5><p>String 数据类型包含一些特殊的字符字面量，也叫转移序列，用于表示非打印字符，或者具有其它用途的字符。</p>
<table>
<thead>
<tr>
<th>字面量</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>\n</code></td>
<td>换行</td>
</tr>
<tr>
<td><code>\t</code></td>
<td>制表</td>
</tr>
<tr>
<td><code>\b</code></td>
<td>空格</td>
</tr>
<tr>
<td><code>\r</code></td>
<td>回车</td>
</tr>
<tr>
<td><code>\\</code></td>
<td>斜杠</td>
</tr>
<tr>
<td><code>\&#39;</code></td>
<td>单引号</td>
</tr>
<tr>
<td><code>\&quot;</code></td>
<td>双引号</td>
</tr>
<tr>
<td><code>\xnn</code></td>
<td>以十六进制代码表示的一个字符</td>
</tr>
<tr>
<td><code>\unnn</code></td>
<td>以十六进制代码表示的一个 Unicode 字符</td>
</tr>
<tr>
<td><code>\f</code></td>
<td>进纸</td>
</tr>
</tbody></table>
<p>这些字符字面量可以出现在字符串中的任意位置，而且也将被作为也给字符来解析。</p>
<h5 id="字符串的特点"><a href="#字符串的特点" class="headerlink" title="字符串的特点"></a>字符串的特点</h5><p>ECMAScript 中的字符串是不可变的，也就是说，字符串一旦创建，它们的值就不能改变。要改变某个变量保存的字符串，首先要销毁原来的字符串，然后再用另一个包含新值得字符串填充该变量。</p>
<h5 id="转换为字符串"><a href="#转换为字符串" class="headerlink" title="转换为字符串"></a>转换为字符串</h5><p>几乎每个值都有 <code>toString()</code> 方法，它将返回相应值得字符串表现（<code>null</code> 和 <code>undefined</code> 没有这个方法 ）。多数情况下，调用 <code>toString()</code> 方法不必传递参数，但是在调用数值的 <code>toString()</code> 方法时，可以传递一个表示输出数值基数的参数。</p>
<p>在不知道要转换的值是不是 <code>null</code> 或 <code>undefined</code> 的情况下，还可以使用转型函数 <code>String()</code> ，这个函数能够将任何类型的值转换为字符串 ：</p>
<ul>
<li>如果值有 <code>toString()</code> 方法，则调用该方法</li>
<li>如果值是 <code>null</code> ，则返回 “null”</li>
<li>如果值是 “undefined” ，则返回 “undefined”</li>
</ul>
<h4 id="Object-类型"><a href="#Object-类型" class="headerlink" title="Object 类型"></a>Object 类型</h4><p>ECMAScript 中的对象其实就是一组数据和功能的集合。对象可以通过执行 <code>new</code> 操作符后跟要创建的对象类型的名称来创建。而创建 <code>Object</code> 类型的实力并为其添加属性和方法，就可以创建自定义对象。</p>
<p>在 ECMAScript 中，<code>Object</code> 类型是所有它的实例的基础。</p>
<p><code>Object</code> 的每个实例都具有下列属性和方法 ：</p>
<ul>
<li><code>constructor</code> : 保存着用于创建当前对象的函数。</li>
<li><code>hasOwnProperty(propertyName)</code> : 用于检查给定的属性在当前的对象实例中是否存在。</li>
<li><code>isPrototypeOf(object)</code> : 用于检查传入的对象是否是传入的对象的原型。</li>
<li><code>propertyIsEnumerable(propertyName)</code> :  用于检查给定的属性是否能够使用 <code>for-in</code> 语句来枚举。</li>
<li><code>toLocalString()</code> : 返回与执行环境的地区对应的字符串表示。</li>
<li><code>toString()</code> : 返回对象的字符串表示。</li>
<li><code>valueOf()</code> : 返回对象的字符串、数值或布尔值表示。</li>
</ul>
<h3 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h3><h4 id="一元操作符"><a href="#一元操作符" class="headerlink" title="一元操作符"></a>一元操作符</h4><h5 id="递增和递减操作符"><a href="#递增和递减操作符" class="headerlink" title="递增和递减操作符"></a>递增和递减操作符</h5><p>前置递增/递减操作符，变量的值都是在包含它的语句被求值之前改变的，而后置递增/递减操作符的则是在包含它的语句被求值之后改变变量的值。</p>
<p>而且递增/递减操作符不仅适用于整数，还可以用于字符串、布尔值、浮点数职和对象 ：</p>
<ul>
<li>在应用于一个包含有效数字字符的字符串时，先将其转换为数字值，再执行加减 1 的操作。字符串变量变成数值变量。</li>
<li>在应用于一个不包含有效数字字符的字符串时，将变量的值设置为 NaN。字符串变量变成数值变量。</li>
<li>在应用于布尔值时，先将其转换为 1 或 0，再执行加减 1 的操作。布尔值变量变成数值变量。</li>
<li>在应用于对象时，先调用对象的 <code>valueOf()</code> 方法以取得一个可供操作的值。然后对该值应用前述规则。如果结果是 NaN，则在调用 <code>toString()</code> 方法后再应用前述规则。对象变量变成数值变量。</li>
</ul>
<h5 id="加和减操作符"><a href="#加和减操作符" class="headerlink" title="加和减操作符"></a>加和减操作符</h5><p><code>+</code> 放在数值之前，对数值不会产生影响。不过，对非数值应用 <code>+</code> 时，它会像 <code>Number()</code> 转型函数一样对这个值进行转换。</p>
<p><code>-</code> 主要用于表示负数。对非数值应用时，先转换为数值，再转换为负数。</p>
<h4 id="位操作符"><a href="#位操作符" class="headerlink" title="位操作符"></a>位操作符</h4><p>位操作符用于在最基本的层次上，即按内存中表示数值的位来操作数值。ECMAScript 中的所有数值都以 IEEE-754 64 位格式存储，但位操作符并不直接操作 64 位的值，而是先将 64 位的值转换成 32 位的整数，然后执行操作，最后再讲结果转换回 64 位。</p>
<p>对于有符号的整数，32 位中的前 32 位用来表示整数的值，第 32 位用于表示数值的符号 ：0 表示正数，1 表示负数。这个表示符号的位叫做符号位，符号位的值决定了其它位数值的格式。其中，正数以纯二进制格式存储，32 位中的每一位都表示 2 的幂，没有用到的位以 0 填充，即忽略不计。负数同样以二进制码存储，但使用的格式是二进制补码。</p>
<p>要注意的是，在处理有符号整数时，是不能访问位 31 的。</p>
<p>对数值进行位操作时，NaN 和 Infinity 会被当做 0 来处理。</p>
<blockquote>
<p>默认情况下，ECMAScript 中的所有整数都是有符号整数。不过，当然也存在无符号整数，对于无符号整数来说，第 32 位不再表示符号，因为无符号整数只能是整数。</p>
</blockquote>
<h5 id="按位非"><a href="#按位非" class="headerlink" title="按位非"></a>按位非</h5><p>按位非操作符由 <code>~</code> 表示，执行按位非的结果就是返回数值的反码。即操作数的负值减 1.</p>
<h5 id="按位与"><a href="#按位与" class="headerlink" title="按位与"></a>按位与</h5><p>按位与操作符由 <code>&amp;</code> 表示，它有两个操作符数。从本质上来讲，按位与操作就是将两个数值的每一位对齐，然后对相同位置上的两个数执行 AND 操作。</p>
<h5 id="按位或"><a href="#按位或" class="headerlink" title="按位或"></a>按位或</h5><p>按位或操作符由 <code>|</code> 表示，同样有两个操作数。从本质上来讲，按位或操作就是将两个数值的每一位对齐，然后对相同位置上的两个数执行 OR 操作。</p>
<h5 id="按位异或"><a href="#按位异或" class="headerlink" title="按位异或"></a>按位异或</h5><p>按位异或操作符由 <code>^</code> 表示，同样有两个操作数。从本质上来讲，按位异或操作就是将两个数值的每一位对齐，然后对相同位置上的两个数执行 XOR 操作。</p>
<h5 id="左移"><a href="#左移" class="headerlink" title="左移"></a>左移</h5><p>左移操作符由 <code>&lt;&lt;</code> 表示，它会将数值的所有位向左移动指定的位数，出现的空位用 0 进行填充。</p>
<p>注意，左移不会影响操作数的符号位。</p>
<h5 id="有符号右移"><a href="#有符号右移" class="headerlink" title="有符号右移"></a>有符号右移</h5><p>右移操作符由 <code>&gt;&gt;</code> 表示，它会将数值的所有位向右移动指定的位数，但保留符号位，原数值中出现的空位以符号位的值来填充所有空位。</p>
<h5 id="无符号右移"><a href="#无符号右移" class="headerlink" title="无符号右移"></a>无符号右移</h5><p>无符号左移由 <code>&lt;&lt;&lt;</code> 表示，它会将数值的所有 32 位都向右移动。对正数来说，无符号右移的结果与有符号右移相同。但对负数来说，其结果就不一样了，而且无符号右移会将负数的二进制码当成整数的二进制码，因此导致无符号右移后的结果非常之大。</p>
<h4 id="布尔操作符"><a href="#布尔操作符" class="headerlink" title="布尔操作符"></a>布尔操作符</h4><h5 id="逻辑非"><a href="#逻辑非" class="headerlink" title="逻辑非"></a>逻辑非</h5><p>逻辑非操作符由 <code>!</code> 表示，可以应用于 ECMAScript 中的任何值。无论这个值是什么数据类型，这个操作符都会返回一个布尔值。逻辑非操作符首先会将它的操作数转换为一个布尔值，然后再对其求反。</p>
<p>逻辑非操作符也可以用于讲一个值转换为与其对应的布尔值。而同时使用两个逻辑非操作符，实际上就会模拟 <code>Boolean()</code> 转型函数的行为。</p>
<h5 id="逻辑与"><a href="#逻辑与" class="headerlink" title="逻辑与"></a>逻辑与</h5><p>逻辑与操作符由 <code>&amp;&amp;</code> 表示，有两个操作数。逻辑与操作可以应用于任何类型的操作数，而不仅仅是布尔值。在有一个操作数不是布尔值的情况下，逻辑与操作就不一定返回布尔值 ：</p>
<ul>
<li>如果第一个操作数是对象，则返回第二个操作数</li>
<li>如果第二个操作数是对象，则只有在第一个操作数的求值结果为 <code>true</code> 的情况下才会返回该对象</li>
<li>如果两个操作数都是对象，则返回第二个操作数</li>
<li>如果有一个操作数是 <code>null</code> ,  <code>NaN</code>  或 <code>undefined</code>，则返回 <code>null</code> ,  <code>NaN</code>  或 <code>undefined</code></li>
</ul>
<p>逻辑与操作属于短路操作，即如果第一个操作数能够决定结果，那么就不会对第二个操作数求值。</p>
<p>注意，不能在逻辑与操作中使用未定义的值。</p>
<h5 id="逻辑或"><a href="#逻辑或" class="headerlink" title="逻辑或"></a>逻辑或</h5><p>逻辑或操作由 <code>||</code> 表示，有两个操作数。与逻辑与操作相似，如果有一个操作数不是布尔值，逻辑或也不一定返回布尔值 ：</p>
<ul>
<li>如果第一个操作数是对象，则返回第一个操作数</li>
<li>如果第一个操作数的求值结果为 <code>false</code> ，则返回第二个操作数</li>
<li>如果两个操作数都是对象，则返回第一个操作数</li>
<li>如果两个操作数都是 <code>null</code> ,  <code>NaN</code>  或 <code>undefined</code> ，则返回 <code>null</code> ,  <code>NaN</code>  或 <code>undefined</code></li>
</ul>
<p>逻辑或操作符也是短路操作符，也就是说，如果第一个操作数的求值结果为 <code>true</code> ，就不会对第二个操作数求值了。</p>
<h4 id="乘性操作符"><a href="#乘性操作符" class="headerlink" title="乘性操作符"></a>乘性操作符</h4><p>ECMAScript 定义了 3 个乘性操作符 ：乘法、除法和求模，在操作数为非数值的情况下会执行自动的类型转换。</p>
<h5 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h5><p>乘法操作符由 <code>*</code> 表示，用于计算两个数值的乘积。</p>
<ul>
<li>如果乘积结果超过了 ECMAScript 的数值表示范围，则返回 <code>Infinity</code> 或 <code>-Infinity</code></li>
<li>如果有一个操作数是 <code>NaN</code> ，则结果是 <code>NaN</code></li>
<li><code>Infinity</code> 与 0 相乘，结果是 <code>NaN</code></li>
<li><code>Infinity</code> 与非 0 数值相乘，结果是  <code>Infinity</code> 或 <code>-Infinity</code> ，取决于有符号操作数的符号</li>
<li>如果 <code>Infinity</code> 与 <code>Infinity</code> 相乘，则结果是 <code>Infinity</code></li>
<li>如果有一个操作数不是数值，则使用 <code>Number()</code> 将其转换为数值</li>
</ul>
<h5 id="除法"><a href="#除法" class="headerlink" title="除法"></a>除法</h5><p>除法操作符由 <code>/</code> 表示，执行第二个操作数除第一个操作数的计算。</p>
<ul>
<li>如果商超过了 ECMAScript 的数值表示范围，则返回 <code>Infinity</code> 或 <code>-Infinity</code></li>
<li>如果有一个操作数是 <code>NaN</code> ，则结果是 <code>NaN</code></li>
<li><code>Infinity</code> 被 <code>Infinity</code> 除，结果是 <code>NaN</code></li>
<li>如果 0 被 0 除，结果是 <code>NaN</code></li>
<li>如果非零的有限数被零除，则结果是 <code>Infinity</code> 或 <code>-Infinity</code> ，取决于有符号的操作数</li>
<li>如果 <code>Infinity</code> 被任何非 0 数值除，则结果是 <code>Infinity</code> 或 <code>-Infinity</code> ，取决于有符号的操作数</li>
<li>如果有一个操作数不是数值，则使用 <code>Number()</code> 将其转换为数值</li>
</ul>
<h5 id="求模"><a href="#求模" class="headerlink" title="求模"></a>求模</h5><p>求模操作符由 <code>%</code> 表示。</p>
<ul>
<li>如果被除数是无穷大值而出除数是有限大的数值，则结果是 <code>NaN</code></li>
<li>如果被除数是有限大的数值而除数是 0 ，则结果是 <code>NaN</code></li>
<li>如果是 <code>Infinity</code> 被 <code>Infinity</code> 除，则结果是 <code>NaN</code></li>
<li>如果被除数是有限大的数值而除数是无穷大的数值，则结果是被除数</li>
<li>如果被除数是 0 ，则结果是0</li>
<li>如果有一个操作数不是数值，则使用 <code>Number()</code> 将其转换为数值</li>
</ul>
<h4 id="加性操作符"><a href="#加性操作符" class="headerlink" title="加性操作符"></a>加性操作符</h4><h5 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h5><p>加法操作符由 <code>+</code> 表示。</p>
<p>如果两个操作数都是数值，执行常规的加法计算，然后按照下列规则返回结果 ：</p>
<ul>
<li>如果一个操作数是 <code>NaN</code> ，则结果是 <code>NaN</code></li>
<li>如果是 <code>Infinity</code> 加 <code>Infinity</code> ，则结果是 <code>Infinity</code></li>
<li>如果是 <code>-Infinity</code> 加 <code>-Infinity</code> ，则结果是 <code>-Infinity</code></li>
<li>如果是<code>Infinity</code> 加 <code>-Infinity</code> ，则结果是 <code>NaN</code></li>
</ul>
<p>如果有一个操作数是字符串 ：</p>
<ul>
<li>如果两个操作数都是字符串，则将它们拼接起来</li>
<li>如果只有一个操作数是字符串，则将另一个操作数转换为字符串，然后再将两个字符串拼接起来</li>
</ul>
<p>如果有一个操作数是对象、数值或布尔值，则调用它们的 <code>toString()</code> 方法取得相应的字符串值，然后再应用前述规则。</p>
<p>对于 <code>undefined</code> 和 <code>null</code> ，则分别调用 <code>String()</code> 函数并取得字符串 “undefined” 和 “null” 。</p>
<h5 id="减法"><a href="#减法" class="headerlink" title="减法"></a>减法</h5><p>减法操作符由 <code>-</code> 表示。</p>
<ul>
<li>如果有一个操作数是 <code>NaN</code> ，则结果是 <code>NaN</code></li>
<li>如果是 <code>Infinity</code> 减 <code>Infinity</code> ，则结果是 <code>NaN</code></li>
<li>如果是 <code>-Infinity</code> 减 <code>-Infinity</code> ，则结果是 <code>NaN</code></li>
<li>如果是 <code>Infinity</code> 减 <code>-Infinity</code> ，则结果是 <code>Infinity</code></li>
<li>如果是 <code>-Infinity</code> 减 <code>Infinity</code> ，则结果是  <code>Infinity</code></li>
<li>如果有一个操作数是字符串、布尔值、<code>null</code> 或 <code>undefined</code> ，则先调用 <code>Number()</code> 函数将其转换为数值，然后在按照前述规则执行减法计算。如果转换的结果是 <code>NaN</code> ，则减法的结果就是 <code>NaN</code></li>
<li>如果有一个操作数是对象，则调用对象的 <code>valueOf()</code> 方法以取得表示该对象的数值。如果得到的是 <code>NaN</code> ，则减法的结果就是 <code>NaN</code> 。如果对象没有 <code>valueOf()</code> 方法，则调用其 <code>toString()</code> 方法并将得到的字符串转换为数值</li>
</ul>
<h4 id="关系操作符"><a href="#关系操作符" class="headerlink" title="关系操作符"></a>关系操作符</h4><p>与 ECMAScript 中其它操作符一样，当关系操作符的操作数使用了非数值时，也要进行数据转换或完成某些奇怪的操作 ：</p>
<ul>
<li>如果两个操作数都是数值，则执行数值比较</li>
<li>如果两个操作数都是字符串，则比较两个字符串对应的字符编码值</li>
<li>如果一个操作数是数值，则将另一个操作数转换为一个数值，然后执行数值比较</li>
<li>如果一个操作数是对象，则调用这个对象的 <code>valueOf()</code> 方法，用得到的结果按照前述规则执行比较。如果对象没有 <code>valueOf()</code> 方法，则调用 <code>toString()</code> 方法，并用得到的结果根据前述规则执行比较</li>
<li>如果一个操作数是布尔值，则先将其转化为数值，然后再执行比较</li>
</ul>
<p>在比较两个字符串时，实际比较的是两个字符串中对应位置的每个字符的字符编码值，因此一般需要将两个操作数转换为相同的大小写形式，然后再执行比较。</p>
<h4 id="相等操作符"><a href="#相等操作符" class="headerlink" title="相等操作符"></a>相等操作符</h4><h5 id="相等和不相等"><a href="#相等和不相等" class="headerlink" title="相等和不相等"></a>相等和不相等</h5><p>ECMAScript 中的相等操作符由 <code>==</code> 表示，如果两个操作数相等，则返回 <code>true</code> 。而不相等操作符由 <code>!=</code>  表示，如果两个操作数不相等，则返回 <code>true</code> 。这两个操作符都会先转换操作数，然后在比较它们的相等性。</p>
<p>在转换不同的数据时，需遵守以下规则 ：</p>
<ul>
<li>如果有一个操作数是布尔值，则在比较相等性之前先将其转换为数值 – <code>false</code> 转换为 0 ，<code>true</code> 转换为 1</li>
<li>如果一个操作数是字符串，另一个操作数是数值，在比较相等性之前先将字符串转换为数值</li>
<li>如果一个操作数是对象，另一个操作数不是，则调用对象的 <code>valueOf()</code> 方法，用得到的基本类型值按照前述规则进行比较</li>
</ul>
<p>这两个操作符在进行比较时要遵守下列规则 ：</p>
<ul>
<li><code>null</code>  和 <code>undefined</code> 时相等的</li>
<li>比较相等性之前，不能将 <code>null</code>  和 <code>undefined</code> 转换为其它任何值</li>
<li>如果有一个操作数是 <code>NaN</code> ，则相等操作符返回 <code>false</code> ，而不相等操作符返回 <code>true</code></li>
<li>如果两个数都是对象，则比较它们是否是同一个对象。如果两个操作数都指向同一个对象，则相等操作符返回 <code>true</code> ；否则， 返回 <code>false</code> 。</li>
</ul>
<p>特殊情况 ：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">null</span> == <span class="literal">undefined</span> 	<span class="comment">// true</span></span><br><span class="line"><span class="literal">true</span> == <span class="number">1</span>		  	<span class="comment">// true</span></span><br><span class="line"><span class="literal">true</span> == <span class="number">2</span>		  	<span class="comment">// false</span></span><br><span class="line"><span class="string">"NaN"</span> == <span class="literal">NaN</span>	  	<span class="comment">// false</span></span><br><span class="line"><span class="number">5</span> == <span class="literal">NaN</span>		  	<span class="comment">// false</span></span><br><span class="line"><span class="literal">undefined</span> == <span class="number">0</span>	  	<span class="comment">// false</span></span><br><span class="line"><span class="literal">NaN</span> == <span class="literal">NaN</span> 		  	<span class="comment">// false</span></span><br><span class="line"><span class="literal">null</span> == <span class="number">0</span>			<span class="comment">// false</span></span><br><span class="line"><span class="literal">NaN</span> != <span class="literal">NaN</span>			<span class="comment">// true</span></span><br><span class="line"><span class="string">"5"</span> == <span class="number">5</span>			<span class="comment">// true</span></span><br><span class="line"><span class="literal">false</span> == <span class="number">0</span>			<span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h5 id="全等和不全等"><a href="#全等和不全等" class="headerlink" title="全等和不全等"></a>全等和不全等</h5><p>除了在比较之前不能转换为操作数之外，全等和不全等操作符与相等和不相等操作符没有什么区别。全等操作符由 <code>===</code> 表示，它只在两个操作数未经转换就想等的情况下返回 <code>true</code> 。</p>
<p>由于相等和不相等操作符存在类型转换问题，为了保持代码中数据类型的完整性，推荐使用全等和不全等操作符。</p>
<h4 id="条件操作符"><a href="#条件操作符" class="headerlink" title="条件操作符"></a>条件操作符</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">variable = boolean_expression ? true_value : false_value;</span><br></pre></td></tr></table></figure>

<p>基于对 boolean_expression 的求值结果，决定给变量 variable 赋什么值。</p>
<h3 id="语句-1"><a href="#语句-1" class="headerlink" title="语句"></a>语句</h3><p><code>if</code> 语句、<code>do-while</code> 语句、<code>while</code> 语句、<code>for</code> 语句、<code>for-in</code> 语句与其它语言并没有不同，在此不做介绍。</p>
<h4 id="label-语句"><a href="#label-语句" class="headerlink" title="label 语句"></a><code>label</code> 语句</h4><p>使用 <code>label</code> 语句可以在代码中添加标签，以便将来使用。</p>
<h4 id="break-和-continue-语句"><a href="#break-和-continue-语句" class="headerlink" title="break  和 continue 语句"></a><code>break</code>  和 <code>continue</code> 语句</h4><p><code>break</code> 和 <code>continue</code> 语句用于在循环中精确地控制代码的执行。<code>break</code> 语句会立即退出循环，强制继续执行循环后面的语句。而 <code>continue</code> 语句虽然也是立即退出循环，但退出循环后会从循环的顶部继续执行。</p>
<h4 id="with-语句"><a href="#with-语句" class="headerlink" title="with 语句"></a><code>with</code> 语句</h4><p><code>with</code> 语句的作用是将代码的作用域设置到一个特定的对象中 ：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> (expression) statment;</span><br></pre></td></tr></table></figure>

<p>定义 <code>with</code> 语句的目的主要是为了简化多次编写同一个对象的工作。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> qs = location.search.substring(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> hostName = location.hostName;</span><br><span class="line"><span class="keyword">var</span> url = location.href;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 with 语句改写</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span>(location) &#123;</span><br><span class="line">	<span class="keyword">var</span> qs = search.substring(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">var</span> hostName = hostName;</span><br><span class="line">    <span class="keyword">var</span> url = href;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>严格模式下不允许使用 <code>with</code> 语句，视为语法错误。</p>
<p>由于大量使用 <code>with</code> 语句会导致性能下架，同时也会给调试代码造成困难，因此在开发大型应用程序时，不建议使用 <code>with</code> 语句。</p>
<h4 id="swithc-语句"><a href="#swithc-语句" class="headerlink" title="swithc 语句"></a><code>swithc</code> 语句</h4><p>ECMAScript 中的 <code>switch</code> 有两个特点 ：</p>
<ul>
<li>可以在 <code>switch</code> 中使用任何数据类型</li>
<li>每个 <code>case</code> 的值不一定是常量，可以是变量，甚至是表达式</li>
</ul>
<p>需要主要的是，<code>switch</code> 语句在比较值时使用的是全等操作符，不会发生类型转换。</p>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>ECMAScript 中的函数使用 <code>function</code> 关键字来声明，后跟一组参数及函数体。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">functionName</span> (<span class="params">arg_0, arg_1, ...</span>) </span>&#123;</span><br><span class="line">    statments</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ECMAScript 中的函数在定义时不必指定是否返回值。</p>
<p><code>return</code> 语句也可以不带有任何返回值。在这种情况下，函数在停止执行后将返回 <code>undefined</code> 值。这种用法一般用在需要提前停止函数执行而又不需要返回值的情况下。</p>
<p>严格模式下 ：</p>
<ul>
<li><p>不能把函数或参数命名为 eval 或 arguments</p>
</li>
<li><p>不能出现两个命名参数同名的情况</p>
</li>
</ul>
<h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><p>ECMAScript 函数的参数不介意传递进来多少个参数，也不在乎传进来的参数是什么数据类型。ECMAScript 中函数的参数在内部是用一个数组来表示的，函数接收到的始终都是这个数组，而不关心数组中包含哪些参数。在函数体内，可以通过 <code>arguments</code> 对象来访问这个参数数组，从而获得传递给函数的每一个参数。</p>
<p>命名的参数只提供便利，但并不是必需的。而且在 ECMAScript 中，解析器不会验证命名参数。</p>
<p>没有传递值得命名参数将自动被赋予 <code>undefined</code> 值。</p>
<p>严格模式对如何使用 <code>arguments</code> 对象做出了一些限制 ：无法对命名参数进行赋值；重写 <code>arguments</code> 的值会导致语法错误。</p>
<blockquote>
<p><code>arguments</code> 本质上并不是一个数组，只是与数组类似，你可以使用方括号语法来访问它的每一个元素。</p>
</blockquote>
<h4 id="没有重载"><a href="#没有重载" class="headerlink" title="没有重载"></a>没有重载</h4><p>ECMAScript 中函数的参数有包含零或多个值得数组来表示，所以没有函数签名。而没有函数签名，真正的重载是不可能做到的。如果在 ECMAScript 中定义了同名函数，则该名字只属于后定义的函数。</p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/blogs/2017/04/06/tableview-optimize/" rel="prev" title="iOS 中 UITableView 的优化">
      <i class="fa fa-chevron-left"></i> iOS 中 UITableView 的优化
    </a></div>
      <div class="post-nav-item">
    <a href="/blogs/2017/05/17/javascript-advanced-variable-scope/" rel="next" title="JavaScript 高级程序设计 - 变量、作用域和内存问题">
      JavaScript 高级程序设计 - 变量、作用域和内存问题 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#JavaScript-简介"><span class="nav-number">1.</span> <span class="nav-text">JavaScript 简介</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ECMAScript"><span class="nav-number">1.1.</span> <span class="nav-text">ECMAScript</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#文档对象模型-DOM"><span class="nav-number">1.2.</span> <span class="nav-text">文档对象模型 DOM</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#浏览器对象模型-BOM"><span class="nav-number">1.3.</span> <span class="nav-text">浏览器对象模型 BOM</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#在-HTML-中使用-JavaScript"><span class="nav-number">2.</span> <span class="nav-text">在 HTML 中使用 JavaScript</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#基本概念"><span class="nav-number">3.</span> <span class="nav-text">基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#语法"><span class="nav-number">3.1.</span> <span class="nav-text">语法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#区分大小写"><span class="nav-number">3.1.1.</span> <span class="nav-text">区分大小写</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#标识符"><span class="nav-number">3.1.2.</span> <span class="nav-text">标识符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#严格模式"><span class="nav-number">3.1.3.</span> <span class="nav-text">严格模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#语句"><span class="nav-number">3.1.4.</span> <span class="nav-text">语句</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关键字和保留字"><span class="nav-number">3.2.</span> <span class="nav-text">关键字和保留字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#变量"><span class="nav-number">3.3.</span> <span class="nav-text">变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据类型"><span class="nav-number">3.4.</span> <span class="nav-text">数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#typeof-操作符"><span class="nav-number">3.4.1.</span> <span class="nav-text">typeof 操作符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Undefined-类型"><span class="nav-number">3.4.2.</span> <span class="nav-text">Undefined 类型</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Null-类型"><span class="nav-number">3.5.</span> <span class="nav-text">Null 类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Boolean-类型"><span class="nav-number">3.5.1.</span> <span class="nav-text">Boolean 类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Number-类型"><span class="nav-number">3.5.2.</span> <span class="nav-text">Number 类型</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#浮点数值"><span class="nav-number">3.5.2.1.</span> <span class="nav-text">浮点数值</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#数值范围"><span class="nav-number">3.5.2.2.</span> <span class="nav-text">数值范围</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#NaN"><span class="nav-number">3.5.2.3.</span> <span class="nav-text">NaN</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#数值转换"><span class="nav-number">3.5.2.4.</span> <span class="nav-text">数值转换</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#String-类型"><span class="nav-number">3.5.3.</span> <span class="nav-text">String 类型</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#字符字面量"><span class="nav-number">3.5.3.1.</span> <span class="nav-text">字符字面量</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#字符串的特点"><span class="nav-number">3.5.3.2.</span> <span class="nav-text">字符串的特点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#转换为字符串"><span class="nav-number">3.5.3.3.</span> <span class="nav-text">转换为字符串</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Object-类型"><span class="nav-number">3.5.4.</span> <span class="nav-text">Object 类型</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#操作符"><span class="nav-number">3.6.</span> <span class="nav-text">操作符</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#一元操作符"><span class="nav-number">3.6.1.</span> <span class="nav-text">一元操作符</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#递增和递减操作符"><span class="nav-number">3.6.1.1.</span> <span class="nav-text">递增和递减操作符</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#加和减操作符"><span class="nav-number">3.6.1.2.</span> <span class="nav-text">加和减操作符</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#位操作符"><span class="nav-number">3.6.2.</span> <span class="nav-text">位操作符</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#按位非"><span class="nav-number">3.6.2.1.</span> <span class="nav-text">按位非</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#按位与"><span class="nav-number">3.6.2.2.</span> <span class="nav-text">按位与</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#按位或"><span class="nav-number">3.6.2.3.</span> <span class="nav-text">按位或</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#按位异或"><span class="nav-number">3.6.2.4.</span> <span class="nav-text">按位异或</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#左移"><span class="nav-number">3.6.2.5.</span> <span class="nav-text">左移</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#有符号右移"><span class="nav-number">3.6.2.6.</span> <span class="nav-text">有符号右移</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#无符号右移"><span class="nav-number">3.6.2.7.</span> <span class="nav-text">无符号右移</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#布尔操作符"><span class="nav-number">3.6.3.</span> <span class="nav-text">布尔操作符</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#逻辑非"><span class="nav-number">3.6.3.1.</span> <span class="nav-text">逻辑非</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#逻辑与"><span class="nav-number">3.6.3.2.</span> <span class="nav-text">逻辑与</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#逻辑或"><span class="nav-number">3.6.3.3.</span> <span class="nav-text">逻辑或</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#乘性操作符"><span class="nav-number">3.6.4.</span> <span class="nav-text">乘性操作符</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#乘法"><span class="nav-number">3.6.4.1.</span> <span class="nav-text">乘法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#除法"><span class="nav-number">3.6.4.2.</span> <span class="nav-text">除法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#求模"><span class="nav-number">3.6.4.3.</span> <span class="nav-text">求模</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#加性操作符"><span class="nav-number">3.6.5.</span> <span class="nav-text">加性操作符</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#加法"><span class="nav-number">3.6.5.1.</span> <span class="nav-text">加法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#减法"><span class="nav-number">3.6.5.2.</span> <span class="nav-text">减法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#关系操作符"><span class="nav-number">3.6.6.</span> <span class="nav-text">关系操作符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#相等操作符"><span class="nav-number">3.6.7.</span> <span class="nav-text">相等操作符</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#相等和不相等"><span class="nav-number">3.6.7.1.</span> <span class="nav-text">相等和不相等</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#全等和不全等"><span class="nav-number">3.6.7.2.</span> <span class="nav-text">全等和不全等</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#条件操作符"><span class="nav-number">3.6.8.</span> <span class="nav-text">条件操作符</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#语句-1"><span class="nav-number">3.7.</span> <span class="nav-text">语句</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#label-语句"><span class="nav-number">3.7.1.</span> <span class="nav-text">label 语句</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#break-和-continue-语句"><span class="nav-number">3.7.2.</span> <span class="nav-text">break  和 continue 语句</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#with-语句"><span class="nav-number">3.7.3.</span> <span class="nav-text">with 语句</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#swithc-语句"><span class="nav-number">3.7.4.</span> <span class="nav-text">swithc 语句</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数"><span class="nav-number">3.8.</span> <span class="nav-text">函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#参数"><span class="nav-number">3.8.1.</span> <span class="nav-text">参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#没有重载"><span class="nav-number">3.8.2.</span> <span class="nav-text">没有重载</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">CocoaLei</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/blogs/archives/">
        
          <span class="site-state-item-count">32</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/blogs/categories">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/blogs/tags/">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">CocoaLei</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/blogs/lib/anime.min.js"></script>
  <script src="/blogs/lib/velocity/velocity.min.js"></script>
  <script src="/blogs/lib/velocity/velocity.ui.min.js"></script>

<script src="/blogs/js/utils.js"></script>

<script src="/blogs/js/motion.js"></script>


<script src="/blogs/js/schemes/pisces.js"></script>


<script src="/blogs/js/next-boot.js"></script>




  















  

  

</body>
</html>
