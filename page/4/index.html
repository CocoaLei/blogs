<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/blogs/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blogs/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/blogs/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/blogs/images/logo.svg" color="#222">

<link rel="stylesheet" href="/blogs/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/blogs/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"cocoalei.github.io","root":"/blogs/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="CocoaLei">
<meta property="og:url" content="https://cocoalei.github.io/blogs/page/4/index.html">
<meta property="og:site_name" content="CocoaLei">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="CocoaLei">
<meta property="article:tag" content="iOS">
<meta property="article:tag" content="HTML">
<meta property="article:tag" content="CSS">
<meta property="article:tag" content="JavaScript">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://cocoalei.github.io/blogs/page/4/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>CocoaLei</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/blogs/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">CocoaLei</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/blogs/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/blogs/categories" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/blogs/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cocoalei.github.io/blogs/2015/10/18/ios-application-life-cycle/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blogs/images/avatar.gif">
      <meta itemprop="name" content="CocoaLei">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CocoaLei">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blogs/2015/10/18/ios-application-life-cycle/" class="post-title-link" itemprop="url">应用程序生命周期和状态转换操作策略</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2015-10-18 00:00:00" itemprop="dateCreated datePublished" datetime="2015-10-18T00:00:00+08:00">2015-10-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-01-17 11:35:28" itemprop="dateModified" datetime="2019-01-17T11:35:28+08:00">2019-01-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="iOS-应用程序生命周期"><a href="#iOS-应用程序生命周期" class="headerlink" title="iOS 应用程序生命周期"></a>iOS 应用程序生命周期</h1><hr>
<h2 id="基本概念介绍"><a href="#基本概念介绍" class="headerlink" title="基本概念介绍"></a>基本概念介绍</h2><h3 id="The-Main-Function-程序的入口"><a href="#The-Main-Function-程序的入口" class="headerlink" title="The Main Function - 程序的入口"></a>The Main Function - 程序的入口</h3><p><code>main</code>函数是每个基于C的应用程序的入口，iOS也是这样。在Xcode中开发iOS程序的话，Xcode会自动为你创建这个函数作为你工程的一部分。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>main</code>函数控制UIKit framework的工作。<code>UIApplicationMain</code>函数通过创建应用程序的核心对象，从可用的<code>storyboard</code>文件加载应用程序的用户界面，调用自定义代码，以便让你可以在程序启动时进行一些初始设置，并将应用程序的运行循环启动。 </p>
<h3 id="The-Structure-of-an-App-程序的结构"><a href="#The-Structure-of-an-App-程序的结构" class="headerlink" title="The Structure of  an App - 程序的结构"></a>The Structure of  an App - 程序的结构</h3><p>在启动过程中，<code>UIApplicationMain</code>函数设置了几个关键对象，启动应用程序并开始运行它。 每个iOS应用程序的核心都是<code>UIApplication</code>对象，其工作是为了方便系统与应用程序中的其他对象之间的交互。 </p>
<p>一个iOS应用程序中包含的关键对象：</p>
<img src="https://raw.githubusercontent.com/apple272487813/apple272487813.github.io/master/images/application_life_cycle/application_core_objects.png"  style="zoom:50%"/>



<p>一个iOS应用程序中各个对象的所起到的作用：</p>
<table>
<thead>
<tr>
<th align="left">Object</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>UIAppplication</code></td>
<td><code>UIApplication</code>对象管理着App的事件循环和一些高级App行为，并向它的委托对象报告App的状态转换和一些特殊事件。</td>
</tr>
<tr>
<td align="left"><code>Appdelegate</code></td>
<td><code>Appdelegate</code>是你编写的程序代码的核心 ，它与<code>UIApplication</code>对象一起工作，处理应用程序初始化，状态转换和许多高级App行为。 这个对象也是唯一一个保证在每个应用程序中都出现的对象，因此通常用于设置应用程序的初始数据结构。</td>
</tr>
<tr>
<td align="left"><code>ViewController</code></td>
<td><code>View Controller</code>对象管理着你的App内容在屏幕上是如何呈现的。一个<code>View Controller</code>对象管理着一个视图和这个视图的子视图。</td>
</tr>
<tr>
<td align="left"><code>UIWindow</code></td>
<td><code>UIWindow</code>对象协调屏幕上一个或多个视图的呈现。 大多数应用程序只有一个窗口，它在主屏幕上显示内容，但应用程序可能会在外部显示器上显示内容的附加窗口。要更改应用程序的内容，可以使用视图控制器更改相应窗口中显示的视图。 你永远不会更换窗口本身。除了托管视图之外，<code>Windows</code>还可以使用<code>UIApplication</code>对象将事件传递给的视图和控制器。</td>
</tr>
<tr>
<td align="left"><code>View,Control and Layer</code></td>
<td>View和Control提供了应用内容的可视化表示。 除了包含View和Control之外，应用程序还可以将Core Animation图层纳入其视图和控制层次结构中。 层对象实际上才是表示可视内容的数据对象。</td>
</tr>
</tbody></table>
<h3 id="The-Main-Run-Loop-主运行循环"><a href="#The-Main-Run-Loop-主运行循环" class="headerlink" title="The Main Run Loop - 主运行循环"></a>The Main Run Loop - 主运行循环</h3><p>应用程序的主运行循环处理所有与用户相关的事件。 <code>UIApplication</code>对象在启动时设置主运行循环，并使用它来处理事件并处理基于视图的接口的更新。</p>
<p> 顾名思义，主运行循环在应用程序的主线程上执行，这确保了与用户相关的事件按照接收的顺序连续处理。</p>
<p>当用户与设备进行交互时，与这些交互相关的事件由系统生成，并通过由UIKit设置的特殊端口传送到应用。 事件在应用程序内部进入队列，并逐个分派到主运行循环执行。<code>UIApplication</code>对象是接收事件的第一个对象，并且决定需要做什么来处理这个事件。 触摸事件通常被分派到主窗口对象，主窗口对象又将其发送到触摸发生的视图。 </p>
<img src="https://raw.githubusercontent.com/apple272487813/apple272487813.github.io/master/images/application_life_cycle/application_event_draw_cycle.png" style="zoom:50%"/>

<p>可以在iOS应用程式中分发许多类型的事件。 最常见的如下表所示。 这些事件大多是使用应用程序的主运行循环分发的，但也有些不是。 一些事件被分发到一个委托对象或被分发给你提供的一个block。</p>
<table>
<thead>
<tr>
<th>事件类型</th>
<th>分发对象</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>触摸事件</td>
<td>事件发生的视图</td>
<td>视图是响应者对象。任何没有被当前视图处理的触摸事件都会被沿着响应链继续向下分发进行处理。</td>
</tr>
<tr>
<td>遥控器事件和摇动运动事件</td>
<td>首要响应对象</td>
<td>遥控器事件用于控制媒体播放，并由耳机和其他附件产生。</td>
</tr>
<tr>
<td>加速度计、磁力仪和陀螺仪</td>
<td>你指定的对象</td>
<td>与加速度计，磁力计和陀螺仪硬件相关的事件传递给你指定的对象。</td>
</tr>
<tr>
<td>定位</td>
<td>你指定的对象</td>
<td>你注册定位服务以接收使用Core Location框架位置的事件。</td>
</tr>
<tr>
<td>重绘</td>
<td>需要更新的视图</td>
<td>重绘事件不涉及事件对象，而是简单地调用视图来绘制自身。</td>
</tr>
</tbody></table>
<p>一些事件，如触摸和遥控事件，由你的应用程序的响应者对象处理。响应者对象在你的应用程序中无处不在。 大多数事件都针对特定的响应者对象，但如果需要处理事件，则可以将其传递给其他响应方（通过响应者链）。 例如，不处理事件的视图可以将事件传递到其父视图或父视图控制器。</p>
<p>触摸控件（如按钮）中发生的事件的处理方式与在许多其他类型的视图中发生的触摸事件的处理方式不同。 通常只有有限数量的交互可能与控件相关联，因此这些交互被重新封装到动作消息中并传递到适当的目标对象。 这种目标动作(Target-Action)设计模式可以轻松地使用控件来触发你应用中自定义代码的执行。</p>
<h3 id="Execution-States-for-Apps-应用程序的执行状态"><a href="#Execution-States-for-Apps-应用程序的执行状态" class="headerlink" title="Execution States for Apps - 应用程序的执行状态"></a>Execution States for Apps - 应用程序的执行状态</h3><p>在任何给定的时刻，你的应用程序都处在下表所列的状态之一。 系统会改变应用程序的状态以响应整个系统中发生的操作。</p>
<table>
<thead>
<tr>
<th>状态</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Not running</td>
<td>应用程序没有运行或被系统终止运行。</td>
</tr>
<tr>
<td>Inactive</td>
<td>应用程序正在前台运行，但当前没有收到事件 (它可能正在执行其他代码)。应用程序通常在转换到不同的状态时暂时保持在此状态。</td>
</tr>
<tr>
<td>Active</td>
<td>应用程序正在前台运行，并且正在接收事件(这是前台应用程序的正常模式)。</td>
</tr>
<tr>
<td>Background</td>
<td>应用程序在后台执行代码。 大多数应用程序短暂地进入此状态。 但是，请求额外执行时间的应用程序可能会保持此状态一段时间。</td>
</tr>
<tr>
<td>Suspended</td>
<td>应用程序是在后台，但不执行代码。 系统将应用程序自动转换到这个状态，在这样做之前并不会通知应用程序。 挂起时，应用程序保留在内存中，但不执行任何代码。当出现低内存条件时，系统可能会清除已挂起的应用程序，以为前台应用程序腾出更多空间。</td>
</tr>
</tbody></table>
<p>下图展示了应用程序在各种状态之间的转换：</p>
<img src="https://raw.githubusercontent.com/apple272487813/apple272487813.github.io/master/images/application_life_cycle/application_high_level_flow.png" style="zoom:50%"/>

<p>大多数状态转换伴随着对应用程序委托对象的方法的相应调用 ，这些方法是你以适当方式响应状态变更的地方。 </p>
<ul>
<li><p><code>application:willFinishLaunchingWithOptions:</code></p>
<p>告诉代理对象启动过程已经开始，但还没有发生状态恢复。</p>
</li>
<li><p><code>application:didFinishLaunchingWithOptions:</code></p>
<p>告诉代理对象启动过程快要完成，应用程序快要准备好运行。</p>
</li>
<li><p><code>applicationDidBecomeActive:</code></p>
<p>告诉代理对象应用程序已经处于Active状态。</p>
</li>
<li><p><code>applicationWillResignActive:</code></p>
<p>告诉代理对象应用程序即将进入Inactive状态。</p>
</li>
<li><p><code>applicationDidEnterBackground:</code></p>
<p>告诉代理对象应用程序已经进入后台。</p>
</li>
<li><p><code>applicationWillEnterForeground:</code></p>
<p>告诉代理对象应用程序即将进入前台。</p>
</li>
<li><p><code>applicationWillTerminate:</code></p>
<p>告诉代理对象应用程序即将被终止。</p>
<p>​</p>
</li>
</ul>
<h3 id="App-Termination-应用程序的终止"><a href="#App-Termination-应用程序的终止" class="headerlink" title="App Termination - 应用程序的终止"></a>App Termination - 应用程序的终止</h3><p>应用程序必须随时准备终止运行，不应等待保存用户数据或执行其他关键任务。 System-initiated termination是应用程序生命周期的正常部分。该系统通常终止应用程序，以便它可以回收内存并为用户启动的其他应用程序腾出空间，但是系统也可能会终止行为不当或未及时响应事件的应用程序。</p>
<p>挂起的应用程序终止时不会收到通知，系统将杀死该进程并回收相应的内存。如果一个应用程序当前在后台运行并且没有挂起，系统会在终止之前调用应用程序委托的<code>applicationWillTerminate：</code>。当设备重新启动时，系统不会调用此方法。</p>
<p>除了系统终止你的应用程序，用户可以使用多任务UI显式地终止你的应用程序。System-initiated termination与终止挂起的应用程序具有相同的效果。该应用程序的进程被杀死，并且不会有通知发送到该应用程序。</p>
<h3 id="Threads-and-Concurrency-线程和并发"><a href="#Threads-and-Concurrency-线程和并发" class="headerlink" title="Threads and Concurrency - 线程和并发"></a>Threads and Concurrency - 线程和并发</h3><p>系统创建你的应用程序的主线程，你可以根据需要创建其他线程来执行其他任务。</p>
<p>对于iOS应用，首选技术是使用Grand Central Dispatch（GCD），操作对象和其它异步编程接口，而不是自己创建和管理线程。 GCD等技术可以让你定义想要执行的工作以及要执行的顺序，但让系统决定如何在可用的CPU上执行该工作。让系统处理线程管理简化了必须编写的代码，使得更容易确保代码的正确性，并提供更好的整体性能。</p>
<p>在考虑线程和并发时，请考虑以下几点：</p>
<ul>
<li><p>涉及视图，核心动画和许多其他UIKit类的工作通常必须发生在应用程序的主线程上。</p>
</li>
<li><p>长时间的任务（或潜在的长度任务）应始终在后台线程上执行。任何涉及网络访问，文件访问或大量数据处理的任务都应使用GCD或操作对象异步执行。</p>
</li>
<li><p>在启动时，尽可能将任务从主线程移出。在启动时，您的应用程序应尽可能快地设置用户界面。只有有助于设置用户界面的任务才能在主线程上执行。</p>
<p>所有其他任务应该是异步执行的。</p>
</li>
</ul>
<hr>
<h2 id="操作应用程序的状态转换"><a href="#操作应用程序的状态转换" class="headerlink" title="操作应用程序的状态转换"></a>操作应用程序的状态转换</h2><hr>
<p>对于应用程序的任何一个可能的运行状态，系统都对你的应用程序有不同的期望。当应用程序的状态发生转换时，系统会通知应用对象，应用对象又通知其代理。你可以使用<code>UIApplicationDelegate</code>协议的状态转换方法来检测这些状态变化并进行适当的响应。</p>
<h2 id="应用程序启动时应该做什么"><a href="#应用程序启动时应该做什么" class="headerlink" title="应用程序启动时应该做什么"></a>应用程序启动时应该做什么</h2><p>当应用程序启动(进入前台货后台)时，你应该使用应用程序委托对象的<code>application:willFinishLaunchingWithOptions:</code>和<code>application：didFinishLaunchingWithOptions：</code>方法执行一些操作：</p>
<ul>
<li><p>检查启动选项字典的内容(launch options dictionary)，了解应用程序启动的原因，并作出适当的响应。</p>
</li>
<li><p>初始化应用程序的关键数据结构。</p>
</li>
<li><p>准备应用程序的窗口和视图以进行内容显示。</p>
<ul>
<li><p>使用OpenGL ES进行绘图的应用程序不能使用这些方法来准备绘图环境，使用OpenGL ES绘图应该在<code>applicationDidBecomeActive:</code>方法中进行准备。</p>
</li>
<li><p>Show your app window from your <code>application:willFinishLaunchingWithOptions:</code> method. UIKit delays making the window visible until after the <code>application:didFinishLaunchingWithOptions:</code> method returns.</p>
</li>
<li><p>在<code>application:willFinishLaunchingWithOptions:</code>方法中配置如何显示应用程序的Window。UIKit延迟Window的显示直到<code>application:didFinishLaunchingWithOptions:</code>方法进行了返回。</p>
</li>
</ul>
</li>
</ul>
<p>在启动时，系统会自动的加载应用程序的主要storyBoard文件，并加载初始视图控制器。对于支持状态恢复的应用程序，状态恢复机制会在调用<code>application:willFinishLaunchingWithOptions:</code>和 <code>application:didFinishLaunchingWithOptions:</code>方法之间将应用程序恢复到以前的状态。使用<code>application:willFinishLaunchingWithOptions:</code>方法显示应用程序窗口，并确定状态恢复是否应该发生。使用<code>application:didFinishLaunchingWithOptions:</code>方法对应用程序的用户界面进行任何最终调整。</p>
<p><code>application:willFinishLaunchingWithOptions:</code>和<code>application:didFinishLaunchingWithOptions:</code>方法应始终尽可能轻量级，以减少应用程序的启动时间。如果应用程序没有及时完成其启动周期，系统将使其无法响应。因此，任何可能减慢启动速度的任务（如访问网络）都应该在辅助线程上执行。</p>
<h3 id="The-Launch-Cycle-启动周期"><a href="#The-Launch-Cycle-启动周期" class="headerlink" title="The Launch Cycle - 启动周期"></a>The Launch Cycle - 启动周期</h3><p>当你的应用程序启动后，在短暂的停留在非活动状态(Inactive)后，将会从非运行状态(Not Running)转换到活动状态(Active)或后台状态(Background)。作为启动周期的一部分，系统会为你的应用程序创建一个进程和一个主线程，并在主线程中调用应用程序的<code>main</code>函数。</p>
<p>下图显示了应用程序启动到前台时发生的事件序列，包括调用的应用程序委派方法。</p>
<img src="https://raw.githubusercontent.com/apple272487813/apple272487813.github.io/master/images/application_life_cycle/app_launch_fg.png" style="zoom:50%" />



<p>当你的应用程序启动到后台时，通常要处理一些后台事件，启动周期会有些许改变。主要的不同在于，在后台的应用程序不是处于活动状态，只是进入后台来处理一些事件，之后可能会被挂起。当启动到后台时，系统仍然会加载用户界面文件，但不会显示应用程序的窗口。</p>
<img src="https://raw.githubusercontent.com/apple272487813/apple272487813.github.io/master/images/application_life_cycle/app_launch_bg.png" style="zoom:50%"/>

<p>你可以通过在代理方法 <code>application:willFinishLaunchingWithOptions:</code> 和<code>application:didFinishLaunchingWithOptions:</code>中检查<code>UIApplication</code>的<code>applicationState</code>属性来决定应用程序是启动到前台还是后台。当你的应用程序启动到前台时，这个属性的值是<code>UIApplicationStateInactive</code>，当你的应用程序启动到后台时，这个属性的值是<code>UIApplicationStateBackground</code>。</p>
<h3 id="Launching-in-Landscape-Mode-以横屏模式启动"><a href="#Launching-in-Landscape-Mode-以横屏模式启动" class="headerlink" title="Launching in Landscape Mode - 以横屏模式启动"></a>Launching in Landscape Mode - 以横屏模式启动</h3><p>对于界面只使用横屏的应用程序来说，必须明确地请求系统以横屏模式启动。通常来说，应用程序以纵屏模式启动，只有在需要适应设备的方向的时候才旋转屏幕的方向。 对于支持纵向和横向方向的应用程序，应始终为纵向模式配置视图，然后让视图控制器处理任何旋转。<br>但是，如果您的应用程序支持横向而不是纵向方向，请执行以下任务，让使其以横向模式启动：</p>
<ul>
<li>像你应用程序中的<code>Infl.plist</code>文件中添加<code>UIInterfaceOrientation</code>字段，并将其值设为<code>UIInterfaceOrientationLandscapeLeft</code>或<code>UIInterfaceOrientationLandscapeRight</code>。</li>
<li>在横屏模式下布局你的视图并确保视图的布局和自动调整大小选项设置正确。</li>
<li>重写试图控制器的<code>shouldAutorotateToInterfaceOrientation:</code>方法并在左向横屏或右向横屏时返回<code>YES</code>，在纵屏模式下返回<code>NO</code>。</li>
</ul>
<blockquote>
<p><strong>重要提示:</strong> 应用程序应该总是用视图控制器来管理基于窗口(Window)的内容。</p>
</blockquote>
<p>在<code>Info.plist</code>文件中的<code>UIInterfaceOrientation</code>字段告诉iOS系统该如何配置应用程序状态栏的方向(如果显示的话)以及任何视图控制器管理的视图在启动时的方向。视图控制器根据这个字段设置它的视图的初始方向。 使用此字段相当于在执行你的<code>applicationDidFinishLaunching:</code>方法的早期调用应用程序的<code>setStatusBarOrientation：animated:</code>方法。</p>
<h3 id="Installing-App-Specific-Data-Files-at-First-Launch-配置应用程序数据文件"><a href="#Installing-App-Specific-Data-Files-at-First-Launch-配置应用程序数据文件" class="headerlink" title="Installing App-Specific Data Files at First Launch - 配置应用程序数据文件"></a>Installing App-Specific Data Files at First Launch - 配置应用程序数据文件</h3><p>你可以使用应用程序的第一个启动周期来设置任何应用程序运行所需要的数据或配置文件。 应用程序特定的数据文件应在应用程序沙箱的<code>Library/Application Support/&lt;bundleID&gt;/</code>目录中创建，其中<bundleID>是应用程序的标识符。你可以根据需要细分目录来组织你的数据文件。</p>
<p>如果应用程序包中包含你打算进行修改的数据文件，你应该将要修改的数据文件从应用程序的数据包中复制出来进行修改。你不能在应用程序包中修改数据文件，因为iOS应用程序是代码签名的，在应用程序包中修改数据文件会使应用程序的签名失效，使得你的应用程序无法启动。将打算修改的数据文件复制到<code>Application Support</code>(或者其它可写的目录)目录下进行修改是唯一安全的方式。</p>
<h2 id="应用程序临时被打断时应该做什么"><a href="#应用程序临时被打断时应该做什么" class="headerlink" title="应用程序临时被打断时应该做什么"></a>应用程序临时被打断时应该做什么</h2><p>基于警报的打断会导致你的应用程序临时性的失去控制。这种情况下，你的应用程序仍然运行在前台，但是不接收任何来自系统的触摸事件(但是会继续接收推送通知等其他类型的时间，比如加速度计时间等)。你应该在<code>applicationWillResignActive:</code>方法中进行如下操作来处理这种情况：</p>
<ul>
<li>保存数据以及任何相关的状态信息。</li>
<li>停止计时器和其他周期性任务。</li>
<li>停止任何进行的数据请求任务。</li>
<li>不要创建任何新的任务。</li>
<li>停止视屏播放(除了通过AriPlay播放的视屏)</li>
<li>如果你的应用程序是游戏的话，是游戏进入暂停状态。</li>
<li>提高OpenGL ES 帧速率。</li>
<li>暂停执行非关键代码的任何调度队列或操作队列。 (可以在不活动的情况下继续处理网络请求和其他时间敏感的后台任务)</li>
</ul>
<p>当你的应用程序返回活动状态时，在<code>applicationDidBecomeActive:</code>方法中应该进行与<code>applicationWillResignActive:</code>相反的操作步骤。因此，一但重新活动，你的应用程序应重新启动计时器，恢复调度队列，并再次调低OpenGL ES帧速率。 但是，游戏不应该自动恢复，它们应该保持暂停，直到用户选择恢复它们为止。</p>
<p>当用户按下睡眠或唤醒按钮时，含有<code>NSFileProtectionComplete</code>保护选项的文件的应用程序必须关闭这些被保护文件的任何引用。对于设置了相应密码的设备，按下睡眠或唤醒按钮时应该锁定屏幕并强制系统丢弃对拥有完全保护文件的解密密钥。当屏幕锁定时，任何尝试访问相关文件的操作都会失败。所以你如果有这样的文件，你应该在<code>applicationWillResignActive:</code>方法中关闭对它们的任何引用，在<code>applicationDidBecomeActive:</code>中打开新的引用。</p>
<p><strong>重要提示:</strong> 你应该总是在适当的时候保存用户数据。虽然你可以使用应用程序状态转换来强制对象将为保存的变更写入磁盘，但是合适的做法是永远不要等到状态转换时才去保存数据。</p>
<h3 id="Responding-to-Temporary-Interruptions-响应临时打断"><a href="#Responding-to-Temporary-Interruptions-响应临时打断" class="headerlink" title="Responding to Temporary Interruptions - 响应临时打断"></a>Responding to Temporary Interruptions - 响应临时打断</h3><p>当基于警报的打断发生时(比如打进电话)，应用程序暂时进入非活动状态已便系统可以提示用户如和继续操作。应用程序保持在这个状态直到用户拒绝了这个警报，这时应用程序会返回前台进入活动状态或进入后台。</p>
<img src="https://raw.githubusercontent.com/apple272487813/apple272487813.github.io/master/images/application_life_cycle/app_interruptions.png" style="zoom:50%"/>

<p>以横幅形式显示的通知不会像基于警报的通知那样是你的应用程序进入非活动状态。尽管横幅放置在你应用程序窗口的顶部边缘，但是你的应用程序还是能够继续接收触摸事件。然而如果用户下拉横幅以便查看通知中心，你的应用程序就会像基于警报的打断发生时那样进入非活动状态。你的应用程序保持在非活动状态直到用户退出通知中心或启动另一个应用程序，这时，你的应用程序相应的会进入非活动转台或后台。</p>
<p>按下睡眠或唤醒按钮是另一种类型的可以导致你的应用程序暂时进入非活动状态的打断。当用户按下这个按钮，系统会使触摸事件变得不可用并让应用程序进入后台，同时将<code>applicationState</code>的值设置为<code>UIApplicationStateBackground</code>并锁定屏幕。</p>
<h2 id="应用程序在前台时做什么"><a href="#应用程序在前台时做什么" class="headerlink" title="应用程序在前台时做什么"></a>应用程序在前台时做什么</h2><p>当你的应用程序返回前台进入活动状态时，你可以重新启动在进入后台时停止的任务。移动到前台时出现的步骤如下图所示，<code>applicationWillEnterForeground：</code>方法应该撤消在<code>applicationDidEnterBackground：</code>方法中完成的任何内容，并且<code>applicationDidBecomeActive：</code>方法应该继续执行与启动时相同的激活任务。</p>
<img src="https://raw.githubusercontent.com/apple272487813/apple272487813.github.io/master/images/application_life_cycle/app_enter_foreground.png" style="zoom:50%"/>



<h3 id="Be-Prepared-to-Process-Queued-Notifications-准备处理通知队列"><a href="#Be-Prepared-to-Process-Queued-Notifications-准备处理通知队列" class="headerlink" title="Be Prepared to Process Queued Notifications - 准备处理通知队列"></a>Be Prepared to Process Queued Notifications - 准备处理通知队列</h3><p>一个处于挂起状态的应用程序必须做好在返回前台或进入后台执行状态时处理任何在队列中的通知。处于挂起状态的应用程序不执行任何代码，因此不能处理通知引发的屏幕方向改变，时间改变，偏好改变以及其它会影响应用程序的外观和状态的改变。为了确保这些改变不会丢失，系统将相关的通知放入队列并在应用程序开始执行代码(无论在前台还是后台)时分发通知给它。为了防止应用程序在恢复通知时变得超负荷，系统会将事件合并，并提供一个单一的通知（每种相关类型），反映自您的应用程序被挂起以来的净变化。</p>
<p>下表列出了分发给你的应用程序的可以合并的通知。这些通知的大多数都直接分发给已经注册的观察者。</p>
<table>
<thead>
<tr>
<th>Event</th>
<th>Notifications</th>
</tr>
</thead>
<tbody><tr>
<td>An accessory is connected or disconnected.</td>
<td><code>EAAccessoryDidConnectNotification</code> <code>EAAccessoryDidDisconnectNotification</code></td>
</tr>
<tr>
<td>设备方向改变</td>
<td><code>UIDeviceOrientationDidChangeNotification</code>除了这个通知，视图控制器自动的改变自己的方向。</td>
</tr>
<tr>
<td>重要的时间改变</td>
<td><code>UIApplicationSignificantTimeChangeNotification</code></td>
</tr>
<tr>
<td>电池状态改变</td>
<td><code>UIDeviceBatteryLevelDidChangeNotification</code> <code>UIDeviceBatteryStateDidChangeNotification</code></td>
</tr>
<tr>
<td>The proximity state changes.</td>
<td><code>UIDeviceProximityStateDidChangeNotification</code></td>
</tr>
<tr>
<td>被保护的文件的状态的改变</td>
<td><code>UIApplicationProtectedDataWillBecomeUnavailable</code> <code>UIApplicationProtectedDataDidBecomeAvailable</code></td>
</tr>
<tr>
<td>内建显示器连接或失去连接</td>
<td><code>UIScreenDidConnectNotification</code> <code>UIScreenDidDisconnectNotification</code></td>
</tr>
<tr>
<td>屏幕显示模式改变</td>
<td><code>UIScreenModeDidChangeNotification</code></td>
</tr>
<tr>
<td>通过设置应用程序改变了应用程序的设置</td>
<td><code>NSUserDefaultsDidChangeNotification</code></td>
</tr>
<tr>
<td>当前语言或本地化设置改变</td>
<td><code>NSCurrentLocaleDidChangeNotification</code></td>
</tr>
<tr>
<td>用户的iCloud账户状态改变</td>
<td><code>NSUbiquityIdentityDidChangeNotification</code></td>
</tr>
</tbody></table>
<p>通常在任何触摸事件或用户输入事件之前，在主线程中分发队列化的通知。大多数的应用程序应该足够快地处理这些事件，避免在重启是导致可观察到的延迟。</p>
<p>应用程序返回前台时也会接收到要更新自从上次更新以来被标记为dirty的视图的通知。一个运行在后台的应用程序仍然能调用<code>setNeedsDisplay</code> 和 <code>setNeedsDisplayInRect:</code>方法来请求更新视图。然而，因为这些请求更新的视图不可见，系统合并了这些请求并在应用程序进入前台后才更新它们。</p>
<h3 id="Handle-iCloud-Changes-处理iCloud改变"><a href="#Handle-iCloud-Changes-处理iCloud改变" class="headerlink" title="Handle iCloud Changes - 处理iCloud改变"></a>Handle iCloud Changes - 处理iCloud改变</h3><p>当iCloud的状态发生改变时，系统会发送一个<code>NSUbiquityIdentityDidChangeNotification</code>通知给你的应用程序。用户登入或登出iCloud账号，关闭了文档和数据的同步，都会引起iCloud状态的改变。这个通知表示应用程序应该更新缓存和与iCloud有关的用户界面元素。</p>
<p>如果你的应用程序已经提示了用户是否要在iCloud存储文件的话，不要在iCloud状态发生改变时再次提醒。在第一次提醒了用户后，将用户的选择保存在本地的偏好设置中。</p>
<h3 id="Handle-Locale-Changes-处理本地化改变"><a href="#Handle-Locale-Changes-处理本地化改变" class="headerlink" title="Handle Locale Changes - 处理本地化改变"></a>Handle Locale Changes - 处理本地化改变</h3><p>如果用户在你的应用程序挂起时改变了当前的本地化方案，当你的应用程序返回前台时，你可以使用<code>NSCurrentLocaleDidChangeNotification</code>通知来强制更新包含了对本地化方案敏感的信息，比如日期，时间和数字。当然，最好的避免发生本地化相关的问题的方法是用能简单更新视图的方法来编写代码：</p>
<ul>
<li>使用<code>autoupdatingCurrentLocale</code>类方法当你检索到<code>NSLocal</code>对象。这个方法返回一个可以自动更新自己来响应本地化方案改变的本地化对象，所以你永远不需要重新创建它。然而，当本地化方案发生改变时，你仍然需要更新包含来自于当前本地化方案的信息的视图。</li>
<li>重新创建任何缓存的日期和数字格式，无论当前本地化方案何时发生变化。</li>
</ul>
<h3 id="Handle-Changes-to-Your-App’s-Settings-处理偏好设置的改变"><a href="#Handle-Changes-to-Your-App’s-Settings-处理偏好设置的改变" class="headerlink" title="Handle Changes to Your App’s Settings - 处理偏好设置的改变"></a>Handle Changes to Your App’s Settings - 处理偏好设置的改变</h3><p>如果你的应用程序含有被设置应用程序管理的设置选项，你应该监测<code>NSUserDefaultsDidChangeNotification</code>通知，因为用户可以改变这些设置当你的应用程序被挂起或在后台。你可以使用这个通知来响应并处理在这些设置上的重要改变。</p>
<p>一旦收到<code>NSUserDefaultsDidChangeNotification</code>通知，你的应用程序应该重新加载任何相关的设置，如果需要，恰当地重置用户界面。</p>
<h2 id="应用程序在后台时做什么"><a href="#应用程序在后台时做什么" class="headerlink" title="应用程序在后台时做什么"></a>应用程序在后台时做什么</h2><p>当应用程序从前台转为后台执行时，使用你的代理对象的<code>applicationDidEnterBackground:</code>方法来做：</p>
<ul>
<li>准备应用程序的照片。当你的<code>applicationDidEnterBackground:</code>返回时，系统会对你的应用程序的用户界面拍照并用这个照片来做过度动画。如果你的应用程序里的视图包含敏感信息，你应该在<code>applicationDidEnterBackground:</code>返回之前隐藏或更改这些视图。</li>
<li>保存任何应用程序状态的相关信息。在进入后台之前，你的应用程序应该已经保存好了所有重要的用户数据。使用转换到后台来保存应用程序状态的最后一分钟更改。</li>
</ul>
<p>你的应用程序代理对象的<code>applicationDidEnterBackground:</code>方法大约有5分钟的时间来结束任何任务并返回。实际上，这个方法应该可能快的返回。如果这个方法没有在时间耗尽前返回，你的应用程序将会被终止并被移出内存。如果你仍然需要更多的时间来执行任务，调用<code>beginBackgroundTaskWithExpirationHandler:</code>方法来请求后台执行时间，然后在一个次要线程里开始任何长时任务。不管你有没有开始一个后台任务，<code>applicationDidEnterBackground:</code>方法都会在5分钟内退出。</p>
<p><strong>提示:</strong> 除了调用<code>applicationDidEnterBackground:</code>方法外，系统还会发送<code>UIApplicationDidEnterBackgroundNotification</code>通知。你可以使用这个通知将清理任务分发给应用程序里的其它对象。</p>
<h3 id="The-Background-Transition-Cycle-后台转换周期"><a href="#The-Background-Transition-Cycle-后台转换周期" class="headerlink" title="The Background Transition Cycle - 后台转换周期"></a>The Background Transition Cycle - 后台转换周期</h3><p>When the user presses the Home button, presses the Sleep/Wake button, or the system launches another app, the foreground app transitions to the inactive state and then to the background state. These transitions result in calls to the app delegate’s <code>applicationWillResignActive:</code> and <code>applicationDidEnterBackground:</code> methods, as shown in Figure 4-5. After returning from the <code>applicationDidEnterBackground:</code> method, most apps move to the suspended state shortly afterward. Apps that request specific background tasks (such as playing music) or that request a little extra execution time from the system may continue to run for a while longer.</p>
<p>当用户按下Home键，按下睡眠或唤醒按钮，或者系统启动了另一个应用程序，运行在前台的应用程序会转换为非活动状态然后进入后台。这些状态转换会导致调用<code>applicationWillResignActive:</code> 和 <code>applicationDidEnterBackground:</code>方法，如下图所示。从<code>applicationDidEnterBackground：</code>方法返回后，大多数应用程序不久之后就会转换到挂起状态。 请求特定后台任务（如播放音乐）或从系统请求一点额外执行时间的应用程序可能会持续运行一段时间。</p>
<img src="https://raw.githubusercontent.com/apple272487813/apple272487813.github.io/master/images/application_life_cycle/app_bg_life_cycle.png" style="zoom:50%"/>



<h3 id="Prepare-for-the-App-Snapshot-准备应用程序快照"><a href="#Prepare-for-the-App-Snapshot-准备应用程序快照" class="headerlink" title="Prepare for the App Snapshot - 准备应用程序快照"></a>Prepare for the App Snapshot - 准备应用程序快照</h3><p>系统在应用程序代理对象<code>applicationDidEnterBackground:</code>方法返回的不久之前，对应用程序的窗口进行快照。相似的，当应用程序被唤醒执行后台任务时，系统会对应用程序进行一次新的反应改变的快照。</p>
<p>如果在进入后台更改视图时，可以调用主视图的<code>snapshotViewAfterScreenUpdates：</code>方法来强制执行这些更改。在一个视图上调用<code>setNeedsDisplay</code>方法对快照是无效的，因为快照发生在下一个绘制周期之前。调用值为“YES”的<code>snapshotViewAfterScreenUpdates：</code>方法将立即使用机器的底层缓冲区更新快照。</p>
<h3 id="Reduce-Your-Memory-Footprint"><a href="#Reduce-Your-Memory-Footprint" class="headerlink" title="Reduce Your Memory Footprint"></a>Reduce Your Memory Footprint</h3><p>每个应用程序应该在进入后台时释放尽可能多的内存。 系统尝试尽可能多地在内存中保留应用程序，但是当内存不足时，会终止挂起的应用程序以回收该内存。 在后台消耗大量内存的应用程序是第一个要终止的应用程序。</p>
<p>实际上，你的应用程序应该在不再需要的时候删除对对象的强引用。 删除强引用使编译器能够立即释放对象，以便可以回收对应的内存。 但是，如果要缓存某些对象以提高性能，则可以等到应用程序转换到后台再删除对它们的引用。</p>
<p>应该尽快删除强引用的对象的一些示例包括：</p>
<ul>
<li>你创建的图像对象。</li>
<li>可以从磁盘重新加载的大型媒体或数据文件</li>
<li>您的应用程序不需要的任何稍后可以重新创建其他对象。</li>
</ul>
<p>为了帮助你减少应用程序的内存占用空间，系统会自动清除在应用程序移动到后台时代表应用程序分配的数据。</p>
<ul>
<li>系统清除所有Core Animation层的后备存储。 此功能不会从应用程序的图层对象中删除内存，也不会更改当前图层属性。 它只是防止这些图层的内容出现在屏幕上，这表明应用程序在后台应该不会发生。</li>
<li>它删除任何系统对缓存图像的引用。</li>
<li>它删除了对其他系统管理的数据高速缓存的强引用。</li>
</ul>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cocoalei.github.io/blogs/2015/09/02/ios-property/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blogs/images/avatar.gif">
      <meta itemprop="name" content="CocoaLei">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CocoaLei">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blogs/2015/09/02/ios-property/" class="post-title-link" itemprop="url">属性修饰符分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2015-09-02 00:00:00" itemprop="dateCreated datePublished" datetime="2015-09-02T00:00:00+08:00">2015-09-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-01-17 11:35:13" itemprop="dateModified" datetime="2019-01-17T11:35:13+08:00">2019-01-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h3><hr>
<h5 id="atomic-amp-nonatomic"><a href="#atomic-amp-nonatomic" class="headerlink" title="atomic &amp; nonatomic"></a>atomic &amp; nonatomic</h5><p>决定编译器生成的setter/getter是否为原子操作 。<br>atomic是Objc使用的一种线程保护技术，防止在某个操作未完成时被另外一个线程操作，造成数据错误。然而这种多线程安全机制对资源的占用很大，在iPhone等小型设备中，除非需要使用多线程之间通讯编程，采用这种技术需要慎重考量。<br>一般情况下，使用nonatomic来修饰成员变量，存取器直接返回一个值，而不需要管当不同的线程同时访问时会发生什么。</p>
<h5 id="readwrite-amp-readonly"><a href="#readwrite-amp-readonly" class="headerlink" title="readwrite &amp; readonly"></a>readwrite &amp; readonly</h5><p>  任何属性都可以声明为readwrite或readonly，且默认设置为readwrite 。<br>  将一个属性声明为readwrite时，编译器将会为这个属性生成setter和getter。<br>  将一个属性生命为readonly时，编译器将只会生成getter。</p>
<h5 id="assign"><a href="#assign" class="headerlink" title="assign"></a>assign</h5><p>   直接赋值，不更改引用计数，一般用于基础数据类型和C语言类型数据。</p>
<h5 id="retain"><a href="#retain" class="headerlink" title="retain"></a>retain</h5><p>   释放旧对象，并使传入的新对象引用计数+1。<br>   此属性只能用于NSObject及其子类，而不能用于Core Foundation（因为其没有使用引用计数，需要另外使用CFRetain和CFRelease来进行CF的内存管理）。</p>
<h5 id="strong"><a href="#strong" class="headerlink" title="strong"></a>strong</h5><p>   释放旧对象，并使传入的新对象引用计数+1。<br>   在ARC下，strong为对象类型属性声明时的默认值。</p>
<h5 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h5><p>   创建一个引用计数为1的新对象，这个新对象是传入对象的拷贝。<br>   会拷贝传入的对象（即创建一个引用计数为1的新对象，但是内容与传入对象相同），并把新对象赋值给实例变量。</p>
<h5 id="weak"><a href="#weak" class="headerlink" title="weak"></a>weak</h5><p>  弱引用，要求不保留传入的属性（既不会使传入的对象引用计数+1）。<br>  类似于assign，但与assign不同的是，当它们指向的对象被释放后，weak会被自动置为nil，而assign则不会。</p>
<hr>
<h3 id="进阶问题"><a href="#进阶问题" class="headerlink" title="进阶问题"></a>进阶问题</h3><hr>
<h5 id="strong-amp-weak"><a href="#strong-amp-weak" class="headerlink" title="strong &amp; weak"></a>strong &amp; weak</h5><p>这里采用 stack overflow 上的一个对强/弱引用的解释</p>
<blockquote>
<p>如果将对象想象成一只想要逃跑(be deallocated)的狗的话。</p>
<p>强引用就像是拴住狗的绳子。只要你还还牵着拴住狗的绳子，狗就逃跑不了。如果有五个人都将绳子拴住了狗，那么除非五个人都解开了绳子，否则狗就不可能逃跑。</p>
<p>而弱引用，就像一个小孩子指着狗说：看，那里有一直狗。只要狗仍被狗绳拴着，小孩就还能看见狗，他们仍会指着它。然而一但狗绳被解开，狗就会逃跑而不管多少小孩子指着它。</p>
</blockquote>
<h5 id="copy-amp-retain"><a href="#copy-amp-retain" class="headerlink" title="copy &amp; retain"></a>copy &amp; retain</h5><p>copy实际上是建立了一个新的相同的对象，而retain是将传入对象的引用计数+1 。</p>
<h5 id="深拷贝-amp-浅拷贝"><a href="#深拷贝-amp-浅拷贝" class="headerlink" title="深拷贝 &amp; 浅拷贝"></a>深拷贝 &amp; 浅拷贝</h5><p>浅拷贝就是对内存地址的复制，让目标对象指针和源对象指向同一片内存空间 。浅拷贝只是对对象的简单拷贝，让几个对象共用一片内存，当内存销毁的时候，指向这片内存的几个指针需要重新定义才可以使用，要不然会成为野指针。<br>在iOS中，使用retain修饰的属性变量，就是一种浅拷贝。它既让几个指针共用同一片内存空间，又可以在release时由于计数的存在，不会轻易的销毁内存，达到更加简单使用的目的。<br>深拷贝是指拷贝对象的具体内容，而内存地址是自主分配的，拷贝结束之后，两个对象虽然存的值是相同的，但是内存地址不一样，两个对象也互不影响，互不干涉。<br>值得注意的是，对可变对象如NSMutableArray等无论是copy还是mutableCopy都是进行了深拷贝。</p>
<h5 id="property-amp-synthesize"><a href="#property-amp-synthesize" class="headerlink" title="@property &amp; @synthesize"></a>@property &amp; @synthesize</h5><p>如果我们希望使用默认的实例变量命名方式，那么我们在.m文件中就不需要使用@synthesize声明，系统会帮我们自动完成。如果我们希望自己命名实例变量命，那么我们就使用@synthesize显式声明我们希望的实例变量名 。</p>
<h5 id="block作为实例变量为何要用copy修饰？"><a href="#block作为实例变量为何要用copy修饰？" class="headerlink" title="block作为实例变量为何要用copy修饰？"></a>block作为实例变量为何要用copy修饰？</h5><p>因为block如果在栈上的话，其所属的变量作用域结束，该block就被释放掉，block中的__block变量也同时被释放掉。为了解决栈块在其变量作用域结束之后被释放掉的问题，我们就需要把block复制到堆中。</p>
<h5 id="为什么NSString、NSDictionary、NSArray要使用copy修饰？"><a href="#为什么NSString、NSDictionary、NSArray要使用copy修饰？" class="headerlink" title="为什么NSString、NSDictionary、NSArray要使用copy修饰？"></a>为什么NSString、NSDictionary、NSArray要使用copy修饰？</h5><p>对于NSString、NSDictionary、NSArray等经常使用copy关键字，是因为它们有对应的可变类型：NSMutableString、NSMutableDictionary、NSMutableArray，它们之间可能进行赋值操作，为确保对象中的字符串值不会无意间变动，应该在设置新属性时拷贝一份。</p>
<h5 id="weak、copy、strong、assgin分别用在什么地方？"><a href="#weak、copy、strong、assgin分别用在什么地方？" class="headerlink" title="weak、copy、strong、assgin分别用在什么地方？"></a>weak、copy、strong、assgin分别用在什么地方？</h5><p>什么情况下会使用weak关键字？</p>
<ul>
<li>在ARC中，出现循环引用的时候，会使用weak关键字。</li>
<li>自身已经对它进行了一次强引用，没有必要再强调引用一次。</li>
</ul>
<p>assgin适用于基本的数据类型，比如NSInteger、BOOL等。</p>
<p>NSString、NSArray、NSDictionary等经常使用copy关键字，是因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary；</p>
<p>除了上面的三种情况，剩下的就使用strong来进行修饰。</p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/blogs/page/3/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/blogs/">1</a><span class="space">&hellip;</span><a class="page-number" href="/blogs/page/3/">3</a><span class="page-number current">4</span>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">CocoaLei</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/blogs/archives/">
        
          <span class="site-state-item-count">32</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/blogs/categories">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/blogs/tags/">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">CocoaLei</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/blogs/lib/anime.min.js"></script>
  <script src="/blogs/lib/velocity/velocity.min.js"></script>
  <script src="/blogs/lib/velocity/velocity.ui.min.js"></script>

<script src="/blogs/js/utils.js"></script>

<script src="/blogs/js/motion.js"></script>


<script src="/blogs/js/schemes/pisces.js"></script>


<script src="/blogs/js/next-boot.js"></script>




  















  

  

</body>
</html>
