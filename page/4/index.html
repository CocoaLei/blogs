<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/FullStackCourse/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/FullStackCourse/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/FullStackCourse/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/FullStackCourse/images/logo.svg" color="#222">

<link rel="stylesheet" href="/FullStackCourse/css/main.css">


<link rel="stylesheet" href="/FullStackCourse/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"cocoalei.github.io","root":"/FullStackCourse/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="CocoaLei">
<meta property="og:url" content="https://cocoalei.github.io/FullStackCourse/page/4/index.html">
<meta property="og:site_name" content="CocoaLei">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="CocoaLei">
<meta property="article:tag" content="iOS">
<meta property="article:tag" content="HTML">
<meta property="article:tag" content="CSS">
<meta property="article:tag" content="JavaScript">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://cocoalei.github.io/FullStackCourse/page/4/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>CocoaLei</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/FullStackCourse/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">CocoaLei</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/FullStackCourse/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/FullStackCourse/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/FullStackCourse/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/FullStackCourse/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cocoalei.github.io/FullStackCourse/2015/10/21/ios-background-execution/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/FullStackCourse/images/avatar.gif">
      <meta itemprop="name" content="CocoaLei">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CocoaLei">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/FullStackCourse/2015/10/21/ios-background-execution/" class="post-title-link" itemprop="url">后台运行探索与解析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2015-10-21 00:00:00" itemprop="dateCreated datePublished" datetime="2015-10-21T00:00:00+08:00">2015-10-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-01-17 11:35:39" itemprop="dateModified" datetime="2019-01-17T11:35:39+08:00">2019-01-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/FullStackCourse/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="iOS-后台运行"><a href="#iOS-后台运行" class="headerlink" title="iOS 后台运行"></a>iOS 后台运行</h1><hr>
<p>当用户没有主动的使用你的应用程序时，系统会将它转换为后台运行状态。对于大多说应用程序来说，后台运行状态只是应用程序在被系统挂起前的一个阶段。挂起应用程序是一个改善电池寿命并让系统为前台应用程序释放重要资源的方式。</p>
<p>大多数应用程序都能很容易的挂起，但是拥有合理的理由在后台继续运行的应用程序也是有的。一个远足应用程序想要随着时间来定位用户的位置，让它能够在地图上显示用户的运动进程。一个音频应用程序可能需要在屏幕锁定时继续播放音乐。其它的应用程序可能想要在后台下载内容以便能够减少将内容呈献给用户的延迟。当你发现你的应用程序需要保持在后台继续运行的时候，iOS系统能够帮助你有效率的且尽可能少地占用系统资源的完成这个目的。</p>
<p>iOS提供的技术分为三类：</p>
<ul>
<li>在前台开始短任务的应用程序可以在进入后台状态时向系统请求完成这个任务的额外时间。</li>
<li>在前台启动下载的应用程序可以将这些下载的管理移交给系统，从而允许在下载过程中暂停或终止该应用。</li>
<li>需要在后台运行以支持特定类型任务的应用程序可以声明对一个或多个后台执行模式的支持。</li>
</ul>
<p>尽可能避免在后台执行任何任务除非这样做能全面的提升用户的体验。应用程序可能会因为启动了另一个应用程序，锁定了屏幕或现在不使用它而被转入后台。在这些情况下，用户都表明你的应用程序现在不需要做任何有意义的工作。在这种情况下继续运行只会浪费设备的电量并可能导致用户强制的完全退出你的应用程序。所以你应该审慎的考虑在后台运行应用程序。</p>
<h2 id="执行有限长度的任务"><a href="#执行有限长度的任务" class="headerlink" title="执行有限长度的任务"></a>执行有限长度的任务</h2><p>被转入后台的应用程序期待尽可能快的进入非活动状态以便它们能够被系统挂起。如果你的应用程序正在执行某个任务而且完成这个任务还需要一些时间的话，你可用调用 <code>UIApplication</code> 的<code>beginBackgroundTaskWithName:expirationHandler:</code> 或<code>beginBackgroundTaskWithExpirationHandler:</code>方法来请求一些额外的执行时间。调用这两个方法的任一个都会暂时的推迟你的应用程序被挂起，从而为完成你正在进行的任务赢得一些额外的时间。一旦你的应用程序完成了任务，你必须调用<code>endBackgroundTask:</code>方法让系统知道你的应用程序已经完成了任务，可以被挂起了。</p>
<p>每个调用<code>beginBackgroundTaskWithName:expirationHandler:</code> 或 <code>beginBackgroundTaskWithExpirationHandler:</code> 方法的应用程序都会生成一个与相应的任务相关的标记。当你的应用程序完成任务时，它必须以这个标记来调用 <code>endBackgroundTask:</code>方法告知系统任务已经完成。调用 <code>endBackgroundTask:</code>方法失败会导致你的应用程序被终止。如果你在启动任务的时候提供了一个完成处理模块，系统会调用这个模块并给你最后一次结束任务避免程序被终止的机会。</p>
<p>你不需要一直到等到应用程序进入后台才指定后台任务。一个更有用的设计是在开始任务之前调用<code>beginBackgroundTaskWithName：expirationHandler：</code>或<code>beginBackgroundTaskWithExpirationHandler：</code>方法，一旦完成就调用<code>endBackgroundTask：</code>方法.</p>
<p>下面的的代码展示了当你的应用程序进入后台时如何开始一个长时运行的任务。在这个例子中，开始后台任务的请求包含了一个完成处理模块以防这个任务耗时太长。这个任务稍后会被提交到一个异步执行的队列中以便<code>applicationDidEnterBackground:</code>方法能够正常返回。blocks的使用简化了维护一些重要变量引用所需要的代码。<code>bgTask</code>变量是指向存储当前任务标识符的指针的类的成员变量，它在调用这个方法之前被初始化。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (void)applicationDidEnterBackground:(UIApplication *)application &#123;</span><br><span class="line">    bgTask &#x3D; [application beginBackgroundTaskWithName:@&quot;MyTask&quot; expirationHandler:^&#123;</span><br><span class="line">        &#x2F;&#x2F; Clean up any unfinished task business by marking where you</span><br><span class="line">        &#x2F;&#x2F; stopped or ending the task outright.</span><br><span class="line">        [application endBackgroundTask:bgTask];</span><br><span class="line">        bgTask &#x3D; UIBackgroundTaskInvalid;</span><br><span class="line">    &#125;];</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; Start the long-running task and return immediately.</span><br><span class="line">    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F; Do the work associated with the task, preferably in chunks.</span><br><span class="line"> </span><br><span class="line">        [application endBackgroundTask:bgTask];</span><br><span class="line">        bgTask &#x3D; UIBackgroundTaskInvalid;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意:</strong> 你总是要在开始一个任务的时候提供完成处理模块，但是如果你想知道你的应用程序还能运行多长时间，你可以通过<code>UIApplication</code>对象的<code>backgroundTimeRemaining</code>属性来获得。</p>
</blockquote>
<p>在你的完成处理模块中，你可以加入一些必须的代码来关闭你的任务。但是，完成处理模块中的任何代码都不应该耗费太长的时间去执行，因为你的完成处理模块一旦被调用，就说明你的应用程序已经快要被关闭了。因此，只执行最少的清理状态信息并结束任务。</p>
<h2 id="在后台执行下载任务"><a href="#在后台执行下载任务" class="headerlink" title="在后台执行下载任务"></a>在后台执行下载任务</h2><p>当下载文件时，应用程序应该使用<code>NSURLSession</code>对象来开始下载，这样系统就能控制下载的进程即使应用程序被挂起或终止。当你配置<code>NSURLSession</code>对象进行后台传输时，系统用一个单独的队列管理这些任务并以常规方式将传输的状态报告给你的应用程序。如果你的应用程序在传输正在进行时被终止，系统会在后台继续传输，并在传输完成或一个甚至多个任务需要你的应用程序时启动你的应用程序(若果使用)。</p>
<p>为了支持后台传输，你必须合适地配置你的<code>NSURLSession</code>对象。为了配置<code>NSURLSession</code>有必须先创建一个<code>NSURLSessionConfiguration</code>对象并给它的一些属性赋予合适的值。然后将这个<code>NSURLSessionConfiguration</code>对象在初始化<code>NSURLSession</code>对象时传递过去。</p>
<p>创建支持后台下载的<code>NSURLSessionConfiguration</code>对象的过程如下：</p>
<p>   1.使用<code>NSURLSessionConfiguration</code>的<code>backgroundSessionConfigurationWithIdentifier：</code>方法创建配置对象。</p>
<p>   2.将配置对象的<code>sessionSendLaunchEvents</code>属性的值设置为<code>YES</code>。</p>
<p>   3.如果你的应用程序在前台进行转移，建议你将<code>sessionSendsLaunchEvents</code>属性设置为<code>YES</code>。</p>
<p>   4.根据需要配置配置对象的任何其他属性。</p>
<p>   5.使用配置对象创建您的<code>NSURLSession</code>对象。</p>
<p>一旦配置完成，你的<code>NSURLSession</code>对象会在合适的时间将上传和下载任务移交给系统。如果任务在你的应用程序仍在运行时完成(无论是在前台或是后台)，<code>NSURLSession</code>对象都会以常规方式通知它的代理。如果任务还未完成时你的应用程序就被终止，系统会自动地在后台管理任务。如果用户终止了你的应用程序，系统会停止任何待处理的任务。</p>
<p>当所有与后台会话管理的任务完成时，系统会重启被终止的应用程序(假定<code>sessionSendsLaunchEvents</code>属性被设置为<code>YES</code>而且这个应用程序不是被用户强制终止的)并调用应用代理的<code>application:handleEventsForBackgroundURLSession:completionHandler:</code>方法。(系统还可以重新启动应用程序来处理身份验证或其他需要你的应用程序注意的任务的相关事件)在执行该委托方法时，请使用提供的标识符创建一个新的与之前相同的<code>NSURLSessionConfiguration</code>和<code>NSURLSession</code>对象。 系统将你的新会话对象重新连接到先前的任务，并将其状态报告给会话对象的委托。</p>
<h2 id="执行长时间运行的任务"><a href="#执行长时间运行的任务" class="headerlink" title="执行长时间运行的任务"></a>执行长时间运行的任务</h2><p>对于需要更多后台执行时间的任务，你必须请求特定的权限才能在后台运行它们而不被挂起。iOS中，只有特定类型的应用程序被允许在后台运行：</p>
<ul>
<li>在后台播放音频内容给用户，比如音乐播放器</li>
<li>在后台录制音频文件</li>
<li>使用户随时了解其位置的应用程序，比如导航应用程序</li>
<li>支持VoIP的应用程序</li>
<li>需要经常性的下载和处理新内容的应用程序</li>
<li>周期性的从外部配件接收更新的应用程序</li>
</ul>
<p>使用这些服务的应用程序必须声明其支持的服务，并使用系统框架来实现这些服务的相关方面。</p>
<h3 id="声明你的应用程序支持的后台模式"><a href="#声明你的应用程序支持的后台模式" class="headerlink" title="声明你的应用程序支持的后台模式"></a>声明你的应用程序支持的后台模式</h3><p>你必须在应用程序使用后台任务之前声明你要支持的后台任务类型。在Xcode 5和之后，你需要在你工程的Capabilities选项卡中声明你要支持哪些后台模式。启用后台模式选项将<code>UIBackgroundModes</code>键添加到应用程序的<code>Info.plist</code>文件中。</p>
<p>下表列出了你可以指定的后台模式的值：</p>
<table>
<thead>
<tr>
<th>Xcode后台模式</th>
<th>UIBackgroundModes 值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>音频和AirPlay</td>
<td><code>audio</code></td>
<td>应用程序在后台播放或录制音频内容。用户必须在第一次使用前就授权使用麦克风。</td>
</tr>
<tr>
<td>位置更新</td>
<td><code>location</code></td>
<td>使用户随时知道他们的位置，即使应用在后台运行。</td>
</tr>
<tr>
<td>网络电话</td>
<td><code>voip</code></td>
<td>应用程序提供给用户通过网络连接进行通话的能力。</td>
</tr>
<tr>
<td>Newsstand下载</td>
<td><code>newsstand-content</code></td>
<td>Newsstand类型的应用程序在后台下载并处理报纸或杂志内容。</td>
</tr>
<tr>
<td>外部附件通信</td>
<td><code>external-accessory</code></td>
<td>应用程序与需要通过外部附件框架定期提供更新的硬件配件配合使用。</td>
</tr>
<tr>
<td>使用蓝牙设备</td>
<td><code>bluetooth-central</code></td>
<td>应用程序使用需要通过Core Bluetooth框架定期发送更新的蓝牙设备。</td>
</tr>
<tr>
<td>作为蓝牙LE附件</td>
<td><code>bluetooth-peripheral</code></td>
<td>应用程序通过Core Bluetooth框架支持外设模式下的蓝牙通信。使用此模式需要用户授权</td>
</tr>
<tr>
<td>后台抓取</td>
<td><code>fetch</code></td>
<td>应用程序定期的从网路下载并处理少量数据。</td>
</tr>
<tr>
<td>远程推送</td>
<td><code>remote-notification</code></td>
<td>应用程序想要在接收到一个远程推送时开始下载内容。</td>
</tr>
</tbody></table>
<p>以上每种模式都让系统知道应该在合适的时间唤醒或启动应用程序来响应相关的事件。</p>
<h4 id="追踪用户位置"><a href="#追踪用户位置" class="headerlink" title="追踪用户位置"></a>追踪用户位置</h4><p>在后台追踪用户的位置的方式有好几种，大多数方式实际上并不需要你的应用程序在后台不断的运行。</p>
<ul>
<li>重大位置变更</li>
<li>仅在前台定位服务</li>
<li>后台定位服务</li>
</ul>
<p>对于不需要高精度位置数据的应用程序来说，推荐使用重大位置变更定位服务。这个服务只有在用户的位置发生非常重大的变化时才会产生位置更新；它对社交类应用程序或者给用户提供不是很重要的位置相关信息的应用程序来说是非常理想的定位方式。如果当一个位置更新发生时应用程序被终止，系统会在后台唤醒它来处理这个更新。如果应用程序开始使用了这个服务然后被终止，当新的位置更新产生时，系统会自动重启它。</p>
<p>仅前台定位服务和后台定位服务都使用标准的Core Location服务获取位置数据。唯一的区别是，如果应用程序被挂起，则仅前台定位服务停止发送更新。 前台定位服务适用于只在前台需要位置数据的应用程序。</p>
<p>你可以在Xcode工程中的<code>Capabilities</code>选项卡中启用支持定位服务(你也可以通过在<code>Info.plist</code>文件中设置<code>UIBackgroundModes</code>的值为<code>location</code>来启用这个服务)。启用这个服务并不会阻止系统挂起你的应用程序，但是它会告知系统无论何时新的位置更新被发送过来都应该唤醒应用程序来处理。</p>
<blockquote>
<p><strong>重要提示:</strong>鼓励你谨慎使用标准的定位服务或改用重要的位置更改服务。 定位服务需要经常使用iOS设备的板载无线电硬件。 连续运行这个硬件会消耗大量的电量。 如果你的应用程序不需要向用户提供精确且连续的位置信息，则最好尽量减少使用位置服务。</p>
</blockquote>
<h4 id="在后台播放或录制音频"><a href="#在后台播放或录制音频" class="headerlink" title="在后台播放或录制音频"></a>在后台播放或录制音频</h4><p>一个需要连续播放或录制音频的应用程序(即使应用处在后台)可以注册后台服务，实现即使在后台也能执行这些任务。你可以在Xcode工程中的<code>Capabilities</code>选项卡中启用服务(你也可以通过在<code>Info.plist</code>文件中设置<code>UIBackgroundModes</code>的值为<code>audio</code>来启用这个服务)。在后台播放音频内容的应用程序必须播放听得见的内容而不能是无声的。</p>
<p>后台音频应用程序的典型例子包括：</p>
<ul>
<li>音乐播放程序</li>
<li>音频录制程序</li>
<li>支持通过AirPlay播放音频或视频的程序</li>
<li>VoIP程序</li>
</ul>
<p>当<code>UIBackgroundModes</code>键包含<code>audio</code>值时，系统的媒体框架会自动阻止相关的应用程序被挂起。只要应用程序还在播放视屏或音频内容，录制音频，它就还能在后台运行。然而，一旦录制或播放停止，就会被系统挂起。</p>
<p>你可以使用任何系统音频框架来处理后台音频播放，并且使用这些框架的过程和在前台使用相同(对于通过AriPlay播放视频内容来说，你可以使用Media Player或AVFoundation框架来实现)。因为应用程序在播放媒体文件时不会被挂起，所以即使应用程序在后台也能正常的进行回调操作。在你的回调中，你应该只做为播放提供数据的工作，不应该在回调中执行任何与播放无关的任务。</p>
<p>在任何给定的时刻，因为可能有不止一个应用程序支持音频服务，所以由系统来决定哪个应用程序能够播放或录制音频。前台应用程序总是有优先的音频操作权利。可能有不止一个应用程序被允许在后台播放音频，这个时候决定哪个应用程序能够播放音频就取决于每个应用程序的音频会话的配置。</p>
<h4 id="实现一个VoIP应用程序"><a href="#实现一个VoIP应用程序" class="headerlink" title="实现一个VoIP应用程序"></a>实现一个VoIP应用程序</h4><p>一个Voice over Internet Protocol应用程序允许用户通过互联网而不是设备的蜂窝网络设备进行语音通话。这样的一个应用程序需要为它的服务维持一个持续的网络连接，以便它能接收到打进来的电话和其它相关数据。系统允许VoIP应用程序被挂起并给它提供了监测它们的sockets的便利，而不是让它一直处于唤醒状态。当检测到传入流量时，系统唤醒VoIP程序并将socket的控制权交还给它。</p>
<p>为了配置VoIP应用程序，你必须：</p>
<ul>
<li>在Xcode工程中的<code>Capabilities</code>选项卡中启用服务(你也可以通过在<code>Info.plist</code>文件中设置<code>UIBackgroundModes</code>的值为<code>voip</code>来启用这个服务)。</li>
<li>为VoIP应用程序配置一个socket。</li>
<li>在移动到后台之前，调用<code>setKeepAliveTimeout:handler:</code>方法来安装一个定期执行的程序。你的应用程序可以使用这个处理程序来保持服务连接。</li>
<li>配置你的音频会话来操作进入或退出活跃的使用状态的转换。</li>
</ul>
<p>设置<code>UIBackgroundModes</code>的值为<code>voip</code>让系统知道，当VoIP应用程序需要管理它的网络会话时，系统应该允许它在后台运行。为了让VoIP应用程序总是可用，系统会在启动后立刻重新启动拥有这个键值的应用程序。</p>
<p>大多数的VoIP应用程序也需要配置后台音频模式，因为它也需要在后台发送音频内容。因此，你应该将<code>UIBackgroundModes</code>的值设置为<code>audio</code>和<code>voip</code>。如果你不这样做的话，你的应用程序将不能在后台播放或录制音频内容。</p>
<h4 id="适时的获取少量内容"><a href="#适时的获取少量内容" class="headerlink" title="适时的获取少量内容"></a>适时的获取少量内容</h4><p>需要定期的检查新内容的应用程序可以请求系统唤醒它们，以便它们可以初始化一个获取内容的拉取操作。为了支持这种模式，你需要在Xcode工程中的<code>Capabilities</code>选项卡中启用服务(你也可以通过在<code>Info.plist</code>文件中设置<code>UIBackgroundModes</code>的值为<code>fetch</code>来启用这个服务)。启用这个服务并不能保证系统会给你的应用程序任何时间来执行后台拉取操作。系统必须在你的应用程序拉取内容的请求和其它应用程序以及系统自身之间做出平衡。在评估所有信息后，如果有很好的机会的话，系统会给请求拉取内容的应用程序一些执行时间。</p>
<p>当有好机会产生时，系统会唤醒或启动你的应用程序到后台并调用应用程序代理对象的<code>application:performFetchWithCompletionHandler:</code>方法。使用这个方法来检查新内容，如果新内容可用则开始下载操作。一旦新内容下载完成，你必须将新内容是否可用的结果传递给提供好的完成处理块。执行这个块告诉系统它可以将你的应用程序转换到挂起状态并评估其使用功率。可以快速下载少量内容并在它们有可用的下载内容时准确反应的应用程序，比起花费更长的下载时间或声称有可用的下载内容但没有下载任何东西的应用程序，更可能在未来获得执行时间。</p>
<p>在下载任何内容时，推荐你使用<code>NSURLSession</code>类来开始和管理你的下载。</p>
<h4 id="使用推送通知来开始下载"><a href="#使用推送通知来开始下载" class="headerlink" title="使用推送通知来开始下载"></a>使用推送通知来开始下载</h4><p>如果你的服务器在有新的应用程序可用内容时向用户的设备发送了一个推送通知，你可以请求系统在后台运行你的应用程序并立即开始下载新的可用内容。这种后台模式意图在于尽可能减少从你的用户看见推送通知到你的应用程序可以展示相关内容之间的时间。应用程序通常会在用户看见推送通知的差不多相同的时间被唤醒，但是仍会给你更多的准备时间。</p>
<p>为了支持这种模式，你需要在Xcode工程中的<code>Capabilities</code>选项卡中启这项用服务(你也可以通过在<code>Info.plist</code>文件中设置<code>UIBackgroundModes</code>的值为<code>remote-notification</code>来启用这个服务)。</p>
<p>对于一个使用推送通知来触发下载操作的应用程序来说，通知的有效内容必须包含值为<code>1</code>的<code>content-available</code>的键。当这个键值对被检测到时，系统会启动或唤醒你的应用程序到后台同时调用应用程序的代理对象的<code>application:didReceiveRemoteNotification:fetchCompletionHandler:</code>方法。你应该在这个方法里实现对相关内容的下载并将下载好的内容在加入到你的应用程序中。</p>
<p>在下载任何内容时，推荐你使用<code>NSURLSession</code>类来开始和管理你的下载。</p>
<h4 id="在后台下载新闻站内容"><a href="#在后台下载新闻站内容" class="headerlink" title="在后台下载新闻站内容"></a>在后台下载新闻站内容</h4><p>下载新闻和新的杂志文章的新闻站应用程序可以注册在后台进行这些下载。你需要在Xcode工程中的<code>Capabilities</code>选项卡中启这项用服务(你也可以通过在<code>Info.plist</code>文件中设置<code>UIBackgroundModes</code>的值为<code>newsstand-content</code>来启用这个服务)。当你提供这个关键字时，如果你的应用程序没有在运行，系统会启动你的应用程序以便它能开始下载新的文章。</p>
<p>当你使用Newsstand Kit框架来开始一个下载时，由系统为你的应用程序操作下载的进程。即使你的应用程序被挂起或终止，系统仍会继续下载文件。当下载操作完成后，系统将下载好的文件传输到你的应用程序的沙盒并向你的应用程序发送一个通知。如果应用程序没有在运行，这个通知会唤醒它并给它一个处理新的下载文件的机会。如果在下载过程中发生了错误，你的应用程序也会这样被唤醒来处理这个错误。</p>
<h4 id="与外部附件通信"><a href="#与外部附件通信" class="headerlink" title="与外部附件通信"></a>与外部附件通信</h4><p>使用外部附件的应用程序可以请求在附件发送了一个更新时被唤醒，即使它处在挂起状态。这种支持对于某些定期发送数据的附件来说是非常重要的，比如心率监视器。你需要在Xcode工程中的<code>Capabilities</code>选项卡中启这项用服务(你也可以通过在<code>Info.plist</code>文件中设置<code>UIBackgroundModes</code>的值为<code>external-accessory</code>来启用这个服务)。当你启用这个模式时，外部附件框架不会关闭活跃的外部附件会话。当外部附件发送来新的内容时，这个框架唤醒你的应用程序以便它能处理这些数据内容。在外部附件建立连接或失去连接时，系统也会唤醒应用程序来进行处理。</p>
<p>任何支持附件更新后台处理的应用程序都必须遵循以下基本准则：</p>
<ul>
<li><p>应用程序必须提供一个界面，让用户来开始或者停止附件更新事件的发送。</p>
</li>
<li><p>一旦被唤醒，应用程序大约有10S时间来处理数据。理想情况下，它应该尽可能快速地处理数据然后转换到挂起状态。但是，如果需要更多的时间，应用程序可以使用<code>beginBackgroundTaskWithExpirationHandler:</code>方法来申请额外的执行时间。</p>
</li>
</ul>
<h4 id="与蓝牙附件通信"><a href="#与蓝牙附件通信" class="headerlink" title="与蓝牙附件通信"></a>与蓝牙附件通信</h4><p>使用蓝牙外设的应用程序可以请求在外设发送了一个更新时被唤醒，即使它处在挂起状态。这种支持对于需要定期发送数据的Bluetooth-LE外设来说是非常重要的。你需要在Xcode工程中的<code>Capabilities</code>选项卡中启这项用服务(你也可以通过在<code>Info.plist</code>文件中设置<code>UIBackgroundModes</code>的值为<code>bluetooth-central</code>来启用这个服务)。当你启用这个模式时，Core Bluetooth框架会保持相应外设的任何活跃会话连接。此外，当有新的数据从外设传来，系统会唤醒应用程序让他能够处理数据。在外设建立连接或失去连接时，系统也会唤醒应用程序来进行处理。</p>
<p>iOS 6中，一个使用蓝牙外设的应用程序也可以在外设模式下运行。要充当蓝牙外设，你需要在Xcode工程中的<code>Capabilities</code>选项卡中启这项用服务(您也可以通过在应用程序<code>Info.plis</code>t文件中包含<code>UIBackgroundModes</code>键和<code>bluetooth-peripheral</code>值来启用此支持)。启用此模式可让Core Bluetooth框架在后台简单地唤醒应用程序，以便它可以处理外设的相关请求。</p>
<p>支持蓝牙数据后台处理的任何应用程序都必须基于会话，并遵循以下基本准则：</p>
<ul>
<li><p>应用程序必须提供一个界面，允许用户启动和停止蓝牙事件的传递。</p>
</li>
<li><p>被唤醒后，应用程序大概需要10秒钟才能处理数据。理想情况下，它应该尽可能快地处理数据，并允许自己再次暂停。但是，如果需要更多的时间，应用程序可以使用<code>beginBackgroundTaskWithExpirationHandler</code>：方法来请求更多的时间，它应该只有在绝对必要的时候才这样做。</p>
<p>​</p>
</li>
</ul>
<h2 id="在后台获得用户的注意"><a href="#在后台获得用户的注意" class="headerlink" title="在后台获得用户的注意"></a>在后台获得用户的注意</h2><p>通知是处在挂起，在后台运行或没有运行的应用程序获得用户的注意的一种方式。应用程序可以使用本地通知来显示提醒框，播放声音，标记应用程序的图标或者全部一起使用。比如，一个闹钟应用程序可能会使用本地通知来播放闹铃声并显示一个提醒框来使闹钟不可用。当一个通知被发送给用户，用户必须决定是否授权让应用程序来到前台。如果应用程序已经在前台，本地通知将会被静默的发送给你的应用程序而不是发送给用户。</p>
<p>为了安排本地通知的发送，需要创建一个配置了通知的各个参数的<code>UILocalNotification</code>类的实例并调用<code>UIApplication</code>类的方法。本地通知对象包含了发送通知的类型和在什么时间发送它的信息。<code>UIApplication</code>类的方法提供了是立即发送还是按时间表发送通知的选项。</p>
<p>下面的代码片段展示了如何安排一个由用户设置的使用了日期和时间的闹钟的例子。这个例子在一个时间只配置了一个闹钟并在安排它之前终止了前一个闹钟(你的应用程序在任何给定的时刻都不能拥有超过128个处在活跃状态的本地通知，它们每一个都能设置成以固定的时间间隔重复)。如果闹钟被触发时，应用程序没有运行或者处在后台，闹钟会弹出提醒框并在后台播放音频。如果应用程序是活动且处在前台，则会调用应用程序的代理对象的<code>application:didReceiveLocalNotification:</code>方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (void)scheduleAlarmForDate:(NSDate*)theDate &#123;</span><br><span class="line">    UIApplication* app &#x3D; [UIApplication sharedApplication];</span><br><span class="line">    NSArray*    oldNotifications &#x3D; [app scheduledLocalNotifications];</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; Clear out the old notification before scheduling a new one.</span><br><span class="line">    if ([oldNotifications count] &gt; 0)</span><br><span class="line">        [app cancelAllLocalNotifications];</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; Create a new notification.</span><br><span class="line">    UILocalNotification* alarm &#x3D; [[UILocalNotification alloc] init];</span><br><span class="line">    if (alarm)</span><br><span class="line">    &#123;</span><br><span class="line">        alarm.fireDate &#x3D; theDate;</span><br><span class="line">        alarm.timeZone &#x3D; [NSTimeZone defaultTimeZone];</span><br><span class="line">        alarm.repeatInterval &#x3D; 0;</span><br><span class="line">        alarm.soundName &#x3D; @&quot;alarmsound.caf&quot;;</span><br><span class="line">        alarm.alertBody &#x3D; @&quot;Time to wake up!&quot;;</span><br><span class="line"> </span><br><span class="line">        [app scheduleLocalNotification:alarm];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本地通知使用的音频文件和推送通知使用的要求相同。自定义的音频文件必须位于你应用程序主要包中且必须是以下几种格式：Linear PCM，MA4，μ-Law或者a-Law。你也可以指定<code>UILocalNotificationDefaultSoundName</code>常量来使设备播放默认的提醒声音。当通知被发送且音频被播放时，系统也会触发设备震动来配合。</p>
<h2 id="何时启动应用程序进入后台"><a href="#何时启动应用程序进入后台" class="headerlink" title="何时启动应用程序进入后台"></a>何时启动应用程序进入后台</h2><p>支持后台执行的应用程序可能会被系统重启来处理发生的事件。如果应用程序不是被用户强制退出，系统会启动应用程序在下列事件发生时：</p>
<ul>
<li>对于定位应用程序<ul>
<li>系统收到一个满足发送给应用程序标准的位置更新。</li>
<li>设备进入或退出一个已注册的区域。</li>
</ul>
</li>
<li>对于音频应用程序，音频框架需要应用程序来处理某些数据。</li>
<li>对于蓝牙应用程序<ul>
<li>应用程序作为从连接的外设接收数据的核心角色。</li>
<li>应用程序作为从连接核心接收命令的外设。</li>
</ul>
</li>
<li>对于后台下载应用程序<ul>
<li>应用程序收到一个包含 <code>content-available</code> 键并且值为 <code>1</code>的远程通知。</li>
<li>系统在随机时间唤醒应用程序来开始新内容的下载。</li>
<li>使用<code>NSURLSession</code>对象在后台下载内容的应用程序，当这个会话相关的任务全部成功完成或发生了一个错误。</li>
<li>Newsstand应用程序内容下载完成。</li>
</ul>
</li>
</ul>
<p>在大多数情况下，系统并不会重启被用户强制退出的应用程序。定位应用程序是个例外，在iOS8和之后。如果不是的话，用户必须显式的启动应用程序或者重启设备，系统才能自动的启动程序进入后台。当启用密码保护时，在用户第一次解锁设备之前，系统不会启动任何应用程序进入后台。</p>
<h2 id="成为一个负责的后台运行应用程序"><a href="#成为一个负责的后台运行应用程序" class="headerlink" title="成为一个负责的后台运行应用程序"></a>成为一个负责的后台运行应用程序</h2><p>在使用系统资源和硬件时，前台应用程序始终比后台应用程序的优先级高。后台应用程序需要为这个差异做准备并调整它们的行为：</p>
<ul>
<li><strong>不要在你的代码中进行任何OpenGL ES调用</strong>。在后台运行时，你绝不能创建<code>EAGLContext</code>对象或发出任何OpenGL ES绘图命令。使用这些会使你的应用程序被立即终止。应用程序必须保证任何先前提交的命令在移入后台之前完成。</li>
</ul>
<ul>
<li><strong>在挂起之前停止任何Bonjour-related服务</strong>。在你的应用程序移入后台但未被挂起之前，它应该从Bonjour注销并关闭任何与网络服务相关的监听sockets。一个挂起的应用程序无论如何不能响应任何传入的服务请求。如果你没有关闭Bonjour服务，在应用程序挂起时，系统会自动的关闭它们。</li>
<li><strong>准备好处理基于网络的sockets的连接失败</strong>。系统可能会销毁socket连接，当你的应用程序因为某些原因被挂起时。只要你的基于网络的socket代码准备好了如何处理其他类型的网络失败，比如使用失败信号或网络转化，socket被销毁就不会导致出现任何不寻常的问题。当你的应用程序重新开始运行时，如果使用socket遭遇故障，只需重新建立一个。</li>
<li><strong>在转入后台之前保存你的应用程序的状态</strong>。处于低内存的情况下，后台应用程序可能会被从内存中移除以释放空间。挂起的应用程序首先被移除，并且不会在移除之前通知应用程序。因此，应用程序应该利用iOS 6及之后提供的状态保存机制将应用程序状态信息保存到磁盘。</li>
<li><strong>在转入后台时移除对任何不需要的对象的强引用</strong>。</li>
<li><strong>在挂起之前停止使用共享系统资源</strong>。与共享系统资源进行交互的应用程序应该在被挂起之前停止使用这些资源。前台应用程序总是拥有这些资源的优先使用权。当你的应用程序挂起时，如果被发现它在使用这些共享资源，则会被系统杀死进程。</li>
<li><strong>避免更新窗口和视图</strong>。因为你的应用程序的窗口和视图在后台是不可见的，你应该避免更新它们。如果你的应用程序需要在系统拍摄快照前更新窗口的内容的话则是一种例外情况。</li>
<li><strong>响应外部附件的连接和断开通知</strong>。对于和外部附件通信的应用程序来说，当应用程序转入后台时系统会自动的发送一个断开通知。应用程序必须注册这个通知并用它来关闭当前附件的会话。当应用程序转入前台时，一个匹配连接的通知被发送，给应用程序重新连接的机会。</li>
<li><strong>在转入后台时清理活动的提醒框的资源</strong>。为了在各个应用程序之间进行切换时保存上下文，在你的应用程序进入后台时，系统不会自动地释放上拉菜单或提醒视图。在应用程序转入后台之前，你需要提供合适的清理行为。</li>
<li><strong>在转入后台之前从视图中移除敏感信息</strong>。当应用程序转入后台时，系统会对应用程序的主窗口拍摄快照，当应用程序转入到前台时，这个快照会短暂的显示。在从<code>applicationDidEnterBackground:</code>方法返回之前，你应该隐藏或混淆可能被作为快照一部分拍摄的密码和其它敏感的个人信息</li>
<li><strong>在后台运行时尽可能的少做工作</strong>。给与后台应用程序的执行时间相比于前台应用程序来说有更多的限制。应用程序不应该在后台执行太长时间，这可能导致应用程序被终止。</li>
</ul>
<h2 id="选择退出后台执行"><a href="#选择退出后台执行" class="headerlink" title="选择退出后台执行"></a>选择退出后台执行</h2><p>如果你不希望你的应用程序在后台运行，你可以通过将值为<code>YES</code>的<code>UIApplicationExitsOnSuspend</code>键加入<code>Info.plist</code>来显式的退出后台模式。当一个应用程序选择退出后台，它的生命周期将在未运行，非活动和活动状态之间转换，永远不会进入后台或被挂起状态。当用户按下Home按钮来退出应用程序时，应用程序代理对象的<code>applicationWillTerminate:</code>方法将会被调用，应用程序将有大约5秒时间在它被终止或移入未运行状态之前来执行清理任务并退出。</p>
<p>强烈不鼓励退出后台执行，但在某些情况下可能是首选。 具体来说，如果后台执行的编码对你的应用程序来说增加了很大的复杂性，那么终止应用程序可能会更简单。 此外，如果你的应用程序消耗大量内存，并且无法轻松释放任何内存，系统可能会迅速杀死你的应用程序，为其他应用程序腾出空间。 因此，选择终止，而不是切换到后台，可能会产生相同的结果，并节省你的开发时间和精力。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cocoalei.github.io/FullStackCourse/2015/10/18/ios-application-life-cycle/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/FullStackCourse/images/avatar.gif">
      <meta itemprop="name" content="CocoaLei">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CocoaLei">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/FullStackCourse/2015/10/18/ios-application-life-cycle/" class="post-title-link" itemprop="url">应用程序生命周期和状态转换操作策略</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2015-10-18 00:00:00" itemprop="dateCreated datePublished" datetime="2015-10-18T00:00:00+08:00">2015-10-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-01-17 11:35:28" itemprop="dateModified" datetime="2019-01-17T11:35:28+08:00">2019-01-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/FullStackCourse/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="iOS-应用程序生命周期"><a href="#iOS-应用程序生命周期" class="headerlink" title="iOS 应用程序生命周期"></a>iOS 应用程序生命周期</h1><hr>
<h2 id="基本概念介绍"><a href="#基本概念介绍" class="headerlink" title="基本概念介绍"></a>基本概念介绍</h2><h3 id="The-Main-Function-程序的入口"><a href="#The-Main-Function-程序的入口" class="headerlink" title="The Main Function - 程序的入口"></a>The Main Function - 程序的入口</h3><p><code>main</code>函数是每个基于C的应用程序的入口，iOS也是这样。在Xcode中开发iOS程序的话，Xcode会自动为你创建这个函数作为你工程的一部分。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>main</code>函数控制UIKit framework的工作。<code>UIApplicationMain</code>函数通过创建应用程序的核心对象，从可用的<code>storyboard</code>文件加载应用程序的用户界面，调用自定义代码，以便让你可以在程序启动时进行一些初始设置，并将应用程序的运行循环启动。 </p>
<h3 id="The-Structure-of-an-App-程序的结构"><a href="#The-Structure-of-an-App-程序的结构" class="headerlink" title="The Structure of  an App - 程序的结构"></a>The Structure of  an App - 程序的结构</h3><p>在启动过程中，<code>UIApplicationMain</code>函数设置了几个关键对象，启动应用程序并开始运行它。 每个iOS应用程序的核心都是<code>UIApplication</code>对象，其工作是为了方便系统与应用程序中的其他对象之间的交互。 </p>
<p>一个iOS应用程序中包含的关键对象：</p>
<img src="https://raw.githubusercontent.com/apple272487813/apple272487813.github.io/master/images/application_life_cycle/application_core_objects.png"  style="zoom:50%"/>



<p>一个iOS应用程序中各个对象的所起到的作用：</p>
<table>
<thead>
<tr>
<th align="left">Object</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>UIAppplication</code></td>
<td><code>UIApplication</code>对象管理着App的事件循环和一些高级App行为，并向它的委托对象报告App的状态转换和一些特殊事件。</td>
</tr>
<tr>
<td align="left"><code>Appdelegate</code></td>
<td><code>Appdelegate</code>是你编写的程序代码的核心 ，它与<code>UIApplication</code>对象一起工作，处理应用程序初始化，状态转换和许多高级App行为。 这个对象也是唯一一个保证在每个应用程序中都出现的对象，因此通常用于设置应用程序的初始数据结构。</td>
</tr>
<tr>
<td align="left"><code>ViewController</code></td>
<td><code>View Controller</code>对象管理着你的App内容在屏幕上是如何呈现的。一个<code>View Controller</code>对象管理着一个视图和这个视图的子视图。</td>
</tr>
<tr>
<td align="left"><code>UIWindow</code></td>
<td><code>UIWindow</code>对象协调屏幕上一个或多个视图的呈现。 大多数应用程序只有一个窗口，它在主屏幕上显示内容，但应用程序可能会在外部显示器上显示内容的附加窗口。要更改应用程序的内容，可以使用视图控制器更改相应窗口中显示的视图。 你永远不会更换窗口本身。除了托管视图之外，<code>Windows</code>还可以使用<code>UIApplication</code>对象将事件传递给的视图和控制器。</td>
</tr>
<tr>
<td align="left"><code>View,Control and Layer</code></td>
<td>View和Control提供了应用内容的可视化表示。 除了包含View和Control之外，应用程序还可以将Core Animation图层纳入其视图和控制层次结构中。 层对象实际上才是表示可视内容的数据对象。</td>
</tr>
</tbody></table>
<h3 id="The-Main-Run-Loop-主运行循环"><a href="#The-Main-Run-Loop-主运行循环" class="headerlink" title="The Main Run Loop - 主运行循环"></a>The Main Run Loop - 主运行循环</h3><p>应用程序的主运行循环处理所有与用户相关的事件。 <code>UIApplication</code>对象在启动时设置主运行循环，并使用它来处理事件并处理基于视图的接口的更新。</p>
<p> 顾名思义，主运行循环在应用程序的主线程上执行，这确保了与用户相关的事件按照接收的顺序连续处理。</p>
<p>当用户与设备进行交互时，与这些交互相关的事件由系统生成，并通过由UIKit设置的特殊端口传送到应用。 事件在应用程序内部进入队列，并逐个分派到主运行循环执行。<code>UIApplication</code>对象是接收事件的第一个对象，并且决定需要做什么来处理这个事件。 触摸事件通常被分派到主窗口对象，主窗口对象又将其发送到触摸发生的视图。 </p>
<img src="https://raw.githubusercontent.com/apple272487813/apple272487813.github.io/master/images/application_life_cycle/application_event_draw_cycle.png" style="zoom:50%"/>

<p>可以在iOS应用程式中分发许多类型的事件。 最常见的如下表所示。 这些事件大多是使用应用程序的主运行循环分发的，但也有些不是。 一些事件被分发到一个委托对象或被分发给你提供的一个block。</p>
<table>
<thead>
<tr>
<th>事件类型</th>
<th>分发对象</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>触摸事件</td>
<td>事件发生的视图</td>
<td>视图是响应者对象。任何没有被当前视图处理的触摸事件都会被沿着响应链继续向下分发进行处理。</td>
</tr>
<tr>
<td>遥控器事件和摇动运动事件</td>
<td>首要响应对象</td>
<td>遥控器事件用于控制媒体播放，并由耳机和其他附件产生。</td>
</tr>
<tr>
<td>加速度计、磁力仪和陀螺仪</td>
<td>你指定的对象</td>
<td>与加速度计，磁力计和陀螺仪硬件相关的事件传递给你指定的对象。</td>
</tr>
<tr>
<td>定位</td>
<td>你指定的对象</td>
<td>你注册定位服务以接收使用Core Location框架位置的事件。</td>
</tr>
<tr>
<td>重绘</td>
<td>需要更新的视图</td>
<td>重绘事件不涉及事件对象，而是简单地调用视图来绘制自身。</td>
</tr>
</tbody></table>
<p>一些事件，如触摸和遥控事件，由你的应用程序的响应者对象处理。响应者对象在你的应用程序中无处不在。 大多数事件都针对特定的响应者对象，但如果需要处理事件，则可以将其传递给其他响应方（通过响应者链）。 例如，不处理事件的视图可以将事件传递到其父视图或父视图控制器。</p>
<p>触摸控件（如按钮）中发生的事件的处理方式与在许多其他类型的视图中发生的触摸事件的处理方式不同。 通常只有有限数量的交互可能与控件相关联，因此这些交互被重新封装到动作消息中并传递到适当的目标对象。 这种目标动作(Target-Action)设计模式可以轻松地使用控件来触发你应用中自定义代码的执行。</p>
<h3 id="Execution-States-for-Apps-应用程序的执行状态"><a href="#Execution-States-for-Apps-应用程序的执行状态" class="headerlink" title="Execution States for Apps - 应用程序的执行状态"></a>Execution States for Apps - 应用程序的执行状态</h3><p>在任何给定的时刻，你的应用程序都处在下表所列的状态之一。 系统会改变应用程序的状态以响应整个系统中发生的操作。</p>
<table>
<thead>
<tr>
<th>状态</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Not running</td>
<td>应用程序没有运行或被系统终止运行。</td>
</tr>
<tr>
<td>Inactive</td>
<td>应用程序正在前台运行，但当前没有收到事件 (它可能正在执行其他代码)。应用程序通常在转换到不同的状态时暂时保持在此状态。</td>
</tr>
<tr>
<td>Active</td>
<td>应用程序正在前台运行，并且正在接收事件(这是前台应用程序的正常模式)。</td>
</tr>
<tr>
<td>Background</td>
<td>应用程序在后台执行代码。 大多数应用程序短暂地进入此状态。 但是，请求额外执行时间的应用程序可能会保持此状态一段时间。</td>
</tr>
<tr>
<td>Suspended</td>
<td>应用程序是在后台，但不执行代码。 系统将应用程序自动转换到这个状态，在这样做之前并不会通知应用程序。 挂起时，应用程序保留在内存中，但不执行任何代码。当出现低内存条件时，系统可能会清除已挂起的应用程序，以为前台应用程序腾出更多空间。</td>
</tr>
</tbody></table>
<p>下图展示了应用程序在各种状态之间的转换：</p>
<img src="https://raw.githubusercontent.com/apple272487813/apple272487813.github.io/master/images/application_life_cycle/application_high_level_flow.png" style="zoom:50%"/>

<p>大多数状态转换伴随着对应用程序委托对象的方法的相应调用 ，这些方法是你以适当方式响应状态变更的地方。 </p>
<ul>
<li><p><code>application:willFinishLaunchingWithOptions:</code></p>
<p>告诉代理对象启动过程已经开始，但还没有发生状态恢复。</p>
</li>
<li><p><code>application:didFinishLaunchingWithOptions:</code></p>
<p>告诉代理对象启动过程快要完成，应用程序快要准备好运行。</p>
</li>
<li><p><code>applicationDidBecomeActive:</code></p>
<p>告诉代理对象应用程序已经处于Active状态。</p>
</li>
<li><p><code>applicationWillResignActive:</code></p>
<p>告诉代理对象应用程序即将进入Inactive状态。</p>
</li>
<li><p><code>applicationDidEnterBackground:</code></p>
<p>告诉代理对象应用程序已经进入后台。</p>
</li>
<li><p><code>applicationWillEnterForeground:</code></p>
<p>告诉代理对象应用程序即将进入前台。</p>
</li>
<li><p><code>applicationWillTerminate:</code></p>
<p>告诉代理对象应用程序即将被终止。</p>
<p>​</p>
</li>
</ul>
<h3 id="App-Termination-应用程序的终止"><a href="#App-Termination-应用程序的终止" class="headerlink" title="App Termination - 应用程序的终止"></a>App Termination - 应用程序的终止</h3><p>应用程序必须随时准备终止运行，不应等待保存用户数据或执行其他关键任务。 System-initiated termination是应用程序生命周期的正常部分。该系统通常终止应用程序，以便它可以回收内存并为用户启动的其他应用程序腾出空间，但是系统也可能会终止行为不当或未及时响应事件的应用程序。</p>
<p>挂起的应用程序终止时不会收到通知，系统将杀死该进程并回收相应的内存。如果一个应用程序当前在后台运行并且没有挂起，系统会在终止之前调用应用程序委托的<code>applicationWillTerminate：</code>。当设备重新启动时，系统不会调用此方法。</p>
<p>除了系统终止你的应用程序，用户可以使用多任务UI显式地终止你的应用程序。System-initiated termination与终止挂起的应用程序具有相同的效果。该应用程序的进程被杀死，并且不会有通知发送到该应用程序。</p>
<h3 id="Threads-and-Concurrency-线程和并发"><a href="#Threads-and-Concurrency-线程和并发" class="headerlink" title="Threads and Concurrency - 线程和并发"></a>Threads and Concurrency - 线程和并发</h3><p>系统创建你的应用程序的主线程，你可以根据需要创建其他线程来执行其他任务。</p>
<p>对于iOS应用，首选技术是使用Grand Central Dispatch（GCD），操作对象和其它异步编程接口，而不是自己创建和管理线程。 GCD等技术可以让你定义想要执行的工作以及要执行的顺序，但让系统决定如何在可用的CPU上执行该工作。让系统处理线程管理简化了必须编写的代码，使得更容易确保代码的正确性，并提供更好的整体性能。</p>
<p>在考虑线程和并发时，请考虑以下几点：</p>
<ul>
<li><p>涉及视图，核心动画和许多其他UIKit类的工作通常必须发生在应用程序的主线程上。</p>
</li>
<li><p>长时间的任务（或潜在的长度任务）应始终在后台线程上执行。任何涉及网络访问，文件访问或大量数据处理的任务都应使用GCD或操作对象异步执行。</p>
</li>
<li><p>在启动时，尽可能将任务从主线程移出。在启动时，您的应用程序应尽可能快地设置用户界面。只有有助于设置用户界面的任务才能在主线程上执行。</p>
<p>所有其他任务应该是异步执行的。</p>
</li>
</ul>
<hr>
<h2 id="操作应用程序的状态转换"><a href="#操作应用程序的状态转换" class="headerlink" title="操作应用程序的状态转换"></a>操作应用程序的状态转换</h2><hr>
<p>对于应用程序的任何一个可能的运行状态，系统都对你的应用程序有不同的期望。当应用程序的状态发生转换时，系统会通知应用对象，应用对象又通知其代理。你可以使用<code>UIApplicationDelegate</code>协议的状态转换方法来检测这些状态变化并进行适当的响应。</p>
<h2 id="应用程序启动时应该做什么"><a href="#应用程序启动时应该做什么" class="headerlink" title="应用程序启动时应该做什么"></a>应用程序启动时应该做什么</h2><p>当应用程序启动(进入前台货后台)时，你应该使用应用程序委托对象的<code>application:willFinishLaunchingWithOptions:</code>和<code>application：didFinishLaunchingWithOptions：</code>方法执行一些操作：</p>
<ul>
<li><p>检查启动选项字典的内容(launch options dictionary)，了解应用程序启动的原因，并作出适当的响应。</p>
</li>
<li><p>初始化应用程序的关键数据结构。</p>
</li>
<li><p>准备应用程序的窗口和视图以进行内容显示。</p>
<ul>
<li><p>使用OpenGL ES进行绘图的应用程序不能使用这些方法来准备绘图环境，使用OpenGL ES绘图应该在<code>applicationDidBecomeActive:</code>方法中进行准备。</p>
</li>
<li><p>Show your app window from your <code>application:willFinishLaunchingWithOptions:</code> method. UIKit delays making the window visible until after the <code>application:didFinishLaunchingWithOptions:</code> method returns.</p>
</li>
<li><p>在<code>application:willFinishLaunchingWithOptions:</code>方法中配置如何显示应用程序的Window。UIKit延迟Window的显示直到<code>application:didFinishLaunchingWithOptions:</code>方法进行了返回。</p>
</li>
</ul>
</li>
</ul>
<p>在启动时，系统会自动的加载应用程序的主要storyBoard文件，并加载初始视图控制器。对于支持状态恢复的应用程序，状态恢复机制会在调用<code>application:willFinishLaunchingWithOptions:</code>和 <code>application:didFinishLaunchingWithOptions:</code>方法之间将应用程序恢复到以前的状态。使用<code>application:willFinishLaunchingWithOptions:</code>方法显示应用程序窗口，并确定状态恢复是否应该发生。使用<code>application:didFinishLaunchingWithOptions:</code>方法对应用程序的用户界面进行任何最终调整。</p>
<p><code>application:willFinishLaunchingWithOptions:</code>和<code>application:didFinishLaunchingWithOptions:</code>方法应始终尽可能轻量级，以减少应用程序的启动时间。如果应用程序没有及时完成其启动周期，系统将使其无法响应。因此，任何可能减慢启动速度的任务（如访问网络）都应该在辅助线程上执行。</p>
<h3 id="The-Launch-Cycle-启动周期"><a href="#The-Launch-Cycle-启动周期" class="headerlink" title="The Launch Cycle - 启动周期"></a>The Launch Cycle - 启动周期</h3><p>当你的应用程序启动后，在短暂的停留在非活动状态(Inactive)后，将会从非运行状态(Not Running)转换到活动状态(Active)或后台状态(Background)。作为启动周期的一部分，系统会为你的应用程序创建一个进程和一个主线程，并在主线程中调用应用程序的<code>main</code>函数。</p>
<p>下图显示了应用程序启动到前台时发生的事件序列，包括调用的应用程序委派方法。</p>
<img src="https://raw.githubusercontent.com/apple272487813/apple272487813.github.io/master/images/application_life_cycle/app_launch_fg.png" style="zoom:50%" />



<p>当你的应用程序启动到后台时，通常要处理一些后台事件，启动周期会有些许改变。主要的不同在于，在后台的应用程序不是处于活动状态，只是进入后台来处理一些事件，之后可能会被挂起。当启动到后台时，系统仍然会加载用户界面文件，但不会显示应用程序的窗口。</p>
<img src="https://raw.githubusercontent.com/apple272487813/apple272487813.github.io/master/images/application_life_cycle/app_launch_bg.png" style="zoom:50%"/>

<p>你可以通过在代理方法 <code>application:willFinishLaunchingWithOptions:</code> 和<code>application:didFinishLaunchingWithOptions:</code>中检查<code>UIApplication</code>的<code>applicationState</code>属性来决定应用程序是启动到前台还是后台。当你的应用程序启动到前台时，这个属性的值是<code>UIApplicationStateInactive</code>，当你的应用程序启动到后台时，这个属性的值是<code>UIApplicationStateBackground</code>。</p>
<h3 id="Launching-in-Landscape-Mode-以横屏模式启动"><a href="#Launching-in-Landscape-Mode-以横屏模式启动" class="headerlink" title="Launching in Landscape Mode - 以横屏模式启动"></a>Launching in Landscape Mode - 以横屏模式启动</h3><p>对于界面只使用横屏的应用程序来说，必须明确地请求系统以横屏模式启动。通常来说，应用程序以纵屏模式启动，只有在需要适应设备的方向的时候才旋转屏幕的方向。 对于支持纵向和横向方向的应用程序，应始终为纵向模式配置视图，然后让视图控制器处理任何旋转。<br>但是，如果您的应用程序支持横向而不是纵向方向，请执行以下任务，让使其以横向模式启动：</p>
<ul>
<li>像你应用程序中的<code>Infl.plist</code>文件中添加<code>UIInterfaceOrientation</code>字段，并将其值设为<code>UIInterfaceOrientationLandscapeLeft</code>或<code>UIInterfaceOrientationLandscapeRight</code>。</li>
<li>在横屏模式下布局你的视图并确保视图的布局和自动调整大小选项设置正确。</li>
<li>重写试图控制器的<code>shouldAutorotateToInterfaceOrientation:</code>方法并在左向横屏或右向横屏时返回<code>YES</code>，在纵屏模式下返回<code>NO</code>。</li>
</ul>
<blockquote>
<p><strong>重要提示:</strong> 应用程序应该总是用视图控制器来管理基于窗口(Window)的内容。</p>
</blockquote>
<p>在<code>Info.plist</code>文件中的<code>UIInterfaceOrientation</code>字段告诉iOS系统该如何配置应用程序状态栏的方向(如果显示的话)以及任何视图控制器管理的视图在启动时的方向。视图控制器根据这个字段设置它的视图的初始方向。 使用此字段相当于在执行你的<code>applicationDidFinishLaunching:</code>方法的早期调用应用程序的<code>setStatusBarOrientation：animated:</code>方法。</p>
<h3 id="Installing-App-Specific-Data-Files-at-First-Launch-配置应用程序数据文件"><a href="#Installing-App-Specific-Data-Files-at-First-Launch-配置应用程序数据文件" class="headerlink" title="Installing App-Specific Data Files at First Launch - 配置应用程序数据文件"></a>Installing App-Specific Data Files at First Launch - 配置应用程序数据文件</h3><p>你可以使用应用程序的第一个启动周期来设置任何应用程序运行所需要的数据或配置文件。 应用程序特定的数据文件应在应用程序沙箱的<code>Library/Application Support/&lt;bundleID&gt;/</code>目录中创建，其中<bundleID>是应用程序的标识符。你可以根据需要细分目录来组织你的数据文件。</p>
<p>如果应用程序包中包含你打算进行修改的数据文件，你应该将要修改的数据文件从应用程序的数据包中复制出来进行修改。你不能在应用程序包中修改数据文件，因为iOS应用程序是代码签名的，在应用程序包中修改数据文件会使应用程序的签名失效，使得你的应用程序无法启动。将打算修改的数据文件复制到<code>Application Support</code>(或者其它可写的目录)目录下进行修改是唯一安全的方式。</p>
<h2 id="应用程序临时被打断时应该做什么"><a href="#应用程序临时被打断时应该做什么" class="headerlink" title="应用程序临时被打断时应该做什么"></a>应用程序临时被打断时应该做什么</h2><p>基于警报的打断会导致你的应用程序临时性的失去控制。这种情况下，你的应用程序仍然运行在前台，但是不接收任何来自系统的触摸事件(但是会继续接收推送通知等其他类型的时间，比如加速度计时间等)。你应该在<code>applicationWillResignActive:</code>方法中进行如下操作来处理这种情况：</p>
<ul>
<li>保存数据以及任何相关的状态信息。</li>
<li>停止计时器和其他周期性任务。</li>
<li>停止任何进行的数据请求任务。</li>
<li>不要创建任何新的任务。</li>
<li>停止视屏播放(除了通过AriPlay播放的视屏)</li>
<li>如果你的应用程序是游戏的话，是游戏进入暂停状态。</li>
<li>提高OpenGL ES 帧速率。</li>
<li>暂停执行非关键代码的任何调度队列或操作队列。 (可以在不活动的情况下继续处理网络请求和其他时间敏感的后台任务)</li>
</ul>
<p>当你的应用程序返回活动状态时，在<code>applicationDidBecomeActive:</code>方法中应该进行与<code>applicationWillResignActive:</code>相反的操作步骤。因此，一但重新活动，你的应用程序应重新启动计时器，恢复调度队列，并再次调低OpenGL ES帧速率。 但是，游戏不应该自动恢复，它们应该保持暂停，直到用户选择恢复它们为止。</p>
<p>当用户按下睡眠或唤醒按钮时，含有<code>NSFileProtectionComplete</code>保护选项的文件的应用程序必须关闭这些被保护文件的任何引用。对于设置了相应密码的设备，按下睡眠或唤醒按钮时应该锁定屏幕并强制系统丢弃对拥有完全保护文件的解密密钥。当屏幕锁定时，任何尝试访问相关文件的操作都会失败。所以你如果有这样的文件，你应该在<code>applicationWillResignActive:</code>方法中关闭对它们的任何引用，在<code>applicationDidBecomeActive:</code>中打开新的引用。</p>
<p><strong>重要提示:</strong> 你应该总是在适当的时候保存用户数据。虽然你可以使用应用程序状态转换来强制对象将为保存的变更写入磁盘，但是合适的做法是永远不要等到状态转换时才去保存数据。</p>
<h3 id="Responding-to-Temporary-Interruptions-响应临时打断"><a href="#Responding-to-Temporary-Interruptions-响应临时打断" class="headerlink" title="Responding to Temporary Interruptions - 响应临时打断"></a>Responding to Temporary Interruptions - 响应临时打断</h3><p>当基于警报的打断发生时(比如打进电话)，应用程序暂时进入非活动状态已便系统可以提示用户如和继续操作。应用程序保持在这个状态直到用户拒绝了这个警报，这时应用程序会返回前台进入活动状态或进入后台。</p>
<img src="https://raw.githubusercontent.com/apple272487813/apple272487813.github.io/master/images/application_life_cycle/app_interruptions.png" style="zoom:50%"/>

<p>以横幅形式显示的通知不会像基于警报的通知那样是你的应用程序进入非活动状态。尽管横幅放置在你应用程序窗口的顶部边缘，但是你的应用程序还是能够继续接收触摸事件。然而如果用户下拉横幅以便查看通知中心，你的应用程序就会像基于警报的打断发生时那样进入非活动状态。你的应用程序保持在非活动状态直到用户退出通知中心或启动另一个应用程序，这时，你的应用程序相应的会进入非活动转台或后台。</p>
<p>按下睡眠或唤醒按钮是另一种类型的可以导致你的应用程序暂时进入非活动状态的打断。当用户按下这个按钮，系统会使触摸事件变得不可用并让应用程序进入后台，同时将<code>applicationState</code>的值设置为<code>UIApplicationStateBackground</code>并锁定屏幕。</p>
<h2 id="应用程序在前台时做什么"><a href="#应用程序在前台时做什么" class="headerlink" title="应用程序在前台时做什么"></a>应用程序在前台时做什么</h2><p>当你的应用程序返回前台进入活动状态时，你可以重新启动在进入后台时停止的任务。移动到前台时出现的步骤如下图所示，<code>applicationWillEnterForeground：</code>方法应该撤消在<code>applicationDidEnterBackground：</code>方法中完成的任何内容，并且<code>applicationDidBecomeActive：</code>方法应该继续执行与启动时相同的激活任务。</p>
<img src="https://raw.githubusercontent.com/apple272487813/apple272487813.github.io/master/images/application_life_cycle/app_enter_foreground.png" style="zoom:50%"/>



<h3 id="Be-Prepared-to-Process-Queued-Notifications-准备处理通知队列"><a href="#Be-Prepared-to-Process-Queued-Notifications-准备处理通知队列" class="headerlink" title="Be Prepared to Process Queued Notifications - 准备处理通知队列"></a>Be Prepared to Process Queued Notifications - 准备处理通知队列</h3><p>一个处于挂起状态的应用程序必须做好在返回前台或进入后台执行状态时处理任何在队列中的通知。处于挂起状态的应用程序不执行任何代码，因此不能处理通知引发的屏幕方向改变，时间改变，偏好改变以及其它会影响应用程序的外观和状态的改变。为了确保这些改变不会丢失，系统将相关的通知放入队列并在应用程序开始执行代码(无论在前台还是后台)时分发通知给它。为了防止应用程序在恢复通知时变得超负荷，系统会将事件合并，并提供一个单一的通知（每种相关类型），反映自您的应用程序被挂起以来的净变化。</p>
<p>下表列出了分发给你的应用程序的可以合并的通知。这些通知的大多数都直接分发给已经注册的观察者。</p>
<table>
<thead>
<tr>
<th>Event</th>
<th>Notifications</th>
</tr>
</thead>
<tbody><tr>
<td>An accessory is connected or disconnected.</td>
<td><code>EAAccessoryDidConnectNotification</code> <code>EAAccessoryDidDisconnectNotification</code></td>
</tr>
<tr>
<td>设备方向改变</td>
<td><code>UIDeviceOrientationDidChangeNotification</code>除了这个通知，视图控制器自动的改变自己的方向。</td>
</tr>
<tr>
<td>重要的时间改变</td>
<td><code>UIApplicationSignificantTimeChangeNotification</code></td>
</tr>
<tr>
<td>电池状态改变</td>
<td><code>UIDeviceBatteryLevelDidChangeNotification</code> <code>UIDeviceBatteryStateDidChangeNotification</code></td>
</tr>
<tr>
<td>The proximity state changes.</td>
<td><code>UIDeviceProximityStateDidChangeNotification</code></td>
</tr>
<tr>
<td>被保护的文件的状态的改变</td>
<td><code>UIApplicationProtectedDataWillBecomeUnavailable</code> <code>UIApplicationProtectedDataDidBecomeAvailable</code></td>
</tr>
<tr>
<td>内建显示器连接或失去连接</td>
<td><code>UIScreenDidConnectNotification</code> <code>UIScreenDidDisconnectNotification</code></td>
</tr>
<tr>
<td>屏幕显示模式改变</td>
<td><code>UIScreenModeDidChangeNotification</code></td>
</tr>
<tr>
<td>通过设置应用程序改变了应用程序的设置</td>
<td><code>NSUserDefaultsDidChangeNotification</code></td>
</tr>
<tr>
<td>当前语言或本地化设置改变</td>
<td><code>NSCurrentLocaleDidChangeNotification</code></td>
</tr>
<tr>
<td>用户的iCloud账户状态改变</td>
<td><code>NSUbiquityIdentityDidChangeNotification</code></td>
</tr>
</tbody></table>
<p>通常在任何触摸事件或用户输入事件之前，在主线程中分发队列化的通知。大多数的应用程序应该足够快地处理这些事件，避免在重启是导致可观察到的延迟。</p>
<p>应用程序返回前台时也会接收到要更新自从上次更新以来被标记为dirty的视图的通知。一个运行在后台的应用程序仍然能调用<code>setNeedsDisplay</code> 和 <code>setNeedsDisplayInRect:</code>方法来请求更新视图。然而，因为这些请求更新的视图不可见，系统合并了这些请求并在应用程序进入前台后才更新它们。</p>
<h3 id="Handle-iCloud-Changes-处理iCloud改变"><a href="#Handle-iCloud-Changes-处理iCloud改变" class="headerlink" title="Handle iCloud Changes - 处理iCloud改变"></a>Handle iCloud Changes - 处理iCloud改变</h3><p>当iCloud的状态发生改变时，系统会发送一个<code>NSUbiquityIdentityDidChangeNotification</code>通知给你的应用程序。用户登入或登出iCloud账号，关闭了文档和数据的同步，都会引起iCloud状态的改变。这个通知表示应用程序应该更新缓存和与iCloud有关的用户界面元素。</p>
<p>如果你的应用程序已经提示了用户是否要在iCloud存储文件的话，不要在iCloud状态发生改变时再次提醒。在第一次提醒了用户后，将用户的选择保存在本地的偏好设置中。</p>
<h3 id="Handle-Locale-Changes-处理本地化改变"><a href="#Handle-Locale-Changes-处理本地化改变" class="headerlink" title="Handle Locale Changes - 处理本地化改变"></a>Handle Locale Changes - 处理本地化改变</h3><p>如果用户在你的应用程序挂起时改变了当前的本地化方案，当你的应用程序返回前台时，你可以使用<code>NSCurrentLocaleDidChangeNotification</code>通知来强制更新包含了对本地化方案敏感的信息，比如日期，时间和数字。当然，最好的避免发生本地化相关的问题的方法是用能简单更新视图的方法来编写代码：</p>
<ul>
<li>使用<code>autoupdatingCurrentLocale</code>类方法当你检索到<code>NSLocal</code>对象。这个方法返回一个可以自动更新自己来响应本地化方案改变的本地化对象，所以你永远不需要重新创建它。然而，当本地化方案发生改变时，你仍然需要更新包含来自于当前本地化方案的信息的视图。</li>
<li>重新创建任何缓存的日期和数字格式，无论当前本地化方案何时发生变化。</li>
</ul>
<h3 id="Handle-Changes-to-Your-App’s-Settings-处理偏好设置的改变"><a href="#Handle-Changes-to-Your-App’s-Settings-处理偏好设置的改变" class="headerlink" title="Handle Changes to Your App’s Settings - 处理偏好设置的改变"></a>Handle Changes to Your App’s Settings - 处理偏好设置的改变</h3><p>如果你的应用程序含有被设置应用程序管理的设置选项，你应该监测<code>NSUserDefaultsDidChangeNotification</code>通知，因为用户可以改变这些设置当你的应用程序被挂起或在后台。你可以使用这个通知来响应并处理在这些设置上的重要改变。</p>
<p>一旦收到<code>NSUserDefaultsDidChangeNotification</code>通知，你的应用程序应该重新加载任何相关的设置，如果需要，恰当地重置用户界面。</p>
<h2 id="应用程序在后台时做什么"><a href="#应用程序在后台时做什么" class="headerlink" title="应用程序在后台时做什么"></a>应用程序在后台时做什么</h2><p>当应用程序从前台转为后台执行时，使用你的代理对象的<code>applicationDidEnterBackground:</code>方法来做：</p>
<ul>
<li>准备应用程序的照片。当你的<code>applicationDidEnterBackground:</code>返回时，系统会对你的应用程序的用户界面拍照并用这个照片来做过度动画。如果你的应用程序里的视图包含敏感信息，你应该在<code>applicationDidEnterBackground:</code>返回之前隐藏或更改这些视图。</li>
<li>保存任何应用程序状态的相关信息。在进入后台之前，你的应用程序应该已经保存好了所有重要的用户数据。使用转换到后台来保存应用程序状态的最后一分钟更改。</li>
</ul>
<p>你的应用程序代理对象的<code>applicationDidEnterBackground:</code>方法大约有5分钟的时间来结束任何任务并返回。实际上，这个方法应该可能快的返回。如果这个方法没有在时间耗尽前返回，你的应用程序将会被终止并被移出内存。如果你仍然需要更多的时间来执行任务，调用<code>beginBackgroundTaskWithExpirationHandler:</code>方法来请求后台执行时间，然后在一个次要线程里开始任何长时任务。不管你有没有开始一个后台任务，<code>applicationDidEnterBackground:</code>方法都会在5分钟内退出。</p>
<p><strong>提示:</strong> 除了调用<code>applicationDidEnterBackground:</code>方法外，系统还会发送<code>UIApplicationDidEnterBackgroundNotification</code>通知。你可以使用这个通知将清理任务分发给应用程序里的其它对象。</p>
<h3 id="The-Background-Transition-Cycle-后台转换周期"><a href="#The-Background-Transition-Cycle-后台转换周期" class="headerlink" title="The Background Transition Cycle - 后台转换周期"></a>The Background Transition Cycle - 后台转换周期</h3><p>When the user presses the Home button, presses the Sleep/Wake button, or the system launches another app, the foreground app transitions to the inactive state and then to the background state. These transitions result in calls to the app delegate’s <code>applicationWillResignActive:</code> and <code>applicationDidEnterBackground:</code> methods, as shown in Figure 4-5. After returning from the <code>applicationDidEnterBackground:</code> method, most apps move to the suspended state shortly afterward. Apps that request specific background tasks (such as playing music) or that request a little extra execution time from the system may continue to run for a while longer.</p>
<p>当用户按下Home键，按下睡眠或唤醒按钮，或者系统启动了另一个应用程序，运行在前台的应用程序会转换为非活动状态然后进入后台。这些状态转换会导致调用<code>applicationWillResignActive:</code> 和 <code>applicationDidEnterBackground:</code>方法，如下图所示。从<code>applicationDidEnterBackground：</code>方法返回后，大多数应用程序不久之后就会转换到挂起状态。 请求特定后台任务（如播放音乐）或从系统请求一点额外执行时间的应用程序可能会持续运行一段时间。</p>
<img src="https://raw.githubusercontent.com/apple272487813/apple272487813.github.io/master/images/application_life_cycle/app_bg_life_cycle.png" style="zoom:50%"/>



<h3 id="Prepare-for-the-App-Snapshot-准备应用程序快照"><a href="#Prepare-for-the-App-Snapshot-准备应用程序快照" class="headerlink" title="Prepare for the App Snapshot - 准备应用程序快照"></a>Prepare for the App Snapshot - 准备应用程序快照</h3><p>系统在应用程序代理对象<code>applicationDidEnterBackground:</code>方法返回的不久之前，对应用程序的窗口进行快照。相似的，当应用程序被唤醒执行后台任务时，系统会对应用程序进行一次新的反应改变的快照。</p>
<p>如果在进入后台更改视图时，可以调用主视图的<code>snapshotViewAfterScreenUpdates：</code>方法来强制执行这些更改。在一个视图上调用<code>setNeedsDisplay</code>方法对快照是无效的，因为快照发生在下一个绘制周期之前。调用值为“YES”的<code>snapshotViewAfterScreenUpdates：</code>方法将立即使用机器的底层缓冲区更新快照。</p>
<h3 id="Reduce-Your-Memory-Footprint"><a href="#Reduce-Your-Memory-Footprint" class="headerlink" title="Reduce Your Memory Footprint"></a>Reduce Your Memory Footprint</h3><p>每个应用程序应该在进入后台时释放尽可能多的内存。 系统尝试尽可能多地在内存中保留应用程序，但是当内存不足时，会终止挂起的应用程序以回收该内存。 在后台消耗大量内存的应用程序是第一个要终止的应用程序。</p>
<p>实际上，你的应用程序应该在不再需要的时候删除对对象的强引用。 删除强引用使编译器能够立即释放对象，以便可以回收对应的内存。 但是，如果要缓存某些对象以提高性能，则可以等到应用程序转换到后台再删除对它们的引用。</p>
<p>应该尽快删除强引用的对象的一些示例包括：</p>
<ul>
<li>你创建的图像对象。</li>
<li>可以从磁盘重新加载的大型媒体或数据文件</li>
<li>您的应用程序不需要的任何稍后可以重新创建其他对象。</li>
</ul>
<p>为了帮助你减少应用程序的内存占用空间，系统会自动清除在应用程序移动到后台时代表应用程序分配的数据。</p>
<ul>
<li>系统清除所有Core Animation层的后备存储。 此功能不会从应用程序的图层对象中删除内存，也不会更改当前图层属性。 它只是防止这些图层的内容出现在屏幕上，这表明应用程序在后台应该不会发生。</li>
<li>它删除任何系统对缓存图像的引用。</li>
<li>它删除了对其他系统管理的数据高速缓存的强引用。</li>
</ul>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://cocoalei.github.io/FullStackCourse/2015/09/02/ios-property/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/FullStackCourse/images/avatar.gif">
      <meta itemprop="name" content="CocoaLei">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CocoaLei">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/FullStackCourse/2015/09/02/ios-property/" class="post-title-link" itemprop="url">属性修饰符分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2015-09-02 00:00:00" itemprop="dateCreated datePublished" datetime="2015-09-02T00:00:00+08:00">2015-09-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-01-17 11:35:13" itemprop="dateModified" datetime="2019-01-17T11:35:13+08:00">2019-01-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/FullStackCourse/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h3><hr>
<h5 id="atomic-amp-nonatomic"><a href="#atomic-amp-nonatomic" class="headerlink" title="atomic &amp; nonatomic"></a>atomic &amp; nonatomic</h5><p>决定编译器生成的setter/getter是否为原子操作 。<br>atomic是Objc使用的一种线程保护技术，防止在某个操作未完成时被另外一个线程操作，造成数据错误。然而这种多线程安全机制对资源的占用很大，在iPhone等小型设备中，除非需要使用多线程之间通讯编程，采用这种技术需要慎重考量。<br>一般情况下，使用nonatomic来修饰成员变量，存取器直接返回一个值，而不需要管当不同的线程同时访问时会发生什么。</p>
<h5 id="readwrite-amp-readonly"><a href="#readwrite-amp-readonly" class="headerlink" title="readwrite &amp; readonly"></a>readwrite &amp; readonly</h5><p>  任何属性都可以声明为readwrite或readonly，且默认设置为readwrite 。<br>  将一个属性声明为readwrite时，编译器将会为这个属性生成setter和getter。<br>  将一个属性生命为readonly时，编译器将只会生成getter。</p>
<h5 id="assign"><a href="#assign" class="headerlink" title="assign"></a>assign</h5><p>   直接赋值，不更改引用计数，一般用于基础数据类型和C语言类型数据。</p>
<h5 id="retain"><a href="#retain" class="headerlink" title="retain"></a>retain</h5><p>   释放旧对象，并使传入的新对象引用计数+1。<br>   此属性只能用于NSObject及其子类，而不能用于Core Foundation（因为其没有使用引用计数，需要另外使用CFRetain和CFRelease来进行CF的内存管理）。</p>
<h5 id="strong"><a href="#strong" class="headerlink" title="strong"></a>strong</h5><p>   释放旧对象，并使传入的新对象引用计数+1。<br>   在ARC下，strong为对象类型属性声明时的默认值。</p>
<h5 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h5><p>   创建一个引用计数为1的新对象，这个新对象是传入对象的拷贝。<br>   会拷贝传入的对象（即创建一个引用计数为1的新对象，但是内容与传入对象相同），并把新对象赋值给实例变量。</p>
<h5 id="weak"><a href="#weak" class="headerlink" title="weak"></a>weak</h5><p>  弱引用，要求不保留传入的属性（既不会使传入的对象引用计数+1）。<br>  类似于assign，但与assign不同的是，当它们指向的对象被释放后，weak会被自动置为nil，而assign则不会。</p>
<hr>
<h3 id="进阶问题"><a href="#进阶问题" class="headerlink" title="进阶问题"></a>进阶问题</h3><hr>
<h5 id="strong-amp-weak"><a href="#strong-amp-weak" class="headerlink" title="strong &amp; weak"></a>strong &amp; weak</h5><p>这里采用 stack overflow 上的一个对强/弱引用的解释</p>
<blockquote>
<p>如果将对象想象成一只想要逃跑(be deallocated)的狗的话。</p>
<p>强引用就像是拴住狗的绳子。只要你还还牵着拴住狗的绳子，狗就逃跑不了。如果有五个人都将绳子拴住了狗，那么除非五个人都解开了绳子，否则狗就不可能逃跑。</p>
<p>而弱引用，就像一个小孩子指着狗说：看，那里有一直狗。只要狗仍被狗绳拴着，小孩就还能看见狗，他们仍会指着它。然而一但狗绳被解开，狗就会逃跑而不管多少小孩子指着它。</p>
</blockquote>
<h5 id="copy-amp-retain"><a href="#copy-amp-retain" class="headerlink" title="copy &amp; retain"></a>copy &amp; retain</h5><p>copy实际上是建立了一个新的相同的对象，而retain是将传入对象的引用计数+1 。</p>
<h5 id="深拷贝-amp-浅拷贝"><a href="#深拷贝-amp-浅拷贝" class="headerlink" title="深拷贝 &amp; 浅拷贝"></a>深拷贝 &amp; 浅拷贝</h5><p>浅拷贝就是对内存地址的复制，让目标对象指针和源对象指向同一片内存空间 。浅拷贝只是对对象的简单拷贝，让几个对象共用一片内存，当内存销毁的时候，指向这片内存的几个指针需要重新定义才可以使用，要不然会成为野指针。<br>在iOS中，使用retain修饰的属性变量，就是一种浅拷贝。它既让几个指针共用同一片内存空间，又可以在release时由于计数的存在，不会轻易的销毁内存，达到更加简单使用的目的。<br>深拷贝是指拷贝对象的具体内容，而内存地址是自主分配的，拷贝结束之后，两个对象虽然存的值是相同的，但是内存地址不一样，两个对象也互不影响，互不干涉。<br>值得注意的是，对可变对象如NSMutableArray等无论是copy还是mutableCopy都是进行了深拷贝。</p>
<h5 id="property-amp-synthesize"><a href="#property-amp-synthesize" class="headerlink" title="@property &amp; @synthesize"></a>@property &amp; @synthesize</h5><p>如果我们希望使用默认的实例变量命名方式，那么我们在.m文件中就不需要使用@synthesize声明，系统会帮我们自动完成。如果我们希望自己命名实例变量命，那么我们就使用@synthesize显式声明我们希望的实例变量名 。</p>
<h5 id="block作为实例变量为何要用copy修饰？"><a href="#block作为实例变量为何要用copy修饰？" class="headerlink" title="block作为实例变量为何要用copy修饰？"></a>block作为实例变量为何要用copy修饰？</h5><p>因为block如果在栈上的话，其所属的变量作用域结束，该block就被释放掉，block中的__block变量也同时被释放掉。为了解决栈块在其变量作用域结束之后被释放掉的问题，我们就需要把block复制到堆中。</p>
<h5 id="为什么NSString、NSDictionary、NSArray要使用copy修饰？"><a href="#为什么NSString、NSDictionary、NSArray要使用copy修饰？" class="headerlink" title="为什么NSString、NSDictionary、NSArray要使用copy修饰？"></a>为什么NSString、NSDictionary、NSArray要使用copy修饰？</h5><p>对于NSString、NSDictionary、NSArray等经常使用copy关键字，是因为它们有对应的可变类型：NSMutableString、NSMutableDictionary、NSMutableArray，它们之间可能进行赋值操作，为确保对象中的字符串值不会无意间变动，应该在设置新属性时拷贝一份。</p>
<h5 id="weak、copy、strong、assgin分别用在什么地方？"><a href="#weak、copy、strong、assgin分别用在什么地方？" class="headerlink" title="weak、copy、strong、assgin分别用在什么地方？"></a>weak、copy、strong、assgin分别用在什么地方？</h5><p>什么情况下会使用weak关键字？</p>
<ul>
<li>在ARC中，出现循环引用的时候，会使用weak关键字。</li>
<li>自身已经对它进行了一次强引用，没有必要再强调引用一次。</li>
</ul>
<p>assgin适用于基本的数据类型，比如NSInteger、BOOL等。</p>
<p>NSString、NSArray、NSDictionary等经常使用copy关键字，是因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary；</p>
<p>除了上面的三种情况，剩下的就使用strong来进行修饰。</p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/FullStackCourse/page/3/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/FullStackCourse/">1</a><span class="space">&hellip;</span><a class="page-number" href="/FullStackCourse/page/3/">3</a><span class="page-number current">4</span>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">CocoaLei</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/FullStackCourse/archives/">
        
          <span class="site-state-item-count">33</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">CocoaLei</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/FullStackCourse/lib/anime.min.js"></script>
  <script src="/FullStackCourse/lib/velocity/velocity.min.js"></script>
  <script src="/FullStackCourse/lib/velocity/velocity.ui.min.js"></script>

<script src="/FullStackCourse/js/utils.js"></script>

<script src="/FullStackCourse/js/motion.js"></script>


<script src="/FullStackCourse/js/schemes/pisces.js"></script>


<script src="/FullStackCourse/js/next-boot.js"></script>




  















  

  

</body>
</html>
