<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>关于代码的碎碎念</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="LeiTech"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="LeiTech"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="ODQ4NjUwMTI5QHFxLmNvbQ&amp;#x3D;&amp;#x3D;"><meta property="og:type" content="blog"><meta property="og:title" content="关于代码的碎碎念"><meta property="og:url" content="https://cocoalei.github.io/blogs"><meta property="og:site_name" content="关于代码的碎碎念"><meta property="og:description" content="ODQ4NjUwMTI5QHFxLmNvbQ&amp;#x3D;&amp;#x3D;"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://cocoalei.github.io/img/og_image.png"><meta property="article:author" content="Y2hlbmdsZWk="><meta property="article:tag" content="iOS,HTML,CSS,JavaScript,Vue.js"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://cocoalei.github.io/blogs"},"headline":"关于代码的碎碎念","image":["https://cocoalei.github.io/img/og_image.png"],"author":{"@type":"Person","name":"Y2hlbmdsZWk="},"publisher":{"@type":"Organization","name":"关于代码的碎碎念","logo":{"@type":"ImageObject","url":"https://cocoalei.github.io/img/logo.svg"}},"description":"ODQ4NjUwMTI5QHFxLmNvbQ&#x3D;&#x3D;"}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-dark.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.4.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="关于代码的碎碎念" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-06-15T16:00:00.000Z" title="2020/6/16 上午12:00:00">2020-06-16</time>发表</span><span class="level-item"><a class="link-muted" href="/categories/Vue/">Vue</a></span><span class="level-item">19 分钟读完 (大约2812个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/06/16/Vue3%20%E6%95%B0%E6%8D%AE%E4%BE%A6%E6%B5%8B%E5%8E%9F%E7%90%86/">Vue 3 原理解析 - 数据侦测原理</a></h1><div class="content"><h2 id="Vue-3-原理解析-数据侦测原理"><a href="#Vue-3-原理解析-数据侦测原理" class="headerlink" title="Vue 3 原理解析 - 数据侦测原理"></a>Vue 3 原理解析 - 数据侦测原理</h2><p>Vue 2.x 及之前的版本中实现数据的可响应，需要对 <code>Object</code> 和 <code>Array</code> 分别进行处理：</p>
<ul>
<li><code>Object</code> 类型通过 <code>Object.definePropery</code> 把属性转换成 <code>getter/setter</code> ，这个过程需要递归侦测所有的对象 <code>key</code> 来实现深度侦测</li>
<li><code>Array</code> 类型通过对改变数组自身的几个方法进行拦截来实现对数组的可响应</li>
</ul>
<p>而在 Vue3 中则是通过 <code>Proxy</code> 实现数据读取和设置拦截，在捕捉器中实现数据依赖收集和触发视图更新的操作。</p>
<h3 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a><code>Proxy</code></h3><p><code>Proxy</code> 是 ES6 中新引入的特性。</p>
<p><code>Proxy</code> 正如其含字面意义 - “代理” 所表明的那样，它是对象与对象之间的一层代理，程序可以通过 <code>Proxy</code> 来访问或操作目标对象，进而可以实现基本操作的拦截和自定义。</p>
<p>基本语法如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br></pre></td></tr></table></figure>

<p>参数：</p>
<ul>
<li><code>target</code> 要代理的原始对象，可以是任何类型的对象，包括原生数组、函数甚至另一个代理对象</li>
<li><code>handler</code> 一个通常以函数作为属性的对象，各属性中的函数分别定义了在执行各种操作时代理的行为</li>
</ul>
<p>举个栗子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> proxyHandler = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> objProxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, proxyHandler);</span><br><span class="line"><span class="comment">// 赋值操作被转发到 obj 对象</span></span><br><span class="line">objProxy.a = <span class="number">37</span>;</span><br></pre></td></tr></table></figure>

<p><code>handler</code> 中可以设置对原始对象各种操作的捕获器，在捕获器中可以自定义修改操作的行为。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">a</span>: <span class="string">&#x27;A&#x27;</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, &#123;</span><br><span class="line">  <span class="attr">get</span>: <span class="function">(<span class="params">o, p</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (p === <span class="string">&#x27;a&#x27;</span>) <span class="keyword">return</span> <span class="string">&#x27;This is A&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> o[p];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>有时我们并不知道目标对象的具体类型，这种情况下使用 <code>Reflect</code> 返回 <code>trap</code> （捕捉器）相应的默认行为。</p>
<p><code>Reflect</code> 是一个内置的不可构造的非函数对象，它提供了拦截 <code>JavaScript</code> 各种操作的方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> proxyObj = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;</span><br><span class="line">    <span class="attr">get</span>: <span class="function">(<span class="params">obj, prop</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(obj, prop, receiver);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">set</span>: <span class="function">(<span class="params">obj, prop, value</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">Reflect</span>.set(obj, prop, value, receiver);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>对于 <code>set</code> 操作，可能会引起代理对象的属性更改，导致 <code>set</code> 多次执行。比如当代理对象是数组时，执行 <code>push</code> 操作，会多次触发 <code>set</code>，同时也引发 <code>get</code> 操作。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> array = [ <span class="number">1</span>, <span class="number">3</span> ];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxyHandler = &#123;</span><br><span class="line">    <span class="attr">get</span>: <span class="function">(<span class="params">target, prop, receiver</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;Get value : &#x27;</span>, prop, <span class="built_in">Reflect</span>.get(target, prop, receiver));</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, prop, receiver);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">set</span>: <span class="function">(<span class="params">target, prop, value, receiver</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;Set value  :&#x27;</span>, prop, value);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(target, prop, value, receiver);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> objProxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(array, proxyHandler);</span><br><span class="line"></span><br><span class="line">objProxy.push(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get value :  push [Function: push]</span></span><br><span class="line"><span class="comment">// Get value :  length 2</span></span><br><span class="line"><span class="comment">// Set value  : 2 4</span></span><br><span class="line"><span class="comment">// Set value  : length 3</span></span><br></pre></td></tr></table></figure>

<p>当要代理的对象是多层结构时，<code>Proxy</code> 的代理只能到第一层，即不能感知操作对象内部的 <code>set</code> 操作，但是 <code>get</code> 会被执行。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; <span class="string">&#x27;foo&#x27;</span>: <span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>: &#123; <span class="string">&#x27;name&#x27;</span>: <span class="number">1</span> &#125; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxyHandler = &#123;</span><br><span class="line">    <span class="attr">get</span>: <span class="function">(<span class="params">target, prop, receiver</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;Get value : &#x27;</span>, prop, <span class="built_in">Reflect</span>.get(target, prop, receiver));</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, prop, receiver);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">set</span>: <span class="function">(<span class="params">target, prop, value, receiver</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;Set value  :&#x27;</span>, prop, value);</span><br><span class="line">        <span class="built_in">Reflect</span>.set(target, prop, value, receiver);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> objProxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, proxyHandler);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(objProxy.bar.name);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get value :  bar &#123; name: 1 &#125;</span></span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p><strong>一句话总结：Proxy 是 ES6 引入的新特性，可以使用 Proxy 间接访问或操作其代理的对象。</strong></p>
<h3 id="Vue-3-中响应式数据实现"><a href="#Vue-3-中响应式数据实现" class="headerlink" title="Vue 3 中响应式数据实现"></a>Vue 3 中响应式数据实现</h3><p>Vue 3 中响应式系统的 API 主要有</p>
<ul>
<li><code>reactive</code></li>
<li><code>ref</code></li>
<li><code>computed</code></li>
<li><code>readonly</code></li>
<li><code>watchEffect</code></li>
<li><code>watch</code></li>
</ul>
<p>其中 <code>reactive</code> 是最核心的 API</p>
<h4 id="reactive"><a href="#reactive" class="headerlink" title="reactive"></a><code>reactive</code></h4><p>Vue 3 中是用全局的 <code>WeakMap</code> 来存储正在追踪的响应式对象，如 <code>reactiveMap</code> 、<code>shallowReactiveMap</code> 、<code>readonlyMap</code>、<code>shallowReadonlyMap</code> 。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> reactiveMap = <span class="keyword">new</span> <span class="built_in">WeakMap</span>&lt;Target, any&gt;()</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> shallowReactiveMap = <span class="keyword">new</span> <span class="built_in">WeakMap</span>&lt;Target, any&gt;()</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> readonlyMap = <span class="keyword">new</span> <span class="built_in">WeakMap</span>&lt;Target, any&gt;()</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> shallowReadonlyMap = <span class="keyword">new</span> <span class="built_in">WeakMap</span>&lt;Target, any&gt;()</span><br></pre></td></tr></table></figure>

<p>此外还定义了代理对象的可响应操作：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通对象，如 Object 、Array 的拦截器</span></span><br><span class="line"><span class="comment">// 包含了当对代理对象进行取值、复制、删除属性等操作时的捕获器</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> mutableHandlers: ProxyHandler&lt;object&gt; = &#123;</span><br><span class="line">  get,</span><br><span class="line">  set,</span><br><span class="line">  deleteProperty,</span><br><span class="line">  has,</span><br><span class="line">  ownKeys</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 集合对象，如果 Map/WeakMap/Set/WeakSet 的拦截器</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> mutableCollectionHandlers: ProxyHandler&lt;CollectionTypes&gt; = &#123;</span><br><span class="line">  <span class="attr">get</span>: <span class="comment">/*#__PURE__*/</span> createInstrumentationGetter(<span class="literal">false</span>, <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>reactive</code> 创建响应式对象的流程如下：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 生成一个原始对象的响应式副本，这种转换是深层次的，会影响到所有嵌套属性</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reactive</span>(<span class="params">target: <span class="built_in">object</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果目标对象是只读的，直接返回目标对象</span></span><br><span class="line">  <span class="keyword">if</span> (target &amp;&amp; (target <span class="keyword">as</span> Target).__v_isReadonly) &#123;</span><br><span class="line">    <span class="keyword">return</span> target</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 否则就在目标对象的基础上创建响应式对象</span></span><br><span class="line">  <span class="keyword">return</span> createReactiveObject(</span><br><span class="line">    target, <span class="comment">// 目标代理对象</span></span><br><span class="line">    <span class="literal">false</span>, <span class="comment">// 是否只读</span></span><br><span class="line">    mutableHandlers,</span><br><span class="line">    mutableCollectionHandlers,</span><br><span class="line">    reactiveMap</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 创建响应式对象</span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createReactiveObject</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  target: Target, <span class="comment">// 原始对象</span></span></span></span><br><span class="line"><span class="params"><span class="function">  isReadonly: <span class="built_in">boolean</span>, <span class="comment">// 是否只读</span></span></span></span><br><span class="line"><span class="params"><span class="function">  baseHandlers: ProxyHandler&lt;<span class="built_in">any</span>&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function">  collectionHandlers: ProxyHandler&lt;<span class="built_in">any</span>&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function">  proxyMap: <span class="built_in">WeakMap</span>&lt;Target, <span class="built_in">any</span>&gt; <span class="comment">// 正在追踪的可响应对象的集合</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果 target 不是对象类型，返回原值</span></span><br><span class="line">  <span class="keyword">if</span> (!isObject(target)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">      <span class="built_in">console</span>.warn(<span class="string">`value cannot be made reactive: <span class="subst">$&#123;<span class="built_in">String</span>(target)&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target</span><br><span class="line">  &#125;</span><br><span class="line">	<span class="comment">// 如果 taret 已经是一个响应式对象，返回原值</span></span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    target[ReactiveFlags.RAW] &amp;&amp;</span><br><span class="line">    !(isReadonly &amp;&amp; target[ReactiveFlags.IS_REACTIVE])</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">return</span> target</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果 target 已经有一个代理对象，返回已经存在的代理对象</span></span><br><span class="line">  <span class="keyword">const</span> existingProxy = proxyMap.get(target)</span><br><span class="line">  <span class="keyword">if</span> (existingProxy) &#123;</span><br><span class="line">    <span class="keyword">return</span> existingProxy</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 只有特定类型的对象才可以被观测</span></span><br><span class="line">  <span class="comment">// 包括 Array/Object/Map/Set/WeakMap/WeakSet，不是则返回 TargetType.INVALID</span></span><br><span class="line">  <span class="keyword">const</span> targetType = getTargetType(target)</span><br><span class="line">  <span class="keyword">if</span> (targetType === TargetType.INVALID) &#123;</span><br><span class="line">    <span class="keyword">return</span> target</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(</span><br><span class="line">    target,</span><br><span class="line">    <span class="comment">// Map/Set/WeakMap/WeakSet 被认为是 COLLECTION 类型，handler 和其它类型不同</span></span><br><span class="line">    targetType === TargetType.COLLECTION ? collectionHandlers : baseHandlers</span><br><span class="line">  )</span><br><span class="line">  proxyMap.set(target, proxy)</span><br><span class="line">  <span class="keyword">return</span> proxy</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面提到了对于多层对象的代理，<code>set</code> 并不能感知到内层对象的变化，但是 <code>get</code> 会被触发，Vue 3 利用这个原理，再对内层数据进行一次代理。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createGetter</span>(<span class="params">isReadonly = <span class="literal">false</span>, shallow = <span class="literal">false</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params">target: Target, key: <span class="built_in">string</span> | symbol, receiver: <span class="built_in">object</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key === ReactiveFlags.IS_REACTIVE) &#123;</span><br><span class="line">      <span class="comment">// 如果 key 是可响应标志 IS_REACTIVE，返回 !isReadonly</span></span><br><span class="line">      <span class="keyword">return</span> !isReadonly</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key === ReactiveFlags.IS_READONLY) &#123;</span><br><span class="line">      <span class="comment">// 如果 key 是只读标志 IS_READONLY，返回 isReadonly</span></span><br><span class="line">      <span class="keyword">return</span> isReadonly</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">      key === ReactiveFlags.RAW &amp;&amp;</span><br><span class="line">      receiver ===</span><br><span class="line">        (isReadonly</span><br><span class="line">          ? shallow</span><br><span class="line">            ? shallowReadonlyMap</span><br><span class="line">            : readonlyMap</span><br><span class="line">          : shallow</span><br><span class="line">          ? shallowReactiveMap</span><br><span class="line">          : reactiveMap</span><br><span class="line">        ).get(target)</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="keyword">return</span> target</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> targetIsArray = isArray(target)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果目标是数组</span></span><br><span class="line">    <span class="keyword">if</span> (!isReadonly &amp;&amp; targetIsArray &amp;&amp; hasOwn(arrayInstrumentations, key)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(arrayInstrumentations, key, receiver)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> res = <span class="built_in">Reflect</span>.get(target, key, receiver)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断 key 是否是 Symbol</span></span><br><span class="line">    <span class="keyword">if</span> (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) &#123;</span><br><span class="line">      <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果可读，追踪</span></span><br><span class="line">    <span class="keyword">if</span> (!isReadonly) &#123;</span><br><span class="line">      track(target, TrackOpTypes.GET, key)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是浅层响应，直接返回得到的值</span></span><br><span class="line">    <span class="keyword">if</span> (shallow) &#123;</span><br><span class="line">      <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否 Ref</span></span><br><span class="line">    <span class="keyword">if</span> (isRef(res)) &#123;</span><br><span class="line">      <span class="comment">// ref unwrapping - does not apply for Array + integer key.</span></span><br><span class="line">      <span class="keyword">const</span> shouldUnwrap = !targetIsArray || !isIntegerKey(key)</span><br><span class="line">      <span class="keyword">return</span> shouldUnwrap ? res.value : res</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isObject(res)) &#123;</span><br><span class="line">      <span class="comment">// Convert returned value into a proxy as well. we do the isObject check</span></span><br><span class="line">      <span class="comment">// here to avoid invalid value warning. Also need to lazy access readonly</span></span><br><span class="line">      <span class="comment">// and reactive here to avoid circular dependency.</span></span><br><span class="line">      <span class="keyword">return</span> isReadonly ? <span class="keyword">readonly</span>(res) : reactive(res)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 <code>reactive</code> 创建了响应式对象后，改变响应式对象的属性操作，会被侦测，并即时地在目标对象上触发对应的响应。</p>
<p>拿 <code>set</code> 方法，即赋值来举例，就是：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> set = <span class="comment">/*#__PURE__*/</span> createSetter()</span><br><span class="line"><span class="keyword">const</span> shallowSet = <span class="comment">/*#__PURE__*/</span> createSetter(<span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createSetter</span>(<span class="params">shallow = <span class="literal">false</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">set</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">    target: object,</span></span></span><br><span class="line"><span class="params"><span class="function">    key: string | symbol,</span></span></span><br><span class="line"><span class="params"><span class="function">    value: unknown,</span></span></span><br><span class="line"><span class="params"><span class="function">    receiver: object</span></span></span><br><span class="line"><span class="params"><span class="function">  </span>): <span class="title">boolean</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 取得旧的值 oldValue</span></span><br><span class="line">    <span class="keyword">let</span> oldValue = (target <span class="keyword">as</span> any)[key]</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果不是浅层响应模式，需要进行一系列的判断，才能赋值</span></span><br><span class="line">    <span class="keyword">if</span> (!shallow) &#123;</span><br><span class="line">      value = toRaw(value)</span><br><span class="line">      oldValue = toRaw(oldValue)</span><br><span class="line">      <span class="comment">// 如果 target 不是数组，旧值是 Ref</span></span><br><span class="line">      <span class="keyword">if</span> (!isArray(target) &amp;&amp; isRef(oldValue) &amp;&amp; !isRef(value)) &#123;</span><br><span class="line">        oldValue.value = value</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// in shallow mode, objects are set as-is regardless of reactive or not</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> hadKey =</span><br><span class="line">      isArray(target) &amp;&amp; isIntegerKey(key)</span><br><span class="line">        ? <span class="built_in">Number</span>(key) &lt; target.length</span><br><span class="line">        : hasOwn(target, key)</span><br><span class="line">    <span class="keyword">const</span> result = <span class="built_in">Reflect</span>.set(target, key, value, receiver)</span><br><span class="line">    <span class="comment">// don&#x27;t trigger if target is something up in the prototype chain of original</span></span><br><span class="line">    <span class="keyword">if</span> (target === toRaw(receiver)) &#123;</span><br><span class="line">      <span class="comment">// 在 target 上触发 ADD 或者 SET 响应</span></span><br><span class="line">      <span class="keyword">if</span> (!hadKey) &#123;</span><br><span class="line">        trigger(target, TriggerOpTypes.ADD, key, value)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (hasChanged(value, oldValue)) &#123;</span><br><span class="line">        trigger(target, TriggerOpTypes.SET, key, value, oldValue)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="ref"><a href="#ref" class="headerlink" title="ref"></a><code>ref</code></h4><p>由于 <code>Proxy</code> 代理的目标需是对象形式，不能对简单类型进行代理，为此 Vue 3 中使用 <code>ref</code> 函数为简单类型的值生成了一个包装，这样就可以通过 <code>recative</code> 函数构建响应式数据了。</p>
<p>包装对象的实现如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RefImpl</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  private _value: T</span><br><span class="line">  private _rawValue: T</span><br><span class="line"></span><br><span class="line">  public dep?: Dep = <span class="literal">undefined</span></span><br><span class="line">  public readonly __v_isRef = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">value: T, public readonly _shallow = <span class="literal">false</span></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>._rawValue = _shallow ? value : toRaw(value)</span><br><span class="line">    <span class="built_in">this</span>._value = _shallow ? value : convert(value)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> <span class="title">value</span>() &#123;</span><br><span class="line">    trackRefValue(<span class="built_in">this</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._value</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span> <span class="title">value</span>(<span class="params">newVal</span>) &#123;</span><br><span class="line">    newVal = <span class="built_in">this</span>._shallow ? newVal : toRaw(newVal)</span><br><span class="line">    <span class="keyword">if</span> (hasChanged(newVal, <span class="built_in">this</span>._rawValue)) &#123;</span><br><span class="line">      <span class="built_in">this</span>._rawValue = newVal</span><br><span class="line">      <span class="built_in">this</span>._value = <span class="built_in">this</span>._shallow ? newVal : convert(newVal)</span><br><span class="line">      triggerRefValue(<span class="built_in">this</span>, newVal)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Ref&lt;T = any&gt; &#123;</span><br><span class="line">  [RefSymbol]: <span class="literal">true</span></span><br><span class="line">  <span class="attr">value</span>: T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ref</span>(<span class="params">value?: unknown</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> createRef(value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createRef</span>(<span class="params">rawValue: unknown, shallow = <span class="literal">false</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 判断是否是 Ref，如果是 Ref 则直接返回</span></span><br><span class="line">  <span class="keyword">if</span> (isRef(rawValue)) &#123;</span><br><span class="line">    <span class="keyword">return</span> rawValue</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 判断是否是浅代理</span></span><br><span class="line">  <span class="comment">// convert = (val) =&gt; isObject(val) ? reactive(val) : val</span></span><br><span class="line">  <span class="keyword">let</span> value = shallow ? rawValue : convert(rawValue)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// </span></span><br><span class="line">  <span class="keyword">const</span> r = &#123;</span><br><span class="line">    <span class="attr">__v_isRef</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="keyword">get</span> <span class="title">value</span>() &#123;</span><br><span class="line">      track(r, TrackOpTypes.GET, <span class="string">&#x27;value&#x27;</span>)</span><br><span class="line">      <span class="keyword">return</span> value</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span> <span class="title">value</span>(<span class="params">newVal</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (hasChanged(toRaw(newVal), rawValue)) &#123;</span><br><span class="line">        rawValue = newVal</span><br><span class="line">        value = shallow ? newVal : convert(newVal)</span><br><span class="line">        trigger(</span><br><span class="line">          r,</span><br><span class="line">          TriggerOpTypes.SET,</span><br><span class="line">          <span class="string">&#x27;value&#x27;</span>,</span><br><span class="line">          __DEV__ ? &#123; <span class="attr">newValue</span>: newVal &#125; : <span class="built_in">void</span> <span class="number">0</span></span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="computed"><a href="#computed" class="headerlink" title="computed"></a><code>computed</code></h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">computed</span>&lt;<span class="title">T</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  getterOrOptions: ComputedGetter&lt;T&gt; | WritableComputedOptions&lt;T&gt;</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> getter: ComputedGetter&lt;T&gt;</span><br><span class="line">  <span class="keyword">let</span> setter: ComputedSetter&lt;T&gt;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果传入的 getterOrOptions 是函数，则将其设置为计算属性的 getter</span></span><br><span class="line">  <span class="keyword">if</span> (isFunction(getterOrOptions)) &#123;</span><br><span class="line">    getter = getterOrOptions</span><br><span class="line">    <span class="comment">// 如果只传入了 getter 函数，将计算属性是不可修改的 readonly</span></span><br><span class="line">    setter = __DEV__</span><br><span class="line">      ? <span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.warn(<span class="string">&#x27;Write operation failed: computed value is readonly&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      : NOOP</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果 getterOrOptions 是个对象，则计算属性是可修改的</span></span><br><span class="line">    getter = getterOrOptions.get</span><br><span class="line">    setter = getterOrOptions.set</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> dirty = <span class="literal">true</span></span><br><span class="line">  <span class="keyword">let</span> value: T</span><br><span class="line">  <span class="keyword">let</span> computed: ComputedRef&lt;T&gt;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> runner = effect(getter, &#123;</span><br><span class="line">    <span class="attr">lazy</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 将 effect 标记为 computed，则其在执行时拥有更高的优先级</span></span><br><span class="line">    <span class="attr">computed</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">scheduler</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!dirty) &#123;</span><br><span class="line">        dirty = <span class="literal">true</span></span><br><span class="line">        trigger(computed, TriggerOpTypes.SET, <span class="string">&#x27;value&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 构建一个 computed 对象</span></span><br><span class="line">  computed = &#123;</span><br><span class="line">    <span class="attr">__v_isRef</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 将 effect 暴露，使得计算属性能够 stop</span></span><br><span class="line">    <span class="attr">effect</span>: runner,</span><br><span class="line">    <span class="keyword">get</span> <span class="title">value</span>() &#123;</span><br><span class="line">      <span class="keyword">if</span> (dirty) &#123;</span><br><span class="line">        value = runner()</span><br><span class="line">        dirty = <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 追踪</span></span><br><span class="line">      track(computed, TrackOpTypes.GET, <span class="string">&#x27;value&#x27;</span>)</span><br><span class="line">      <span class="comment">// 返回最新值</span></span><br><span class="line">      <span class="keyword">return</span> value</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span> <span class="title">value</span>(<span class="params">newValue: T</span>) &#123;</span><br><span class="line">      setter(newValue)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">as</span> <span class="built_in">any</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> computed</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="effect"><a href="#effect" class="headerlink" title="effect"></a><code>effect</code></h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">effect</span>&lt;<span class="title">T</span> = <span class="title">any</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  fn: () =&gt; T,</span></span></span><br><span class="line"><span class="params"><span class="function">  options: ReactiveEffectOptions = EMPTY_OBJ</span></span></span><br><span class="line"><span class="params"><span class="function"></span>): <span class="title">ReactiveEffect</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (isEffect(fn)) &#123;</span><br><span class="line">    fn = fn.raw</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> effect = createReactiveEffect(fn, options)</span><br><span class="line">  <span class="keyword">if</span> (!options.lazy) &#123;</span><br><span class="line">    effect()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> effect</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createReactiveEffect</span>&lt;<span class="title">T</span> = <span class="title">any</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  fn: (...args: <span class="built_in">any</span>[]) =&gt; T,</span></span></span><br><span class="line"><span class="params"><span class="function">  options: ReactiveEffectOptions</span></span></span><br><span class="line"><span class="params"><span class="function"></span>): <span class="title">ReactiveEffect</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> effect = <span class="function"><span class="keyword">function</span> <span class="title">reactiveEffect</span>(<span class="params">...args: unknown[]</span>): <span class="title">unknown</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!effect.active) &#123;</span><br><span class="line">      <span class="keyword">return</span> options.scheduler ? <span class="literal">undefined</span> : fn(...args)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果 effectStack 不存在当前 effect</span></span><br><span class="line">    <span class="keyword">if</span> (!effectStack.includes(effect)) &#123;</span><br><span class="line">      cleanup(effect)</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        enableTracking()</span><br><span class="line">        <span class="comment">// 将当前 effect 加入 effectStack</span></span><br><span class="line">        effectStack.push(effect)</span><br><span class="line">        <span class="comment">// 将当前 effect 设置为 activeEffect</span></span><br><span class="line">        activeEffect = effect</span><br><span class="line">        <span class="keyword">return</span> fn(...args)</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        effectStack.pop()</span><br><span class="line">        resetTracking()</span><br><span class="line">        activeEffect = effectStack[effectStack.length - <span class="number">1</span>]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">as</span> ReactiveEffect</span><br><span class="line">  effect.id = uid++</span><br><span class="line">  effect._isEffect = <span class="literal">true</span></span><br><span class="line">  effect.active = <span class="literal">true</span></span><br><span class="line">  effect.raw = fn</span><br><span class="line">  effect.deps = []</span><br><span class="line">  effect.options = options</span><br><span class="line">  <span class="keyword">return</span> effect</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="关于-trigger-和-track"><a href="#关于-trigger-和-track" class="headerlink" title="关于 trigger 和 track"></a>关于 <code>trigger</code> 和 <code>track</code></h5><p><code>trigger</code> 用来当观测值发生发生变化时通知观察者</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">trigger</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  target: <span class="built_in">object</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">type</span>: TriggerOpTypes,</span></span></span><br><span class="line"><span class="params"><span class="function">  key?: unknown,</span></span></span><br><span class="line"><span class="params"><span class="function">  newValue?: unknown,</span></span></span><br><span class="line"><span class="params"><span class="function">  oldValue?: unknown,</span></span></span><br><span class="line"><span class="params"><span class="function">  oldTarget?: <span class="built_in">Map</span>&lt;unknown, unknown&gt; | <span class="built_in">Set</span>&lt;unknown&gt;</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// targetMap 存储了所有被追踪的对象，如果当前对象没有被追踪，直接返回</span></span><br><span class="line">  <span class="keyword">const</span> depsMap = targetMap.get(target)</span><br><span class="line">  <span class="keyword">if</span> (!depsMap) &#123;</span><br><span class="line">    <span class="comment">// never been tracked</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> effects = <span class="keyword">new</span> <span class="built_in">Set</span>&lt;ReactiveEffect&gt;()</span><br><span class="line">  <span class="keyword">const</span> computedRunners = <span class="keyword">new</span> <span class="built_in">Set</span>&lt;ReactiveEffect&gt;()</span><br><span class="line">  <span class="keyword">const</span> add = <span class="function">(<span class="params">effectsToAdd: <span class="built_in">Set</span>&lt;ReactiveEffect&gt; | <span class="literal">undefined</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (effectsToAdd) &#123;</span><br><span class="line">      effectsToAdd.forEach(<span class="function"><span class="params">effect</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (effect !== activeEffect || !shouldTrack) &#123;</span><br><span class="line">          <span class="keyword">if</span> (effect.options.computed) &#123;</span><br><span class="line">            computedRunners.add(effect)</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            effects.add(effect)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// the effect mutated its own dependency during its execution.</span></span><br><span class="line">          <span class="comment">// this can be caused by operations like foo.value++</span></span><br><span class="line">          <span class="comment">// do not trigger or we end in an infinite loop</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果当前触发类型为 CLEAR</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">type</span> === TriggerOpTypes.CLEAR) &#123;</span><br><span class="line">    <span class="comment">// collection being cleared</span></span><br><span class="line">    <span class="comment">// trigger all effects for target</span></span><br><span class="line">    depsMap.forEach(add)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key === <span class="string">&#x27;length&#x27;</span> &amp;&amp; isArray(target)) &#123;</span><br><span class="line">    depsMap.forEach(<span class="function">(<span class="params">dep, key</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (key === <span class="string">&#x27;length&#x27;</span> || key &gt;= (newValue <span class="keyword">as</span> <span class="built_in">number</span>)) &#123;</span><br><span class="line">        add(dep)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// schedule runs for SET | ADD | DELETE</span></span><br><span class="line">    <span class="keyword">if</span> (key !== <span class="built_in">void</span> <span class="number">0</span>) &#123;</span><br><span class="line">      add(depsMap.get(key))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// also run for iteration key on ADD | DELETE | Map.SET</span></span><br><span class="line">    <span class="keyword">const</span> isAddOrDelete =</span><br><span class="line">      <span class="keyword">type</span> === TriggerOpTypes.ADD ||</span><br><span class="line">      (<span class="keyword">type</span> === TriggerOpTypes.DELETE &amp;&amp; !isArray(target))</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      isAddOrDelete ||</span><br><span class="line">      (<span class="keyword">type</span> === TriggerOpTypes.SET &amp;&amp; target <span class="keyword">instanceof</span> <span class="built_in">Map</span>)</span><br><span class="line">    ) &#123;</span><br><span class="line">      add(depsMap.get(isArray(target) ? <span class="string">&#x27;length&#x27;</span> : ITERATE_KEY))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isAddOrDelete &amp;&amp; target <span class="keyword">instanceof</span> <span class="built_in">Map</span>) &#123;</span><br><span class="line">      add(depsMap.get(MAP_KEY_ITERATE_KEY))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> run = <span class="function">(<span class="params">effect: ReactiveEffect</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 在开发环境下，调试触发器</span></span><br><span class="line">    <span class="keyword">if</span> (__DEV__ &amp;&amp; effect.options.onTrigger) &#123;</span><br><span class="line">      effect.options.onTrigger(&#123;</span><br><span class="line">        effect,</span><br><span class="line">        target,</span><br><span class="line">        key,</span><br><span class="line">        <span class="keyword">type</span>,</span><br><span class="line">        newValue,</span><br><span class="line">        oldValue,</span><br><span class="line">        oldTarget</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (effect.options.scheduler) &#123;</span><br><span class="line">      effect.options.scheduler(effect)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      effect()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Important: computed effects must be run first so that computed getters</span></span><br><span class="line">  <span class="comment">// can be invalidated before any normal effects that depend on them are run.</span></span><br><span class="line">  computedRunners.forEach(run)</span><br><span class="line">  effects.forEach(run)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">track</span>(<span class="params">target: <span class="built_in">object</span>, <span class="keyword">type</span>: TrackOpTypes, key: unknown</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!shouldTrack || activeEffect === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> depsMap = targetMap.get(target)</span><br><span class="line">  <span class="keyword">if</span> (!depsMap) &#123;</span><br><span class="line">    targetMap.set(target, (depsMap = <span class="keyword">new</span> <span class="built_in">Map</span>()))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> dep = depsMap.get(key)</span><br><span class="line">  <span class="keyword">if</span> (!dep) &#123;</span><br><span class="line">    depsMap.set(key, (dep = <span class="keyword">new</span> <span class="built_in">Set</span>()))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!dep.has(activeEffect)) &#123;</span><br><span class="line">    dep.add(activeEffect)</span><br><span class="line">    activeEffect.deps.push(dep)</span><br><span class="line">    <span class="keyword">if</span> (__DEV__ &amp;&amp; activeEffect.options.onTrack) &#123;</span><br><span class="line">      activeEffect.options.onTrack(&#123;</span><br><span class="line">        <span class="attr">effect</span>: activeEffect,</span><br><span class="line">        target,</span><br><span class="line">        <span class="keyword">type</span>,</span><br><span class="line">        key</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2019-09-12T16:00:00.000Z" title="2019/9/13 上午12:00:00">2019-09-13</time>发表</span><span class="level-item"><a class="link-muted" href="/categories/Web/">Web</a></span><span class="level-item">39 分钟读完 (大约5790个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/09/13/typescript-tutorial/">TypeScript 概览</a></h1><div class="content"><h1 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h1><p>TypeScript 是 JavaScript 类型的超集，它可以编译成纯 JavaScript，可以在任何浏览器、任何计算机和任何操作系统上运行，并且是开源的。</p>
<h2 id="基础类型"><a href="#基础类型" class="headerlink" title="基础类型"></a>基础类型</h2><p>TypeScript 支持与 JavaScript 几乎相同的数据类型，此外还提供了方便使用的枚举类型。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// boolean</span></span><br><span class="line"><span class="keyword">let</span> isDone: <span class="built_in">boolean</span> = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">// number</span></span><br><span class="line"><span class="comment">// JavaScript 和 TypeScript 中的数字不是浮点类型 floating point 就是大整数类型 BigInteger</span></span><br><span class="line"><span class="keyword">let</span> decLiteral: <span class="built_in">number</span> = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">let</span> bigLiteral: <span class="built_in">number</span> = <span class="number">100n</span>;</span><br><span class="line"><span class="comment">// string</span></span><br><span class="line"><span class="keyword">let</span> name: <span class="built_in">string</span> = <span class="string">&#x27;bob&#x27;</span>;</span><br><span class="line"><span class="comment">// Array</span></span><br><span class="line"><span class="keyword">let</span> list: <span class="built_in">number</span>[] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> list: <span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="comment">// Tuple</span></span><br><span class="line"><span class="comment">// 元组类型要求值类型、顺序和个数一一对应</span></span><br><span class="line"><span class="keyword">let</span> tuple: [<span class="built_in">string</span>, <span class="built_in">string</span>] = [<span class="string">&#x27;string&#x27;</span>, <span class="string">&#x27;string&#x27;</span>];</span><br><span class="line"><span class="comment">// enum</span></span><br><span class="line"><span class="built_in">enum</span> Color &#123;Red = <span class="number">0</span>, Green, Blue&#125;</span><br><span class="line"><span class="keyword">let</span> c: Color = Color.Green;</span><br><span class="line"><span class="comment">// Any</span></span><br><span class="line"><span class="keyword">let</span> source: <span class="built_in">any</span> = <span class="number">4</span></span><br><span class="line"><span class="comment">// Void</span></span><br><span class="line"><span class="keyword">let</span> unusable: <span class="built_in">void</span> = <span class="literal">undefined</span>;</span><br><span class="line"><span class="comment">// Null &amp; Undefined</span></span><br><span class="line"><span class="keyword">let</span> u: <span class="literal">undefined</span> = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">let</span> n: <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="comment">// Never</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">error</span>(<span class="params">message: <span class="built_in">string</span></span>): <span class="title">never</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(message);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 类型断言</span></span><br><span class="line"><span class="comment">// 明确知道值的类型时可使用类型断言</span></span><br><span class="line"><span class="keyword">let</span> strValue: <span class="built_in">any</span> = <span class="string">&#x27;str&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> length: <span class="built_in">number</span> = (&lt;<span class="built_in">string</span>&gt;strValue).length;</span><br><span class="line"><span class="keyword">let</span> length: <span class="built_in">number</span> = (strValue <span class="keyword">as</span> <span class="built_in">string</span>).length</span><br></pre></td></tr></table></figure>



<h2 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h2><ul>
<li><p><code>var</code></p>
<p>可以通过 <code>var</code> 关键字定义变量，但是 <code>var</code> 声明可以在包含它的函数、模块、命名空间或全局作用域内部任何位置被访问，包含它的代码块对此没有影响，这可能会引发一些错误，比如多次声明同一个变量并不会报错。</p>
</li>
<li><p><code>let</code></p>
<p>当用 <code>let</code> 声明一个变量，它使用的是词法作用域或块作用域。不同于使用 <code>var</code> 声明的变量那样可以在包含它们的函数外访问，块作用域变量在包含它们的块之外是不能访问的。</p>
</li>
<li><p><code>const</code></p>
<p><code>const</code> 拥有与 <code>let</code> 相同的作用域规则，但是声明的变量被赋值后不能再改变。</p>
</li>
</ul>
<p>每次进入一个作用域时，它创建了一个变量的环境，就算作用域内代码已经执行完毕，这个环境与其捕获的变量依然存在。当 <code>let</code> 声明出现在循环体里时拥有完全不同的行为，不仅是在循环里引入了一个新的变量环境，而是针对每次迭代都会创建这样一个新作用域。</p>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p><strong>TypeScript 的核心原则之一是对值所具有的结构进行类型检查</strong>。 它有时被称做 “鸭式辨型法”或”结构性子类型化”。 在 TypeScript 里，接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约。</p>
<p>JavaScript 为开发者提供了非常大的灵活性：比如你可以为一个初始化为整数的变量赋值一个函数。但同时这种不确定性也会带来很多的麻烦，TypeScript 内置的接口就可以用来解决这个问题。 </p>
<p><em>接口帮助我们在赋值和传递参数时进行类型检查，确保我们给变量的赋值符合变量的类型或接收参数正确(接口在某种程度上表示了变量或函数对于赋值给它的值或传递给它的参数的一种期望和要求)。</em></p>
<h3 id="可选属性"><a href="#可选属性" class="headerlink" title="可选属性"></a>可选属性</h3><p>接口里的属性不全都是必需的，有些是只在某些条件下存在，或者根本不存在，可以为接口定义可选属性来实现这些需求。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> OptionAttribute &#123;</span><br><span class="line">    optionNum?: <span class="built_in">number</span>;</span><br><span class="line">    optionStr?: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可选属性的好处之一是可以对可能存在的属性进行预定义，好处之二是可以捕获引用了不存在的属性时的错误。 </p>
<h3 id="只读属性"><a href="#只读属性" class="headerlink" title="只读属性"></a>只读属性</h3><p>如果希望对象的某些属性只有在刚创建的时候修改其值，可以通过在属性名前用 readonly 来指定属性为只读属性。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> ReadonlyAttribute &#123;</span><br><span class="line">    <span class="keyword">readonly</span> num: <span class="built_in">number</span>;</span><br><span class="line">    <span class="keyword">readonly</span> str: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>TypeScript</code> 具有 <code>ReadonlyArray&lt;T&gt;</code> 类型，它与 <code>Array&lt;T&gt;</code> 类似，只是把所有可变方法去掉了，因此可以保证数组创建后再也不能被修改。</p>
<blockquote>
<p><strong>readonly</strong> vs <strong>const</strong></p>
<p>使用 <code>const</code> 来修饰变量，使用 <code>readonly</code> 来修饰属性</p>
</blockquote>
<h3 id="额外的类型检查"><a href="#额外的类型检查" class="headerlink" title="额外的类型检查"></a>额外的类型检查</h3><p>在 <code>TypeScript</code> 中，对象字面量赋值给变量或作为参数进行传递的时候，会经过 “额外属性检查”，如果一个对象字面量存在任何 “目标类型” 不包含的属性时，会发生错误。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> SquareConfig &#123; </span><br><span class="line">  <span class="attr">width</span>: <span class="built_in">number</span>;</span><br><span class="line">  color?: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createSquare</span>(<span class="params">config: SquareConfig</span>): </span>&#123; color: <span class="built_in">string</span>, <span class="attr">area</span>: <span class="built_in">number</span> &#125; &#123;</span><br><span class="line">  <span class="keyword">let</span> newSquare = &#123; <span class="attr">color</span>: <span class="string">&#x27;blue&#x27;</span>, <span class="attr">area</span>: <span class="number">0</span> &#125;;</span><br><span class="line">  <span class="keyword">if</span> (config.width) newSquare.area = config.width * config.width;</span><br><span class="line">  <span class="keyword">if</span> (config.color) newSquare.color = config.color;</span><br><span class="line">  <span class="keyword">return</span> newSquare;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// error: height not expected in type SquareConfig</span></span><br><span class="line"><span class="keyword">let</span> mySquare = createSquare(&#123; <span class="attr">color</span>: <span class="string">&#x27;green&#x27;</span>, <span class="attr">width</span>: <span class="number">10</span>, <span class="attr">height</span>: <span class="number">10</span> &#125;);</span><br></pre></td></tr></table></figure>

<p>使用 ‘类型断言’ 可以绕开额外属性检查</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mySquare = createSquare(&#123; <span class="attr">color</span>: <span class="string">&#x27;green&#x27;</span>, <span class="attr">width</span>: <span class="number">10</span>, <span class="attr">height</span>: <span class="number">10</span> &#125; <span class="keyword">as</span> SquareConfig);</span><br></pre></td></tr></table></figure>

<p>但是更好的做法是在接口中提供一个字符串索引签名</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> SquareConfig &#123; </span><br><span class="line">  <span class="attr">width</span>: <span class="built_in">number</span>;</span><br><span class="line">  color?: <span class="built_in">string</span>;</span><br><span class="line">  [propName: <span class="built_in">string</span>]: <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h3><p>接口能够描述 <code>JavaScript</code> 中对象拥有的各种各样的外形。 除了描述带有属性的普通对象外，接口也可以描述函数类型。</p>
<p>为了使用接口表示函数类型，我们需要给接口定义一个调用签名。 它就像是一个只有参数列表和返回值类型的函数定义。</p>
<p>参数列表里的每个参数都需要名字和类型。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> TypeFunc &#123;</span><br><span class="line">    (source: <span class="built_in">string</span>, <span class="attr">subString</span>: <span class="built_in">string</span>): <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样定义后，我们可以像使用其它接口一样使用这个函数类型的接口。 下例展示了如何创建一个函数类型的变量，并将一个同类型的函数赋值给这个变量。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mySearchFunc: TypeFunc;</span><br><span class="line">mySearchFunc = <span class="function"><span class="keyword">function</span>(<span class="params">source: <span class="built_in">string</span>, subString: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = source.search(subString);</span><br><span class="line">    <span class="keyword">return</span> result &gt; -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于函数类型的类型检查来说，函数的参数名不需要与接口定义里的名字相匹配。</p>
<p>函数的参数会逐个进行检查，要求对应位置上的参数类型是兼容的。如果没有指定类型，<code>TypeScript</code> 的类型系统会推断出参数类型，而函数的返回值类型是通过其返回值推断出来的。</p>
<h3 id="可索引的类型"><a href="#可索引的类型" class="headerlink" title="可索引的类型"></a>可索引的类型</h3><p>与使用接口描述函数类型差不多，我们也可以描述那些能够通过索引得到的类型。可索引类型具有一个索引签名，它描述了对象索引的类型，还有相应的索引返回值类型。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 表明了当用 number 去索引 StringArr 时会得到 string 类型的返回值</span></span><br><span class="line"><span class="keyword">interface</span> StringArr &#123;</span><br><span class="line">    [index: <span class="built_in">number</span>]: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myArr: StringArr;</span><br><span class="line">myArr = [<span class="string">&quot;A&quot;</span>,<span class="string">&quot;B&quot;</span>];</span><br><span class="line"><span class="keyword">let</span> myStr: <span class="built_in">string</span> = myArr[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>

<p>索引签名共有两种类型：字符串和数字。可以同时使用这两种类型的索引，但是数字索引的返回值必须是字符串索引返回值类型的子类型。这是因为当使用 <code>number</code> 来索引时，<code>TypeScript</code> 会将它转换为 <code>string</code> 然后再去索引对象。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> StringArray &#123; </span><br><span class="line">  [index: <span class="built_in">string</span>]: <span class="built_in">string</span>;</span><br><span class="line">  [index: <span class="built_in">number</span>]: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一般将索引签名设置为只读，这样可以防止给索引赋值。</p>
<h3 id="类类型"><a href="#类类型" class="headerlink" title="类类型"></a>类类型</h3><p><code>TypeScript</code> 中的接口也能够用来明确的强制一个类去符合某种协议/契约。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> ClockInterface &#123;</span><br><span class="line">    <span class="attr">currentTime</span>: <span class="built_in">Date</span>;</span><br><span class="line">    setTime:(d: <span class="built_in">Date</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="title">implements</span> <span class="title">ClockInterface</span> </span>&#123;</span><br><span class="line">    <span class="attr">currentTime</span>: <span class="built_in">Date</span>;</span><br><span class="line">    setTime:(d: <span class="built_in">Date</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.currentTime = d;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">h: <span class="built_in">number</span>, m: <span class="built_in">number</span></span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口描述了类的公共部分，而不是公共和私有两部分，它不会帮你检查类是否具有某些私有成员。</p>
<h3 id="类静态部分与实例部分的区别"><a href="#类静态部分与实例部分的区别" class="headerlink" title="类静态部分与实例部分的区别"></a>类静态部分与实例部分的区别</h3><p>类具有两个类型 ：静态部分的类型和实例的类型。</p>
<p>当一个类实现了一个接口时，只对其实例部分进行类型检查。<code>constructor</code> 存在于类的静态部分，不在检查范围内。因此我们应该直接操作类的静态部分。</p>
<blockquote>
<p>可以认为类的静态部分指的是类本身，实例部分指的是类实例化出来的对象。</p>
</blockquote>
<h3 id="继承接口"><a href="#继承接口" class="headerlink" title="继承接口"></a>继承接口</h3><p>和类一样，接口也可以相互继承。这让我们能够从一个接口里复制成员到另一个接口里，可以更灵活地将接口分割到可重用的模块里。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Father &#123;</span><br><span class="line">    <span class="attr">familyName</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Son <span class="keyword">extends</span> Father &#123;</span><br><span class="line">    <span class="attr">givenName</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> aPerson = &lt;Son&gt;&#123;&#125;;</span><br><span class="line">aPerson.familyName = <span class="string">&#x27;S&#x27;</span>;</span><br><span class="line">aPerson.givenName = <span class="string">&#x27;T&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>一个接口可以继承多个接口，创建出多个接口的合成接口。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Shape &#123;</span><br><span class="line">  <span class="attr">color</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Stroke &#123;</span><br><span class="line">  <span class="attr">penWidth</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Square <span class="keyword">extends</span> Shape, Stroke &#123;</span><br><span class="line">  <span class="attr">width</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="混合类型"><a href="#混合类型" class="headerlink" title="混合类型"></a>混合类型</h3><p>接口能够描述 <code>JavaScript</code> 中丰富的类型，可以使用 混合类型 来使某个对象具有多个类型。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Counter &#123;</span><br><span class="line">  (start: <span class="built_in">number</span>): <span class="built_in">number</span>;</span><br><span class="line">	interval: <span class="built_in">number</span>;</span><br><span class="line">	reset(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCounter</span>(<span class="params"></span>): <span class="title">Counter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> counter = &lt;Counter&gt;<span class="function"><span class="keyword">function</span> (<span class="params">start: <span class="built_in">number</span></span>) </span>&#123;&#125;;</span><br><span class="line">  counter.interval = <span class="number">1</span>;</span><br><span class="line">  counter.reset = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">  <span class="keyword">return</span> counter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = getCounter();</span><br><span class="line">c(<span class="number">10</span>);</span><br><span class="line">c.reset();</span><br><span class="line">c.interval = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>



<h3 id="接口继承类"><a href="#接口继承类" class="headerlink" title="接口继承类"></a>接口继承类</h3><p>当接口继承了一个类类型时，它会继承类的成员但不继承其实现。就好像接口声明了所有类中存在的成员，但没有提供具体实现一样。接口同样会继承到类的 <code>private</code> 和 <code>protected</code> 成员。这意味着当你创建了一个接口继承了一个拥有私有或受保护的成员的类时，这个接口类型只能被这个类或其子类所实现。</p>
<p>当你有一个庞大的继承结构时这很有用，但要指出的是你的代码只在子类拥有特定的属性时起作用。</p>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>从 <code>ECMAScript 2015</code> , 也就是 <code>ECMAScript 6</code> 开始， <code>JavaScript</code> 中也能使用基于类的面向对象的方式。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="attr">familyName</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">familyName: <span class="built_in">string</span>, givenName: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.familyName = familyName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">say</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Hello, my name is &#x27;</span> + <span class="built_in">this</span>.familyName + <span class="string">&#x27; &#x27;</span> + <span class="built_in">this</span>.givenName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">move</span>(<span class="params">distanceInMeters = <span class="number">0</span></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;$&#123;this.name&#125; moved $&#123;distanceInMeters&#125;m.&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建类实例</span></span><br><span class="line">lei aPerson = <span class="keyword">new</span> Person(<span class="string">&#x27;Wang&#x27;</span>, <span class="string">&#x27;XiaoHong&#x27;</span>, <span class="number">22</span>);</span><br></pre></td></tr></table></figure>

<p>在引用任何一个类的成员时都需要使用 <code>this</code> ，它表示我们访问的是类的成员。</p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>在 <code>TypeScript</code> 中允许使用继承来扩展现有的类。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">familyName: <span class="built_in">string</span>, givenName: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(familyName, givenName, age);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">move</span>(<span class="params">distanceInMeters = <span class="number">5</span></span>)</span> &#123;</span><br><span class="line">			<span class="built_in">super</span>.move(distanceInMeters);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果子类包含了构造函数，它必须调用 <code>super()</code> ，它会执行基类的构造函数。在构造函数中访问 <code>this</code> 的属性之前，一定要先调用 <code>super()</code> 。</p>
<p>子类从父类中继承属性和方法</p>
<h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><ul>
<li><p><code>public</code></p>
<p><code>public</code> 是 <code>TypeScript</code> 中类成员的默认属性</p>
</li>
<li><p><code>private</code></p>
<p>类成员声明为 <code>private</code> 时，不能在生声明它的类的外部访问</p>
</li>
<li><p><code>protected</code></p>
<p>类成员声明为 <code>protected</code> 时，在派生类中仍可访问</p>
<p>构造函数也能被标记为 <code>protected</code> ，这意味着它不能在包含它的类外被实例化，但是能被继承</p>
</li>
<li><p><code>readonly</code></p>
<p>通过 <code>readonly</code> 属性将属性设置为只读，只读属性必须在声明时或构造函数里被初始化</p>
</li>
</ul>
<h4 id="参数属性"><a href="#参数属性" class="headerlink" title="参数属性"></a>参数属性</h4><p>参数属性通过给构造函数参数前添加一个访问限定符来声明。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"><span class="keyword">public</span> familyName: <span class="built_in">string</span>, <span class="keyword">public</span> givenName: <span class="built_in">string</span>, <span class="keyword">public</span> age: <span class="built_in">number</span></span>)</span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过这个特性我们可以方便的在一个地方定义并初始化一个成员。</p>
<h3 id="存取器"><a href="#存取器" class="headerlink" title="存取器"></a>存取器</h3><p><code>TypeScript</code> 支持通过 <code>getters/setters</code> 来截取对对象成员的访问，它们可以有效的控制对对象成员的访问。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">student</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> _familyName: <span class="built_in">string</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">get</span> <span class="title">familyName</span>(): <span class="title">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._familyNmae;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">set</span> <span class="title">familyName</span>(<span class="params">fName: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">		<span class="built_in">this</span>._familyName = fName;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，存取器只支持 <code>ECMAScript 5</code> 或更高，其次，只带有 <code>getter</code> 存取器被推断为 <code>readonly</code>。</p>
<h3 id="静态属性"><a href="#静态属性" class="headerlink" title="静态属性"></a>静态属性</h3><p>类的实例成员是那些仅当类被实例化时才会被初始化的属性，而类的静态成员存在于类本身上面而不是类的实例上。实例想要访问静态属性时，需要在其加上类名。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">student</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> school = <span class="string">&#x27;ts&#x27;</span>;</span><br><span class="line">  ...</span><br><span class="line">  <span class="function"><span class="title">getStudentSchool</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> student.school;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>抽象类一般作为其它派生类的基类使用，一般不会被实例化。不同于接口，抽象类可以包含成员的实现细节。</p>
<p>使用 <code>abstract</code> 关键字定义抽象类和在抽象类中定义抽象方法。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">  <span class="keyword">abstract</span> function_name: return_type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>抽象类中的抽象方法不包含具体实现并且必须在派生类中实现。</p>
<p>抽象方法的语法与接口语法相似，两者都是定义方法签名但不包含方法体。然而，抽象方法必须包含 <code>abstract</code> 关键字并且可以包含访问修饰符。</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>函数是 <code>JavaScript</code> 应用程序的基础。 它帮助你实现抽象层，模拟类，信息隐藏和模块。 在 <code>TypeScript</code> 里，虽然已经支持类，命名空间和模块，但函数仍然是主要的定义行为的地方。 <code>TypeScript</code> 为 <code>JavaScript</code> 函数添加了额外的功能，让我们可以更容易地使用。</p>
<h3 id="函数类型-1"><a href="#函数类型-1" class="headerlink" title="函数类型"></a>函数类型</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params">arg_1: arg_type, arg_2: arg_type, ...</span>): <span class="title">return_type</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>TypeScript</code> 能够通过返回语句自动推断出返回值类型，因此函数返回类型一般是省略的。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fun_var_name: <span class="function">(<span class="params">arg_1: arg_type, arg_2: arg_type, ...</span>) =&gt;</span> return_type;</span><br></pre></td></tr></table></figure>

<p>函数类型包括两部分，参数类型和返回值类型。而且只要参数类型是匹配的，就认为它是有效的函数类型，而不在乎参数名是否准确。</p>
<h3 id="可选参数和默认参数"><a href="#可选参数和默认参数" class="headerlink" title="可选参数和默认参数"></a>可选参数和默认参数</h3><p><code>JavaScript</code> 中函数的每个参数都是可选的，可传可不传，没有传参的时候它的值就是 <code>undefined</code>。而 <code>TypeScript</code> 中函数的每个参数默认情况下都是必须的，编译器检查用户是否为每个参数都传入了值，还会假设只有这些参数被传递进函数-即传递给一个函数的参数个数必须与函数期望的参数个数一致。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myAdd: <span class="function">(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span> = <span class="function"><span class="keyword">function</span> (<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) </span>&#123; </span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sum = myAdd(<span class="number">1</span>); <span class="comment">// error: Expected 2 arugements, but got 1</span></span><br><span class="line"><span class="keyword">const</span> sum1 = myAdd(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// error: Expected 2 arugements, but got 3</span></span><br></pre></td></tr></table></figure>

<p>在 <code>TypeScript</code> 中，可以在参数名称旁使用 <code>?</code> 实现可选参数的功能。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可选参数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildStudent</span>(<span class="params">name: <span class="built_in">string</span>, grade: <span class="built_in">number</span>, gender?: <span class="built_in">string</span></span>) </span>&#123; </span><br><span class="line">  <span class="keyword">return</span> name + <span class="string">&#x27; &#x27;</span> + grade + <span class="string">&#x27; &#x27;</span> + (gender ? gender : <span class="string">&#x27;&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> student_1 = buildStudent(<span class="string">&#x27;Tom&#x27;</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">const</span> student_2 = buildStudent(<span class="string">&#x27;Jerry&#x27;</span>, <span class="number">2</span>, <span class="string">&#x27;male&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>需要注意的是，可选参数必须跟在可选参数后面。</p>
<p>在 <code>TypeScript</code> 中，当用户没有传递这个参数或传递的值是 <code>undefined</code> 时，我们可以为参数提供一个默认值。在所有必须参数后面的带默认初始化的参数都是可选的，与可选参数一样，在调用函数的时候可以省略-即可选参数与末尾的默认参数共享参数类型。</p>
<p>需要注意的是，如果带默认值的参数出现在必须参数之前，用户必须明确的传入 <code>undefined</code> 值来获得默认值。</p>
<h3 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a>剩余参数</h3><p>如果你想同时操作多个参数或不知道会有多少个参数传递进来，在 <code>JavaScript</code> 中，你可以通过 <code>arguments</code> 来访问所有传入的参数，在 <code>TypeScript</code> 中，你则可以将所有参数收集到一个变量里。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 剩余参数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildChildren</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span>, ...restOfProperty: <span class="built_in">string</span>[]</span>) </span>&#123; </span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;name&#125;</span> <span class="subst">$&#123;age&#125;</span> <span class="subst">$&#123;restOfProperty.join(<span class="string">&#x27; &#x27;</span>)&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> children = buildChildren(<span class="string">&#x27;Mike&#x27;</span>, <span class="number">12</span>, <span class="string">&#x27;male&#x27;</span>, <span class="string">&#x27;grade 3&#x27;</span>);</span><br></pre></td></tr></table></figure>



<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>泛型是程序设计语言的一种特性，是程序员在编写代码时定义的一些可变部分，这些部分在使用前必须做出指明。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类型变量 T 会捕获用户传入的类型，之后我们就可以使用者个类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123; </span><br><span class="line">  <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> strId = identity(<span class="string">&#x27;JavaScript&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> numId = identity(<span class="number">12</span>);</span><br></pre></td></tr></table></figure>



<h3 id="泛型变量"><a href="#泛型变量" class="headerlink" title="泛型变量"></a>泛型变量</h3><p>使用泛型函数时，编译器要求你在函数体必须正确的使用这个通用的类型-即你必须把这些参数当做是任意或所有类型。</p>
<h3 id="泛型函数"><a href="#泛型函数" class="headerlink" title="泛型函数"></a>泛型函数</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">combineFunc</span>&lt;<span class="title">T</span>,<span class="title">K</span>&gt;(<span class="params">x: T, y: K</span>): [<span class="title">T</span>, <span class="title">K</span>] </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [T, K];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> combine: &lt;T,K&gt;(x: T, y: K) =&gt; [T,K] = combineFunc;</span><br><span class="line">// or</span><br><span class="line">let combine: &#123; &lt;T,K&gt;(x: T, y: K): [T, K] &#125; = combineFunc;</span><br></pre></td></tr></table></figure>



<h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> CombineFunc &#123;</span><br><span class="line">  &lt;T,K&gt;(x: T, <span class="attr">y</span>: K): [T, K];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> combine: CombineFunc = <span class="function">(<span class="params">x, y</span>) =&gt;</span> [x, y];</span><br></pre></td></tr></table></figure>



<h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CombineFunC</span> </span>&#123;</span><br><span class="line">  <span class="attr">combine</span>: &lt;T,K&gt;(x: T, y: K) =&gt; [T, K];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let combineC: CombineFunC = new CombineFunC&lt;number, number&gt;();</span><br><span class="line">combineC.combine = (x, y) =&gt; [x, y];</span><br></pre></td></tr></table></figure>





<h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>使用枚举可以定义一些带名字的常量，清晰的表达意图或创建一组有区别的用例。<code>TypeScript</code> 支持数字的和基于字符串的枚举。</p>
<h3 id="数字枚举"><a href="#数字枚举" class="headerlink" title="数字枚举"></a>数字枚举</h3><p>数字枚举默认的枚举值是从 0 开始自增长的，如果你为第一个枚举名字指定了一个数字枚举值，则会从这个数字值开始自增长。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">enum</span> Status &#123;</span><br><span class="line">  DELETED = -<span class="number">1</span>,</span><br><span class="line">  VALID,</span><br><span class="line">  UNPAID,</span><br><span class="line">  PAID</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="字符串枚举"><a href="#字符串枚举" class="headerlink" title="字符串枚举"></a>字符串枚举</h3><p>字符串枚举中，每个成员都需要使用字符串字面量或另外一个字符串枚举成员进行初始化。</p>
<p>需要注意的是，字符串枚举没有自增长行为。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">enum</span> StatusTip &#123;</span><br><span class="line">  DELETED = <span class="string">&#x27;Order has been deleted.&#x27;</span>,</span><br><span class="line">  VALID = <span class="string">&#x27;Order is valid.&#x27;</span>,</span><br><span class="line">  UNPAID = <span class="string">&#x27;Order is unpaid.&#x27;</span>,</span><br><span class="line">  PAID = <span class="string">&#x27;Order is paid&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="异构枚举"><a href="#异构枚举" class="headerlink" title="异构枚举"></a>异构枚举</h3><p>枚举可以混合字符串和数字成员。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">enum</span> HeterogeneousEnum &#123;</span><br><span class="line">  NO = <span class="number">0</span>,</span><br><span class="line">  YES = <span class="string">&#x27;Yes&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="计算的和常量成员"><a href="#计算的和常量成员" class="headerlink" title="计算的和常量成员"></a>计算的和常量成员</h3><p>每个枚举成员都带有一个值，它可以是常量或计算出来的。当满足如下条件时，枚举成员被当做常量：</p>
<ul>
<li><p>它是枚举的第一个成员，且没有初始化器，此时它的值为 0</p>
</li>
<li><p>它不带有初始化器且它之前的枚举成员是一个数字常量，此时它的值为上一个枚举成员的值 + 1</p>
</li>
<li><p>枚举成员使用常量枚举表达式初始化。常量枚举表达式是 <code>TypeScript</code> 表达式的子集，它可以在编译阶段求值。当一个表达式满足以下条件时，它就是一个常量枚举表达式：</p>
<ul>
<li><p>一个枚举表达式字面量</p>
</li>
<li><p>一个对之前定义的常量枚举成员的引用</p>
</li>
<li><p>带括号的常量枚举表达式</p>
</li>
<li><p>一元运算符 <code>+ - ~</code> 其中之一应用在了常量枚举表达式</p>
</li>
<li><p>常量枚举表达式作为二元运算符 <code>+, -, *, /, %, &lt;&lt;, &gt;&gt;, &gt;&gt;&gt;, &amp;, |, ^</code> 的操作对象(若常量枚举表达式求值后为 <code>NaN</code> 或 <code>Infinity</code>，则会在编译时报错)</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">enum</span> FileAccess &#123;</span><br><span class="line">  None,</span><br><span class="line">  Read = <span class="number">1</span> &lt;&lt; <span class="number">1</span>,</span><br><span class="line">  Write = <span class="number">1</span> &lt;&lt; <span class="number">2</span>,</span><br><span class="line">  ReadWrite = Read | Write,</span><br><span class="line">  G = <span class="string">&#x27;1024&#x27;</span>.length</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ul>
<h3 id="联合枚举与枚举成员的类型"><a href="#联合枚举与枚举成员的类型" class="headerlink" title="联合枚举与枚举成员的类型"></a>联合枚举与枚举成员的类型</h3><p>存在一种特殊的非计算的常量枚举成员的子集：字面量枚举成员。字面量枚举成员是指不带有初始值的常量枚举成员或是被初始化为</p>
<ul>
<li>任何字符串字面量</li>
<li>任何数字字面量</li>
<li>应用了一元 <code>-</code> 符号的数字字面量</li>
</ul>
<p>当所有枚举成员都拥有字面量枚举值时，它就带有了一种特殊的语义。</p>
<h3 id="运行时枚举"><a href="#运行时枚举" class="headerlink" title="运行时枚举"></a>运行时枚举</h3><p>枚举是在运行时真正存在的对象</p>
<h3 id="反向映射"><a href="#反向映射" class="headerlink" title="反向映射"></a>反向映射</h3><p>数字枚举成员具有从枚举值到枚举名字的反向映射。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">enum</span> Status &#123;</span><br><span class="line">  DELETED = -<span class="number">1</span>,</span><br><span class="line">  VALID,</span><br><span class="line">  UNPAID,</span><br><span class="line">  PAID</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Status[<span class="number">0</span>]); <span class="comment">// VALID</span></span><br></pre></td></tr></table></figure>



<h3 id="const-枚举"><a href="#const-枚举" class="headerlink" title="const 枚举"></a><code>const</code> 枚举</h3><p>常量枚举只能使用常量枚举表达式，并且不同于常规的枚举，它们在编译阶段会被删除-常量枚举成员会在使用的地方被内联进来，这是因为常量枚举不允许包含计算成员。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">enum</span> Directions &#123;</span><br><span class="line">  Up,</span><br><span class="line">  Down,</span><br><span class="line">  Left,</span><br><span class="line">  Right</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> directions = [ Directions.Up, Directions.Down, Directions.Left, Directions.Right ];</span><br></pre></td></tr></table></figure>



<h2 id="类型推论"><a href="#类型推论" class="headerlink" title="类型推论"></a>类型推论</h2><p>类型推论是指能够在编译期间自动推导出值的类型的能力。一般发生在初始化变量和成员，设置默认参数值和决定函数返回值时。</p>
<h3 id="最佳通用类型"><a href="#最佳通用类型" class="headerlink" title="最佳通用类型"></a>最佳通用类型</h3><p>当需要从几个表达式中推断类型时，会使用这几个表达式的类型来推断出一个最合适的通用类型。</p>
<h3 id="上下文类型"><a href="#上下文类型" class="headerlink" title="上下文类型"></a>上下文类型</h3><p>当表达式的类型与所处的位置相关时，类型推论按照上下文归类来推论类型。当然，如果表达式包含了明确的类型信息，上下文的类型会被忽略。</p>
<h2 id="类型兼容性"><a href="#类型兼容性" class="headerlink" title="类型兼容性"></a>类型兼容性</h2><p><code>TypeScript</code> 中的类型兼容性是基于结构子类型的-结构子类型是一种只使用其成员来描述类型的方式。</p>
<h3 id="原始类型和对象类型的兼容性"><a href="#原始类型和对象类型的兼容性" class="headerlink" title="原始类型和对象类型的兼容性"></a>原始类型和对象类型的兼容性</h3><p>如果 x 要兼容 y， 那么 y 至少需要具有与 x 相同的属性。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果 x 要兼容 y， y 至少要与 x 拥有相同的属性</span></span><br><span class="line"><span class="keyword">let</span> x = &#123; <span class="attr">name</span>: <span class="string">&#x27;x&#x27;</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> y = &#123; <span class="attr">name</span>: <span class="string">&#x27;y&#x27;</span>, <span class="attr">alias</span>: <span class="string">&#x27;Y&#x27;</span> &#125;;</span><br><span class="line">x = y;</span><br><span class="line">y = x; <span class="comment">// Property &#x27;alias&#x27; is missing in type &#x27;&#123; name: string; &#125;&#x27; but required in type &#x27;&#123; name: string; alias: string; &#125;</span></span><br></pre></td></tr></table></figure>



<h3 id="函数的类型兼容性"><a href="#函数的类型兼容性" class="headerlink" title="函数的类型兼容性"></a>函数的类型兼容性</h3><p>如果函数 x 要兼容函数 y，那么 x 至少要与 y 具有相同的参数并且返回值类型相同。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> funCom = <span class="function">(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) =&gt;</span> x + y;</span><br><span class="line"><span class="keyword">let</span> funAbc = <span class="function">(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) =&gt;</span> [x, y];</span><br><span class="line"><span class="keyword">let</span> funSub = <span class="function">(<span class="params">x: <span class="built_in">number</span></span>) =&gt;</span> x;</span><br><span class="line"><span class="keyword">let</span> funDef = <span class="function">(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) =&gt;</span> x * y;</span><br><span class="line">funCom = funSub;</span><br><span class="line">funSub = funCom; <span class="comment">// Type &#x27;(x: number, y: number) =&gt; number&#x27; is not assignable to type &#x27;(x: number) =&gt; number&#x27;</span></span><br><span class="line">funCom = funAbc; <span class="comment">// Type &#x27;(x: number, y: number) =&gt; number[]&#x27; is not assignable to type &#x27;(x: number, y: number) =&gt; number&#x27;.Type &#x27;number[]&#x27; is not assignable to type &#x27;number&#x27;</span></span><br><span class="line">funCom = funDef;</span><br></pre></td></tr></table></figure>



<h3 id="类的兼容性"><a href="#类的兼容性" class="headerlink" title="类的兼容性"></a>类的兼容性</h3><p>比较两个类类型的对象时，只有实例的成员会被比较。 静态成员和构造函数不在比较的范围内。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">W</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> sign: <span class="built_in">string</span> = <span class="string">&#x27;AAAAA&#x27;</span>;</span><br><span class="line">  pro: <span class="built_in">string</span> = <span class="string">&#x27;W&#x27;</span>;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Y</span> </span>&#123;</span><br><span class="line">  <span class="attr">pro</span>: <span class="built_in">string</span> = <span class="string">&#x27;W&#x27;</span>;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">length: <span class="built_in">number</span></span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> wC = <span class="keyword">new</span> W(<span class="string">&#x27;W&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> yC = <span class="keyword">new</span> Y(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">wC = yC; <span class="comment">// OK</span></span><br><span class="line">yC = wC; <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>

<p>类的私有成员和受保护成员会影响兼容性。 当检查类实例的兼容时，如果目标类型包含一个私有成员，那么源类型必须包含来自同一个类的这个私有成员。 同样地，这条规则也适用于包含受保护成员实例的类型检查。 这允许子类赋值给父类，但是不能赋值给其它有同样类型的类。</p>
<h3 id="泛型的兼容性"><a href="#泛型的兼容性" class="headerlink" title="泛型的兼容性"></a>泛型的兼容性</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> NotEmpty&lt;T&gt; &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> gA: NotEmpty&lt;<span class="built_in">number</span>&gt;;</span><br><span class="line"><span class="keyword">let</span> gB: NotEmpty&lt;<span class="built_in">string</span>&gt;;</span><br><span class="line">gA = gB; <span class="comment">// ok</span></span><br></pre></td></tr></table></figure>



<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> NotEmpty&lt;T&gt; &#123;</span><br><span class="line">  <span class="attr">data</span>: T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> gA: NotEmpty&lt;<span class="built_in">number</span>&gt;;</span><br><span class="line"><span class="keyword">let</span> gB: NotEmpty&lt;<span class="built_in">string</span>&gt;;</span><br><span class="line">gA = gB; <span class="comment">// Error</span></span><br></pre></td></tr></table></figure>



<h2 id="高级类型"><a href="#高级类型" class="headerlink" title="高级类型"></a>高级类型</h2><h3 id="交叉类型"><a href="#交叉类型" class="headerlink" title="交叉类型"></a>交叉类型</h3><p>交叉类型是将多个类型合并为一个类型。 这让我们可以把现有的多种类型叠加到一起成为一种类型，它包含了所需的所有类型的特性。</p>
<h3 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h3><p>联合类型表示一个值可以是几种类型之一。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/ 联合类型</span><br><span class="line"><span class="comment">// 联合类型表示一个值可以是几个类型之一</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pad</span>(<span class="params">padding: <span class="built_in">number</span> | <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> padding;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(pad(<span class="number">1</span>));</span><br><span class="line"><span class="built_in">console</span>.log(pad(<span class="string">&#x27;A&#x27;</span>));</span><br></pre></td></tr></table></figure>

<p>如果一个值是联合类型，我们只能访问联合类型所有类型里共有的成员</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Elephant &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  walk();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Shark &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  swim();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAnimal</span>(<span class="params"></span>): <span class="title">Elephant</span> | <span class="title">Shark</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">name</span>: <span class="string">&#x27;Elephant&#x27;</span>, <span class="function"><span class="title">walk</span>(<span class="params"></span>)</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;walk&#x27;</span>) &#125; &#125; <span class="keyword">as</span> Elephant;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> aAnimal = getAnimal();</span><br><span class="line"><span class="built_in">console</span>.log(aAnimal.name);</span><br><span class="line">aAnimal.walk();</span><br><span class="line">aAnimal.swim();</span><br></pre></td></tr></table></figure>



</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2019-06-25T16:00:00.000Z" title="2019/6/26 上午12:00:00">2019-06-26</time>发表</span><span class="level-item"><a class="link-muted" href="/categories/JavaScript/">JavaScript</a></span><span class="level-item">4 分钟读完 (大约567个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/06/26/JavaScript%20%E6%93%8D%E4%BD%9C%E7%AC%A6/">JavaScript 操作符</a></h1><div class="content"><h2 id="位操作符"><a href="#位操作符" class="headerlink" title="位操作符"></a>位操作符</h2><p>ECMAScript 中的所有数值都以 IEEE 754 64 位格式存储，但位操作并不直接应用到 64 位表示，而是先把值转换为 32 位整数，再进行位操作，之后再把结果转换为 64 位。对开发者而言，就好像只有 32 位整数一样，因 为 64 位整数存储格式是不可见的。这让二进制操作变得与其他语言中类似。但这个转换也导致了一个奇特的副作用，即特殊值 <code>NaN</code> 和 <code>Infinity</code> 在位操作中都会被当成 0 处理。</p>
<p>有符号整数使用 32 位的前 31 位表示整数值。第 32 位表示数值的符号，如 0 表示正，1 表示负。这 一位称为符号位（sign bit），它的值决定了数值其余部分的格式。正值以真正的二进制格式存储，即 31 位中的每一位都代表 2 的幂。第一位（称为第 0 位）表示 20 ，第二位表示 21 ，依此类推。如果一个位是空的，则以 0填充，相当于忽略不计。</p>
<p>负值以一种称为二补数（或补码）的二进制编码存储。一个数值的二补数通过如下 3 个步骤计算 得到：</p>
<ol>
<li><p>确定绝对值的二进制表示</p>
</li>
<li><p>找到数值的一补数（或反码），换句话说，就是每个 0 都变成 1，每个 1 都变成 0</p>
</li>
<li><p>给结果加 1</p>
</li>
</ol>
<p>默认情况下，ECMAScript 中的所有整数都表示为有符号数。不过，确实存在无符号整数。对无符号整数来说，第 32 位不表示符号，因为只有正值。无符号整数比有符号整数的范围更大，因为符号位被用来表示数值了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span> &lt;&lt; <span class="number">10</span>); <span class="comment">// 1024</span></span><br><span class="line"><span class="built_in">console</span>.log(-<span class="number">1</span> &lt;&lt; <span class="number">10</span>); <span class="comment">// -1024</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1024</span> &gt;&gt; <span class="number">10</span>); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(-<span class="number">1024</span> &gt;&gt; <span class="number">10</span>); <span class="comment">// -1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1024</span> &gt;&gt;&gt; <span class="number">10</span>); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(-<span class="number">1024</span> &gt;&gt;&gt; <span class="number">10</span>); <span class="comment">// 4194303</span></span><br></pre></td></tr></table></figure>



<h2 id="相等操作符"><a href="#相等操作符" class="headerlink" title="相等操作符"></a>相等操作符</h2><p>全等和不全等操作符与相等和不相等操作符类似，只不过它们在比较相等时不转换操作数。全等操 作符由 3 个等于号（===）表示，只有两个操作数在不转换的前提下相等才返回 <code>true</code>。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2019-06-24T16:00:00.000Z" title="2019/6/25 上午12:00:00">2019-06-25</time>发表</span><span class="level-item"><a class="link-muted" href="/categories/JavaScript/">JavaScript</a></span><span class="level-item">18 分钟读完 (大约2697个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/06/25/JavaScrtip%20%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">JavaScript 数据类型</a></h1><div class="content"><p><code>ECMAScript</code> 有 6 种简单数据类型（也称为原始类型）：<code>Undefined</code>、<code>Null</code>、<code>Boolean</code>、<code>Number</code>、 <code>String</code> 和 <code>Symbol</code>。还有一种复杂数据类型叫 <code>Object</code>（对 象）。<code>Object</code> 是一种无序名值对的集合。</p>
<h3 id="Undefined-和-Null"><a href="#Undefined-和-Null" class="headerlink" title="Undefined 和 Null"></a><code>Undefined</code> 和 <code>Null</code></h3><p><code>Undefined</code> 类型只有一个值 <code>undefined</code>，当使用 <code>let</code> 或 <code>var</code> 声明变量单并没有初始化时，就相当于给变量赋予了 <code>undefined</code> 值。</p>
<p>一般来说不建议显式的给变量赋值 <code>undefined</code>，字面值 <code>undefined</code> 主要是用来比较。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> v1;</span><br><span class="line"><span class="keyword">var</span> v2;</span><br><span class="line"><span class="built_in">console</span>.log(v1); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(v2); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(v1 === v2); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>增加这个特殊值的目的就是为了正式明确空对象指针 <code>null</code> 和未初始化变量的区别。</p>
<p><code>undefined</code> 值是由 <code>null</code> 值派生而来的，因此 ECMA-262 将它们定义为表面上相等，如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="literal">null</span> === <span class="literal">undefined</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">null</span> == <span class="literal">undefined</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>



<p><code>Null</code> 类型同样只有一个值，即特殊值 <code>null</code>。逻辑上讲，<code>null</code> 值表示一个空对象指针，这也是给 <code>typeof</code> 传一个 <code>null</code> 会返回 “object” 的原因。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> v3 = <span class="literal">null</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> v3); <span class="comment">// &quot;object&quot;</span></span><br></pre></td></tr></table></figure>

<p>在定义将来要保存对象值的变量时，建议使用 <code>null</code> 来初始化，不要使用其他值。这样，只要检查这个变量的值是不是 <code>null</code> 就可以知道这个变量是否在后来被重新赋予了一个对象的引用。</p>
<p><code>undefined</code> 和 <code>null</code> 都是假值，如果只是为了检测假值，可以方便的检测它们；如果是明确的想要检测 <code>undefined</code> 或 <code>null</code>，则需要显式的对其进行判断。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> v4;</span><br><span class="line"><span class="keyword">let</span> o1 = <span class="literal">null</span>;</span><br><span class="line"><span class="built_in">console</span>.log(!v4); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(v4 === <span class="literal">undefined</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(!o1); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(o1 === <span class="literal">null</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>



<h3 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a><code>Boolean</code></h3><p><code>Boolean</code> 类型是使用非常频繁的数据类型，它有两个值 <code>true</code> 和 <code>false</code> (布尔值字面量是区分大小写的)。</p>
<p>这两个布尔值并不等同于数值：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> t1 = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">let</span> f1 = <span class="literal">false</span>;</span><br><span class="line"><span class="built_in">console</span>.log(t1 === <span class="number">1</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(f1 === <span class="number">0</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>虽然布尔值只有两个，但所有其他 ECMAScript 类型的值都有相应布尔值的等价形式。要将一个其他类型的值转换为布尔值，可以调用特定的 <code>Boolean()</code> 转型函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="literal">true</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="literal">false</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="string">&#x27;true&#x27;</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="string">&#x27;false&#x27;</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="number">0</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(-<span class="number">0</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="literal">NaN</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="number">1</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(-<span class="number">1</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="string">&#x27;&#x27;</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(<span class="string">&#x27; &#x27;</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>



<h3 id="Number"><a href="#Number" class="headerlink" title="Number"></a><code>Number</code></h3><p><code>Number</code> 类型使用 IEEE 754 格式表示整 数和浮点值（在某些语言中也叫双精度值）。不同的数值类型相应地也有不同的数值字面量格式。</p>
<img src="https://raw.githubusercontent.com/CocoaLei/images/master/img/20201223142824.png" alt="image-20201223142823585" style="zoom: 33%;" />

<p>整数可以用八进制、十进制和十六进制字面量表示，但是使用八进制和十六进制格式创建的数值在所有数学操作中都被视为十进制数值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> octalNum = <span class="number">077</span>;</span><br><span class="line"><span class="keyword">let</span> hexNum = <span class="number">0xff</span>;</span><br><span class="line"><span class="built_in">console</span>.log(octalNum); <span class="comment">// 63</span></span><br><span class="line"><span class="built_in">console</span>.log(hexNum); <span class="comment">// 255</span></span><br><span class="line"><span class="keyword">let</span> sum = octalNum + hexNum;</span><br><span class="line"><span class="built_in">console</span>.log(sum); <span class="comment">// 318</span></span><br></pre></td></tr></table></figure>

<h4 id="浮点值"><a href="#浮点值" class="headerlink" title="浮点值"></a>浮点值</h4><p>要定义浮点值，数值中必须包含小数点，而且小数点后面必须至少有一个数字。虽然小数点前面不是必须有整数，但推荐加上。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> float1 = <span class="number">1.01</span>;</span><br><span class="line"><span class="keyword">let</span> float2 = <span class="number">.01</span>;</span><br></pre></td></tr></table></figure>

<p>因为存储浮点值使用的内存空间是存储整数值的两倍，所以 ECMAScript 总是想方设法把值转换为 整数。在小数点后面没有数字的情况下，数值就会变成整数。类似地，如果数值本身就是整数，只是小 数点后面跟着 0（如 1.0），那它也会被转换为整数。</p>
<p>对于非常大或非常小的数值，浮点值可以用科学记数法来表示。科学记数法用于表示一个应该乘以 10 的给定次幂的数值。ECMAScript 中科学记数法的格式要求是一个数值（整数或浮点数）后跟一个大 写或小写的字母 e，再加上一个要乘的 10 的多少次幂</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> float3 = <span class="number">2.23e9</span>;</span><br><span class="line"><span class="built_in">console</span>.log(float3); <span class="comment">//2230000000</span></span><br><span class="line"><span class="keyword">let</span> float4 = <span class="number">1.01e-5</span>;</span><br><span class="line"><span class="built_in">console</span>.log(float4); <span class="comment">// 0.0000101</span></span><br></pre></td></tr></table></figure>

<p><strong>浮点值的精确度最高可达 17 位小数</strong>，但在算术计算中远不如整数精确。例如，0.1 加 0.2 得到的不 是 0.3，而是 0.300 000 000 000 000 04。由于这种微小的舍入错误，导致很难测试特定的浮点值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> float5 = <span class="number">0.1</span>;</span><br><span class="line"><span class="keyword">let</span> float6 = <span class="number">0.2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(float5 + float6); <span class="comment">// 0.30000000000000004</span></span><br></pre></td></tr></table></figure>

<p>之所以存在这种舍入错误，是因为使用了 IEEE 754 数值，这种错误并非 ECMAScript 所独有。其他使用相同格式的语言也有这个问题。</p>
<p>因此永远不要测试某个特定的浮点值。</p>
<p>使用最小精度值来比较浮点数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log( <span class="built_in">Math</span>.abs(<span class="number">0.1</span> + <span class="number">0.2</span> - <span class="number">0.3</span>) &lt;= <span class="built_in">Number</span>.EPSILON);</span><br></pre></td></tr></table></figure>

<h4 id="值的范围"><a href="#值的范围" class="headerlink" title="值的范围"></a>值的范围</h4><p>ECMAScript 可以表示的最小 数值保存在 <code>Number.MIN_VALUE</code> 中，这个值在多数浏览器中是 <code>5e-324</code>；可以表示的最大数值保存在 <code>Number.MAX_VALUE</code> 中，这个值在多数浏览器中是 <code>1.7976931348623157e+308</code>。如果某个计算得到的数值结果超出了 <code>JavaScript</code> 可以表示的范围，那么这个数值会被自动转换为一个特殊的 <code>Infinity</code>（无 穷）值。任何无法表示的负数以 <code>-Infinity</code>（负无穷大）表示，任何无法表示的正数以 <code>Infinity</code>（正 无穷大）表示。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.MIN_VALUE); <span class="comment">// 5e-234</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.MAX_VALUE); <span class="comment">// 1.7976931348623157e+308</span></span><br></pre></td></tr></table></figure>

<p>如果计算返回正 <code>Infinity</code> 或负 <code>Infinity</code> ， 则该值将不能再进一步用于任何计算。 这是因为 <code>Infinity</code> 没有可用于计算的数值表示形式。要确定一个值是不是有限大（即介于 <code>JavaScript</code> 能表示的最小值和最大值之间），可以使用 <code>isFinite()</code> 函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num1 = <span class="number">6e-325</span>;</span><br><span class="line"><span class="keyword">let</span> num2 = <span class="number">1.8e308</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.isFinite(num1)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.isFinite(num2)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p><code>Number.NEGATIVE_INFINITY</code> 和 <code>Number.POSITIVE_INFINITY</code> 也可以获取正、负 <code>Infinity</code>。没错，这两个属性包含的值分别就是 <code>-Infinity</code> 和 <code>Infinity</code>。</p>
<h4 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a><code>NaN</code></h4><p>有一个特殊的数值叫 <code>NaN</code>，意思是 “不是数值”（Not a Number），用于表示本来要返回数值的操作 失败了（而不是抛出错误）。比如，用 0 除任意数值在其他语言中通常都会导致错误，从而中止代码执 行。但在 ECMAScript 中，0、+0 或-0 相除会返回 <code>NaN</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.parseFloat(<span class="string">&#x27;f1.f&#x27;</span>)); <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>/<span class="number">0</span>); <span class="comment">// Infinity</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">0</span>/<span class="number">1</span>); <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">0</span>/<span class="number">0</span>); <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>

<p><code>NaN</code> 有几个独特的属性。首先，任何涉及 <code>NaN</code> 的操作始终返回 <code>NaN</code>（如 <code>NaN</code>/10），在连续多步计算 时这可能是个问题。其次，<code>NaN</code> 不等于包括 <code>NaN</code> 在内的任何值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">0</span>/<span class="number">0</span> === <span class="literal">NaN</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">NaN</span> === <span class="literal">NaN</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>要判断一个值是不是 <code>NaN</code>， 可以使用 <code>isNaN()</code> 函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.isNaN(<span class="number">0</span>/<span class="number">0</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.isNaN(<span class="literal">true</span>)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h4 id="数值转换"><a href="#数值转换" class="headerlink" title="数值转换"></a>数值转换</h4><p><code>JavaScript</code> 中提供了 <code>Number()</code>，<code>parseInt()</code>，<code>parseFloat()</code> 三个方法用来将非数值转换为数值。</p>
<h5 id="Number-1"><a href="#Number-1" class="headerlink" title="Number"></a><code>Number</code></h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="literal">true</span>)); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="literal">false</span>)); <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="number">1000</span>)); <span class="comment">// 1000</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="literal">null</span>)); <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="literal">undefined</span>)); <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="string">&#x27;12&#x27;</span>)); <span class="comment">// 12</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="string">&#x27; 12&#x27;</span>)); <span class="comment">// 12</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="string">&#x27;12-&#x27;</span>)); <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>

<h5 id="parseInt"><a href="#parseInt" class="headerlink" title="parseInt()"></a><code>parseInt()</code></h5><p><code>parseInt()</code> 函数更专注于字符串是否包含数值模式。字符串最前面的空格会被忽略，从第一个非空格字符开始转换。如果第一个字符不是数值字符、加号或减号，<code>parseInt()</code> 立即 返回 <code>NaN</code>。这意味着空字符串也会返回 <code>NaN</code>（这一点跟 <code>Number()</code> 不一样，它返回 0）。如果第一个字符 是数值字符、加号或减号，则继续依次检测每个字符，直到字符串末尾，或碰到非数值字符。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="number">100</span>)); <span class="comment">// 100</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">&#x27;1000&#x27;</span>)); <span class="comment">// 1000</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">&#x27;1000lll&#x27;</span>)); <span class="comment">// 1000</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">&#x27; 1000&#x27;</span>)); <span class="comment">// 1000</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">&#x27;001000&#x27;</span>)); <span class="comment">// 1000</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">&#x27;a 1000&#x27;</span>)); <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>

<p><code>parseInt()</code> 也接收第二个参数，用于指定底数（进制数）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">&#x27;077&#x27;</span>, <span class="number">8</span>)); <span class="comment">// 63</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">&#x27;0xff&#x27;</span>, <span class="number">16</span>)); <span class="comment">// 255</span></span><br></pre></td></tr></table></figure>

<p>不传底数参数相当于让 <code>parseInt()</code> 自己决定如何解析，所以为避免解析出错，建议始终传给 它第二个参数。</p>
<h5 id="parseFloat"><a href="#parseFloat" class="headerlink" title="parseFloat()"></a><code>parseFloat()</code></h5><p><code>parseFloat()</code> 函数的工作方式跟 <code>parseInt()</code> 函数类似，都是从位置 0 开始检测每个字符。同样， 它也是解析到字符串末尾或者解析到一个无效的浮点数值字符为止。这意味着第一次出现的小数点是有效的，但第二次出现的小数点就无效了，此时字符串的剩余字符都会被忽略。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseFloat</span>(<span class="string">&#x27;-1.01&#x27;</span>)); <span class="comment">// -1.01</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseFloat</span>(<span class="string">&#x27;1.01&#x27;</span>)); <span class="comment">// 1.01</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseFloat</span>(<span class="string">&#x27;1.01.01&#x27;</span>)); <span class="comment">// 1.01</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseFloat</span>(<span class="string">&#x27; 1.01&#x27;</span>)); <span class="comment">// 1.01</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseFloat</span>(<span class="string">&#x27;a1.01&#x27;</span>)); <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseFloat</span>(<span class="string">&#x27;1.01a&#x27;</span>)); <span class="comment">// 1.01</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseFloat</span>(<span class="string">&#x27;00001.01a&#x27;</span>)); <span class="comment">// 1.01</span></span><br></pre></td></tr></table></figure>



<h3 id="String"><a href="#String" class="headerlink" title="String"></a><code>String</code></h3><p><code>String</code>（字符串）数据类型表示零或多个 16 位 <code>Unicode</code> 字符序列。</p>
<img src="https://raw.githubusercontent.com/CocoaLei/images/master/img/20201223160959.png" alt="image-20201223160958920" style="zoom: 67%;" />

<p>ECMAScript 中的字符串是不可变的（immutable），意思是一旦创建，它们的值就不能变了。要修改某个变量中的字符串值，必须先销毁原始的字符串，然后将包含新值的另一个字符串保存到该变量。</p>
<h4 id="把值转换为字符串"><a href="#把值转换为字符串" class="headerlink" title="把值转换为字符串"></a>把值转换为字符串</h4><h5 id="使用-toString-方法"><a href="#使用-toString-方法" class="headerlink" title="使用 toString() 方法"></a>使用 <code>toString()</code> 方法</h5><p><code>null</code> 和 <code>undefined</code> 没有 <code>toString()</code> 方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> val1 = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">let</span> val2= <span class="string">&#x27;12&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> val3 = [<span class="number">1</span>,<span class="number">2</span>];</span><br><span class="line"><span class="keyword">let</span> val4 = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="keyword">let</span> val5 = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 12 12 1,2 Fri Dec 25 2020 13:48:14 GMT+0800 (China Standard Time) [object Object]</span></span><br><span class="line"><span class="built_in">console</span>.log(val1.toString(), val2.toString(), val3.toString(), val4.toString(), val5.toString());</span><br><span class="line"></span><br><span class="line"><span class="literal">null</span>.toString(); <span class="comment">// Uncaught TypeError: Cannot read property &#x27;toString&#x27; of undefined</span></span><br><span class="line"></span><br><span class="line"><span class="literal">undefined</span>.toString(); <span class="comment">// Uncaught TypeError: Cannot read property &#x27;toString&#x27; of null</span></span><br></pre></td></tr></table></figure>

<p>在对数字类型值调用 <code>toString()</code> 方法时，可传递一个参数指定以什么底数输出数值的字符串表示。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numVal = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(numVal.toString(<span class="number">2</span>)); <span class="comment">// 1111011</span></span><br><span class="line"><span class="built_in">console</span>.log(numVal.toString(<span class="number">8</span>)); <span class="comment">// 173</span></span><br><span class="line"><span class="built_in">console</span>.log(numVal.toString(<span class="number">10</span>)); <span class="comment">// 123</span></span><br><span class="line"><span class="built_in">console</span>.log(numVal.toString(<span class="number">16</span>)); <span class="comment">// 7b</span></span><br></pre></td></tr></table></figure>



<h5 id="使用-String"><a href="#使用-String" class="headerlink" title="使用 String()"></a>使用 <code>String()</code></h5><p>在使用 <code>String()</code> 将值转换为字符串时，如果值有 <code>toString()</code> 方法，则直接调用 <code>toString()</code> 方法并返回结果。对于没有 <code>toString()</code> 方法的 <code>null</code> 和 <code>undefined</code> ，则会分别返回 “null” 和 “undefiend”。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(<span class="literal">null</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(<span class="literal">undefined</span>));</span><br></pre></td></tr></table></figure>





<h3 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a><code>Symbol</code></h3><p><code>Symbol</code>（符号）是 ECMAScript 6 新增的数据类型。符号是原始值，且符号实例是<strong>唯一</strong>、<strong>不可变</strong>的。 符号的用途是确保对象属性使用唯一标识符，不会发生属性冲突的危险。</p>
<p>尽管听起来跟私有属性有点类似，但符号并不是为了提供私有属性的行为才增加的。相反，符号就是用来创建唯一记号，进而用作非字符串形式的对象属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>(<span class="string">&#x27;s2&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(s1);</span><br><span class="line"><span class="built_in">console</span>.log(s2);</span><br></pre></td></tr></table></figure>





<h3 id="Object"><a href="#Object" class="headerlink" title="Object"></a><code>Object</code></h3><p>ECMAScript 中的对象其实就是一组数据和功能的集合。对象通过 <code>new</code> 操作符后跟对象类型的名称 来创建。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2019-06-18T16:00:00.000Z" title="2019/6/19 上午12:00:00">2019-06-19</time>发表</span><span class="level-item"><a class="link-muted" href="/categories/JavaScript/">JavaScript</a></span><span class="level-item">4 分钟读完 (大约540个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/06/19/JavaScript%20%E4%BD%9C%E7%94%A8%E5%9F%9F/">JavaScript 变量作用域</a></h1><div class="content"><h2 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h2><p>变量能够被访问的范围被称为变量作用域。</p>
<h3 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h3><p>ES6 之前所有的变量都使用 <code>var</code> 关键字进行声明，ES6 中新增了 <code>let</code> 和 <code>const</code> 两种变量声明的关键字。</p>
<ul>
<li><p>使用 <code>var</code> 声明变量</p>
<p>使用 <code>var</code> 声明的变量会被自动添加到最靠近的上下文中，如果变量未经声明就初始化了，会被添加到全局上下文中。</p>
<p><code>var</code> 声明的变量会被拿到函数或全局作用域的顶部，这种现象被称为<strong>变量提升</strong>。提升让同一作用域中的代码不必考虑变量是否已经声明就可以直接使用。可是在实践中，提 升也会导致合法却奇怪的现象，即在变量声明之前使用变量。</p>
<p>单需要注意的是：变量的声明会提升，但变量的赋值不会。</p>
</li>
<li><p>使用 <code>let</code> 的块级作用域声明</p>
<p>ES6 新增的 <code>let</code> 关键字跟 <code>var</code> 很相似，但它的作用域是块级的，这也是 <code>JavaScript</code> 中的新概念。块级作用域由最近的一对包含花括号 <code>&#123;&#125;</code> 界定。换句话说，if 块、while 块、function 块，甚至连单独 的块也是 <code>let</code> 声明变量的作用域。</p>
<p><code>let</code> 与 <code>var</code> 的另一个不同之处是在同一作用域内不能声明两次。</p>
<p>重复的 <code>var</code> 声明会被忽略，而重 复的 <code>let</code> 声明会抛出 <code>SyntaxError</code>。</p>
</li>
<li><p>使用 <code>const</code> 的常量声明</p>
<p>ES6 同时还增加了 <code>const</code> 关键字。使用 <code>const</code> 声明的变量必须同时初始化为某个值。 一经声明，在其生命周期的任何时候都不能再重新赋予新值。</p>
<p>由于 <code>const</code> 声明暗示变量的值是单一类型且不可修改，<code>JavaScript</code> 运行时编译器可以将其所有实例都替换成实际的值，而不会通过查询表进行变量查找。谷歌的 V8 引擎就执行这种优化。</p>
</li>
</ul>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/">上一页</a></div><div class="pagination-next"><a href="/page/3/">下一页</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/">1</a></li><li><a class="pagination-link is-current" href="/page/2/">2</a></li><li><a class="pagination-link" href="/page/3/">3</a></li><li><span class="pagination-ellipsis">&hellip;</span></li><li><a class="pagination-link" href="/page/11/">11</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="LeiTech"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">LeiTech</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>China</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">52</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">10</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">4</p></a></div></div></nav><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="/"><i class="fab fa-github"></i></a></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/CS/"><span class="level-start"><span class="level-item">CS</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/Git/"><span class="level-start"><span class="level-item">Git</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/GoLang/"><span class="level-start"><span class="level-item">GoLang</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/JavaScript/"><span class="level-start"><span class="level-item">JavaScript</span></span><span class="level-end"><span class="level-item tag">19</span></span></a></li><li><a class="level is-mobile" href="/categories/Mac/"><span class="level-start"><span class="level-item">Mac</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/TypeScript/"><span class="level-start"><span class="level-item">TypeScript</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Vue/"><span class="level-start"><span class="level-item">Vue</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Web/"><span class="level-start"><span class="level-item">Web</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/iOS/"><span class="level-start"><span class="level-item">iOS</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"><span class="level-start"><span class="level-item">大前端</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></div></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2021/05/"><span class="level-start"><span class="level-item">五月 2021</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/01/"><span class="level-start"><span class="level-item">一月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/12/"><span class="level-start"><span class="level-item">十二月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/06/"><span class="level-start"><span class="level-item">六月 2020</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/09/"><span class="level-start"><span class="level-item">九月 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/06/"><span class="level-start"><span class="level-item">六月 2019</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/04/"><span class="level-start"><span class="level-item">四月 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/03/"><span class="level-start"><span class="level-item">三月 2019</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/02/"><span class="level-start"><span class="level-item">二月 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/12/"><span class="level-start"><span class="level-item">十二月 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/09/"><span class="level-start"><span class="level-item">九月 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/07/"><span class="level-start"><span class="level-item">七月 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/06/"><span class="level-start"><span class="level-item">六月 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/05/"><span class="level-start"><span class="level-item">五月 2018</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/04/"><span class="level-start"><span class="level-item">四月 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/03/"><span class="level-start"><span class="level-item">三月 2018</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/02/"><span class="level-start"><span class="level-item">二月 2018</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/01/"><span class="level-start"><span class="level-item">一月 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/05/"><span class="level-start"><span class="level-item">五月 2017</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/04/"><span class="level-start"><span class="level-item">四月 2017</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2016/06/"><span class="level-start"><span class="level-item">六月 2016</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2016/04/"><span class="level-start"><span class="level-item">四月 2016</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2016/03/"><span class="level-start"><span class="level-item">三月 2016</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2016/02/"><span class="level-start"><span class="level-item">二月 2016</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2016/01/"><span class="level-start"><span class="level-item">一月 2016</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/archives/2015/12/"><span class="level-start"><span class="level-item">十二月 2015</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2015/11/"><span class="level-start"><span class="level-item">十一月 2015</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2015/10/"><span class="level-start"><span class="level-item">十月 2015</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2015/09/"><span class="level-start"><span class="level-item">九月 2015</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Git/"><span class="tag">Git</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/GoLang/"><span class="tag">GoLang</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/JavaScript/"><span class="tag">JavaScript</span><span class="tag">12</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Web/"><span class="tag">Web</span><span class="tag">3</span></a></div></div></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><!--!--></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="关于代码的碎碎念" height="28"></a><p class="is-size-7"><span>&copy; 2021 Y2hlbmdsZWk=</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>