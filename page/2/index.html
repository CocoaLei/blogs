<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>关于代码的碎碎念</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="LeiTech"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="LeiTech"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="ODQ4NjUwMTI5QHFxLmNvbQ&amp;#x3D;&amp;#x3D;"><meta property="og:type" content="blog"><meta property="og:title" content="关于代码的碎碎念"><meta property="og:url" content="https://cocoalei.github.io/blogs"><meta property="og:site_name" content="关于代码的碎碎念"><meta property="og:description" content="ODQ4NjUwMTI5QHFxLmNvbQ&amp;#x3D;&amp;#x3D;"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://cocoalei.github.io/img/og_image.png"><meta property="article:author" content="Y2hlbmdsZWk="><meta property="article:tag" content="iOS,HTML,CSS,JavaScript,Vue.js"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://cocoalei.github.io/blogs"},"headline":"关于代码的碎碎念","image":["https://cocoalei.github.io/img/og_image.png"],"author":{"@type":"Person","name":"Y2hlbmdsZWk="},"publisher":{"@type":"Organization","name":"关于代码的碎碎念","logo":{"@type":"ImageObject","url":"https://cocoalei.github.io/img/logo.svg"}},"description":"ODQ4NjUwMTI5QHFxLmNvbQ&#x3D;&#x3D;"}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-dark.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.4.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="关于代码的碎碎念" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-12-15T01:55:27.983Z" title="2020/12/15 09:55:27">2020-12-15</time>发表</span><span class="level-item">1 分钟读完 (大约151个字)</span></div></div><div class="content"><p>关于前端工程师成长，需要两个视角。一是立足标准，系统性总结和整理前端知识，建立自己的认知和方法论；二是放眼团队，从业务和工程角度思考前端团队的价值和发展需要。只有这样做，才能够持续发展，在高速发展的技术和工程浪潮中稳稳立足。</p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="建立知识架构"><a href="#建立知识架构" class="headerlink" title="建立知识架构"></a>建立知识架构</h3><p>建立具有逻辑性和完备性的知识目录。</p>
<p><img src="https://raw.githubusercontent.com/CocoaLei/images/master/img/20201215101724.jpg" alt="img"></p>
<h3 id="追本溯源"><a href="#追本溯源" class="headerlink" title="追本溯源"></a>追本溯源</h3></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-06-17T16:00:00.000Z" title="2020/6/18 00:00:00">2020-06-18</time>发表</span><span class="level-item"><a class="link-muted" href="/categories/JavaScript/">JavaScript</a></span><span class="level-item">7 分钟读完 (大约983个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/06/18/JavaScript%20%E5%8F%8D%E5%B0%84%E4%B8%8E%20Reflect/">JavaScript 中的反射与 Proxy 与 Reflect</a></h1><div class="content"><h1 id="JavaScript-中的反射与-Proxy-与-Reflect"><a href="#JavaScript-中的反射与-Proxy-与-Reflect" class="headerlink" title="JavaScript 中的反射与 Proxy 与 Reflect"></a>JavaScript 中的反射与 Proxy 与 Reflect</h1><p><strong>反射</strong>（Reflect）是指程序运行时访问、检测和修改本身状态和行为的<strong>能力</strong>。在 ES6 中引入 <code>Reflect</code> 之前，常用 <code>for...in</code> 实现反射，而在引入 <code>Reflect</code> 之后，反射机制在 <code>JavaScript</code> 中得到了更大的延伸与应用。</p>
<h2 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a><code>Reflect</code></h2><p><code>Reflect</code> 是一个全局对象，但与其它全局对象不同，它并不是一个构造函数，所以不能通过 <code>new</code> 来对其进行调用。</p>
<p>而且它所有的属性和方法都是静态的（类似的还有 <code>Math</code>）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ** 检测一个对象是否有特定的属性</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">A</span>: <span class="string">&#x27;1&#x27;</span>, <span class="attr">B</span>: <span class="string">&#x27;2&#x27;</span> &#125;;</span><br><span class="line"><span class="built_in">Reflect</span>.has(obj, <span class="string">&#x27;A&#x27;</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Reflect</span>.has(obj. <span class="string">&#x27;C&#x27;</span>); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ** 返回对象自身的键 has 与 in 运算符作用相同</span></span><br><span class="line"><span class="built_in">Reflect</span>.ownKeys(obj); <span class="comment">// [&#x27;A&#x27;, &#x27;B&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ** 为对象添加新的属性</span></span><br><span class="line"><span class="built_in">Reflect</span>.set(obj, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;3&#x27;</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>



<h2 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a><code>Proxy</code></h2><p><code>Proxy</code> 基于目标对象创建一个代理对象，可以通过代理对象实现对于基本操作的拦截和自定义。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// target 要代理的对象，可以是任何对象，包括函数</span></span><br><span class="line"><span class="comment">// handler 代理配置，带有扑捉器的对象</span></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(targe, handler);</span><br></pre></td></tr></table></figure>

<p>对 proxy 对象进行操作，如果 handler 中包含了对应的捕捉器，则扑捉器会拦截这个操作，并对其进行处理。如果没有相应的捕捉器，则操作会被转发到被代理的对象。</p>
<p>对被代理对象的操作和相应的捕捉器名称如下：</p>
<table>
<thead>
<tr>
<th>被代理对象的操作</th>
<th>捕捉器</th>
</tr>
</thead>
<tbody><tr>
<td><code>Object.getPrototypeOf()</code></td>
<td><code>handler.getPrototypeOf()</code></td>
</tr>
<tr>
<td><code>Object.setPrototypeOf()</code></td>
<td><code>handler.setPrototypeOf()</code></td>
</tr>
<tr>
<td><code>Object.isExtensible()</code></td>
<td><code>handler.isExtensible()</code></td>
</tr>
<tr>
<td><code>Object.preventExtensions()</code></td>
<td><code>handler.preventExtensions()</code></td>
</tr>
<tr>
<td><code>Object.getOwnPropertyDescriptor()</code></td>
<td><code>handler.getOwnPropertyDescriptor()</code></td>
</tr>
<tr>
<td><code>Object.defineProperty()</code></td>
<td><code>handler.defineProperty()</code></td>
</tr>
<tr>
<td><code>in</code></td>
<td><code>handler.has()</code></td>
</tr>
<tr>
<td>属性读取</td>
<td><code>handler.get()</code></td>
</tr>
<tr>
<td>属性赋值</td>
<td><code>handler.set()</code></td>
</tr>
<tr>
<td><code>delete</code></td>
<td><code>handler.deleteProperty()</code></td>
</tr>
<tr>
<td><code>Object.getOwnPropertyNames()</code> 和 <code>Object.getOwnPropertySymbols()</code></td>
<td><code>handler.ownKeys()</code></td>
</tr>
<tr>
<td>函数调用</td>
<td><code>handler.apply()</code></td>
</tr>
<tr>
<td><code>new</code></td>
<td><code>handler.construct()</code></td>
</tr>
</tbody></table>
<h3 id="不变量"><a href="#不变量" class="headerlink" title="不变量"></a>不变量</h3><p>为了确保语言功能和行为的一致性，代理对象的捕捉器的返回是有一定限制的，被称为不变量。</p>
<ul>
<li><p><code>set()</code> ，如果设置属性值成功，需要返回 <code>true</code>，否则返回 <code>false</code></p>
</li>
<li><p><code>deleteProperty()</code>，如果属性删除成功，需要返回 <code>true</code>，否则返回 <code>false</code></p>
</li>
<li><p><code>getPrototypeOf()</code> 必须返回被代理对象的原型</p>
</li>
<li><p>…</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> origin = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Mike&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">29</span>,</span><br><span class="line">  <span class="attr">_isMarried</span>: <span class="literal">false</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">origin = <span class="keyword">new</span> <span class="built_in">Proxy</span>(origin, &#123;</span><br><span class="line">  <span class="attr">isExtensible</span>: <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.isExtensible(obj);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">has</span>: <span class="function"><span class="keyword">function</span>(<span class="params">obj, prop</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.has(obj, prop);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params">obj, prop, receiver</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Reflect</span>.has(obj, prop)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (prop.startsWith(<span class="string">&#x27;_&#x27;</span>)) <span class="keyword">return</span> <span class="string">&#x27;Access denied&#x27;</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(obj, prop, receiver);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;No &quot;</span>.concat(prop, <span class="string">&quot; find in target&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">set</span>: <span class="function"><span class="keyword">function</span> <span class="title">set</span>(<span class="params">obj, prop, value, receiver</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Reflect</span>.has(obj, prop)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (prop.startsWith(<span class="string">&#x27;_&#x27;</span>)) <span class="keyword">return</span> <span class="string">&#x27;Access denied&#x27;</span>;</span><br><span class="line">      <span class="built_in">Reflect</span>.set(obj, prop, value, receiver);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(origin._isMarried); <span class="comment">// Access denied</span></span><br><span class="line"><span class="built_in">console</span>.log(origin._isMarried = <span class="string">&#x27;1&#x27;</span>); <span class="comment">// Access denied</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">constructPoint</span>(<span class="params">numX, numY</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [numX, numY];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> funcProxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(constructPoint, &#123;</span><br><span class="line">  <span class="attr">apply</span>: <span class="function"><span class="keyword">function</span>(<span class="params">obj, thisArg, argumentsList</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> argumentsList.join(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(funcProxy(<span class="number">1</span>, <span class="number">2</span>)); <span class="comment">// 1-2</span></span><br></pre></td></tr></table></figure>

<p>对于每个可被 <code>Proxy</code> 捕获的内部方法，在 <code>Reflect</code> 中都有一个对应的方法，其名称和参数与 <code>Proxy</code> 捕捉器相同。</p>
<p>所以，我们可以使用 <code>Reflect</code> 来将操作转发给原始对象。</p>
<h3 id="Proxy-的局限"><a href="#Proxy-的局限" class="headerlink" title="Proxy 的局限"></a><code>Proxy</code> 的局限</h3><p>许多内建对象，例如 <code>Map</code>，<code>Set</code>，<code>Date</code>，<code>Promise</code> 等，都使用了所谓的“内部插槽”。</p>
<p>它们类似于属性，但仅限于内部使用，仅用于规范目的。例如，<code>Map</code> 将项目（item）存储在 <code>[[MapData]]</code> 中。内建方法可以直接访问它们，而不通过 <code>[[Get]]/[[Set]]</code> 内部方法。所以 <code>Proxy</code> 无法拦截它们。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(map, &#123;</span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params">target, prop, receiver</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> value = <span class="built_in">Reflect</span>.get(...arguments);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> value == <span class="string">&#x27;function&#x27;</span> ? value.bind(target) : value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">proxy.set(<span class="string">&#x27;test&#x27;</span>, <span class="number">1</span>);</span><br><span class="line">alert(proxy.get(<span class="string">&#x27;test&#x27;</span>)); <span class="comment">// 1（工作了！）</span></span><br></pre></td></tr></table></figure>

<p>类似的，类的私有属性也是通过内部插槽而不是 <code>get</code> 和 <code>set</code> 方法，采用上面的方法依旧有效</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">  #name = <span class="string">&quot;Guest&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">getName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.#name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> user = <span class="keyword">new</span> User();</span><br><span class="line"></span><br><span class="line">user = <span class="keyword">new</span> <span class="built_in">Proxy</span>(user, &#123;</span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params">target, prop, receiver</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> value = <span class="built_in">Reflect</span>.get(...arguments);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> value == <span class="string">&#x27;function&#x27;</span> ? value.bind(target) : value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">alert(user.getName()); <span class="comment">// Guest</span></span><br></pre></td></tr></table></figure>

</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-06-15T16:00:00.000Z" title="2020/6/16 00:00:00">2020-06-16</time>发表</span><span class="level-item"><a class="link-muted" href="/categories/Vue/">Vue</a></span><span class="level-item">19 分钟读完 (大约2812个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/06/16/Vue3%20%E6%95%B0%E6%8D%AE%E4%BE%A6%E6%B5%8B%E5%8E%9F%E7%90%86/">Vue 3 原理解析 - 数据侦测原理</a></h1><div class="content"><h2 id="Vue-3-原理解析-数据侦测原理"><a href="#Vue-3-原理解析-数据侦测原理" class="headerlink" title="Vue 3 原理解析 - 数据侦测原理"></a>Vue 3 原理解析 - 数据侦测原理</h2><p>Vue 2.x 及之前的版本中实现数据的可响应，需要对 <code>Object</code> 和 <code>Array</code> 分别进行处理：</p>
<ul>
<li><code>Object</code> 类型通过 <code>Object.definePropery</code> 把属性转换成 <code>getter/setter</code> ，这个过程需要递归侦测所有的对象 <code>key</code> 来实现深度侦测</li>
<li><code>Array</code> 类型通过对改变数组自身的几个方法进行拦截来实现对数组的可响应</li>
</ul>
<p>而在 Vue3 中则是通过 <code>Proxy</code> 实现数据读取和设置拦截，在捕捉器中实现数据依赖收集和触发视图更新的操作。</p>
<h3 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a><code>Proxy</code></h3><p><code>Proxy</code> 是 ES6 中新引入的特性。</p>
<p><code>Proxy</code> 正如其含字面意义 - “代理” 所表明的那样，它是对象与对象之间的一层代理，程序可以通过 <code>Proxy</code> 来访问或操作目标对象，进而可以实现基本操作的拦截和自定义。</p>
<p>基本语法如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br></pre></td></tr></table></figure>

<p>参数：</p>
<ul>
<li><code>target</code> 要代理的原始对象，可以是任何类型的对象，包括原生数组、函数甚至另一个代理对象</li>
<li><code>handler</code> 一个通常以函数作为属性的对象，各属性中的函数分别定义了在执行各种操作时代理的行为</li>
</ul>
<p>举个栗子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> proxyHandler = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> objProxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, proxyHandler);</span><br><span class="line"><span class="comment">// 赋值操作被转发到 obj 对象</span></span><br><span class="line">objProxy.a = <span class="number">37</span>;</span><br></pre></td></tr></table></figure>

<p><code>handler</code> 中可以设置对原始对象各种操作的捕获器，在捕获器中可以自定义修改操作的行为。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">a</span>: <span class="string">&#x27;A&#x27;</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, &#123;</span><br><span class="line">  <span class="attr">get</span>: <span class="function">(<span class="params">o, p</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (p === <span class="string">&#x27;a&#x27;</span>) <span class="keyword">return</span> <span class="string">&#x27;This is A&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> o[p];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>有时我们并不知道目标对象的具体类型，这种情况下使用 <code>Reflect</code> 返回 <code>trap</code> （捕捉器）相应的默认行为。</p>
<p><code>Reflect</code> 是一个内置的不可构造的非函数对象，它提供了拦截 <code>JavaScript</code> 各种操作的方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> proxyObj = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;</span><br><span class="line">    <span class="attr">get</span>: <span class="function">(<span class="params">obj, prop</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(obj, prop, receiver);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">set</span>: <span class="function">(<span class="params">obj, prop, value</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">Reflect</span>.set(obj, prop, value, receiver);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>对于 <code>set</code> 操作，可能会引起代理对象的属性更改，导致 <code>set</code> 多次执行。比如当代理对象是数组时，执行 <code>push</code> 操作，会多次触发 <code>set</code>，同时也引发 <code>get</code> 操作。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> array = [ <span class="number">1</span>, <span class="number">3</span> ];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxyHandler = &#123;</span><br><span class="line">    <span class="attr">get</span>: <span class="function">(<span class="params">target, prop, receiver</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;Get value : &#x27;</span>, prop, <span class="built_in">Reflect</span>.get(target, prop, receiver));</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, prop, receiver);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">set</span>: <span class="function">(<span class="params">target, prop, value, receiver</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;Set value  :&#x27;</span>, prop, value);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(target, prop, value, receiver);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> objProxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(array, proxyHandler);</span><br><span class="line"></span><br><span class="line">objProxy.push(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get value :  push [Function: push]</span></span><br><span class="line"><span class="comment">// Get value :  length 2</span></span><br><span class="line"><span class="comment">// Set value  : 2 4</span></span><br><span class="line"><span class="comment">// Set value  : length 3</span></span><br></pre></td></tr></table></figure>

<p>当要代理的对象是多层结构时，<code>Proxy</code> 的代理只能到第一层，即不能感知操作对象内部的 <code>set</code> 操作，但是 <code>get</code> 会被执行。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; <span class="string">&#x27;foo&#x27;</span>: <span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>: &#123; <span class="string">&#x27;name&#x27;</span>: <span class="number">1</span> &#125; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxyHandler = &#123;</span><br><span class="line">    <span class="attr">get</span>: <span class="function">(<span class="params">target, prop, receiver</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;Get value : &#x27;</span>, prop, <span class="built_in">Reflect</span>.get(target, prop, receiver));</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, prop, receiver);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">set</span>: <span class="function">(<span class="params">target, prop, value, receiver</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;Set value  :&#x27;</span>, prop, value);</span><br><span class="line">        <span class="built_in">Reflect</span>.set(target, prop, value, receiver);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> objProxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, proxyHandler);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(objProxy.bar.name);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get value :  bar &#123; name: 1 &#125;</span></span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p><strong>一句话总结：Proxy 是 ES6 引入的新特性，可以使用 Proxy 间接访问或操作其代理的对象。</strong></p>
<h3 id="Vue-3-中响应式数据实现"><a href="#Vue-3-中响应式数据实现" class="headerlink" title="Vue 3 中响应式数据实现"></a>Vue 3 中响应式数据实现</h3><p>Vue 3 中响应式系统的 API 主要有</p>
<ul>
<li><code>reactive</code></li>
<li><code>ref</code></li>
<li><code>computed</code></li>
<li><code>readonly</code></li>
<li><code>watchEffect</code></li>
<li><code>watch</code></li>
</ul>
<p>其中 <code>reactive</code> 是最核心的 API</p>
<h4 id="reactive"><a href="#reactive" class="headerlink" title="reactive"></a><code>reactive</code></h4><p>Vue 3 中是用全局的 <code>WeakMap</code> 来存储正在追踪的响应式对象，如 <code>reactiveMap</code> 、<code>shallowReactiveMap</code> 、<code>readonlyMap</code>、<code>shallowReadonlyMap</code> 。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> reactiveMap = <span class="keyword">new</span> <span class="built_in">WeakMap</span>&lt;Target, any&gt;()</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> shallowReactiveMap = <span class="keyword">new</span> <span class="built_in">WeakMap</span>&lt;Target, any&gt;()</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> readonlyMap = <span class="keyword">new</span> <span class="built_in">WeakMap</span>&lt;Target, any&gt;()</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> shallowReadonlyMap = <span class="keyword">new</span> <span class="built_in">WeakMap</span>&lt;Target, any&gt;()</span><br></pre></td></tr></table></figure>

<p>此外还定义了代理对象的可响应操作：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通对象，如 Object 、Array 的拦截器</span></span><br><span class="line"><span class="comment">// 包含了当对代理对象进行取值、复制、删除属性等操作时的捕获器</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> mutableHandlers: ProxyHandler&lt;object&gt; = &#123;</span><br><span class="line">  get,</span><br><span class="line">  set,</span><br><span class="line">  deleteProperty,</span><br><span class="line">  has,</span><br><span class="line">  ownKeys</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 集合对象，如果 Map/WeakMap/Set/WeakSet 的拦截器</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> mutableCollectionHandlers: ProxyHandler&lt;CollectionTypes&gt; = &#123;</span><br><span class="line">  <span class="attr">get</span>: <span class="comment">/*#__PURE__*/</span> createInstrumentationGetter(<span class="literal">false</span>, <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>reactive</code> 创建响应式对象的流程如下：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 生成一个原始对象的响应式副本，这种转换是深层次的，会影响到所有嵌套属性</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reactive</span>(<span class="params">target: <span class="built_in">object</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果目标对象是只读的，直接返回目标对象</span></span><br><span class="line">  <span class="keyword">if</span> (target &amp;&amp; (target <span class="keyword">as</span> Target).__v_isReadonly) &#123;</span><br><span class="line">    <span class="keyword">return</span> target</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 否则就在目标对象的基础上创建响应式对象</span></span><br><span class="line">  <span class="keyword">return</span> createReactiveObject(</span><br><span class="line">    target, <span class="comment">// 目标代理对象</span></span><br><span class="line">    <span class="literal">false</span>, <span class="comment">// 是否只读</span></span><br><span class="line">    mutableHandlers,</span><br><span class="line">    mutableCollectionHandlers,</span><br><span class="line">    reactiveMap</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 创建响应式对象</span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createReactiveObject</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  target: Target, <span class="comment">// 原始对象</span></span></span></span><br><span class="line"><span class="params"><span class="function">  isReadonly: <span class="built_in">boolean</span>, <span class="comment">// 是否只读</span></span></span></span><br><span class="line"><span class="params"><span class="function">  baseHandlers: ProxyHandler&lt;<span class="built_in">any</span>&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function">  collectionHandlers: ProxyHandler&lt;<span class="built_in">any</span>&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function">  proxyMap: <span class="built_in">WeakMap</span>&lt;Target, <span class="built_in">any</span>&gt; <span class="comment">// 正在追踪的可响应对象的集合</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果 target 不是对象类型，返回原值</span></span><br><span class="line">  <span class="keyword">if</span> (!isObject(target)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">      <span class="built_in">console</span>.warn(<span class="string">`value cannot be made reactive: <span class="subst">$&#123;<span class="built_in">String</span>(target)&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target</span><br><span class="line">  &#125;</span><br><span class="line">	<span class="comment">// 如果 taret 已经是一个响应式对象，返回原值</span></span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    target[ReactiveFlags.RAW] &amp;&amp;</span><br><span class="line">    !(isReadonly &amp;&amp; target[ReactiveFlags.IS_REACTIVE])</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">return</span> target</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果 target 已经有一个代理对象，返回已经存在的代理对象</span></span><br><span class="line">  <span class="keyword">const</span> existingProxy = proxyMap.get(target)</span><br><span class="line">  <span class="keyword">if</span> (existingProxy) &#123;</span><br><span class="line">    <span class="keyword">return</span> existingProxy</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 只有特定类型的对象才可以被观测</span></span><br><span class="line">  <span class="comment">// 包括 Array/Object/Map/Set/WeakMap/WeakSet，不是则返回 TargetType.INVALID</span></span><br><span class="line">  <span class="keyword">const</span> targetType = getTargetType(target)</span><br><span class="line">  <span class="keyword">if</span> (targetType === TargetType.INVALID) &#123;</span><br><span class="line">    <span class="keyword">return</span> target</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(</span><br><span class="line">    target,</span><br><span class="line">    <span class="comment">// Map/Set/WeakMap/WeakSet 被认为是 COLLECTION 类型，handler 和其它类型不同</span></span><br><span class="line">    targetType === TargetType.COLLECTION ? collectionHandlers : baseHandlers</span><br><span class="line">  )</span><br><span class="line">  proxyMap.set(target, proxy)</span><br><span class="line">  <span class="keyword">return</span> proxy</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面提到了对于多层对象的代理，<code>set</code> 并不能感知到内层对象的变化，但是 <code>get</code> 会被触发，Vue 3 利用这个原理，再对内层数据进行一次代理。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createGetter</span>(<span class="params">isReadonly = <span class="literal">false</span>, shallow = <span class="literal">false</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params">target: Target, key: <span class="built_in">string</span> | symbol, receiver: <span class="built_in">object</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key === ReactiveFlags.IS_REACTIVE) &#123;</span><br><span class="line">      <span class="comment">// 如果 key 是可响应标志 IS_REACTIVE，返回 !isReadonly</span></span><br><span class="line">      <span class="keyword">return</span> !isReadonly</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key === ReactiveFlags.IS_READONLY) &#123;</span><br><span class="line">      <span class="comment">// 如果 key 是只读标志 IS_READONLY，返回 isReadonly</span></span><br><span class="line">      <span class="keyword">return</span> isReadonly</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">      key === ReactiveFlags.RAW &amp;&amp;</span><br><span class="line">      receiver ===</span><br><span class="line">        (isReadonly</span><br><span class="line">          ? shallow</span><br><span class="line">            ? shallowReadonlyMap</span><br><span class="line">            : readonlyMap</span><br><span class="line">          : shallow</span><br><span class="line">          ? shallowReactiveMap</span><br><span class="line">          : reactiveMap</span><br><span class="line">        ).get(target)</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="keyword">return</span> target</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> targetIsArray = isArray(target)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果目标是数组</span></span><br><span class="line">    <span class="keyword">if</span> (!isReadonly &amp;&amp; targetIsArray &amp;&amp; hasOwn(arrayInstrumentations, key)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(arrayInstrumentations, key, receiver)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> res = <span class="built_in">Reflect</span>.get(target, key, receiver)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断 key 是否是 Symbol</span></span><br><span class="line">    <span class="keyword">if</span> (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) &#123;</span><br><span class="line">      <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果可读，追踪</span></span><br><span class="line">    <span class="keyword">if</span> (!isReadonly) &#123;</span><br><span class="line">      track(target, TrackOpTypes.GET, key)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是浅层响应，直接返回得到的值</span></span><br><span class="line">    <span class="keyword">if</span> (shallow) &#123;</span><br><span class="line">      <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否 Ref</span></span><br><span class="line">    <span class="keyword">if</span> (isRef(res)) &#123;</span><br><span class="line">      <span class="comment">// ref unwrapping - does not apply for Array + integer key.</span></span><br><span class="line">      <span class="keyword">const</span> shouldUnwrap = !targetIsArray || !isIntegerKey(key)</span><br><span class="line">      <span class="keyword">return</span> shouldUnwrap ? res.value : res</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isObject(res)) &#123;</span><br><span class="line">      <span class="comment">// Convert returned value into a proxy as well. we do the isObject check</span></span><br><span class="line">      <span class="comment">// here to avoid invalid value warning. Also need to lazy access readonly</span></span><br><span class="line">      <span class="comment">// and reactive here to avoid circular dependency.</span></span><br><span class="line">      <span class="keyword">return</span> isReadonly ? <span class="keyword">readonly</span>(res) : reactive(res)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 <code>reactive</code> 创建了响应式对象后，改变响应式对象的属性操作，会被侦测，并即时地在目标对象上触发对应的响应。</p>
<p>拿 <code>set</code> 方法，即赋值来举例，就是：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> set = <span class="comment">/*#__PURE__*/</span> createSetter()</span><br><span class="line"><span class="keyword">const</span> shallowSet = <span class="comment">/*#__PURE__*/</span> createSetter(<span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createSetter</span>(<span class="params">shallow = <span class="literal">false</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">set</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">    target: object,</span></span></span><br><span class="line"><span class="params"><span class="function">    key: string | symbol,</span></span></span><br><span class="line"><span class="params"><span class="function">    value: unknown,</span></span></span><br><span class="line"><span class="params"><span class="function">    receiver: object</span></span></span><br><span class="line"><span class="params"><span class="function">  </span>): <span class="title">boolean</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 取得旧的值 oldValue</span></span><br><span class="line">    <span class="keyword">let</span> oldValue = (target <span class="keyword">as</span> any)[key]</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果不是浅层响应模式，需要进行一系列的判断，才能赋值</span></span><br><span class="line">    <span class="keyword">if</span> (!shallow) &#123;</span><br><span class="line">      value = toRaw(value)</span><br><span class="line">      oldValue = toRaw(oldValue)</span><br><span class="line">      <span class="comment">// 如果 target 不是数组，旧值是 Ref</span></span><br><span class="line">      <span class="keyword">if</span> (!isArray(target) &amp;&amp; isRef(oldValue) &amp;&amp; !isRef(value)) &#123;</span><br><span class="line">        oldValue.value = value</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// in shallow mode, objects are set as-is regardless of reactive or not</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> hadKey =</span><br><span class="line">      isArray(target) &amp;&amp; isIntegerKey(key)</span><br><span class="line">        ? <span class="built_in">Number</span>(key) &lt; target.length</span><br><span class="line">        : hasOwn(target, key)</span><br><span class="line">    <span class="keyword">const</span> result = <span class="built_in">Reflect</span>.set(target, key, value, receiver)</span><br><span class="line">    <span class="comment">// don&#x27;t trigger if target is something up in the prototype chain of original</span></span><br><span class="line">    <span class="keyword">if</span> (target === toRaw(receiver)) &#123;</span><br><span class="line">      <span class="comment">// 在 target 上触发 ADD 或者 SET 响应</span></span><br><span class="line">      <span class="keyword">if</span> (!hadKey) &#123;</span><br><span class="line">        trigger(target, TriggerOpTypes.ADD, key, value)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (hasChanged(value, oldValue)) &#123;</span><br><span class="line">        trigger(target, TriggerOpTypes.SET, key, value, oldValue)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="ref"><a href="#ref" class="headerlink" title="ref"></a><code>ref</code></h4><p>由于 <code>Proxy</code> 代理的目标需是对象形式，不能对简单类型进行代理，为此 Vue 3 中使用 <code>ref</code> 函数为简单类型的值生成了一个包装，这样就可以通过 <code>recative</code> 函数构建响应式数据了。</p>
<p>包装对象的实现如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RefImpl</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  private _value: T</span><br><span class="line">  private _rawValue: T</span><br><span class="line"></span><br><span class="line">  public dep?: Dep = <span class="literal">undefined</span></span><br><span class="line">  public readonly __v_isRef = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">value: T, public readonly _shallow = <span class="literal">false</span></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>._rawValue = _shallow ? value : toRaw(value)</span><br><span class="line">    <span class="built_in">this</span>._value = _shallow ? value : convert(value)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> <span class="title">value</span>() &#123;</span><br><span class="line">    trackRefValue(<span class="built_in">this</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._value</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span> <span class="title">value</span>(<span class="params">newVal</span>) &#123;</span><br><span class="line">    newVal = <span class="built_in">this</span>._shallow ? newVal : toRaw(newVal)</span><br><span class="line">    <span class="keyword">if</span> (hasChanged(newVal, <span class="built_in">this</span>._rawValue)) &#123;</span><br><span class="line">      <span class="built_in">this</span>._rawValue = newVal</span><br><span class="line">      <span class="built_in">this</span>._value = <span class="built_in">this</span>._shallow ? newVal : convert(newVal)</span><br><span class="line">      triggerRefValue(<span class="built_in">this</span>, newVal)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Ref&lt;T = any&gt; &#123;</span><br><span class="line">  [RefSymbol]: <span class="literal">true</span></span><br><span class="line">  <span class="attr">value</span>: T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ref</span>(<span class="params">value?: unknown</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> createRef(value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createRef</span>(<span class="params">rawValue: unknown, shallow = <span class="literal">false</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 判断是否是 Ref，如果是 Ref 则直接返回</span></span><br><span class="line">  <span class="keyword">if</span> (isRef(rawValue)) &#123;</span><br><span class="line">    <span class="keyword">return</span> rawValue</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 判断是否是浅代理</span></span><br><span class="line">  <span class="comment">// convert = (val) =&gt; isObject(val) ? reactive(val) : val</span></span><br><span class="line">  <span class="keyword">let</span> value = shallow ? rawValue : convert(rawValue)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// </span></span><br><span class="line">  <span class="keyword">const</span> r = &#123;</span><br><span class="line">    <span class="attr">__v_isRef</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="keyword">get</span> <span class="title">value</span>() &#123;</span><br><span class="line">      track(r, TrackOpTypes.GET, <span class="string">&#x27;value&#x27;</span>)</span><br><span class="line">      <span class="keyword">return</span> value</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span> <span class="title">value</span>(<span class="params">newVal</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (hasChanged(toRaw(newVal), rawValue)) &#123;</span><br><span class="line">        rawValue = newVal</span><br><span class="line">        value = shallow ? newVal : convert(newVal)</span><br><span class="line">        trigger(</span><br><span class="line">          r,</span><br><span class="line">          TriggerOpTypes.SET,</span><br><span class="line">          <span class="string">&#x27;value&#x27;</span>,</span><br><span class="line">          __DEV__ ? &#123; <span class="attr">newValue</span>: newVal &#125; : <span class="built_in">void</span> <span class="number">0</span></span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="computed"><a href="#computed" class="headerlink" title="computed"></a><code>computed</code></h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">computed</span>&lt;<span class="title">T</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  getterOrOptions: ComputedGetter&lt;T&gt; | WritableComputedOptions&lt;T&gt;</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> getter: ComputedGetter&lt;T&gt;</span><br><span class="line">  <span class="keyword">let</span> setter: ComputedSetter&lt;T&gt;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果传入的 getterOrOptions 是函数，则将其设置为计算属性的 getter</span></span><br><span class="line">  <span class="keyword">if</span> (isFunction(getterOrOptions)) &#123;</span><br><span class="line">    getter = getterOrOptions</span><br><span class="line">    <span class="comment">// 如果只传入了 getter 函数，将计算属性是不可修改的 readonly</span></span><br><span class="line">    setter = __DEV__</span><br><span class="line">      ? <span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.warn(<span class="string">&#x27;Write operation failed: computed value is readonly&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      : NOOP</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果 getterOrOptions 是个对象，则计算属性是可修改的</span></span><br><span class="line">    getter = getterOrOptions.get</span><br><span class="line">    setter = getterOrOptions.set</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> dirty = <span class="literal">true</span></span><br><span class="line">  <span class="keyword">let</span> value: T</span><br><span class="line">  <span class="keyword">let</span> computed: ComputedRef&lt;T&gt;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> runner = effect(getter, &#123;</span><br><span class="line">    <span class="attr">lazy</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 将 effect 标记为 computed，则其在执行时拥有更高的优先级</span></span><br><span class="line">    <span class="attr">computed</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">scheduler</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!dirty) &#123;</span><br><span class="line">        dirty = <span class="literal">true</span></span><br><span class="line">        trigger(computed, TriggerOpTypes.SET, <span class="string">&#x27;value&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 构建一个 computed 对象</span></span><br><span class="line">  computed = &#123;</span><br><span class="line">    <span class="attr">__v_isRef</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 将 effect 暴露，使得计算属性能够 stop</span></span><br><span class="line">    <span class="attr">effect</span>: runner,</span><br><span class="line">    <span class="keyword">get</span> <span class="title">value</span>() &#123;</span><br><span class="line">      <span class="keyword">if</span> (dirty) &#123;</span><br><span class="line">        value = runner()</span><br><span class="line">        dirty = <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 追踪</span></span><br><span class="line">      track(computed, TrackOpTypes.GET, <span class="string">&#x27;value&#x27;</span>)</span><br><span class="line">      <span class="comment">// 返回最新值</span></span><br><span class="line">      <span class="keyword">return</span> value</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span> <span class="title">value</span>(<span class="params">newValue: T</span>) &#123;</span><br><span class="line">      setter(newValue)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">as</span> <span class="built_in">any</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> computed</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="effect"><a href="#effect" class="headerlink" title="effect"></a><code>effect</code></h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">effect</span>&lt;<span class="title">T</span> = <span class="title">any</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  fn: () =&gt; T,</span></span></span><br><span class="line"><span class="params"><span class="function">  options: ReactiveEffectOptions = EMPTY_OBJ</span></span></span><br><span class="line"><span class="params"><span class="function"></span>): <span class="title">ReactiveEffect</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (isEffect(fn)) &#123;</span><br><span class="line">    fn = fn.raw</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> effect = createReactiveEffect(fn, options)</span><br><span class="line">  <span class="keyword">if</span> (!options.lazy) &#123;</span><br><span class="line">    effect()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> effect</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createReactiveEffect</span>&lt;<span class="title">T</span> = <span class="title">any</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  fn: (...args: <span class="built_in">any</span>[]) =&gt; T,</span></span></span><br><span class="line"><span class="params"><span class="function">  options: ReactiveEffectOptions</span></span></span><br><span class="line"><span class="params"><span class="function"></span>): <span class="title">ReactiveEffect</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> effect = <span class="function"><span class="keyword">function</span> <span class="title">reactiveEffect</span>(<span class="params">...args: unknown[]</span>): <span class="title">unknown</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!effect.active) &#123;</span><br><span class="line">      <span class="keyword">return</span> options.scheduler ? <span class="literal">undefined</span> : fn(...args)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果 effectStack 不存在当前 effect</span></span><br><span class="line">    <span class="keyword">if</span> (!effectStack.includes(effect)) &#123;</span><br><span class="line">      cleanup(effect)</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        enableTracking()</span><br><span class="line">        <span class="comment">// 将当前 effect 加入 effectStack</span></span><br><span class="line">        effectStack.push(effect)</span><br><span class="line">        <span class="comment">// 将当前 effect 设置为 activeEffect</span></span><br><span class="line">        activeEffect = effect</span><br><span class="line">        <span class="keyword">return</span> fn(...args)</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        effectStack.pop()</span><br><span class="line">        resetTracking()</span><br><span class="line">        activeEffect = effectStack[effectStack.length - <span class="number">1</span>]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">as</span> ReactiveEffect</span><br><span class="line">  effect.id = uid++</span><br><span class="line">  effect._isEffect = <span class="literal">true</span></span><br><span class="line">  effect.active = <span class="literal">true</span></span><br><span class="line">  effect.raw = fn</span><br><span class="line">  effect.deps = []</span><br><span class="line">  effect.options = options</span><br><span class="line">  <span class="keyword">return</span> effect</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="关于-trigger-和-track"><a href="#关于-trigger-和-track" class="headerlink" title="关于 trigger 和 track"></a>关于 <code>trigger</code> 和 <code>track</code></h5><p><code>trigger</code> 用来当观测值发生发生变化时通知观察者</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">trigger</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  target: <span class="built_in">object</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">type</span>: TriggerOpTypes,</span></span></span><br><span class="line"><span class="params"><span class="function">  key?: unknown,</span></span></span><br><span class="line"><span class="params"><span class="function">  newValue?: unknown,</span></span></span><br><span class="line"><span class="params"><span class="function">  oldValue?: unknown,</span></span></span><br><span class="line"><span class="params"><span class="function">  oldTarget?: <span class="built_in">Map</span>&lt;unknown, unknown&gt; | <span class="built_in">Set</span>&lt;unknown&gt;</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// targetMap 存储了所有被追踪的对象，如果当前对象没有被追踪，直接返回</span></span><br><span class="line">  <span class="keyword">const</span> depsMap = targetMap.get(target)</span><br><span class="line">  <span class="keyword">if</span> (!depsMap) &#123;</span><br><span class="line">    <span class="comment">// never been tracked</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> effects = <span class="keyword">new</span> <span class="built_in">Set</span>&lt;ReactiveEffect&gt;()</span><br><span class="line">  <span class="keyword">const</span> computedRunners = <span class="keyword">new</span> <span class="built_in">Set</span>&lt;ReactiveEffect&gt;()</span><br><span class="line">  <span class="keyword">const</span> add = <span class="function">(<span class="params">effectsToAdd: <span class="built_in">Set</span>&lt;ReactiveEffect&gt; | <span class="literal">undefined</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (effectsToAdd) &#123;</span><br><span class="line">      effectsToAdd.forEach(<span class="function"><span class="params">effect</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (effect !== activeEffect || !shouldTrack) &#123;</span><br><span class="line">          <span class="keyword">if</span> (effect.options.computed) &#123;</span><br><span class="line">            computedRunners.add(effect)</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            effects.add(effect)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// the effect mutated its own dependency during its execution.</span></span><br><span class="line">          <span class="comment">// this can be caused by operations like foo.value++</span></span><br><span class="line">          <span class="comment">// do not trigger or we end in an infinite loop</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果当前触发类型为 CLEAR</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">type</span> === TriggerOpTypes.CLEAR) &#123;</span><br><span class="line">    <span class="comment">// collection being cleared</span></span><br><span class="line">    <span class="comment">// trigger all effects for target</span></span><br><span class="line">    depsMap.forEach(add)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key === <span class="string">&#x27;length&#x27;</span> &amp;&amp; isArray(target)) &#123;</span><br><span class="line">    depsMap.forEach(<span class="function">(<span class="params">dep, key</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (key === <span class="string">&#x27;length&#x27;</span> || key &gt;= (newValue <span class="keyword">as</span> <span class="built_in">number</span>)) &#123;</span><br><span class="line">        add(dep)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// schedule runs for SET | ADD | DELETE</span></span><br><span class="line">    <span class="keyword">if</span> (key !== <span class="built_in">void</span> <span class="number">0</span>) &#123;</span><br><span class="line">      add(depsMap.get(key))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// also run for iteration key on ADD | DELETE | Map.SET</span></span><br><span class="line">    <span class="keyword">const</span> isAddOrDelete =</span><br><span class="line">      <span class="keyword">type</span> === TriggerOpTypes.ADD ||</span><br><span class="line">      (<span class="keyword">type</span> === TriggerOpTypes.DELETE &amp;&amp; !isArray(target))</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      isAddOrDelete ||</span><br><span class="line">      (<span class="keyword">type</span> === TriggerOpTypes.SET &amp;&amp; target <span class="keyword">instanceof</span> <span class="built_in">Map</span>)</span><br><span class="line">    ) &#123;</span><br><span class="line">      add(depsMap.get(isArray(target) ? <span class="string">&#x27;length&#x27;</span> : ITERATE_KEY))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isAddOrDelete &amp;&amp; target <span class="keyword">instanceof</span> <span class="built_in">Map</span>) &#123;</span><br><span class="line">      add(depsMap.get(MAP_KEY_ITERATE_KEY))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> run = <span class="function">(<span class="params">effect: ReactiveEffect</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 在开发环境下，调试触发器</span></span><br><span class="line">    <span class="keyword">if</span> (__DEV__ &amp;&amp; effect.options.onTrigger) &#123;</span><br><span class="line">      effect.options.onTrigger(&#123;</span><br><span class="line">        effect,</span><br><span class="line">        target,</span><br><span class="line">        key,</span><br><span class="line">        <span class="keyword">type</span>,</span><br><span class="line">        newValue,</span><br><span class="line">        oldValue,</span><br><span class="line">        oldTarget</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (effect.options.scheduler) &#123;</span><br><span class="line">      effect.options.scheduler(effect)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      effect()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Important: computed effects must be run first so that computed getters</span></span><br><span class="line">  <span class="comment">// can be invalidated before any normal effects that depend on them are run.</span></span><br><span class="line">  computedRunners.forEach(run)</span><br><span class="line">  effects.forEach(run)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">track</span>(<span class="params">target: <span class="built_in">object</span>, <span class="keyword">type</span>: TrackOpTypes, key: unknown</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!shouldTrack || activeEffect === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> depsMap = targetMap.get(target)</span><br><span class="line">  <span class="keyword">if</span> (!depsMap) &#123;</span><br><span class="line">    targetMap.set(target, (depsMap = <span class="keyword">new</span> <span class="built_in">Map</span>()))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> dep = depsMap.get(key)</span><br><span class="line">  <span class="keyword">if</span> (!dep) &#123;</span><br><span class="line">    depsMap.set(key, (dep = <span class="keyword">new</span> <span class="built_in">Set</span>()))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!dep.has(activeEffect)) &#123;</span><br><span class="line">    dep.add(activeEffect)</span><br><span class="line">    activeEffect.deps.push(dep)</span><br><span class="line">    <span class="keyword">if</span> (__DEV__ &amp;&amp; activeEffect.options.onTrack) &#123;</span><br><span class="line">      activeEffect.options.onTrack(&#123;</span><br><span class="line">        <span class="attr">effect</span>: activeEffect,</span><br><span class="line">        target,</span><br><span class="line">        <span class="keyword">type</span>,</span><br><span class="line">        key</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2019-09-12T16:00:00.000Z" title="2019/9/13 00:00:00">2019-09-13</time>发表</span><span class="level-item"><a class="link-muted" href="/categories/Web/">Web</a></span><span class="level-item">39 分钟读完 (大约5790个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/09/13/typescript-tutorial/">TypeScript 概览</a></h1><div class="content"><h1 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h1><p>TypeScript 是 JavaScript 类型的超集，它可以编译成纯 JavaScript，可以在任何浏览器、任何计算机和任何操作系统上运行，并且是开源的。</p>
<h2 id="基础类型"><a href="#基础类型" class="headerlink" title="基础类型"></a>基础类型</h2><p>TypeScript 支持与 JavaScript 几乎相同的数据类型，此外还提供了方便使用的枚举类型。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// boolean</span></span><br><span class="line"><span class="keyword">let</span> isDone: <span class="built_in">boolean</span> = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">// number</span></span><br><span class="line"><span class="comment">// JavaScript 和 TypeScript 中的数字不是浮点类型 floating point 就是大整数类型 BigInteger</span></span><br><span class="line"><span class="keyword">let</span> decLiteral: <span class="built_in">number</span> = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">let</span> bigLiteral: <span class="built_in">number</span> = <span class="number">100n</span>;</span><br><span class="line"><span class="comment">// string</span></span><br><span class="line"><span class="keyword">let</span> name: <span class="built_in">string</span> = <span class="string">&#x27;bob&#x27;</span>;</span><br><span class="line"><span class="comment">// Array</span></span><br><span class="line"><span class="keyword">let</span> list: <span class="built_in">number</span>[] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> list: <span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="comment">// Tuple</span></span><br><span class="line"><span class="comment">// 元组类型要求值类型、顺序和个数一一对应</span></span><br><span class="line"><span class="keyword">let</span> tuple: [<span class="built_in">string</span>, <span class="built_in">string</span>] = [<span class="string">&#x27;string&#x27;</span>, <span class="string">&#x27;string&#x27;</span>];</span><br><span class="line"><span class="comment">// enum</span></span><br><span class="line"><span class="built_in">enum</span> Color &#123;Red = <span class="number">0</span>, Green, Blue&#125;</span><br><span class="line"><span class="keyword">let</span> c: Color = Color.Green;</span><br><span class="line"><span class="comment">// Any</span></span><br><span class="line"><span class="keyword">let</span> source: <span class="built_in">any</span> = <span class="number">4</span></span><br><span class="line"><span class="comment">// Void</span></span><br><span class="line"><span class="keyword">let</span> unusable: <span class="built_in">void</span> = <span class="literal">undefined</span>;</span><br><span class="line"><span class="comment">// Null &amp; Undefined</span></span><br><span class="line"><span class="keyword">let</span> u: <span class="literal">undefined</span> = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">let</span> n: <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="comment">// Never</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">error</span>(<span class="params">message: <span class="built_in">string</span></span>): <span class="title">never</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(message);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 类型断言</span></span><br><span class="line"><span class="comment">// 明确知道值的类型时可使用类型断言</span></span><br><span class="line"><span class="keyword">let</span> strValue: <span class="built_in">any</span> = <span class="string">&#x27;str&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> length: <span class="built_in">number</span> = (&lt;<span class="built_in">string</span>&gt;strValue).length;</span><br><span class="line"><span class="keyword">let</span> length: <span class="built_in">number</span> = (strValue <span class="keyword">as</span> <span class="built_in">string</span>).length</span><br></pre></td></tr></table></figure>



<h2 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h2><ul>
<li><p><code>var</code></p>
<p>可以通过 <code>var</code> 关键字定义变量，但是 <code>var</code> 声明可以在包含它的函数、模块、命名空间或全局作用域内部任何位置被访问，包含它的代码块对此没有影响，这可能会引发一些错误，比如多次声明同一个变量并不会报错。</p>
</li>
<li><p><code>let</code></p>
<p>当用 <code>let</code> 声明一个变量，它使用的是词法作用域或块作用域。不同于使用 <code>var</code> 声明的变量那样可以在包含它们的函数外访问，块作用域变量在包含它们的块之外是不能访问的。</p>
</li>
<li><p><code>const</code></p>
<p><code>const</code> 拥有与 <code>let</code> 相同的作用域规则，但是声明的变量被赋值后不能再改变。</p>
</li>
</ul>
<p>每次进入一个作用域时，它创建了一个变量的环境，就算作用域内代码已经执行完毕，这个环境与其捕获的变量依然存在。当 <code>let</code> 声明出现在循环体里时拥有完全不同的行为，不仅是在循环里引入了一个新的变量环境，而是针对每次迭代都会创建这样一个新作用域。</p>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p><strong>TypeScript 的核心原则之一是对值所具有的结构进行类型检查</strong>。 它有时被称做 “鸭式辨型法”或”结构性子类型化”。 在 TypeScript 里，接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约。</p>
<p>JavaScript 为开发者提供了非常大的灵活性：比如你可以为一个初始化为整数的变量赋值一个函数。但同时这种不确定性也会带来很多的麻烦，TypeScript 内置的接口就可以用来解决这个问题。 </p>
<p><em>接口帮助我们在赋值和传递参数时进行类型检查，确保我们给变量的赋值符合变量的类型或接收参数正确(接口在某种程度上表示了变量或函数对于赋值给它的值或传递给它的参数的一种期望和要求)。</em></p>
<h3 id="可选属性"><a href="#可选属性" class="headerlink" title="可选属性"></a>可选属性</h3><p>接口里的属性不全都是必需的，有些是只在某些条件下存在，或者根本不存在，可以为接口定义可选属性来实现这些需求。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> OptionAttribute &#123;</span><br><span class="line">    optionNum?: <span class="built_in">number</span>;</span><br><span class="line">    optionStr?: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可选属性的好处之一是可以对可能存在的属性进行预定义，好处之二是可以捕获引用了不存在的属性时的错误。 </p>
<h3 id="只读属性"><a href="#只读属性" class="headerlink" title="只读属性"></a>只读属性</h3><p>如果希望对象的某些属性只有在刚创建的时候修改其值，可以通过在属性名前用 readonly 来指定属性为只读属性。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> ReadonlyAttribute &#123;</span><br><span class="line">    <span class="keyword">readonly</span> num: <span class="built_in">number</span>;</span><br><span class="line">    <span class="keyword">readonly</span> str: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>TypeScript</code> 具有 <code>ReadonlyArray&lt;T&gt;</code> 类型，它与 <code>Array&lt;T&gt;</code> 类似，只是把所有可变方法去掉了，因此可以保证数组创建后再也不能被修改。</p>
<blockquote>
<p><strong>readonly</strong> vs <strong>const</strong></p>
<p>使用 <code>const</code> 来修饰变量，使用 <code>readonly</code> 来修饰属性</p>
</blockquote>
<h3 id="额外的类型检查"><a href="#额外的类型检查" class="headerlink" title="额外的类型检查"></a>额外的类型检查</h3><p>在 <code>TypeScript</code> 中，对象字面量赋值给变量或作为参数进行传递的时候，会经过 “额外属性检查”，如果一个对象字面量存在任何 “目标类型” 不包含的属性时，会发生错误。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> SquareConfig &#123; </span><br><span class="line">  <span class="attr">width</span>: <span class="built_in">number</span>;</span><br><span class="line">  color?: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createSquare</span>(<span class="params">config: SquareConfig</span>): </span>&#123; color: <span class="built_in">string</span>, <span class="attr">area</span>: <span class="built_in">number</span> &#125; &#123;</span><br><span class="line">  <span class="keyword">let</span> newSquare = &#123; <span class="attr">color</span>: <span class="string">&#x27;blue&#x27;</span>, <span class="attr">area</span>: <span class="number">0</span> &#125;;</span><br><span class="line">  <span class="keyword">if</span> (config.width) newSquare.area = config.width * config.width;</span><br><span class="line">  <span class="keyword">if</span> (config.color) newSquare.color = config.color;</span><br><span class="line">  <span class="keyword">return</span> newSquare;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// error: height not expected in type SquareConfig</span></span><br><span class="line"><span class="keyword">let</span> mySquare = createSquare(&#123; <span class="attr">color</span>: <span class="string">&#x27;green&#x27;</span>, <span class="attr">width</span>: <span class="number">10</span>, <span class="attr">height</span>: <span class="number">10</span> &#125;);</span><br></pre></td></tr></table></figure>

<p>使用 ‘类型断言’ 可以绕开额外属性检查</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mySquare = createSquare(&#123; <span class="attr">color</span>: <span class="string">&#x27;green&#x27;</span>, <span class="attr">width</span>: <span class="number">10</span>, <span class="attr">height</span>: <span class="number">10</span> &#125; <span class="keyword">as</span> SquareConfig);</span><br></pre></td></tr></table></figure>

<p>但是更好的做法是在接口中提供一个字符串索引签名</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> SquareConfig &#123; </span><br><span class="line">  <span class="attr">width</span>: <span class="built_in">number</span>;</span><br><span class="line">  color?: <span class="built_in">string</span>;</span><br><span class="line">  [propName: <span class="built_in">string</span>]: <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h3><p>接口能够描述 <code>JavaScript</code> 中对象拥有的各种各样的外形。 除了描述带有属性的普通对象外，接口也可以描述函数类型。</p>
<p>为了使用接口表示函数类型，我们需要给接口定义一个调用签名。 它就像是一个只有参数列表和返回值类型的函数定义。</p>
<p>参数列表里的每个参数都需要名字和类型。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> TypeFunc &#123;</span><br><span class="line">    (source: <span class="built_in">string</span>, <span class="attr">subString</span>: <span class="built_in">string</span>): <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样定义后，我们可以像使用其它接口一样使用这个函数类型的接口。 下例展示了如何创建一个函数类型的变量，并将一个同类型的函数赋值给这个变量。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mySearchFunc: TypeFunc;</span><br><span class="line">mySearchFunc = <span class="function"><span class="keyword">function</span>(<span class="params">source: <span class="built_in">string</span>, subString: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = source.search(subString);</span><br><span class="line">    <span class="keyword">return</span> result &gt; -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于函数类型的类型检查来说，函数的参数名不需要与接口定义里的名字相匹配。</p>
<p>函数的参数会逐个进行检查，要求对应位置上的参数类型是兼容的。如果没有指定类型，<code>TypeScript</code> 的类型系统会推断出参数类型，而函数的返回值类型是通过其返回值推断出来的。</p>
<h3 id="可索引的类型"><a href="#可索引的类型" class="headerlink" title="可索引的类型"></a>可索引的类型</h3><p>与使用接口描述函数类型差不多，我们也可以描述那些能够通过索引得到的类型。可索引类型具有一个索引签名，它描述了对象索引的类型，还有相应的索引返回值类型。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 表明了当用 number 去索引 StringArr 时会得到 string 类型的返回值</span></span><br><span class="line"><span class="keyword">interface</span> StringArr &#123;</span><br><span class="line">    [index: <span class="built_in">number</span>]: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myArr: StringArr;</span><br><span class="line">myArr = [<span class="string">&quot;A&quot;</span>,<span class="string">&quot;B&quot;</span>];</span><br><span class="line"><span class="keyword">let</span> myStr: <span class="built_in">string</span> = myArr[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>

<p>索引签名共有两种类型：字符串和数字。可以同时使用这两种类型的索引，但是数字索引的返回值必须是字符串索引返回值类型的子类型。这是因为当使用 <code>number</code> 来索引时，<code>TypeScript</code> 会将它转换为 <code>string</code> 然后再去索引对象。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> StringArray &#123; </span><br><span class="line">  [index: <span class="built_in">string</span>]: <span class="built_in">string</span>;</span><br><span class="line">  [index: <span class="built_in">number</span>]: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一般将索引签名设置为只读，这样可以防止给索引赋值。</p>
<h3 id="类类型"><a href="#类类型" class="headerlink" title="类类型"></a>类类型</h3><p><code>TypeScript</code> 中的接口也能够用来明确的强制一个类去符合某种协议/契约。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> ClockInterface &#123;</span><br><span class="line">    <span class="attr">currentTime</span>: <span class="built_in">Date</span>;</span><br><span class="line">    setTime:(d: <span class="built_in">Date</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="title">implements</span> <span class="title">ClockInterface</span> </span>&#123;</span><br><span class="line">    <span class="attr">currentTime</span>: <span class="built_in">Date</span>;</span><br><span class="line">    setTime:(d: <span class="built_in">Date</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.currentTime = d;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">h: <span class="built_in">number</span>, m: <span class="built_in">number</span></span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口描述了类的公共部分，而不是公共和私有两部分，它不会帮你检查类是否具有某些私有成员。</p>
<h3 id="类静态部分与实例部分的区别"><a href="#类静态部分与实例部分的区别" class="headerlink" title="类静态部分与实例部分的区别"></a>类静态部分与实例部分的区别</h3><p>类具有两个类型 ：静态部分的类型和实例的类型。</p>
<p>当一个类实现了一个接口时，只对其实例部分进行类型检查。<code>constructor</code> 存在于类的静态部分，不在检查范围内。因此我们应该直接操作类的静态部分。</p>
<blockquote>
<p>可以认为类的静态部分指的是类本身，实例部分指的是类实例化出来的对象。</p>
</blockquote>
<h3 id="继承接口"><a href="#继承接口" class="headerlink" title="继承接口"></a>继承接口</h3><p>和类一样，接口也可以相互继承。这让我们能够从一个接口里复制成员到另一个接口里，可以更灵活地将接口分割到可重用的模块里。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Father &#123;</span><br><span class="line">    <span class="attr">familyName</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Son <span class="keyword">extends</span> Father &#123;</span><br><span class="line">    <span class="attr">givenName</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> aPerson = &lt;Son&gt;&#123;&#125;;</span><br><span class="line">aPerson.familyName = <span class="string">&#x27;S&#x27;</span>;</span><br><span class="line">aPerson.givenName = <span class="string">&#x27;T&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>一个接口可以继承多个接口，创建出多个接口的合成接口。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Shape &#123;</span><br><span class="line">  <span class="attr">color</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Stroke &#123;</span><br><span class="line">  <span class="attr">penWidth</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Square <span class="keyword">extends</span> Shape, Stroke &#123;</span><br><span class="line">  <span class="attr">width</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="混合类型"><a href="#混合类型" class="headerlink" title="混合类型"></a>混合类型</h3><p>接口能够描述 <code>JavaScript</code> 中丰富的类型，可以使用 混合类型 来使某个对象具有多个类型。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Counter &#123;</span><br><span class="line">  (start: <span class="built_in">number</span>): <span class="built_in">number</span>;</span><br><span class="line">	interval: <span class="built_in">number</span>;</span><br><span class="line">	reset(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCounter</span>(<span class="params"></span>): <span class="title">Counter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> counter = &lt;Counter&gt;<span class="function"><span class="keyword">function</span> (<span class="params">start: <span class="built_in">number</span></span>) </span>&#123;&#125;;</span><br><span class="line">  counter.interval = <span class="number">1</span>;</span><br><span class="line">  counter.reset = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">  <span class="keyword">return</span> counter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = getCounter();</span><br><span class="line">c(<span class="number">10</span>);</span><br><span class="line">c.reset();</span><br><span class="line">c.interval = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>



<h3 id="接口继承类"><a href="#接口继承类" class="headerlink" title="接口继承类"></a>接口继承类</h3><p>当接口继承了一个类类型时，它会继承类的成员但不继承其实现。就好像接口声明了所有类中存在的成员，但没有提供具体实现一样。接口同样会继承到类的 <code>private</code> 和 <code>protected</code> 成员。这意味着当你创建了一个接口继承了一个拥有私有或受保护的成员的类时，这个接口类型只能被这个类或其子类所实现。</p>
<p>当你有一个庞大的继承结构时这很有用，但要指出的是你的代码只在子类拥有特定的属性时起作用。</p>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>从 <code>ECMAScript 2015</code> , 也就是 <code>ECMAScript 6</code> 开始， <code>JavaScript</code> 中也能使用基于类的面向对象的方式。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="attr">familyName</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">familyName: <span class="built_in">string</span>, givenName: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.familyName = familyName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">say</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Hello, my name is &#x27;</span> + <span class="built_in">this</span>.familyName + <span class="string">&#x27; &#x27;</span> + <span class="built_in">this</span>.givenName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">move</span>(<span class="params">distanceInMeters = <span class="number">0</span></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;$&#123;this.name&#125; moved $&#123;distanceInMeters&#125;m.&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建类实例</span></span><br><span class="line">lei aPerson = <span class="keyword">new</span> Person(<span class="string">&#x27;Wang&#x27;</span>, <span class="string">&#x27;XiaoHong&#x27;</span>, <span class="number">22</span>);</span><br></pre></td></tr></table></figure>

<p>在引用任何一个类的成员时都需要使用 <code>this</code> ，它表示我们访问的是类的成员。</p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>在 <code>TypeScript</code> 中允许使用继承来扩展现有的类。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">familyName: <span class="built_in">string</span>, givenName: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(familyName, givenName, age);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">move</span>(<span class="params">distanceInMeters = <span class="number">5</span></span>)</span> &#123;</span><br><span class="line">			<span class="built_in">super</span>.move(distanceInMeters);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果子类包含了构造函数，它必须调用 <code>super()</code> ，它会执行基类的构造函数。在构造函数中访问 <code>this</code> 的属性之前，一定要先调用 <code>super()</code> 。</p>
<p>子类从父类中继承属性和方法</p>
<h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><ul>
<li><p><code>public</code></p>
<p><code>public</code> 是 <code>TypeScript</code> 中类成员的默认属性</p>
</li>
<li><p><code>private</code></p>
<p>类成员声明为 <code>private</code> 时，不能在生声明它的类的外部访问</p>
</li>
<li><p><code>protected</code></p>
<p>类成员声明为 <code>protected</code> 时，在派生类中仍可访问</p>
<p>构造函数也能被标记为 <code>protected</code> ，这意味着它不能在包含它的类外被实例化，但是能被继承</p>
</li>
<li><p><code>readonly</code></p>
<p>通过 <code>readonly</code> 属性将属性设置为只读，只读属性必须在声明时或构造函数里被初始化</p>
</li>
</ul>
<h4 id="参数属性"><a href="#参数属性" class="headerlink" title="参数属性"></a>参数属性</h4><p>参数属性通过给构造函数参数前添加一个访问限定符来声明。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"><span class="keyword">public</span> familyName: <span class="built_in">string</span>, <span class="keyword">public</span> givenName: <span class="built_in">string</span>, <span class="keyword">public</span> age: <span class="built_in">number</span></span>)</span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过这个特性我们可以方便的在一个地方定义并初始化一个成员。</p>
<h3 id="存取器"><a href="#存取器" class="headerlink" title="存取器"></a>存取器</h3><p><code>TypeScript</code> 支持通过 <code>getters/setters</code> 来截取对对象成员的访问，它们可以有效的控制对对象成员的访问。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">student</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> _familyName: <span class="built_in">string</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">get</span> <span class="title">familyName</span>(): <span class="title">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._familyNmae;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">set</span> <span class="title">familyName</span>(<span class="params">fName: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">		<span class="built_in">this</span>._familyName = fName;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，存取器只支持 <code>ECMAScript 5</code> 或更高，其次，只带有 <code>getter</code> 存取器被推断为 <code>readonly</code>。</p>
<h3 id="静态属性"><a href="#静态属性" class="headerlink" title="静态属性"></a>静态属性</h3><p>类的实例成员是那些仅当类被实例化时才会被初始化的属性，而类的静态成员存在于类本身上面而不是类的实例上。实例想要访问静态属性时，需要在其加上类名。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">student</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> school = <span class="string">&#x27;ts&#x27;</span>;</span><br><span class="line">  ...</span><br><span class="line">  <span class="function"><span class="title">getStudentSchool</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> student.school;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>抽象类一般作为其它派生类的基类使用，一般不会被实例化。不同于接口，抽象类可以包含成员的实现细节。</p>
<p>使用 <code>abstract</code> 关键字定义抽象类和在抽象类中定义抽象方法。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">  <span class="keyword">abstract</span> function_name: return_type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>抽象类中的抽象方法不包含具体实现并且必须在派生类中实现。</p>
<p>抽象方法的语法与接口语法相似，两者都是定义方法签名但不包含方法体。然而，抽象方法必须包含 <code>abstract</code> 关键字并且可以包含访问修饰符。</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>函数是 <code>JavaScript</code> 应用程序的基础。 它帮助你实现抽象层，模拟类，信息隐藏和模块。 在 <code>TypeScript</code> 里，虽然已经支持类，命名空间和模块，但函数仍然是主要的定义行为的地方。 <code>TypeScript</code> 为 <code>JavaScript</code> 函数添加了额外的功能，让我们可以更容易地使用。</p>
<h3 id="函数类型-1"><a href="#函数类型-1" class="headerlink" title="函数类型"></a>函数类型</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params">arg_1: arg_type, arg_2: arg_type, ...</span>): <span class="title">return_type</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>TypeScript</code> 能够通过返回语句自动推断出返回值类型，因此函数返回类型一般是省略的。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fun_var_name: <span class="function">(<span class="params">arg_1: arg_type, arg_2: arg_type, ...</span>) =&gt;</span> return_type;</span><br></pre></td></tr></table></figure>

<p>函数类型包括两部分，参数类型和返回值类型。而且只要参数类型是匹配的，就认为它是有效的函数类型，而不在乎参数名是否准确。</p>
<h3 id="可选参数和默认参数"><a href="#可选参数和默认参数" class="headerlink" title="可选参数和默认参数"></a>可选参数和默认参数</h3><p><code>JavaScript</code> 中函数的每个参数都是可选的，可传可不传，没有传参的时候它的值就是 <code>undefined</code>。而 <code>TypeScript</code> 中函数的每个参数默认情况下都是必须的，编译器检查用户是否为每个参数都传入了值，还会假设只有这些参数被传递进函数-即传递给一个函数的参数个数必须与函数期望的参数个数一致。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myAdd: <span class="function">(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span> = <span class="function"><span class="keyword">function</span> (<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) </span>&#123; </span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sum = myAdd(<span class="number">1</span>); <span class="comment">// error: Expected 2 arugements, but got 1</span></span><br><span class="line"><span class="keyword">const</span> sum1 = myAdd(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// error: Expected 2 arugements, but got 3</span></span><br></pre></td></tr></table></figure>

<p>在 <code>TypeScript</code> 中，可以在参数名称旁使用 <code>?</code> 实现可选参数的功能。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可选参数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildStudent</span>(<span class="params">name: <span class="built_in">string</span>, grade: <span class="built_in">number</span>, gender?: <span class="built_in">string</span></span>) </span>&#123; </span><br><span class="line">  <span class="keyword">return</span> name + <span class="string">&#x27; &#x27;</span> + grade + <span class="string">&#x27; &#x27;</span> + (gender ? gender : <span class="string">&#x27;&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> student_1 = buildStudent(<span class="string">&#x27;Tom&#x27;</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">const</span> student_2 = buildStudent(<span class="string">&#x27;Jerry&#x27;</span>, <span class="number">2</span>, <span class="string">&#x27;male&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>需要注意的是，可选参数必须跟在可选参数后面。</p>
<p>在 <code>TypeScript</code> 中，当用户没有传递这个参数或传递的值是 <code>undefined</code> 时，我们可以为参数提供一个默认值。在所有必须参数后面的带默认初始化的参数都是可选的，与可选参数一样，在调用函数的时候可以省略-即可选参数与末尾的默认参数共享参数类型。</p>
<p>需要注意的是，如果带默认值的参数出现在必须参数之前，用户必须明确的传入 <code>undefined</code> 值来获得默认值。</p>
<h3 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a>剩余参数</h3><p>如果你想同时操作多个参数或不知道会有多少个参数传递进来，在 <code>JavaScript</code> 中，你可以通过 <code>arguments</code> 来访问所有传入的参数，在 <code>TypeScript</code> 中，你则可以将所有参数收集到一个变量里。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 剩余参数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildChildren</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span>, ...restOfProperty: <span class="built_in">string</span>[]</span>) </span>&#123; </span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;name&#125;</span> <span class="subst">$&#123;age&#125;</span> <span class="subst">$&#123;restOfProperty.join(<span class="string">&#x27; &#x27;</span>)&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> children = buildChildren(<span class="string">&#x27;Mike&#x27;</span>, <span class="number">12</span>, <span class="string">&#x27;male&#x27;</span>, <span class="string">&#x27;grade 3&#x27;</span>);</span><br></pre></td></tr></table></figure>



<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>泛型是程序设计语言的一种特性，是程序员在编写代码时定义的一些可变部分，这些部分在使用前必须做出指明。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类型变量 T 会捕获用户传入的类型，之后我们就可以使用者个类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123; </span><br><span class="line">  <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> strId = identity(<span class="string">&#x27;JavaScript&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> numId = identity(<span class="number">12</span>);</span><br></pre></td></tr></table></figure>



<h3 id="泛型变量"><a href="#泛型变量" class="headerlink" title="泛型变量"></a>泛型变量</h3><p>使用泛型函数时，编译器要求你在函数体必须正确的使用这个通用的类型-即你必须把这些参数当做是任意或所有类型。</p>
<h3 id="泛型函数"><a href="#泛型函数" class="headerlink" title="泛型函数"></a>泛型函数</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">combineFunc</span>&lt;<span class="title">T</span>,<span class="title">K</span>&gt;(<span class="params">x: T, y: K</span>): [<span class="title">T</span>, <span class="title">K</span>] </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [T, K];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> combine: &lt;T,K&gt;(x: T, y: K) =&gt; [T,K] = combineFunc;</span><br><span class="line">// or</span><br><span class="line">let combine: &#123; &lt;T,K&gt;(x: T, y: K): [T, K] &#125; = combineFunc;</span><br></pre></td></tr></table></figure>



<h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> CombineFunc &#123;</span><br><span class="line">  &lt;T,K&gt;(x: T, <span class="attr">y</span>: K): [T, K];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> combine: CombineFunc = <span class="function">(<span class="params">x, y</span>) =&gt;</span> [x, y];</span><br></pre></td></tr></table></figure>



<h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CombineFunC</span> </span>&#123;</span><br><span class="line">  <span class="attr">combine</span>: &lt;T,K&gt;(x: T, y: K) =&gt; [T, K];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let combineC: CombineFunC = new CombineFunC&lt;number, number&gt;();</span><br><span class="line">combineC.combine = (x, y) =&gt; [x, y];</span><br></pre></td></tr></table></figure>





<h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>使用枚举可以定义一些带名字的常量，清晰的表达意图或创建一组有区别的用例。<code>TypeScript</code> 支持数字的和基于字符串的枚举。</p>
<h3 id="数字枚举"><a href="#数字枚举" class="headerlink" title="数字枚举"></a>数字枚举</h3><p>数字枚举默认的枚举值是从 0 开始自增长的，如果你为第一个枚举名字指定了一个数字枚举值，则会从这个数字值开始自增长。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">enum</span> Status &#123;</span><br><span class="line">  DELETED = -<span class="number">1</span>,</span><br><span class="line">  VALID,</span><br><span class="line">  UNPAID,</span><br><span class="line">  PAID</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="字符串枚举"><a href="#字符串枚举" class="headerlink" title="字符串枚举"></a>字符串枚举</h3><p>字符串枚举中，每个成员都需要使用字符串字面量或另外一个字符串枚举成员进行初始化。</p>
<p>需要注意的是，字符串枚举没有自增长行为。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">enum</span> StatusTip &#123;</span><br><span class="line">  DELETED = <span class="string">&#x27;Order has been deleted.&#x27;</span>,</span><br><span class="line">  VALID = <span class="string">&#x27;Order is valid.&#x27;</span>,</span><br><span class="line">  UNPAID = <span class="string">&#x27;Order is unpaid.&#x27;</span>,</span><br><span class="line">  PAID = <span class="string">&#x27;Order is paid&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="异构枚举"><a href="#异构枚举" class="headerlink" title="异构枚举"></a>异构枚举</h3><p>枚举可以混合字符串和数字成员。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">enum</span> HeterogeneousEnum &#123;</span><br><span class="line">  NO = <span class="number">0</span>,</span><br><span class="line">  YES = <span class="string">&#x27;Yes&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="计算的和常量成员"><a href="#计算的和常量成员" class="headerlink" title="计算的和常量成员"></a>计算的和常量成员</h3><p>每个枚举成员都带有一个值，它可以是常量或计算出来的。当满足如下条件时，枚举成员被当做常量：</p>
<ul>
<li><p>它是枚举的第一个成员，且没有初始化器，此时它的值为 0</p>
</li>
<li><p>它不带有初始化器且它之前的枚举成员是一个数字常量，此时它的值为上一个枚举成员的值 + 1</p>
</li>
<li><p>枚举成员使用常量枚举表达式初始化。常量枚举表达式是 <code>TypeScript</code> 表达式的子集，它可以在编译阶段求值。当一个表达式满足以下条件时，它就是一个常量枚举表达式：</p>
<ul>
<li><p>一个枚举表达式字面量</p>
</li>
<li><p>一个对之前定义的常量枚举成员的引用</p>
</li>
<li><p>带括号的常量枚举表达式</p>
</li>
<li><p>一元运算符 <code>+ - ~</code> 其中之一应用在了常量枚举表达式</p>
</li>
<li><p>常量枚举表达式作为二元运算符 <code>+, -, *, /, %, &lt;&lt;, &gt;&gt;, &gt;&gt;&gt;, &amp;, |, ^</code> 的操作对象(若常量枚举表达式求值后为 <code>NaN</code> 或 <code>Infinity</code>，则会在编译时报错)</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">enum</span> FileAccess &#123;</span><br><span class="line">  None,</span><br><span class="line">  Read = <span class="number">1</span> &lt;&lt; <span class="number">1</span>,</span><br><span class="line">  Write = <span class="number">1</span> &lt;&lt; <span class="number">2</span>,</span><br><span class="line">  ReadWrite = Read | Write,</span><br><span class="line">  G = <span class="string">&#x27;1024&#x27;</span>.length</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ul>
<h3 id="联合枚举与枚举成员的类型"><a href="#联合枚举与枚举成员的类型" class="headerlink" title="联合枚举与枚举成员的类型"></a>联合枚举与枚举成员的类型</h3><p>存在一种特殊的非计算的常量枚举成员的子集：字面量枚举成员。字面量枚举成员是指不带有初始值的常量枚举成员或是被初始化为</p>
<ul>
<li>任何字符串字面量</li>
<li>任何数字字面量</li>
<li>应用了一元 <code>-</code> 符号的数字字面量</li>
</ul>
<p>当所有枚举成员都拥有字面量枚举值时，它就带有了一种特殊的语义。</p>
<h3 id="运行时枚举"><a href="#运行时枚举" class="headerlink" title="运行时枚举"></a>运行时枚举</h3><p>枚举是在运行时真正存在的对象</p>
<h3 id="反向映射"><a href="#反向映射" class="headerlink" title="反向映射"></a>反向映射</h3><p>数字枚举成员具有从枚举值到枚举名字的反向映射。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">enum</span> Status &#123;</span><br><span class="line">  DELETED = -<span class="number">1</span>,</span><br><span class="line">  VALID,</span><br><span class="line">  UNPAID,</span><br><span class="line">  PAID</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Status[<span class="number">0</span>]); <span class="comment">// VALID</span></span><br></pre></td></tr></table></figure>



<h3 id="const-枚举"><a href="#const-枚举" class="headerlink" title="const 枚举"></a><code>const</code> 枚举</h3><p>常量枚举只能使用常量枚举表达式，并且不同于常规的枚举，它们在编译阶段会被删除-常量枚举成员会在使用的地方被内联进来，这是因为常量枚举不允许包含计算成员。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">enum</span> Directions &#123;</span><br><span class="line">  Up,</span><br><span class="line">  Down,</span><br><span class="line">  Left,</span><br><span class="line">  Right</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> directions = [ Directions.Up, Directions.Down, Directions.Left, Directions.Right ];</span><br></pre></td></tr></table></figure>



<h2 id="类型推论"><a href="#类型推论" class="headerlink" title="类型推论"></a>类型推论</h2><p>类型推论是指能够在编译期间自动推导出值的类型的能力。一般发生在初始化变量和成员，设置默认参数值和决定函数返回值时。</p>
<h3 id="最佳通用类型"><a href="#最佳通用类型" class="headerlink" title="最佳通用类型"></a>最佳通用类型</h3><p>当需要从几个表达式中推断类型时，会使用这几个表达式的类型来推断出一个最合适的通用类型。</p>
<h3 id="上下文类型"><a href="#上下文类型" class="headerlink" title="上下文类型"></a>上下文类型</h3><p>当表达式的类型与所处的位置相关时，类型推论按照上下文归类来推论类型。当然，如果表达式包含了明确的类型信息，上下文的类型会被忽略。</p>
<h2 id="类型兼容性"><a href="#类型兼容性" class="headerlink" title="类型兼容性"></a>类型兼容性</h2><p><code>TypeScript</code> 中的类型兼容性是基于结构子类型的-结构子类型是一种只使用其成员来描述类型的方式。</p>
<h3 id="原始类型和对象类型的兼容性"><a href="#原始类型和对象类型的兼容性" class="headerlink" title="原始类型和对象类型的兼容性"></a>原始类型和对象类型的兼容性</h3><p>如果 x 要兼容 y， 那么 y 至少需要具有与 x 相同的属性。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果 x 要兼容 y， y 至少要与 x 拥有相同的属性</span></span><br><span class="line"><span class="keyword">let</span> x = &#123; <span class="attr">name</span>: <span class="string">&#x27;x&#x27;</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> y = &#123; <span class="attr">name</span>: <span class="string">&#x27;y&#x27;</span>, <span class="attr">alias</span>: <span class="string">&#x27;Y&#x27;</span> &#125;;</span><br><span class="line">x = y;</span><br><span class="line">y = x; <span class="comment">// Property &#x27;alias&#x27; is missing in type &#x27;&#123; name: string; &#125;&#x27; but required in type &#x27;&#123; name: string; alias: string; &#125;</span></span><br></pre></td></tr></table></figure>



<h3 id="函数的类型兼容性"><a href="#函数的类型兼容性" class="headerlink" title="函数的类型兼容性"></a>函数的类型兼容性</h3><p>如果函数 x 要兼容函数 y，那么 x 至少要与 y 具有相同的参数并且返回值类型相同。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> funCom = <span class="function">(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) =&gt;</span> x + y;</span><br><span class="line"><span class="keyword">let</span> funAbc = <span class="function">(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) =&gt;</span> [x, y];</span><br><span class="line"><span class="keyword">let</span> funSub = <span class="function">(<span class="params">x: <span class="built_in">number</span></span>) =&gt;</span> x;</span><br><span class="line"><span class="keyword">let</span> funDef = <span class="function">(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) =&gt;</span> x * y;</span><br><span class="line">funCom = funSub;</span><br><span class="line">funSub = funCom; <span class="comment">// Type &#x27;(x: number, y: number) =&gt; number&#x27; is not assignable to type &#x27;(x: number) =&gt; number&#x27;</span></span><br><span class="line">funCom = funAbc; <span class="comment">// Type &#x27;(x: number, y: number) =&gt; number[]&#x27; is not assignable to type &#x27;(x: number, y: number) =&gt; number&#x27;.Type &#x27;number[]&#x27; is not assignable to type &#x27;number&#x27;</span></span><br><span class="line">funCom = funDef;</span><br></pre></td></tr></table></figure>



<h3 id="类的兼容性"><a href="#类的兼容性" class="headerlink" title="类的兼容性"></a>类的兼容性</h3><p>比较两个类类型的对象时，只有实例的成员会被比较。 静态成员和构造函数不在比较的范围内。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">W</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> sign: <span class="built_in">string</span> = <span class="string">&#x27;AAAAA&#x27;</span>;</span><br><span class="line">  pro: <span class="built_in">string</span> = <span class="string">&#x27;W&#x27;</span>;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Y</span> </span>&#123;</span><br><span class="line">  <span class="attr">pro</span>: <span class="built_in">string</span> = <span class="string">&#x27;W&#x27;</span>;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">length: <span class="built_in">number</span></span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> wC = <span class="keyword">new</span> W(<span class="string">&#x27;W&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> yC = <span class="keyword">new</span> Y(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">wC = yC; <span class="comment">// OK</span></span><br><span class="line">yC = wC; <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>

<p>类的私有成员和受保护成员会影响兼容性。 当检查类实例的兼容时，如果目标类型包含一个私有成员，那么源类型必须包含来自同一个类的这个私有成员。 同样地，这条规则也适用于包含受保护成员实例的类型检查。 这允许子类赋值给父类，但是不能赋值给其它有同样类型的类。</p>
<h3 id="泛型的兼容性"><a href="#泛型的兼容性" class="headerlink" title="泛型的兼容性"></a>泛型的兼容性</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> NotEmpty&lt;T&gt; &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> gA: NotEmpty&lt;<span class="built_in">number</span>&gt;;</span><br><span class="line"><span class="keyword">let</span> gB: NotEmpty&lt;<span class="built_in">string</span>&gt;;</span><br><span class="line">gA = gB; <span class="comment">// ok</span></span><br></pre></td></tr></table></figure>



<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> NotEmpty&lt;T&gt; &#123;</span><br><span class="line">  <span class="attr">data</span>: T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> gA: NotEmpty&lt;<span class="built_in">number</span>&gt;;</span><br><span class="line"><span class="keyword">let</span> gB: NotEmpty&lt;<span class="built_in">string</span>&gt;;</span><br><span class="line">gA = gB; <span class="comment">// Error</span></span><br></pre></td></tr></table></figure>



<h2 id="高级类型"><a href="#高级类型" class="headerlink" title="高级类型"></a>高级类型</h2><h3 id="交叉类型"><a href="#交叉类型" class="headerlink" title="交叉类型"></a>交叉类型</h3><p>交叉类型是将多个类型合并为一个类型。 这让我们可以把现有的多种类型叠加到一起成为一种类型，它包含了所需的所有类型的特性。</p>
<h3 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h3><p>联合类型表示一个值可以是几种类型之一。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/ 联合类型</span><br><span class="line"><span class="comment">// 联合类型表示一个值可以是几个类型之一</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pad</span>(<span class="params">padding: <span class="built_in">number</span> | <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> padding;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(pad(<span class="number">1</span>));</span><br><span class="line"><span class="built_in">console</span>.log(pad(<span class="string">&#x27;A&#x27;</span>));</span><br></pre></td></tr></table></figure>

<p>如果一个值是联合类型，我们只能访问联合类型所有类型里共有的成员</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Elephant &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  walk();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Shark &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  swim();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAnimal</span>(<span class="params"></span>): <span class="title">Elephant</span> | <span class="title">Shark</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">name</span>: <span class="string">&#x27;Elephant&#x27;</span>, <span class="function"><span class="title">walk</span>(<span class="params"></span>)</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;walk&#x27;</span>) &#125; &#125; <span class="keyword">as</span> Elephant;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> aAnimal = getAnimal();</span><br><span class="line"><span class="built_in">console</span>.log(aAnimal.name);</span><br><span class="line">aAnimal.walk();</span><br><span class="line">aAnimal.swim();</span><br></pre></td></tr></table></figure>



</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2019-06-25T16:00:00.000Z" title="2019/6/26 00:00:00">2019-06-26</time>发表</span><span class="level-item"><a class="link-muted" href="/categories/JavaScript/">JavaScript</a></span><span class="level-item">4 分钟读完 (大约567个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/06/26/JavaScript%20%E6%93%8D%E4%BD%9C%E7%AC%A6/">JavaScript 操作符</a></h1><div class="content"><h2 id="位操作符"><a href="#位操作符" class="headerlink" title="位操作符"></a>位操作符</h2><p>ECMAScript 中的所有数值都以 IEEE 754 64 位格式存储，但位操作并不直接应用到 64 位表示，而是先把值转换为 32 位整数，再进行位操作，之后再把结果转换为 64 位。对开发者而言，就好像只有 32 位整数一样，因 为 64 位整数存储格式是不可见的。这让二进制操作变得与其他语言中类似。但这个转换也导致了一个奇特的副作用，即特殊值 <code>NaN</code> 和 <code>Infinity</code> 在位操作中都会被当成 0 处理。</p>
<p>有符号整数使用 32 位的前 31 位表示整数值。第 32 位表示数值的符号，如 0 表示正，1 表示负。这 一位称为符号位（sign bit），它的值决定了数值其余部分的格式。正值以真正的二进制格式存储，即 31 位中的每一位都代表 2 的幂。第一位（称为第 0 位）表示 20 ，第二位表示 21 ，依此类推。如果一个位是空的，则以 0填充，相当于忽略不计。</p>
<p>负值以一种称为二补数（或补码）的二进制编码存储。一个数值的二补数通过如下 3 个步骤计算 得到：</p>
<ol>
<li><p>确定绝对值的二进制表示</p>
</li>
<li><p>找到数值的一补数（或反码），换句话说，就是每个 0 都变成 1，每个 1 都变成 0</p>
</li>
<li><p>给结果加 1</p>
</li>
</ol>
<p>默认情况下，ECMAScript 中的所有整数都表示为有符号数。不过，确实存在无符号整数。对无符号整数来说，第 32 位不表示符号，因为只有正值。无符号整数比有符号整数的范围更大，因为符号位被用来表示数值了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span> &lt;&lt; <span class="number">10</span>); <span class="comment">// 1024</span></span><br><span class="line"><span class="built_in">console</span>.log(-<span class="number">1</span> &lt;&lt; <span class="number">10</span>); <span class="comment">// -1024</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1024</span> &gt;&gt; <span class="number">10</span>); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(-<span class="number">1024</span> &gt;&gt; <span class="number">10</span>); <span class="comment">// -1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1024</span> &gt;&gt;&gt; <span class="number">10</span>); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(-<span class="number">1024</span> &gt;&gt;&gt; <span class="number">10</span>); <span class="comment">// 4194303</span></span><br></pre></td></tr></table></figure>



<h2 id="相等操作符"><a href="#相等操作符" class="headerlink" title="相等操作符"></a>相等操作符</h2><p>全等和不全等操作符与相等和不相等操作符类似，只不过它们在比较相等时不转换操作数。全等操 作符由 3 个等于号（===）表示，只有两个操作数在不转换的前提下相等才返回 <code>true</code>。</p>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/">上一页</a></div><div class="pagination-next"><a href="/page/3/">下一页</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/">1</a></li><li><a class="pagination-link is-current" href="/page/2/">2</a></li><li><a class="pagination-link" href="/page/3/">3</a></li><li><span class="pagination-ellipsis">&hellip;</span></li><li><a class="pagination-link" href="/page/11/">11</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="LeiTech"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">LeiTech</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>China</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">54</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">10</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">4</p></a></div></div></nav><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="/"><i class="fab fa-github"></i></a></div></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2021/05/"><span class="level-start"><span class="level-item">五月 2021</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/01/"><span class="level-start"><span class="level-item">一月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/12/"><span class="level-start"><span class="level-item">十二月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/06/"><span class="level-start"><span class="level-item">六月 2020</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/09/"><span class="level-start"><span class="level-item">九月 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/06/"><span class="level-start"><span class="level-item">六月 2019</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/04/"><span class="level-start"><span class="level-item">四月 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/03/"><span class="level-start"><span class="level-item">三月 2019</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/02/"><span class="level-start"><span class="level-item">二月 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/12/"><span class="level-start"><span class="level-item">十二月 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/09/"><span class="level-start"><span class="level-item">九月 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/07/"><span class="level-start"><span class="level-item">七月 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/06/"><span class="level-start"><span class="level-item">六月 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/05/"><span class="level-start"><span class="level-item">五月 2018</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/04/"><span class="level-start"><span class="level-item">四月 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/03/"><span class="level-start"><span class="level-item">三月 2018</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/02/"><span class="level-start"><span class="level-item">二月 2018</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/01/"><span class="level-start"><span class="level-item">一月 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/05/"><span class="level-start"><span class="level-item">五月 2017</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/04/"><span class="level-start"><span class="level-item">四月 2017</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2016/06/"><span class="level-start"><span class="level-item">六月 2016</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2016/04/"><span class="level-start"><span class="level-item">四月 2016</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2016/03/"><span class="level-start"><span class="level-item">三月 2016</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2016/02/"><span class="level-start"><span class="level-item">二月 2016</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2016/01/"><span class="level-start"><span class="level-item">一月 2016</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/archives/2015/12/"><span class="level-start"><span class="level-item">十二月 2015</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2015/11/"><span class="level-start"><span class="level-item">十一月 2015</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2015/10/"><span class="level-start"><span class="level-item">十月 2015</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2015/09/"><span class="level-start"><span class="level-item">九月 2015</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><!--!--><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/CS/"><span class="level-start"><span class="level-item">CS</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/Git/"><span class="level-start"><span class="level-item">Git</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/GoLang/"><span class="level-start"><span class="level-item">GoLang</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/JavaScript/"><span class="level-start"><span class="level-item">JavaScript</span></span><span class="level-end"><span class="level-item tag">19</span></span></a></li><li><a class="level is-mobile" href="/categories/Mac/"><span class="level-start"><span class="level-item">Mac</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/TypeScript/"><span class="level-start"><span class="level-item">TypeScript</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Vue/"><span class="level-start"><span class="level-item">Vue</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Web/"><span class="level-start"><span class="level-item">Web</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/iOS/"><span class="level-start"><span class="level-item">iOS</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"><span class="level-start"><span class="level-item">大前端</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-05-16T16:00:00.000Z">2021-05-17</time></p><p class="title"><a href="/2021/05/17/Vue%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">Vue 3 源码解析</a></p><p class="categories"><a href="/categories/Vue/">Vue</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-05-14T16:00:00.000Z">2021-05-15</time></p><p class="title"><a href="/2021/05/15/golang-channel/">GoLang Channel and</a></p><p class="categories"><a href="/categories/GoLang/">GoLang</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-05-12T16:00:00.000Z">2021-05-13</time></p><p class="title"><a href="/2021/05/13/golang-road-map/">GoLang Developer Road Map</a></p><p class="categories"><a href="/categories/GoLang/">GoLang</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-05-12T16:00:00.000Z">2021-05-13</time></p><p class="title"><a href="/2021/05/13/golang-basic/">GoLang Basic Knowledge</a></p><p class="categories"><a href="/categories/GoLang/">GoLang</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-01-08T08:15:01.381Z">2021-01-08</time></p><p class="title"><a href="/2021/01/08/Web%20%E5%8A%A0%E5%AF%86%E5%92%8C%E8%A7%A3%E5%AF%86/"> </a></p></div></article></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Git/"><span class="tag">Git</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/GoLang/"><span class="tag">GoLang</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/JavaScript/"><span class="tag">JavaScript</span><span class="tag">12</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Web/"><span class="tag">Web</span><span class="tag">3</span></a></div></div></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="关于代码的碎碎念" height="28"></a><p class="is-size-7"><span>&copy; 2022 Y2hlbmdsZWk=</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>