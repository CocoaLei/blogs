<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/blogs/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blogs/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/blogs/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/blogs/images/logo.svg" color="#222">

<link rel="stylesheet" href="/blogs/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/blogs/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"blog.chenglei.tech","root":"/blogs/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="CocoaLei">
<meta property="og:url" content="https://blog.chenglei.tech/blogs/page/3/index.html">
<meta property="og:site_name" content="CocoaLei">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="CocoaLei">
<meta property="article:tag" content="iOS">
<meta property="article:tag" content="HTML">
<meta property="article:tag" content="CSS">
<meta property="article:tag" content="JavaScript">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://blog.chenglei.tech/blogs/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>CocoaLei</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/blogs/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">CocoaLei</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/blogs/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/blogs/categories" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/blogs/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.chenglei.tech/blogs/2016/01/25/iOS-Responder-Chain/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blogs/images/avatar.gif">
      <meta itemprop="name" content="CocoaLei">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CocoaLei">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blogs/2016/01/25/iOS-Responder-Chain/" class="post-title-link" itemprop="url">事件传递与响应链探索</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-01-25 00:00:00" itemprop="dateCreated datePublished" datetime="2016-01-25T00:00:00+08:00">2016-01-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-01-17 11:36:46" itemprop="dateModified" datetime="2019-01-17T11:36:46+08:00">2019-01-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <hr>
<p>iOS App 使用响应者对象( <code>Responder</code>)来接收和处理事件。一个响应者对象是 <code>UIResponder</code> 类的实例，它常见的子类包括 <code>UIView</code> 、<code>UIViewController</code> 和 <code>UIApplication</code>。响应者对象接收原始事件数据，并且必须处理该事件或将它转发给另一个响应者对象。</p>
<p>当你的 App 接收到一个事件时，<code>UIKit</code> 自动将它发送给最适合的响应者对象，即第一响应者对象(First Responder)。未处理的事件从响应者对象被发送到正在活动的响应链中的响应者对象(响应者链是应用程序的响应者对象的动态配置,在应用程序中没有单个响应者链)。</p>
<p><code>UIKit</code> 为事件如何从一个响应者对象传递到另一个响应者对象预定义了规则，但是你可以通过覆盖响应者对象中的属性来改变这些规则。</p>
<br>

<h3 id="响应者对象-Responder-Object"><a href="#响应者对象-Responder-Object" class="headerlink" title="响应者对象 (Responder Object)"></a>响应者对象 (Responder Object)</h3><p><code>Responder</code> 对象是 <code>UIResponder</code> 类的实例，构成了 <code>UIKit</code> 应用程序事件处理的主干。许多重要对象也是响应者，包括 <code>UIApplication</code> 对象，<code>UIViewController</code> 对象和所有 <code>UIView</code> 对象（包括 <code>UIWindow</code>）。当事件发生时，<code>UIKit</code> 将它们分派给你的应用程序的响应者对象进行处理。<br><code>UIResponder</code> 对象能处理的事件，包括触摸事件，动作事件，远程控制事件和新闻事件。</p>
<p>为了处理特定类型的事件，响应者必须覆盖相应的方法。例如，为了处理触摸事件，响应者实现了 <code>touchesBegan:with:</code>，<code>touchesMoved:with:</code>，<code>touchesEnded:with:</code> 和 <code>touchesCancelled:with:</code>方法。在触摸事件发生时，响应者使用 <code>UIKit</code> 提供的事件信息来跟踪触摸的变化，并适当地更新应用的界面。</p>
<p>除了处理事件之外，<code>UIKit</code>响应者还负责将未处理事件转发到应用程序的其他部分。如果给定的响应者不处理事件，则将该事件转发给响应者链中的下一个响应者对象。 <code>UIKit</code> 动态地管理响应者链，使用预定义的规则来确定接下来哪个对象应该接收事件。</p>
<p>响应者处理 <code>UIEvent</code> 对象，但也可以通过输入视图接受自定义输入。系统的键盘是输入视图最明显的例子。当用户点击屏幕上的 <code>UITextField</code> 和  <code>UITextView</code> 对象时，视图成为第一响应者并显示其输入视图，这是系统键盘。同样，你可以创建自定义输入视图，并在其它响应者激活时显示它们。要将自定义输入视图与响应者相关联，请将该视图分配给响应者的 <code>inputView</code> 属性。</p>
<blockquote>
<p><strong>NOTE</strong></p>
<p>与加速度计、陀螺仪和磁力计相关的运动事件不遵循响应者链。Core Motion 会直接将这些事件发送给你指定的对象。</p>
</blockquote>
<br>

<h3 id="第一响应者对象-The-First-Responder"><a href="#第一响应者对象-The-First-Responder" class="headerlink" title="第一响应者对象 (The First Responder)"></a>第一响应者对象 (The First Responder)</h3><p><code>UIKit</code> 为各种类型的事件指定第一响应者对象并在事件发生时首先发送到第一响应者对象。</p>
<ul>
<li><p>Touch events</p>
<p> 第一响应者对象是触摸发生的视图</p>
</li>
<li><p>Press events</p>
<p>  第一响应者对象是获得焦点的响应者对象</p>
</li>
<li><p>Shake-motion events</p>
<p>   第一响应者对象是你或 <code>UIKit</code> 指定的对象</p>
</li>
<li><p>Remote-control events</p>
<p>第一响应者对象是你或 <code>UIKit</code> 指定的对象</p>
</li>
<li><p>Editing menu messages</p>
<p>第一响应者对象是你或 <code>UIKit</code> 指定的对象</p>
</li>
</ul>
<p>控件使用动作消息 (Action message) 与其关联的目标对象 (Target Object) 直接进行通信。当用户与控件进行交互时，控件调用其目标对象的动作方法 (Action Method)，向目标对象(Target object)发送一个动作消息。动作消息不是一个事件，但它们仍可利用响应链。当控件的目标对象为 <code>nil</code> 时，<code>UIKit</code> 从目标对象开始，遍历响应者链，直到寻找到实现了相应方法的对象。</p>
<p>如果视图中有添加手势，那么手势会在视图接收之前接收触摸和按下事件。如果视图中的所有手势都无法处理这个事件，则将事件传递给视图进行处理。如果视图也不能处理，则 <code>UIKit</code> 会将事件传递给响应者链。</p>
<br>

<h3 id="基于视图的点击测试-View-Based-Hit-Testing"><a href="#基于视图的点击测试-View-Based-Hit-Testing" class="headerlink" title="基于视图的点击测试 (View-Based Hit-Testing)"></a>基于视图的点击测试 (View-Based Hit-Testing)</h3><p><code>UIKit</code> 使用基于视图的点击测试来确定触摸事件到底发生在哪里。<code>UIKit</code> 将触摸位置与处在视图层级中的视图的 <code>bounds</code> 进行比较。<code>hitTest:withEvent:</code> 方法遍历视图层级，寻找包含指定触摸的层级最深的子视图。 然后这个视图就成为第一响应者对象。</p>
<p>当用户触摸屏幕进行交互时，系统检测到手指触摸操作，并将触摸以 <code>UIEvent</code> 的方式加入 <code>UIApplication</code>  的事件队列中。<code>UIApplication</code> 从事件队列中取出最新的触摸事件进行分发传递到 <code>UIWindow</code> 进行处理。而 <code>UIWindow</code> 会通过 <code>hitTest:withEvent:</code> 方法寻找触点所在的视图，这个过程称之为 Hit-Test。</p>
<p><code>UIKit</code> 将每个触摸永久绑定到包含它的视图对象。<code>UIKit</code> 在触摸第一次发生时创建 <code>UITouch</code> 对象，并只在触摸结束时释放它。当触摸位置或其它参数改变时，<code>UIKit</code> 使用新的信息来更新 <code>UITouch</code> 对象。唯一不改变的属性就是包含它的视图，即使触摸位置已经移出原始的视图。</p>
<p>Hit-Test 从顶级视图开始调用 <code>pointInside:withEvevt:</code> 方法判断触摸点是否在当前视图内，如果返回为 <code>NO</code>  ，则 <code>hitTest:withEvent:</code> 方法返回 nil；如果返回 <code>YES</code> ，则向当前视图的所有子视图发送 <code>hitTest:withEvent:</code> 消息，所有子视图的遍历顺序是从最顶层视图一直到最底层视图，直到有子视图返回非空对象或者全部子视图遍历完毕。</p>
<blockquote>
<p><strong>NOTE</strong></p>
<p>如果一个触摸的位置超出了视图的边界，<code>hitTest:withEvent:</code> 方法就会忽略这个视图及其所有子视图。</p>
</blockquote>
<br>

<h3 id="响应者链-（Resoponder-Chain）"><a href="#响应者链-（Resoponder-Chain）" class="headerlink" title="响应者链 （Resoponder Chain）"></a>响应者链 （Resoponder Chain）</h3><p>当系统通过 Hit-Test 找到触摸点所在的视图，但是这个视图并没有或者无法正常处理此次触摸事件，这个时候，系统便会通过响应者链寻找下一个响应者，以对此次触摸事件进行响应。</p>
<p><img src="https://github.com/apple272487813/codeLei.github.io/blob/master/images/iOS_Responder_Chain.jpg?raw=true" alt="https://github.com/apple272487813/codeLei.github.io/blob/master/images/iOS_Responder_Chain.jpg?raw=true"></p>
<p>如果一个 View 有一个视图控制器，它的下一个响应者就是这个视图控制器，然后才是它的父视图，如果一直到根视图都没能处理这个事件，事件会传递到 <code>UIWindow</code> ，若在 <code>UIWindow</code> 中也没有处理，则会传递给 <code>UIApplication</code> ，它是一个响应者链的终点，它的下一个响应者指向 <code>nil</code> ，以劫数整个循环。</p>
<br>

<h3 id="改变响应者链-Altering-the-Responder-Chain"><a href="#改变响应者链-Altering-the-Responder-Chain" class="headerlink" title="改变响应者链 (Altering the Responder Chain)"></a>改变响应者链 (Altering the Responder Chain)</h3><p>你可以通过覆盖你的响应者对象中的 <code>nextResponder</code> 属性来改变响应者链。当你这样做时，下一个响应者就是你返回的对象。</p>
<p>很多 <code>UIKit</code> 类已经覆盖了这个属性 : </p>
<ul>
<li><code>UIView</code> 对象。如果视图是视图控制器的根视图，那它的 <code>nextResponder</code> 是视图控制器，否则是视图的父视图。</li>
<li><code>UIViewController</code> 对象。<ul>
<li>如果视图控制器的视图是一个窗口的根视图，<code>nextResponder</code> 是窗口对象。</li>
<li>如果一个视图是被其它视图控制器推出的，<code>nextResponder</code> 是推出它的视图控制器。</li>
</ul>
</li>
<li><code>UIWindow</code> 对象。窗口的 <code>nextResponder</code> 是 <code>UIApplication</code> 对象。</li>
<li><code>UIApplication</code> 对象。只有在应用代理是 <code>UIResponder</code> 的实例而不是视图、视图控制器或者应用对象自身时，<code>UIApplication</code> 的 <code>nextResponder</code> 是应用程序代理。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.chenglei.tech/blogs/2016/01/10/iOS-Runtime/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blogs/images/avatar.gif">
      <meta itemprop="name" content="CocoaLei">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CocoaLei">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blogs/2016/01/10/iOS-Runtime/" class="post-title-link" itemprop="url">Objective-C Runtime</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-01-10 00:00:00" itemprop="dateCreated datePublished" datetime="2016-01-10T00:00:00+08:00">2016-01-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-01-17 11:36:22" itemprop="dateModified" datetime="2019-01-17T11:36:22+08:00">2019-01-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Objective-C-Runtime"><a href="#Objective-C-Runtime" class="headerlink" title="Objective-C Runtime"></a>Objective-C Runtime</h1><p>动态语言，是指程序在运行时可以改变其结构：新的函数可以被引进，已有的函数可以被删除等在结构上的变化，类型的检查是在运行时做的，优点为方便阅读，清晰明了，缺点为不方便调试。</p>
<p>这里有三个名词容易被混淆：</p>
<p>Dynamic Programming Language，即动态语言或动态编程语言</p>
<p>Dynamically Typed  Language，即动态类型语言</p>
<p>Statically Typed Language，即静态类型语言</p>
<p>所谓的动态类型语言，指的是类型的检查是在运行时做的；与此相对，静态类型语言的类型判断是在运行前判断(如编译阶段)，C#、Java 等就是静态类型语言，静态类型的语言为了达到多态会采取一些类型鉴别手段，如接口、继承，而动态类型的语言却不需要，所以一般动态语言都会采用 dynamic typing，常出现于脚本语言中。</p>
<p><strong><code>Objective-C</code> 就是一门动态语言，它有一个运行时系统来执行编译的代码。这个运行时系统就是 <code>Objc Runtime</code>，它是一个由 C 和汇编语言编写的库。</strong></p>
<p><code>Runtime</code> 库的主要工作是封装和找出最终执行的代码。</p>
<ul>
<li>封装 ：在 <code>Objc Runtime</code> 库中，对象可以用 C 中的结构体表示，而方法可以用 C 中的函数来实现，另外再加上一些额外的特性。这些结构体和函数被 <code>Runtime</code> 函数封装后，我们就可以在程序运行时创建，检查，修改类、对象和它们的方法了。</li>
<li>找出方法的最终执行代码：当程序执行 <code>[object doSomething]</code>时，会向消息接收者发送一条消息，<code>Runtime</code> 会根据消息接收者是否能响应该消息而做出不同的反应。</li>
</ul>
<p>Objective-C Runtime 目前有两个版本：<code>Modern Runtime</code>和 <code>Legacy Runtime</code>。<code>Moder Runtime</code>覆盖了64位的 <code>Mac  OS X Apps</code>和 <code>iOS Apps</code>，<code>Legacy Runtime</code>是早期用来给32位的 <code>Mac OS X Apps</code>用的。</p>
<h2 id="Objective-C-Runtime-中的类与对象"><a href="#Objective-C-Runtime-中的类与对象" class="headerlink" title="Objective-C Runtime 中的类与对象"></a>Objective-C Runtime 中的类与对象</h2><h3 id="类与对象的基本数据结构"><a href="#类与对象的基本数据结构" class="headerlink" title="类与对象的基本数据结构"></a>类与对象的基本数据结构</h3><h4 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h4><p><code>Objective-C</code> 中的类是由 <code>Class</code> 类型来表示的，实际上是一个指向 <code>objc_class</code> 结构体的指针</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_class	*Class;</span><br></pre></td></tr></table></figure>

<p>它的结构体定义如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">struct	objc_class &#123;</span><br><span class="line">  Class isa OBJC_ISA_AVAILABILITY;</span><br><span class="line">  </span><br><span class="line"> #if !__OBJC2__</span><br><span class="line"> 	Class	super_class						OBJC2_UNAVAILABLE;</span><br><span class="line">	const 	char *name						OBJC2_UNAVAILABLE;</span><br><span class="line">	long	version							OBJC2_UNAVAILABLE;</span><br><span class="line">	long	info 							OBJC2_UNAVAILABLE;</span><br><span class="line">	long 	instance_size					OBJC2_UNAVAILABLE;</span><br><span class="line">	struct	objc_ivar_list	*ivars			OBJC2_UNAVAILABLE;</span><br><span class="line">	struct	objc_method_list **methodLists  OBJC2_UNAVAILABLE;</span><br><span class="line">	struct	objc_cache	*cache				OBJC2_UNAVAILABLE;</span><br><span class="line">	struct	objc_protocol_list	*protocols	OBJC2_UNAVAILABLE;</span><br><span class="line"> #endif</span><br><span class="line">&#125; OBJC2_UNAVAILABLE;</span><br></pre></td></tr></table></figure>

<p>这些字段的意义如下：</p>
<ul>
<li><code>isa</code>：<code>Objective-C</code> 中所有类自身也是对象，这个对象的 <code>Class</code> 里也有一个 <code>isa</code> 指针，它指向 <code>metaClass</code> 元类。</li>
<li><code>super_class</code> ：指向该类的父类，如果该类已经是最顶层的根类，则为 <code>NULL</code>。</li>
<li><code>name</code> ：类名。</li>
<li><code>version</code> ：类的版本信息，默认为0。我们可以使用这个字段来提供类的版本信息，这对于对象的序列化非常有用，它可以让我们识别出不同类定义版本中实例变量布局的改变。</li>
<li><code>info</code> ：类信息，供运行期使用的一些位标识。</li>
<li><code>instance_size</code> ：类的实例变量的大小。</li>
<li><code>ivars</code> ：类的成员变量链表。</li>
<li><code>methodLists</code> ：方法定义的链表。</li>
<li><code>cache</code> ：用于缓存最近使用的方法。当一个接收者对象接收到一个消息时，它会根据 <code>isa</code> 指针去查找能够响应这消息的对象。在实际情况里，这个对象只有一部分方法是常用的，很多方法其实很少用或根本用不上。这种情况下，如果每次消息来时，都是在 <code>methodLists</code> 链表中遍历一遍，性能势必很差。更好的做法是，在我们每次调用过一个方法后，就将这个方法缓存到 <code>cache</code> 列表中，下次调用就会优先去 <code>cache</code> 中查找。</li>
<li><code>protocols</code> ：协议链表。</li>
</ul>
<p>当我们向一个 <code>Objective-C</code> 对象发送消息时，<code>Runtime</code> 会根据实例对象的 <code>isa</code> 指针找到这个实例对象所属的类，然后 <code>Runtime</code> 会在类的方法列表及其父类的方法列表中寻找与消息对应的 <code>selector</code> 指向的方法，找到后即运行这个方法。</p>
<p>当创建一个特定类的实例对象时，分配的内存会包含一个 <code>objc_object</code> 数据结构，然后是类的实例变量的数据。<code>NSObject</code> 类的 <code>alloc</code> 和 <code>allocWithZone:</code> 方法使用函数 <code>class_createInstance</code> 来创建 <code>objc_object</code> 数据结构。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct objc_object &#123;</span><br><span class="line">  Class isa	OBJC_ISA_AVAILABILITY;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">typedef	struct objc_object	*id;</span><br></pre></td></tr></table></figure>

<p>常见的 <code>id</code> 是一个 <code>objc_object</code> 结构类型的指针。</p>
<h4 id="objc-cache"><a href="#objc-cache" class="headerlink" title="objc_cache"></a>objc_cache</h4><p><code>objc_class</code> 中的 <code>cache</code> 字段用于缓存调用过的方法，它是一个指向 <code>objc_cache</code> 结构体的指针。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct	objc_cache &#123;</span><br><span class="line">  unsigned int mask 				OBJC2_UNAVAILABLE;	</span><br><span class="line">  unsigned int occupied				OBJC2_UNAVAILABLE;</span><br><span class="line">  Method buchets[1]					OBJC2_UNAVAILABLE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该结构体的字段描述如下：</p>
<ul>
<li><code>mask</code> ：一个整数，指定分配的缓存 <code>bucket</code> 的总数。在方法查找过程中，<code>Runtime</code> 使用这个字段来确定开始线性查找数组的索引位置。指向方法的 <code>selector</code> 指针与该字段做一个 <code>AND</code> 位操作。</li>
<li><code>occupied</code> ：一个整数，指定实际占用的缓存 <code>bucket</code> 的总数。</li>
<li><code>buckets</code> ： 指向 <code>Method</code> 数据结构指针的数组。这个数组可能包含不超过 <code>mask+1</code> 个元素。如果指针为 <code>NULL</code>，表明这个缓存 <code>bucket</code> 没有被占用，另外被占用的 <code>bucket</code> 可能是不连续的。</li>
</ul>
<h4 id="元类-Meta-Class"><a href="#元类-Meta-Class" class="headerlink" title="元类(Meta Class)"></a>元类(Meta Class)</h4><p>所有的类自身也是一个对象，我们也可以向这个对象发送消息。</p>
<p>当我们向一个对象发送消息时，<code>Runtime</code> 会在这个对象所属的类的方法列表中查找方法；而向一个类发送消息时，会在这个类的 <code>meta-class</code> 的方法列表中查找。</p>
<p><code>meta-class</code> 存储着一个类的所有类方法。每个类都会有个一个单独的 <code>meta-class</code> ，因为每个类的类方法基本不可能完全相同。</p>
<p><code>meta-class</code> 的 <code>isa</code> 指针指向基类的 <code>meta-class</code> ，以此作为它的所属类。可以理解为，任何 <code>NSObject</code> 继承体系下的 <code>meta-class</code> 都使用 <code>NSObject</code> 的 <code>meta-class</code> 作为自己的所属类，而基类的 <code>meta-class</code> 的 <code>isa</code> 指针则指向它自己。</p>
<p>对于 <code>NSObject</code> 继承体系来说，其实例方法对体系中的所有实例、类和 <code>meta-class</code> 都是有效的；而类方法对于体系内的所有类和 <code>meta-class</code> 都是有效的。</p>
<h3 id="类与对象操作函数"><a href="#类与对象操作函数" class="headerlink" title="类与对象操作函数"></a>类与对象操作函数</h3><p><code>Runtime</code> 提供了大量函数来操作类与对象。类的操作方法大部分以 <code>class_</code> 为前缀，对象的操作方法大部分是以 <code>objc_</code> 或 <code>object_</code> 为前缀。</p>
<h4 id="类名"><a href="#类名" class="headerlink" title="类名"></a>类名</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 获取类的类名</span><br><span class="line">const char * class_getName	(Class cls);</span><br></pre></td></tr></table></figure>

<p>对于 <code>class_getName</code> 函数来说，如果传入的 <code>cls</code> 为 <code>nil</code>，则返回一个字字符串。</p>
<h4 id="父类-super-class-和元类-meta-class"><a href="#父类-super-class-和元类-meta-class" class="headerlink" title="父类(super_class)和元类(meta-class)"></a>父类(super_class)和元类(meta-class)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 获取类的父类</span><br><span class="line">Class	class_getSuperClass	(Class cls);</span><br><span class="line">&#x2F;&#x2F; 判断给定的类是否是元类</span><br><span class="line">BOOL class_isMetaClass	(Class cls);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>class_getSuperClass</code> 函数，当<code>cls</code> 为 <code>nil</code> 或 <code>cls</code> 为根类时，返回 <code>nil</code>。</li>
<li><code>class_isMetaClass</code> 函数，如果 <code>cls</code> 是元类，返回 <code>YES</code>。如果传入的 <code>cls</code> 为 <code>nil</code>，则返回 <code>NO</code>。</li>
</ul>
<h4 id="实例变量大小-instance-size"><a href="#实例变量大小-instance-size" class="headerlink" title="实例变量大小(instance_size)"></a>实例变量大小(instance_size)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 获取实例大小</span><br><span class="line">size_t	class_getInstanceSize	(Class cls);</span><br></pre></td></tr></table></figure>



<h4 id="成员变量-ivar-及属性"><a href="#成员变量-ivar-及属性" class="headerlink" title="成员变量(ivar)及属性"></a>成员变量(ivar)及属性</h4><p><code>objc_class</code> 中，所有的成员变量、属性的信息都是放在链表 <code>ivars</code> 中。<code>ivars</code> 是一个数组，数组中的每个元素是指向 <code>ivar</code> 的指针。</p>
<ul>
<li><p>成员变量操作函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 获取类中指定名称实例成员变量的信息</span><br><span class="line">Ivar	class_getInstanceVariable	(Class cls, const char *name);	</span><br><span class="line">&#x2F;&#x2F; 获取类成员变量的信息</span><br><span class="line">Ivar	class_getClassVariable	(Class cls, const char *name);</span><br><span class="line">&#x2F;&#x2F; 添加成员变量</span><br><span class="line">BOOL	class_addIvar	(Class cls, const char *name, size_t size, uint8_t alignment, const char *types);</span><br><span class="line">&#x2F;&#x2F; 获取整个成员变量列表</span><br><span class="line">Ivar	* class_copyIvarList	(Class cls, unsigned int *outCount);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>class_getInstanceVariable</code> 函数，它返回一个指向包含 <code>name</code> 指定的成员变量信息的 <code>objc_ivar</code> 结构体的指针 <code>Ivar</code>。</li>
<li><code>class_getClassVariable</code> 函数，目前没有找到关于 <code>Objective-C</code> 中类变量的信息，一般认为 <code>Objective-C</code> 不支持类变量。</li>
<li><code>Objective-C</code> 不支持向已经存在的类中添加实例变量，但如果通过 <code>Runtime</code> 来创建一个类的话，就可以使用 <code>class_addIvar</code> 函数了。需要注意的是，这个函数只能在 <code>objc_allocateClassPair</code> 与 <code>objc_registerClassPair</code> 之间调用。另外这个类也不能是元类。</li>
<li><code>class_copyIvarList</code> ，返回一个包含成员变量信息的数组，数组中的每个元素是指向该成员变量信息的 <code>objc_ivar</code> 结构体的指针。这个数组不包含在父类中声明的变量。<code>outCount</code> 指针返回数组的大小。需要注意的是，我们必须使用 <code>free()</code> 来释放这个数组。</li>
</ul>
</li>
<li><p>属性操作函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 获取指定的属性</span><br><span class="line">objc_property_t	class_getProperty	(Class cls, const char *name);</span><br><span class="line">&#x2F;&#x2F; 获取属性列表</span><br><span class="line">objc_property_t * class_copyPropertyList	(Class cls, unsigned int *outCount);</span><br><span class="line">&#x2F;&#x2F; 为类添加属性</span><br><span class="line">BOOL class_addProperty	(Class cls, const char *name, const objc_property_attribute_t *attributes, unsigned int attributeCount);</span><br><span class="line">&#x2F;&#x2F; 替换类的属性</span><br><span class="line">void class_replaceProperty	(Class cls, const char *name, const objc_property_attribute_t *attributes, unsigned int attributeCount);</span><br></pre></td></tr></table></figure>
</li>
<li><p>在 <code>Mac OS X</code> 系统中，<code>Runtime</code> 提供了几个函数来确定一个对象的内存区域是否可以被垃圾回收器扫描，以处理 <code>strong/weak</code> 引用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const	uint8_t * class_getIvarLayout	(Class cls);</span><br><span class="line">void	class_setIvarLayout	(Class cls, const uint8_t *layout);</span><br><span class="line">const	uint_8	* class_getWeakIvarLayout	(Class cls);</span><br><span class="line">void	class_setWeakIvarLayout	(Class cls, const uint8_t *layout);</span><br></pre></td></tr></table></figure>

<p>通常情况下，我们不需要去主动调用这些方法，在调用 <code>objc_registerClassPair</code> 时，会生成合理的布局。</p>
</li>
</ul>
<h4 id="方法-methodLists"><a href="#方法-methodLists" class="headerlink" title="方法(methodLists)"></a>方法(methodLists)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 添加方法</span><br><span class="line">BOOL class_addMethod	(Class cls, SEL name, IMP imp, const char *types);</span><br><span class="line">&#x2F;&#x2F; 获取实例方法</span><br><span class="line">Method	class_getInstanceMethod	(Class cls, SEL name);</span><br><span class="line">&#x2F;&#x2F; 获取类方法</span><br><span class="line">Method	class_getClassMethod	(Class cls, SEL name);</span><br><span class="line">&#x2F;&#x2F; 获取所有方法的数组</span><br><span class="line">Method	* class_copyMethodList	(Class cls, unsigned int *outCount);</span><br><span class="line">&#x2F;&#x2F; 替代方法的实现</span><br><span class="line">IMP	class_replaceMethod	(Class cls, SEL name, IMP imp, const char *types);</span><br><span class="line">&#x2F;&#x2F; 返回方法的具体实现</span><br><span class="line">IMP	class_getMethodImplementation	(Class cls, SEL name);</span><br><span class="line">IMP class_getMethodImplementation_stret	(Class cls, SEL name);</span><br><span class="line">&#x2F;&#x2F; 类实例是否响应指定的 selector</span><br><span class="line">BOOL class_respondsToSelector	(Class cls, SEL sel);</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>class_addMethod</code> 的实现会覆盖父类的方法实现，但不会取代本类中已经存在的实现，如果本类中包含一个同名的实现，则函数会返回 <code>NO</code>。如果要修改已经存在的实现，可以使用 <code>method_setImplementation</code>。一个 <code>Objectice-C</code> 方法是一个简单的 C 函数，它至少包含两个参数 <code>self</code> 和 <code>_cmd</code>，所以我们实现函数至少需要两个参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void myMethodIMP (id self, SEL _cmd) &#123;</span><br><span class="line">  &#x2F;&#x2F; implementation</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与成员变量不同的是，我们可以动态的为类添加方法，不管这个类是否已经存在。</p>
<p>参数 <code>types</code> 是一个描述传递给方法的参数类型的字符数组。</p>
</li>
<li><p><code>class_getInstanceMethod</code> 、<code>class_getClassMethod</code> 函数，与 <code>class_copyMethodList</code> 不同的是，这两个函数都会去搜索父类的实现。</p>
</li>
<li><p><code>class_copyMethodList</code> 函数，返回包含所有实例方法的数组，如果需要获取类方法，则可使用 <code>class_copyMethodList(object_getClass(Class cls), &amp;count)</code> (一个类的实例方法是定义在元类中的)。该列表不包含父类实现的方法。<code>outCount</code> 参数返回方法的个数。在获取到列表后，我们需要使用 <code>free()</code> 来释放它。</p>
</li>
<li><p><code>class_replaceMethod</code> 函数，该函数的行为可以分为两种 ：如果类中不存在参数 <code>name</code> 指定的方法，则类似于 <code>class_addMethod</code> 函数一样会添加方法；如果类中已经存在 <code>name</code> 指定的方法，则类似于 <code>method_setImplementation</code> 一样替代原方法的实现。</p>
</li>
<li><p><code>class_getMethodImplementation</code> 函数，该函数在向类实例发送消息时会被调用，并返回一个指向方法实现函数的指针。这个函数会比 <code>method_getImplementation(Class cls, const char * name)</code> 更快。返回的函数指针可能是一个指向 <code>Runtime</code> 内部的函数，而不一定是方法的实际实现。</p>
</li>
<li><p><code>class_respondsToSelector</code> 函数，我们经常使用 <code>NSObject</code> 类的 <code>respondsToSelector:</code> 或 <code>instanceRespondToSelector:</code> 方法来达到同样的目的。</p>
</li>
</ul>
<h4 id="协议-objc-protocol-list"><a href="#协议-objc-protocol-list" class="headerlink" title="协议 (objc_protocol_list)"></a>协议 (objc_protocol_list)</h4><p>协议相关的操作包含以下函数：：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 添加协议</span><br><span class="line">BOOL class_addProtocol	(Class cls, Protocol *protocol);</span><br><span class="line">&#x2F;&#x2F; 返回类是否实现指定的协议</span><br><span class="line">BOOL class_conformsToProtocol	(Class cls, Protocol *protocol);</span><br><span class="line">&#x2F;&#x2F; 返回类实现的协议列表</span><br><span class="line">Protocol	*class_copyProtocolList	(Class cls, unsigned int *outCout);</span><br></pre></td></tr></table></figure>



<h4 id="版本-version"><a href="#版本-version" class="headerlink" title="版本(version)"></a>版本(version)</h4><p>版本相关的操作函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 获取版本号</span><br><span class="line">int class_getVersion	(Class cls);</span><br><span class="line">&#x2F;&#x2F; 设置版本号</span><br><span class="line">void class_setVersion	(Class cls, int version)</span><br></pre></td></tr></table></figure>



<h3 id="动态创建类和对象"><a href="#动态创建类和对象" class="headerlink" title="动态创建类和对象"></a>动态创建类和对象</h3><p><code>Runtime</code> 经常被用到的功能就是在运行时创建类和对象。</p>
<h4 id="动态创建类"><a href="#动态创建类" class="headerlink" title="动态创建类"></a>动态创建类</h4><p>动态创建类涉及到一下几个函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建一个新类和元类</span><br><span class="line">Class	objc_allocateClassPair	(Class superclass, const char *name, size_t extraBytes);</span><br><span class="line">&#x2F;&#x2F; 销毁一个类及其相关的类</span><br><span class="line">void objc_disposeClassPair	(Class cls);</span><br><span class="line">&#x2F;&#x2F; 在应用中注册由 objc_allocateClassPair 创建的类</span><br><span class="line">void objc_registerClassPair	(Class cls);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>objc_allocateClassPair</code> 函数 ：如果我们要创建一个根类，则指定 <code>superClass</code> 为 <code>Nil</code>。<code>extraBytes</code> 通常指定为 0 ，该参数是分配给类和元类对象尾部的索引 <code>ivars</code> 的字节数。</li>
</ul>
<p>为了创建一个新类，我们需要调用 <code>objc_allocateClassPair</code> ，然后使用诸如 <code>class_addMethod</code> , <code>class_addIvar</code> 等函数来为新创建的类添加方法、实例变量和属性等。完成这些后，我们需要调用 <code>objc_registerClassPair</code> 函数来注册类，之后这个类就可以在程序中使用了。</p>
<p>实例方法和实例变量应该添加到类自身上，而类方法应该添加到类的元类上。</p>
<ul>
<li><code>objc_disposeClassPair</code> 函数用于销毁一个类，值得注意的是，如果程序运行中还存在类或其子类的实例，则不能对针对类调用该方法。</li>
</ul>
<h4 id="动态创建对象"><a href="#动态创建对象" class="headerlink" title="动态创建对象"></a>动态创建对象</h4><p>动态创建对象的函数如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建类实例</span><br><span class="line">id class_createInstance	(Class cls, size_t extraBytes);</span><br><span class="line">&#x2F;&#x2F; 在指定位置创建类实例</span><br><span class="line">id objc_constructInstance	(Class cls, void *bytes);</span><br><span class="line">&#x2F;&#x2F; 销毁类实例</span><br><span class="line">void * objc_destructInstance (id obj);</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>class_createInstance</code> 函数 ：创建实例时，会在默认的内存区域为类分配内存。<code>extraBytes</code> 表示分配的额外字节数。这些额外的字节数可用于存储在类定义中所定义的实例变量之外的实例变量。该函数在ARC环境下无法使用。</p>
<p>调用 <code>class_createInstance</code> 的效果和 <code>+alloc</code> 方法类似。</p>
</li>
<li><p><code>objc_constructInstance</code> 函数 ：在指定的位置(bytes)创建类实例。</p>
</li>
<li><p><code>objc_destructInstance</code> 函数 ：销毁一个类的实例，但不会释放并移除任何与其先关的引用。</p>
</li>
</ul>
<h3 id="实例操作函数"><a href="#实例操作函数" class="headerlink" title="实例操作函数"></a>实例操作函数</h3><p>实例操作函数主要是针对创建的实例对象的一系列操作函数。</p>
<h4 id="针对整个对象进行操作的函数"><a href="#针对整个对象进行操作的函数" class="headerlink" title="针对整个对象进行操作的函数"></a>针对整个对象进行操作的函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 返回指定对象的一份拷贝</span><br><span class="line">id object_copy (id obj, size_t size);</span><br><span class="line">&#x2F;&#x2F; 释放指定对象占用的内存</span><br><span class="line">id object_dispose	(id obj);</span><br></pre></td></tr></table></figure>



<h4 id="针对对象实例变量进行操作的函数"><a href="#针对对象实例变量进行操作的函数" class="headerlink" title="针对对象实例变量进行操作的函数"></a>针对对象实例变量进行操作的函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 修改类实例的实例变量的值</span><br><span class="line">Ivar	object_setInstanceVariable	(id obj, const char *name, void *value);</span><br><span class="line">&#x2F;&#x2F; 获取对象实例变量的值</span><br><span class="line">Ivar	object_getInstanceVariable	(id obj, const char *name, void **outValue);</span><br><span class="line">&#x2F;&#x2F; 返回指向给定对象分配的任何额外字节的指针</span><br><span class="line">void * object_getIndexedIvars (id obj);</span><br><span class="line">&#x2F;&#x2F; 返回对象中实例变量的值</span><br><span class="line">id object_getIvar	(id obj, Ivar ivar);</span><br><span class="line">&#x2F;&#x2F; 设置对象中实例变量的值</span><br><span class="line">void object_setIvar	(id obj, Ivar ivar, id value);</span><br></pre></td></tr></table></figure>

<p>如果实例变量的 <code>Ivar</code> 已经知道，那么调用 <code>objc_getIvar</code> 会比 <code>objc_getInstanceVariable</code> 函数快。相同情况下，<code>object_setIvar</code> 也比 <code>object_setInstanceVariable</code> 快。</p>
<h4 id="针对对象的类进行操作的函数"><a href="#针对对象的类进行操作的函数" class="headerlink" title="针对对象的类进行操作的函数"></a>针对对象的类进行操作的函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 返回给定对象的类名</span><br><span class="line">const char * object_getClassName	(id obj);</span><br><span class="line">&#x2F;&#x2F; 返回对象的类</span><br><span class="line">Class object_getClass (id obj);</span><br><span class="line">&#x2F;&#x2F; 设置对象的类</span><br><span class="line">Class object_setClass	(id obj, Class cls);</span><br></pre></td></tr></table></figure>



<h3 id="获取类定义"><a href="#获取类定义" class="headerlink" title="获取类定义"></a>获取类定义</h3><p><code>Objective-C Runtime</code> 会自动注册我们代码中定义的所有的类。我们也可以在运行时创建类定义并使用 <code>objc_addClass</code> 来注册它们。</p>
<p>获取类定义的相关函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 获取以注册的类定义的列表</span><br><span class="line">int objc_getClassList	(Class *buffer, int bufferCount);</span><br><span class="line">&#x2F;&#x2F; 创建并返回一个指向所有已注册类的指针列表</span><br><span class="line">Class	*	objc_copyClassList	(unsigned int *outCount);</span><br><span class="line">&#x2F;&#x2F; 返回指定类的类定义</span><br><span class="line">Class	objc_lookUpClass	(const char *name);</span><br><span class="line">Class	objc_getClass	(const char *name);</span><br><span class="line">Class	objc_getRequiredClass	(const char *name);</span><br><span class="line">&#x2F;&#x2F; 返回指定类的元类</span><br><span class="line">Class	objc_getMetaClass	(const char *name);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>objc_getClassList</code> 函数 ：获取已注册的类定义的列表。我们不能假设从该函数中获取的类对象是继承自 <code>NSObject</code> 体系的，所以在这些类上调用方法时，都应该先检测一下这个方法是否在这个类中实现。</li>
<li>获取类定义的方法有三个 ：<code>objc_lookUpClass</code> , <code>objc_getClass</code> 和 <code>objc_getRequiredClass</code>。如果类在运行时未注册，则 <code>objc_lookUpClass</code> 会返回 <code>nil</code>，而 <code>objc_getClass</code> 会调用类处理回调，并在此确认类是否注册，如果确认未注册，再返回 <code>nil</code>。而 <code>objc_getRequiredClass</code> 函数的操作与 <code>objc_getClass</code> 相同，只不过没有找到类，就会杀死进程。</li>
<li><code>objc_getMetaClass</code> 函数 ：如果指定的类没有注册，则该函数会调用类处理回调，并在此确认类是否注册，如果确认未注册，再返回 <code>nil</code>。不过，每个类定义都必须有一个有效的元类定义，所以这个函数总是会返回一个元类定义。不管它是否有效。</li>
</ul>
<h2 id="Objective-C-Runtime-中的成员变量与属性"><a href="#Objective-C-Runtime-中的成员变量与属性" class="headerlink" title="Objective-C Runtime 中的成员变量与属性"></a>Objective-C Runtime 中的成员变量与属性</h2><h3 id="类型编码-Type-Encoding"><a href="#类型编码-Type-Encoding" class="headerlink" title="类型编码(Type Encoding)"></a>类型编码(Type Encoding)</h3><p>作为对 <code>Runtime</code> 的补充，编译器将每个方法的返回值和参数类型编码为一个字符串，并将其与方法的 <code>selector</code> 关联在一起。这种编码方案在其它情况下也是非常有用的，因此我们可以使用  <code>@encod</code> 编译器指令来获取它。当给定一个类型时，<code>@encode</code> 会返回这个类型的字符串编码。   </p>
<h3 id="成员变量、属性"><a href="#成员变量、属性" class="headerlink" title="成员变量、属性"></a>成员变量、属性</h3><p><code>Runtime</code> 中关于成员变量和属性的相关数据结构并不多，只有三个。</p>
<h4 id="基础数据类型"><a href="#基础数据类型" class="headerlink" title="基础数据类型"></a>基础数据类型</h4><h5 id="Ivar"><a href="#Ivar" class="headerlink" title="Ivar"></a>Ivar</h5><p><code>Ivar</code> 是表示实例变量的类型，其实际上是一个指向 <code>objc_ivar</code> 结构体的指针 ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">typedef struct	objc_ivar	*Ivar;</span><br><span class="line"></span><br><span class="line">struct objc_ivar	&#123;</span><br><span class="line">  char *ivar_name		OBJC2_UNAVAILABLE;	&#x2F;&#x2F; 变量名</span><br><span class="line">  char *ivar_type		OBJC2_UNAVAILABLE;	&#x2F;&#x2F; 变量类型</span><br><span class="line">  int ivar_offset		OBJC2_UNAVAILABLE;	&#x2F;&#x2F; 基地址偏移字节</span><br><span class="line">  </span><br><span class="line">#ifdef __LP64__</span><br><span class="line">  int space				OBJC2_UNAVAILABLE;</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="objc-property-t"><a href="#objc-property-t" class="headerlink" title="objc_property_t"></a>objc_property_t</h5><p><code>objc_property_t</code> 是声明属性的类型，是一个指向 <code>objc_property</code> 结构体的指针 ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef	struct	objc_property	*objc_property_t;</span><br></pre></td></tr></table></figure>

<h5 id="objc-property-attribute-t"><a href="#objc-property-attribute-t" class="headerlink" title="objc_property_attribute_t"></a>objc_property_attribute_t</h5><p><code>objc_property_attribute_t</code> 定义了属性的特性，它是一个结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span>	<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *name;		<span class="comment">//	特姓名</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *value;	<span class="comment">//	特性值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="关联对象-Associated-Object"><a href="#关联对象-Associated-Object" class="headerlink" title="关联对象(Associated Object)"></a>关联对象(Associated Object)</h4><p>关联对象是<code>Runtime</code> 中一个非常实用的特性。关联对象类似于成员变量，不过是在运行时添加的。我们通常会把变量(<code>Ivar</code>)放在类声明的头文件中，或者放在类实现的 <code>@implementation</code> 后面。但这有一个缺点，我们不能在分类中添加成员变量。<code>Objective-C</code> 针对这一问题，提出了一个解决方案：即关联对象(Associated Object)。</p>
<p>我们可以把关联对象想象成一个<code>Objective-C</code> 对象(如字典)，这个对象通过给定的key连接到类的一个实例上。不过由于使用的是C接口，所以key是一个<code>void</code> 指针。我们还需要指定一个内存管理策略，告诉<code>Runtime</code> 如何管理这个对象的内存，这个内存管理策略可以由一下指定：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">OBJC_ASSOCIATION_ASSIGN</span><br><span class="line">OBJC_ASSOCIATION_RETAIN_NONATOMIC</span><br><span class="line">OBJC_ASSOCIATION_COPY_NONATOMIC</span><br><span class="line">OBJC_ASSOCIATION_RETAIN</span><br><span class="line">OBJC_ASSOCIATION_COPY</span><br></pre></td></tr></table></figure>

<p>当宿主对象被释放时，会根据指定的内存管理策略来处理关联对象。如果指定的是 <code>OBJC_ASSOCIATION_ASSIGN</code></p>
<p>，则宿主释放时，关联对象不会被释放；而如果指定的是 <code>retain</code> 或者是 <code>copy</code> ，则宿主释放时，关联对象会被释放。</p>
<p>将一个对象连接到其它对象所需的就是下面两行代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">static char aKey;</span><br><span class="line">objc_setAssociatedObject(self, &amp;aKey, anObject, OBJC_ASSOCIATION_RETAIN);</span><br></pre></td></tr></table></figure>

<p>在这种情况下，<code>self</code> 对象将获取一个新的关联对象 <code>anObject</code> ，且内存管理策略是自动 <code>retian</code> 管理对象，当<code>self</code> 对象释放时，会自动 <code>release</code> 关联对象。另外，如果我们使用同一个key来关联另外一个对象时，也会自动释放之前关联的对象，在这种情况下，先前的关联对象会被妥善的处理掉，并且新的对象会使用它的内存。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 获取指定key的关联对象</span><br><span class="line">id anObject	&#x3D;	objc_getAssociatedObject(self, &amp;aKey);</span><br></pre></td></tr></table></figure>

<p>使用 <code>objc_removeAssociatedObjects</code> 函数来移除一个关联对象，或者使用 <code>objc_setAssociatedObject</code> 函数将key指定的关联对象设置为<code>nil</code> 。</p>
<h4 id="成员变量、属性的操作方法"><a href="#成员变量、属性的操作方法" class="headerlink" title="成员变量、属性的操作方法"></a>成员变量、属性的操作方法</h4><h5 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h5><p>成员变量的操作函数包括 ： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 获取成员变量名</span><br><span class="line">const char * ivar_getName (Ivar v);</span><br><span class="line">&#x2F;&#x2F; 获取成员变量类型编码</span><br><span class="line">const char * ivar_getTypeEncoding (Ivar v);</span><br><span class="line">&#x2F;&#x2F; 获取成员变量的偏移量</span><br><span class="line">ptrdiff_t ivar_getOffset (Ivar v);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>ivar_getOffset</code> 函数，对于 <code>id</code>  或其它对象类型的实例变量，可以调用 <code>object_getIvar</code> 和 <code>object_setIvar</code> 来直接访问成员变量，而不使用偏移量。</li>
</ul>
<h5 id="关联对象"><a href="#关联对象" class="headerlink" title="关联对象"></a>关联对象</h5><p>关联对象的操作函数包括 ： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 设置关联对象</span><br><span class="line">void objc_setAssociatedObject (id object, const void *key, id value, objc_AssociationPolicy policy);</span><br><span class="line">&#x2F;&#x2F; 获取关联对象</span><br><span class="line">id objc_getAssociatedObject (id object, const void *key);</span><br><span class="line">&#x2F;&#x2F; 移除关联对象</span><br><span class="line">void objc_removeAssociatedObjects (id object);</span><br></pre></td></tr></table></figure>

<h5 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h5><p>属性操作相关函数包括 ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 获取属性名</span><br><span class="line">const char * property_getName (objc_property_t property);</span><br><span class="line">&#x2F;&#x2F; 获取属性特性描述字符串</span><br><span class="line">const char * property_getAttributes (objc_property_t property);</span><br><span class="line">&#x2F;&#x2F; 获取属性中指定的特性</span><br><span class="line">char * property_copyAttributeValue (objc_property_t property, const char *attributeName);</span><br><span class="line">&#x2F;&#x2F; 获取属性的特性列表</span><br><span class="line">objc_property_attribute_t * property_copyAttributeList (objc_property_t property, unsigned int *outCount);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>property_copyAttributeValue</code> 函数，返回的 <code>char*</code> 在使用完后需要调用 <code>free()</code> 释放。</li>
<li><code>property_copuAttributeList</code> 函数，返回值在使用完后需要调用 <code>free()</code> 释放。</li>
</ul>
<h2 id="Objective-C-Runtime-中的方法与消息"><a href="#Objective-C-Runtime-中的方法与消息" class="headerlink" title="Objective-C Runtime 中的方法与消息"></a>Objective-C Runtime 中的方法与消息</h2><h3 id="基础数据类型-1"><a href="#基础数据类型-1" class="headerlink" title="基础数据类型"></a>基础数据类型</h3><h4 id="SEL"><a href="#SEL" class="headerlink" title="SEL"></a>SEL</h4><p>SEL 又叫做选择器，是表示一个方法的 <code>selector</code> 的指针，定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_selector *SEL;</span><br></pre></td></tr></table></figure>

<p>方法的 <code>selector</code> 用于表示运行时方法的名字。<code>Objective-C</code> 在编译时，会根据每一个方法的名字、参数序列，生成一个唯一的整型标识(<code>Int</code> 类型的地址)，这个标识就是 <code>SEL</code>。</p>
<p>两个类之间，不管它们是不是父类与子类的关系，还是之间没有这种关系，只要方法名相同，那么方法的 <code>SEL</code> 就是一样的。每一个方法都对应着一个 <code>SEL</code>。所以在 <code>Objective-C</code> 的同一个类(及类的继承体系)中，不能存在两个同名的方法，即使参数类型不同也不行。因为相同的方法只能对应一个 <code>SEL</code>，这导致 <code>Objectice-C</code> 在处理相同方法名且参数个数相同但类型不同的方法方面能力很差。</p>
<p>当然不同的类可以拥有相同的 <code>selector</code> ，这个没有问题。不同类的实例对象执行相同的 <code>selector</code> 时，会在各自的方法列表中根据 <code>selector</code> 去寻找自己对应的 <code>IMP</code>。</p>
<p>工程中的所有的 <code>SEL</code> 组成了一个 <code>Set</code> 集合，Set 特点就是唯一，因此 SEL 也是唯一的。因此，如果我们想到这个方法集合中查找某个方法时，只需要去找到这个方法对应的 SEL 就行了，SEL 实际上就是根据方法名 <code>hash</code> 化了的一个字符串，而对于字符串的比较仅仅需要比较它们的地址就可以了。</p>
<p>本质上，<code>SEL</code> 只是一个指向方法的指针(准确地说，只是一个根据方法名 <code>hash</code> 化了的 <code>KEY</code> 值，能唯一代表一个方法)，它的存在只是为了加快方法的查询速度。</p>
<p>我们可以在运行时添加新的 <code>selector</code> ，也可以在运行时获取已经存在的 <code>selector</code> ，我们可以通过下面三种方式来获取 <code>SEL</code> :</p>
<ul>
<li><code>sel_registerName</code> 函数</li>
<li><code>Objective-C</code> 编译器提供的 <code>@selector()</code></li>
<li><code>NSSelectorFromString()</code> 方法</li>
</ul>
<h4 id="IMP"><a href="#IMP" class="headerlink" title="IMP"></a>IMP</h4><p><code>IMP</code> 实际上是一个函数指针，指向函数实现的首地址。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id (*IMP)(id, SEL, ...)</span><br></pre></td></tr></table></figure>

<p>这个函数使用当前 <code>CPU</code> 架构实现的标准 C 调用约定。第一个参数是指向 <code>self</code> (如果是实例方法，则是类实例的内存地址；如果是类方法，则是指向元类的指针)的指针，第二个参数是 <code>selector</code> ，接下来是方法的实际参数列表。</p>
<p>通过取得 <code>IMP</code> ，我们可以跳过 <code>Runtime</code> 的消息传递机制，直接执行 <code>IMP</code> 指向的函数实现，这样就省去了 <code>Runtime</code> 消息传递过程中所做的一系列查找操作。</p>
<h4 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h4><p><code>Method</code> 用于表示类定义中的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_method *Method;</span><br><span class="line"></span><br><span class="line">struct objc_method &#123;</span><br><span class="line">  SEL	method_name			OBJC2_UNAVAILABLE;	&#x2F;&#x2F;	方法名</span><br><span class="line">  char  *method_types		OBJC2_UNAVAILABLE;	&#x2F;&#x2F;</span><br><span class="line">  IMP	method_imp			OBJC2_UNAVAILABLE;	&#x2F;&#x2F;	方法实现	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="方法操作相关函数"><a href="#方法操作相关函数" class="headerlink" title="方法操作相关函数"></a>方法操作相关函数</h3><p><code>Runtime</code> 提供了一系列的方法来处理与方法相关的操作，包括方法本身及 <code>SEL</code> 。</p>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>方法的相关操作函数如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 调用指定方法的实现</span><br><span class="line">id method_invoke ( id receiver, Method m, ... );</span><br><span class="line">&#x2F;&#x2F; 调用返回一个数据结构的方法的实现</span><br><span class="line">void method_invoke_stret ( id receiver, Method m, ... );</span><br><span class="line">&#x2F;&#x2F; 获取方法名</span><br><span class="line">SEL method_getName ( Method m );</span><br><span class="line">&#x2F;&#x2F; 返回方法的实现</span><br><span class="line">IMP method_getImplementation ( Method m );</span><br><span class="line">&#x2F;&#x2F; 获取描述方法参数和返回值类型的字符串</span><br><span class="line">const char * method_getTypeEncoding ( Method m );</span><br><span class="line">&#x2F;&#x2F; 获取方法的返回值类型的字符串</span><br><span class="line">char * method_copyReturnType ( Method m );</span><br><span class="line">&#x2F;&#x2F; 获取方法的指定位置参数的类型字符串</span><br><span class="line">char * method_copyArgumentType ( Method m, unsigned int index );</span><br><span class="line">&#x2F;&#x2F; 通过引用返回方法的返回值类型字符串</span><br><span class="line">void method_getReturnType ( Method m, char *dst, size_t dst_len );</span><br><span class="line">&#x2F;&#x2F; 返回方法的参数的个数</span><br><span class="line">unsigned int method_getNumberOfArguments ( Method m );</span><br><span class="line">&#x2F;&#x2F; 通过引用返回方法指定位置参数的类型字符串</span><br><span class="line">void method_getArgumentType ( Method m, unsigned int index, char *dst, size_t dst_len );</span><br><span class="line">&#x2F;&#x2F; 返回指定方法的方法描述结构体</span><br><span class="line">struct objc_method_description * method_getDescription ( Method m );</span><br><span class="line">&#x2F;&#x2F; 设置方法的实现</span><br><span class="line">IMP method_setImplementation ( Method m, IMP imp );</span><br><span class="line">&#x2F;&#x2F; 交换两个方法的实现</span><br><span class="line">void method_exchangeImplementations ( Method m1, Method m2 );</span><br></pre></td></tr></table></figure>

<ul>
<li><code>method_invoke</code>函数，返回的是实际实现的返回值。参数<code>receiver</code>不能为空。这个方法的效率会比<code>method_getImplementation</code>和<code>method_getName</code>更快。</li>
<li><code>method_getName</code>函数，返回的是一个<code>SEL</code>。如果想获取方法名的C字符串，可以使用<code>sel_getName(method_getName(method))</code>。</li>
<li><code>method_getReturnType</code>函数，类型字符串会被拷贝到<code>dst</code>中。</li>
<li><code>method_setImplementation</code>函数，注意该函数返回值是方法之前的实现。</li>
</ul>
<h4 id="方法选择器"><a href="#方法选择器" class="headerlink" title="方法选择器"></a>方法选择器</h4><p>选择器的相关操作函数包括 ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 返回给定选择器指定的方法的名称</span><br><span class="line">const char * sel_getName ( SEL sel );</span><br><span class="line">&#x2F;&#x2F; 在Objective-C Runtime系统中注册一个方法，将方法名映射到一个选择器，并返回这个选择器</span><br><span class="line">SEL sel_registerName ( const char *str );</span><br><span class="line">&#x2F;&#x2F; 在Objective-C Runtime系统中注册一个方法</span><br><span class="line">SEL sel_getUid ( const char *str );</span><br><span class="line">&#x2F;&#x2F; 比较两个选择器</span><br><span class="line">BOOL sel_isEqual ( SEL lhs, SEL rhs );</span><br></pre></td></tr></table></figure>

<ul>
<li><code>sel_registerName</code>函数：在我们将一个方法添加到类定义时，我们必须在<code>Objective-C Runtime</code>系统中注册一个方法名以获取方法的选择器。</li>
</ul>
<h3 id="方法调用流程"><a href="#方法调用流程" class="headerlink" title="方法调用流程"></a>方法调用流程</h3><p>在 <code>Objective-C</code> 中，消息直到运行时才绑定到方法实现上。编译器会将消息表达式 <code>[receiver message]</code> 转化为一个消息调用的函数，即 <code>objc_msgSend</code> 。这个函数将消息接收者和方法名作为其基础参数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objc_msgSend(receiver, selector)</span><br></pre></td></tr></table></figure>

<p>如果消息中还有其它参数，则该方法的形式如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objc_msgSend(receiver, selector, arg1, arg2, ...)</span><br></pre></td></tr></table></figure>

<p>这个函数完成了动态绑定的所有事情：</p>
<ul>
<li>首先它找到 <code>selector</code> 对应的方法实现。因为同一个方法在不同的类中有不同的实现，所以我们需要依赖于接收者的类来找到确切的实现。</li>
<li>它调用方法实现，并将接收者对象及方法的所有参数传递给它。</li>
<li>最后，它将实现返回的值作为它自己的返回值。</li>
</ul>
<p>消息的关键在于结构体 <code>objc_class</code> ，这个结构体中有两个字段是我们在分发消息时关注的：</p>
<ul>
<li>指向父类的指针</li>
<li>一个类的方法分发表，即 <code>methodLists</code>。</li>
</ul>
<p>当我们创建一个新对象时，先为其分配内存，并初始化其成员变量。其中 <code>isa</code> 指针也会被初始化，让对象可以访问类及类的继承体系。</p>
<p>当消息发送给一个对象时，<code>objc_msgSend</code> 通过对象的 <code>isa</code> 指针获取到类的结构体，然后在方法列表里查找方法的 <code>selector</code> 。如果没有找到 <code>selector</code> ，则通过 <code>objc_class</code> 结构体中指向父类的指针找到其父类，并在父类的方法列表里寻找方法的 <code>selector</code> 。依此，会一直沿着类的的继承体系到达 <code>NSObject</code> 类。一旦定位到 <code>selector</code> ，函数就会获取到实现的入口点，并传入相应的参数来执行方法的具体实现。如果没有定位到 <code>selector</code> ，则会走消息转发流程。</p>
<p>为了加速消息的处理，运行时系统缓存使用过的 <code>selector</code> 及对应的方法的地址。</p>
<h4 id="隐藏参数"><a href="#隐藏参数" class="headerlink" title="隐藏参数"></a>隐藏参数</h4><p><code>objc_msgSend</code> 有两个隐藏参数 ：</p>
<ul>
<li>消息接受对象</li>
<li>方法的 <code>selector</code></li>
</ul>
<p>这两个参数为方法的实现提供了调用者的信息，之所以说是隐藏的，是因为它们在定义方法的源代码中没有声明，而是在编译期被插入实现代码的。</p>
<p>虽然这些参数没有声明，但是我们仍然能在代码中引用它们。我们可以用 <code>self</code> 来引用接收者对象，使用 <code>_cmd</code> 来引用选择器。</p>
<h4 id="获取方法地址"><a href="#获取方法地址" class="headerlink" title="获取方法地址"></a>获取方法地址</h4><p><code>Runtime</code> 中方法的动态绑定让我们写代码时更具灵活性，如我们可以把消息转发给我们想要的对象，或者随意交换一个方法的实现等。不过灵活性的提升也带来了性能上的一些损耗。毕竟我们需要去查找方法的实现，而不像函数调用来得那么直接。当然，方法的缓存一定程度上解决了这一问题。</p>
<p>我们上面提到过，如果想要避开这种动态绑定方式，我们可以获取方法实现的地址，然后像调用函数一样来直接调用它。特别是当我们需要在一个循环内频繁地调用一个特定的方法时，通过这种方式可以提高程序的性能。</p>
<p><code>NSObject</code> 类提供了<code>methodForSelector:</code>方法，让我们可以获取到方法的指针，然后通过这个指针来调用实现代码。我们需要将<code>methodForSelector:</code>返回的指针转换为合适的函数类型，函数参数和返回值都需要匹配上。</p>
<p>我们通过以下代码来看看<code>methodForSelector:</code>的使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void (*setter)(id, SEL, BOOL);</span><br><span class="line">int i;</span><br><span class="line">setter &#x3D; (void (*)(id, SEL, BOOL))[target methodForSelector:@selector(setFilled:)];</span><br><span class="line">for (i &#x3D; 0 ; i &lt; 1000 ; i++)</span><br><span class="line">    setter(targetList[i], @selector(setFilled:), YES);</span><br></pre></td></tr></table></figure>

<p>这里需要注意的就是函数指针的前两个参数必须是<code>id</code>和<code>SEL</code>。</p>
<p>当然这种方式只适合于在类似于<code>for</code>循环这种情况下频繁调用同一方法，以提高性能的情况。另外，<code>methodForSelector:</code>是由Cocoa运行时提供的；它不是Objective-C语言的特性。</p>
<h3 id="消息转发"><a href="#消息转发" class="headerlink" title="消息转发"></a>消息转发</h3><p>当一个对象能接收一个消息时，就会走正常的方法调用流程。但如果一个对象无法接收指定消息时，又会发生什么事呢？默认情况下，如果是以<code>[object message]</code>的方式调用方法，如果<code>object</code>无法响应<code>message</code>消息时，编译器会报错。但如果是以<code>perform...</code>的形式来调用，则需要等到运行时才能确定object是否能接收<code>message</code>消息。如果不能，则程序崩溃。</p>
<p>通常，当我们不能确定一个对象是否能接收某个消息时，会先调用<code>respondsToSelector:</code>来判断一下。如下代码所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if ([self respondsToSelector:@selector(method)]) &#123;</span><br><span class="line">    [self performSelector:@selector(method)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不过，我们这边想讨论下不使用<code>respondsToSelector:</code>判断的情况。这才是我们这一节的重点。</p>
<p>当一个对象无法接收某一消息时，就会启动所谓”<strong>消息转发(message forwarding)</strong>“机制，通过这一机制，我们可以告诉对象如何处理未知的消息。默认情况下，对象接收到未知的消息，会导致程序崩溃，并由 <code>NSObject</code> 的 <code>doesNotRecognizeSelector</code> 方法抛出 ‘unrecognized selector sent to instance’ 错误信息。不过，我们可以采取一些措施，让我们的程序执行特定的逻辑，而避免程序的崩溃。</p>
<p>消息转发机制基本上分为三个步骤：</p>
<ol>
<li>动态方法解析</li>
<li>备用接收者</li>
<li>完整转发</li>
</ol>
<p>下面我们详细讨论一下这三个步骤。</p>
<h4 id="动态方法解析"><a href="#动态方法解析" class="headerlink" title="动态方法解析"></a>动态方法解析</h4><p>对象在接收到未知的消息时，首先会调用所属类的类方法<code>+resolveInstanceMethod:</code>(实例方法)或者<code>+resolveClassMethod:</code>(类方法)。在这个方法中，我们有机会为该未知消息新增一个”处理方法””。不过使用该方法的前提是我们已经实现了该”处理方法”，只需要在运行时通过<code>class_addMethod</code>函数动态添加到类里面就可以了。如下代码所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void functionForMethod1(id self, SEL _cmd) &#123;</span><br><span class="line">   NSLog(@&quot;%@, %p&quot;, self, _cmd);</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line">+ (BOOL)resolveInstanceMethod:(SEL)sel &#123;</span><br><span class="line">    NSString *selectorString &#x3D; NSStringFromSelector(sel);</span><br><span class="line">    if ([selectorString isEqualToString:@&quot;method1&quot;]) &#123;</span><br><span class="line">        class_addMethod(self.class, @selector(method1), (IMP)functionForMethod1, &quot;@:&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return [super resolveInstanceMethod:sel];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不过这种方案更多的是为了实现<code>@dynamic</code>属性。</p>
<h4 id="备用接收者"><a href="#备用接收者" class="headerlink" title="备用接收者"></a>备用接收者</h4><p>如果在上一步无法处理消息，则 <code>Runtime</code>会继续调以下方法 :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (id)forwardingTargetForSelector:(SEL)aSelector</span><br></pre></td></tr></table></figure>

<p>如果一个对象实现了这个方法，并返回一个非nil的结果，则这个对象会作为消息的新接收者，且消息会被分发到这个对象。当然这个对象不能是<code>self</code>自身，否则就是出现无限循环。当然，如果我们没有指定相应的对象来处理<code>aSelector</code>，则应该调用父类的实现来返回结果。</p>
<p>使用这个方法通常是在对象内部，可能还有一系列其它对象能处理该消息，我们便可借这些对象来处理消息并返回，这样在对象外部看来，还是由该对象亲自处理了这一消息。</p>
<p>这一步合适于我们只想将消息转发到另一个能处理该消息的对象上。但这一步无法对消息进行处理，如操作消息的参数和返回值。</p>
<h4 id="完整消息转发"><a href="#完整消息转发" class="headerlink" title="完整消息转发"></a>完整消息转发</h4><p>如果在上一步还不能处理未知消息，则唯一能做的就是启用完整的消息转发机制了。此时会调用以下方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)forwardInvocation:(NSInvocation *)anInvocation</span><br></pre></td></tr></table></figure>

<p>运行时系统会在这一步给消息接收者最后一次机会将消息转发给其它对象。对象会创建一个表示消息的<code>NSInvocation</code>对象，把与尚未处理的消息有关的全部细节都封装在<code>anInvocation</code>中，包括<code>selector</code>，目标(<code>target</code>)和参数。我们可以在<code>forwardInvocation</code>方法中选择将消息转发给其它对象。</p>
<p><code>forwardInvocation:</code>方法的实现有两个任务：</p>
<ol>
<li>定位可以响应封装在<code>anInvocation</code>中的消息的对象。这个对象不需要能处理所有未知消息。</li>
<li>使用<code>anInvocation</code>作为参数，将消息发送到选中的对象。<code>anInvocation</code>将会保留调用结果，运行时系统会提取这一结果并将其发送到消息的原始发送者。</li>
</ol>
<p>不过，在这个方法中我们可以实现一些更复杂的功能，我们可以对消息的内容进行修改，比如追回一个参数等，然后再去触发消息。另外，若发现某个消息不应由本类处理，则应调用父类的同名方法，以便继承体系中的每个类都有机会处理此调用请求。</p>
<p>还有一个很重要的问题，我们必须重写以下方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</span><br></pre></td></tr></table></figure>

<p>消息转发机制使用从这个方法中获取的信息来创建<code>NSInvocation</code>对象。因此我们必须重写这个方法，为给定的<code>selector</code>提供一个合适的方法签名。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector &#123;</span><br><span class="line">    NSMethodSignature *signature &#x3D; [super methodSignatureForSelector:aSelector];</span><br><span class="line">    if (!signature) &#123;</span><br><span class="line">        if ([SUTRuntimeMethodHelper instancesRespondToSelector:aSelector]) &#123;</span><br><span class="line">            signature &#x3D; [SUTRuntimeMethodHelper instanceMethodSignatureForSelector:aSelector];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return signature;</span><br><span class="line">&#125;</span><br><span class="line">- (void)forwardInvocation:(NSInvocation *)anInvocation &#123;</span><br><span class="line">    if ([SUTRuntimeMethodHelper instancesRespondToSelector:anInvocation.selector]) &#123;</span><br><span class="line">        [anInvocation invokeWithTarget:_helper];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>NSObject</code>的<code>forwardInvocation:</code>方法实现只是简单调用了<code>doesNotRecognizeSelector:</code>方法，它不会转发任何消息。这样，如果不在以上所述的三个步骤中处理未知消息，则会引发一个异常。</p>
<p>从某种意义上来讲，<code>forwardInvocation:</code>就像一个未知消息的分发中心，将这些未知的消息转发给其它对象。或者也可以像一个运输站一样将所有未知消息都发送给同一个接收对象。这取决于具体的实现。</p>
<h4 id="消息转发与多重继承"><a href="#消息转发与多重继承" class="headerlink" title="消息转发与多重继承"></a>消息转发与多重继承</h4><p>回过头来看第二和第三步，通过这两个方法我们可以允许一个对象与其它对象建立关系，以处理某些未知消息，而表面上看仍然是该对象在处理消息。通过这种关系，我们可以模拟“多重继承”的某些特性，让对象可以“继承”其它对象的特性来处理一些事情。不过，这两者间有一个重要的区别：多重继承将不同的功能集成到一个对象中，它会让对象变得过大，涉及的东西过多；而消息转发将功能分解到独立的小的对象中，并通过某种方式将这些对象连接起来，并做相应的消息转发。</p>
<p>不过消息转发虽然类似于继承，但<code>NSObject</code>的一些方法还是能区分两者。如<code>respondsToSelector:</code>和<code>isKindOfClass:</code>只能用于继承体系，而不能用于转发链。如果我们想让这种消息转发看起来像是继承，则可以重写这些方法，如以下代码所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)respondsToSelector:(SEL)aSelector</span><br><span class="line">&#123;</span><br><span class="line">	if ( [super respondsToSelector:aSelector])</span><br><span class="line">		return YES;</span><br><span class="line">	else &#123;</span><br><span class="line">		&#x2F;* Here, test whether the aSelector message can     *</span><br><span class="line">		 * be forwarded to another object and whether that  *</span><br><span class="line">		 * object can respond to it. Return YES if it can.  *&#x2F;</span><br><span class="line">	&#125;</span><br><span class="line">	return NO; 	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Objective-C-Runtime-Method-Swizzling"><a href="#Objective-C-Runtime-Method-Swizzling" class="headerlink" title="Objective-C Runtime Method Swizzling"></a>Objective-C Runtime Method Swizzling</h2><p><code>Method Swizzling</code>是改变一个<code>selector</code>的实际实现的技术。通过这一技术，我们可以在运行时通过修改类的分发表中<code>selector</code>对应的函数，来修改方法的实现。</p>
<p>例如，我们想跟踪在程序中每一个view controller展示给用户的次数：当然，我们可以在每个view controller的viewDidAppear中添加跟踪代码；但是这太过麻烦，需要在每个view controller中写重复的代码。创建一个子类可能是一种实现方式，但需要同时创建UIViewController, UITableViewController, UINavigationController及其它UIKit中view controller的子类，这同样会产生许多重复的代码。</p>
<p>这种情况下，我们就可以使用<code>Method Swizzling</code>，如在代码所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;objc&#x2F;runtime.h&gt;</span><br><span class="line"></span><br><span class="line">@implementation UIViewController (Tracking)</span><br><span class="line">  </span><br><span class="line">+ (void)load &#123;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        Class class &#x3D; [self class];         </span><br><span class="line">        &#x2F;&#x2F; When swizzling a class method, use the following:</span><br><span class="line">        &#x2F;&#x2F; Class class &#x3D; object_getClass((id)self);</span><br><span class="line">        SEL originalSelector &#x3D; @selector(viewWillAppear:);</span><br><span class="line">        SEL swizzledSelector &#x3D; @selector(xxx_viewWillAppear:);</span><br><span class="line">        Method originalMethod &#x3D; class_getInstanceMethod(class, originalSelector);</span><br><span class="line">        Method swizzledMethod &#x3D; class_getInstanceMethod(class, swizzledSelector);</span><br><span class="line">        BOOL didAddMethod &#x3D; class_addMethod(class,</span><br><span class="line">                originalSelector,</span><br><span class="line">                method_getImplementation(swizzledMethod),</span><br><span class="line">                method_getTypeEncoding(swizzledMethod));</span><br><span class="line">        if (didAddMethod) &#123;</span><br><span class="line">            class_replaceMethod(class,</span><br><span class="line">                swizzledSelector,</span><br><span class="line">                method_getImplementation(originalMethod),</span><br><span class="line">                method_getTypeEncoding(originalMethod));</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            method_exchangeImplementations(originalMethod, swizzledMethod);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark - Method Swizzling</span><br><span class="line">- (void)xxx_viewWillAppear:(BOOL)animated &#123;</span><br><span class="line">    [self xxx_viewWillAppear:animated];</span><br><span class="line">    NSLog(@&quot;viewWillAppear: %@&quot;, self);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>在这里，我们通过<code>method swizzling</code>修改了UIViewController的<code>@selector(viewWillAppear:)</code>对应的函数指针，使其实现指向了我们自定义的<code>xxx_viewWillAppear</code>的实现。这样，当UIViewController及其子类的对象调用<code>viewWillAppear</code>时，都会打印一条日志信息。</p>
<p>上面的例子很好地展示了使用<code>method swizzling</code>来向一个类中注入一些我们新的操作。当然，还有许多场景可以使用<code>method swizzling</code>，在此不多举例。在此我们说说使用<code>method swizzling</code>需要注意的一些问题：</p>
<h3 id="Swizzling应该总是在-load中执行"><a href="#Swizzling应该总是在-load中执行" class="headerlink" title="Swizzling应该总是在+load中执行"></a>Swizzling应该总是在+load中执行</h3><p>在<code>Objective-C</code>中，运行时会自动调用每个类的两个方法。<code>+load</code>会在类初始加载时调用，<code>+initialize</code>会在第一次调用类的类方法或实例方法之前被调用。这两个方法是可选的，且只有在实现了它们时才会被调用。由于<code>method swizzling</code>会影响到类的全局状态，因此要尽量避免在并发处理中出现竞争的情况。<code>+load</code>能保证在类的初始化过程中被加载，并保证这种改变应用级别的行为的一致性。相比之下，<code>+initialize</code>在其执行时不提供这种保证–事实上，如果在应用中没有给这个类发送消息，则它可能永远不会被调用。</p>
<h3 id="Swizzling应该总是在dispatch-once中执行"><a href="#Swizzling应该总是在dispatch-once中执行" class="headerlink" title="Swizzling应该总是在dispatch_once中执行"></a>Swizzling应该总是在dispatch_once中执行</h3><p>与上面相同，因为<code>swizzling</code>会改变全局状态，所以我们需要在运行时采取一些预防措施。原子性就是这样一种措施，它确保代码只被执行一次，不管有多少个线程。GCD的<code>dispatch_once</code>可以确保这种行为，我们应该将其作为<code>method swizzling</code>的最佳实践。</p>
<h3 id="选择器、方法与实现"><a href="#选择器、方法与实现" class="headerlink" title="选择器、方法与实现"></a>选择器、方法与实现</h3><p>在<code>Objective-C</code>中，选择器(<code>selector</code>)、方法(<code>method</code>)和实现(<code>implementation</code>)是运行时中一个特殊点，虽然在一般情况下，这些术语更多的是用在消息发送的过程描述中。</p>
<p>以下是<code>Objective-C Runtime Reference</code>中的对这几个术语一些描述：</p>
<ol>
<li><code>Selector(typedef struct objc_selector *SEL)</code>：用于在运行时中表示一个方法的名称。一个方法选择器是一个C字符串，它是在<code>Objective-C</code>运行时被注册的。选择器由编译器生成，并且在类被加载时由运行时自动做映射操作。</li>
<li><code>Method(typedef struct objc_method *Method)</code>：在类定义中表示方法的类型</li>
<li><code>Implementation(typedef id (*IMP)(id, SEL, ...))</code>：这是一个指针类型，指向方法实现函数的开始位置。这个函数使用为当前CPU架构实现的标准C调用规范。第一个参数是指向对象自身的指针(self)，第二个参数是方法选择器。然后是方法的实际参数。</li>
</ol>
<p>理解这几个术语之间的关系最好的方式是：一个类维护一个运行时可接收的消息分发表；分发表中的每个入口是一个方法(Method)，其中key是一个特定名称，即选择器(SEL)，其对应一个实现(IMP)，即指向底层C函数的指针。</p>
<p>为了swizzle一个方法，我们可以在分发表中将一个方法的现有的选择器映射到不同的实现，而将该选择器对应的原始实现关联到一个新的选择器中。</p>
<h3 id="调用-cmd"><a href="#调用-cmd" class="headerlink" title="调用 _cmd"></a>调用 _cmd</h3><p>我们回过头来看看前面新的方法的实现代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)xxx_viewWillAppear:(BOOL)animated &#123;</span><br><span class="line">    [self xxx_viewWillAppear:animated];</span><br><span class="line">    NSLog(@&quot;viewWillAppear: %@&quot;, NSStringFromClass([self class]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>乍看上去是会导致无限循环的。但令人惊奇的是，并没有出现这种情况。在swizzling的过程中，方法中的<code>[self xxx_viewWillAppear:animated]</code>已经被重新指定到UIViewController类的-viewWillAppear:中。在这种情况下，不会产生无限循环。不过如果我们调用的是<code>[self viewWillAppear:animated]</code>，则会产生无限循环，因为这个方法的实现在运行时已经被重新指定为<code>xxx_viewWillAppear:</code>了。</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>Swizzling通常被称作是一种黑魔法，容易产生不可预知的行为和无法预见的后果。虽然它不是最安全的，但如果遵从以下几点预防措施的话，还是比较安全的：</p>
<ol>
<li>总是调用方法的原始实现(除非有更好的理由不这么做)：API提供了一个输入与输出约定，但其内部实现是一个黑盒。Swizzle一个方法而不调用原始实现可能会打破私有状态底层操作，从而影响到程序的其它部分。</li>
<li>避免冲突：给自定义的分类方法加前缀，从而使其与所依赖的代码库不会存在命名冲突。</li>
<li>明白是怎么回事：简单地拷贝粘贴swizzle代码而不理解它是如何工作的，不仅危险，而且会浪费学习Objective-C运行时的机会。阅读<code>Objective-C Runtime Reference</code>和查看<code>&lt;objc/runtime.h&gt;</code>头文件以了解事件是如何发生的。</li>
<li>小心操作：无论我们对Foundation, UIKit或其它内建框架执行Swizzle操作抱有多大信心，需要知道在下一版本中许多事可能会不一样。</li>
</ol>
<h2 id="Objective-C-Runtime-中的协议与分类"><a href="#Objective-C-Runtime-中的协议与分类" class="headerlink" title="Objective-C Runtime 中的协议与分类"></a>Objective-C Runtime 中的协议与分类</h2><p><code>Objective-C</code> 中的分类允许我们通过给一个类添加方法来扩充它（但是通过<code>category</code>不能添加新的实例变量），并且我们不需要访问类中的代码就可以做到。</p>
<p><code>Objective-C</code> 中的协议是普遍存在的接口定义方式，即在一个类中通过<code>@protocol</code>定义接口，在另外类中实现接口，这种接口定义方式也称为“<code>delegation</code>”模式，<code>@protocol</code>声明了可以被其他任何方法类实现的方法，协议仅仅是定义一个接口，而由其他的类去负责实现。</p>
<h3 id="基础数据类型-2"><a href="#基础数据类型-2" class="headerlink" title="基础数据类型"></a>基础数据类型</h3><h4 id="Category"><a href="#Category" class="headerlink" title="Category"></a>Category</h4><p>Category 是表示一个指向分类的结构体的指针。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_category *Category;</span><br><span class="line"></span><br><span class="line">struct objc_category &#123;</span><br><span class="line">  	char *category_name                          OBJC2_UNAVAILABLE;	&#x2F;&#x2F; 分类名</span><br><span class="line">    char *class_name                             OBJC2_UNAVAILABLE;	&#x2F;&#x2F; 分类所属的类名</span><br><span class="line">    struct objc_method_list *instance_methods    OBJC2_UNAVAILABLE;	&#x2F;&#x2F; 实例方法列表</span><br><span class="line">    struct objc_method_list *class_methods       OBJC2_UNAVAILABLE;	&#x2F;&#x2F; 类方法列表</span><br><span class="line">    struct objc_protocol_list *protocols  		 OBJC2_UNAVAILABLE;	&#x2F;&#x2F; 分类所实现的协议列表    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个结构体主要包含了分类定义的实例方法与类方法，其中<code>instance_methods</code>列表是<code>objc_class</code>中方法列表的一个子集，而<code>class_methods</code>列表是元类方法列表的一个子集。</p>
<h4 id="Protocol"><a href="#Protocol" class="headerlink" title="Protocol"></a>Protocol</h4><p>Protocol 的定义如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_object Protocol;</span><br></pre></td></tr></table></figure>

<p>可以看到，<code>Protocol</code> 其实就是一个对象结构体。</p>
<h3 id="操作函数"><a href="#操作函数" class="headerlink" title="操作函数"></a>操作函数</h3><p><code>Runtime</code>并没有在<code>&lt;objc/runtime.h&gt;</code>头文件中提供针对分类的操作函数。因为这些分类中的信息都包含在<code>objc_class</code>中，我们可以通过针对<code>objc_class</code>的操作函数来获取分类的信息。</p>
<p>而对于Protocol，runtime提供了一系列函数来对其进行操作，这些函数包括：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 返回指定的协议</span><br><span class="line">Protocol * objc_getProtocol ( const char *name );</span><br><span class="line">&#x2F;&#x2F; 获取运行时所知道的所有协议的数组</span><br><span class="line">Protocol ** objc_copyProtocolList ( unsigned int *outCount );</span><br><span class="line">&#x2F;&#x2F; 创建新的协议实例</span><br><span class="line">Protocol * objc_allocateProtocol ( const char *name );</span><br><span class="line">&#x2F;&#x2F; 在运行时中注册新创建的协议</span><br><span class="line">void objc_registerProtocol ( Protocol *proto );</span><br><span class="line">&#x2F;&#x2F; 为协议添加方法</span><br><span class="line">void protocol_addMethodDescription ( Protocol *proto, SEL name, const char *types, BOOL isRequiredMethod, BOOL isInstanceMethod );</span><br><span class="line">&#x2F;&#x2F; 添加一个已注册的协议到协议中</span><br><span class="line">void protocol_addProtocol ( Protocol *proto, Protocol *addition );</span><br><span class="line">&#x2F;&#x2F; 为协议添加属性</span><br><span class="line">void protocol_addProperty ( Protocol *proto, const char *name, const objc_property_attribute_t *attributes, unsigned int attributeCount, BOOL isRequiredProperty, BOOL isInstanceProperty );</span><br><span class="line">&#x2F;&#x2F; 返回协议名</span><br><span class="line">const char * protocol_getName ( Protocol *p );</span><br><span class="line">&#x2F;&#x2F; 测试两个协议是否相等</span><br><span class="line">BOOL protocol_isEqual ( Protocol *proto, Protocol *other );</span><br><span class="line">&#x2F;&#x2F; 获取协议中指定条件的方法的方法描述数组</span><br><span class="line">struct objc_method_description * protocol_copyMethodDescriptionList ( Protocol *p, BOOL isRequiredMethod, BOOL isInstanceMethod, unsigned int *outCount );</span><br><span class="line">&#x2F;&#x2F; 获取协议中指定方法的方法描述</span><br><span class="line">struct objc_method_description protocol_getMethodDescription ( Protocol *p, SEL aSel, BOOL isRequiredMethod, BOOL isInstanceMethod );</span><br><span class="line">&#x2F;&#x2F; 获取协议中的属性列表</span><br><span class="line">objc_property_t * protocol_copyPropertyList ( Protocol *proto, unsigned int *outCount );</span><br><span class="line">&#x2F;&#x2F; 获取协议的指定属性</span><br><span class="line">objc_property_t protocol_getProperty ( Protocol *proto, const char *name, BOOL isRequiredProperty, BOOL isInstanceProperty );</span><br><span class="line">&#x2F;&#x2F; 获取协议采用的协议</span><br><span class="line">Protocol ** protocol_copyProtocolList ( Protocol *proto, unsigned int *outCount );</span><br><span class="line">&#x2F;&#x2F; 查看协议是否采用了另一个协议</span><br><span class="line">BOOL protocol_conformsToProtocol ( Protocol *proto, Protocol *other );</span><br></pre></td></tr></table></figure>

<ul>
<li><code>objc_getProtocol</code>函数，需要注意的是如果仅仅是声明了一个协议，而未在任何类中实现这个协议，则该函数返回的是<code>nil</code>。</li>
<li><code>objc_copyProtocolList</code>函数，获取到的数组需要使用<code>free()</code>来释放</li>
<li><code>objc_allocateProtocol</code>函数，如果同名的协议已经存在，则返回<code>nil</code></li>
<li><code>objc_registerProtocol</code>函数，创建一个新的协议后，必须调用该函数以在运行时中注册新的协议。协议注册后便可以使用，但不能再做修改，即注册完后不能再向协议添加方法或协议</li>
</ul>
<p>需要强调的是，协议一旦注册后就不可再修改，即无法再通过调用<code>protocol_addMethodDescription</code>、<code>protocol_addProtocol</code>和<code>protocol_addProperty</code>往协议中添加方法等。</p>
<h2 id="Objective-C-Runtime-补充知识"><a href="#Objective-C-Runtime-补充知识" class="headerlink" title="Objective-C Runtime 补充知识"></a>Objective-C Runtime 补充知识</h2><h3 id="super"><a href="#super" class="headerlink" title="super"></a>super</h3><p>在<code>Objective-C</code>中，如果我们需要在类的方法中调用父类的方法时，通常都会用到<code>super</code>。</p>
<p>如何使用<code>super</code>我们都知道。现在的问题是，它是如何工作的呢？</p>
<p>首先我们需要知道的是<code>super</code>与<code>self</code>不同。<code>self</code>是类的一个隐藏参数，每个方法的实现的第一个参数即为<code>self</code>。而<code>super</code>并不是隐藏参数，它实际上只是一个<strong>”编译器标示符”</strong>，它负责告诉编译器，当调用viewDidLoad方法时，去调用父类的方法，而不是本类中的方法。而它实际上与<code>self</code>指向的是相同的消息接收者。为了理解这一点，我们先来看看<code>super</code>的定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">struct objc_super &#123; id receiver; Class superClass; &#125;;</span><br></pre></td></tr></table></figure>

<p>这个结构体有两个成员：</p>
<ol>
<li>receiver：即消息的实际接收者</li>
<li>superClass：指针当前类的父类</li>
</ol>
<p>当我们使用<code>super</code>来接收消息时，编译器会生成一个<code>objc_super</code>结构体。就上面的例子而言，这个结构体的<code>receiver</code>就是当前对象，与<code>self</code>相同；<code>superClass</code>指向当前类的父类。</p>
<p>接下来，发送消息时，不是调用<code>objc_msgSend</code>函数，而是调用<code>objc_msgSendSuper</code>函数，其声明如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id objc_msgSendSuper ( struct objc_super *super, SEL op, ... );</span><br></pre></td></tr></table></figure>

<p>该函数第一个参数即为前面生成的<code>objc_super</code>结构体，第二个参数是方法的<code>selector</code>。该函数实际的操作是：从<code>objc_super</code>结构体指向的<code>superClass</code>的方法列表开始查找<code>viewDidLoad</code> 的<code>selector</code>，找到后以<code>objc-&gt;receiver</code>去调用这个<code>selector</code>，而此时的操作流程就是如下方式了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objc_msgSend(objc_super-&gt;receiver, @selector(viewDidLoad))</span><br></pre></td></tr></table></figure>

<p>由于<code>objc_super-&gt;receiver</code>就是<code>self</code>本身，所以该方法实际与下面这个调用是相同的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objc_msgSend(self, @selector(viewDidLoad))</span><br></pre></td></tr></table></figure>



<h3 id="库相关操作"><a href="#库相关操作" class="headerlink" title="库相关操作"></a>库相关操作</h3><p>库相关的操作主要是用于获取由系统提供的库相关的信息，主要包含以下函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 获取所有加载的Objective-C框架和动态库的名称</span><br><span class="line">const char ** objc_copyImageNames ( unsigned int *outCount );</span><br><span class="line">&#x2F;&#x2F; 获取指定类所在动态库</span><br><span class="line">const char * class_getImageName ( Class cls );</span><br><span class="line">&#x2F;&#x2F; 获取指定库或框架中所有类的类名</span><br><span class="line">const char ** objc_copyClassNamesForImage ( const char *image, unsigned int *outCount )</span><br></pre></td></tr></table></figure>

<p>通过这几个函数，我们可以了解到某个类所有的库，以及某个库中包含哪些类。</p>
<h3 id="块操作"><a href="#块操作" class="headerlink" title="块操作"></a>块操作</h3><p>我们都知道block给我们带到极大的方便，苹果也不断提供一些使用block的新的API。同时，苹果在runtime中也提供了一些函数来支持针对block的操作，这些函数包括：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建一个指针函数的指针，该函数调用时会调用特定的block</span><br><span class="line">IMP imp_implementationWithBlock ( id block );</span><br><span class="line">&#x2F;&#x2F; 返回与IMP(使用imp_implementationWithBlock创建的)相关的block</span><br><span class="line">id imp_getBlock ( IMP anImp );</span><br><span class="line">&#x2F;&#x2F; 解除block与IMP(使用imp_implementationWithBlock创建的)的关联关系，并释放block的拷贝</span><br><span class="line">BOOL imp_removeBlock ( IMP anImp );</span><br></pre></td></tr></table></figure>

<ul>
<li><code>imp_implementationWithBlock</code>函数：参数block的签名必须是<code>method_return_type ^(id self, method_args …)</code>形式的。该方法能让我们使用block作为<code>IMP</code>。</li>
</ul>
<h3 id="弱引用操作"><a href="#弱引用操作" class="headerlink" title="弱引用操作"></a>弱引用操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 加载弱引用指针引用的对象并返回</span><br><span class="line">id objc_loadWeak ( id *location );</span><br><span class="line">&#x2F;&#x2F; 存储__weak变量的新值</span><br><span class="line">id objc_storeWeak ( id *location, id obj );</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>objc_loadWeak</code>函数：该函数加载一个弱指针引用的对象，并在对其做<code>retain</code>和<code>autoreleasing</code>操作后返回它。这样，对象就可以在调用者使用它时保持足够长的生命周期。该函数典型的用法是在任何有使用<code>__weak</code>变量的表达式中使用。</p>
<p>●  <code>objc_storeWeak</code>函数：该函数的典型用法是用于<code>__weak</code>变量做为赋值对象时。</p>
</li>
</ul>
<h3 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h3><p>在<code>Runtime</code> 中，还定义了一些宏定义供我们使用，有些值我们会经常用到，如表示BOOL值的YES/NO；而有些值不常用，如<code>OBJC_ROOT_CLASS</code>。在此我们做一个简单的介绍。</p>
<h4 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define YES  (BOOL)1</span><br><span class="line">#define NO   (BOOL)0</span><br></pre></td></tr></table></figure>

<p>这两个宏定义定义了表示布尔值的常量，需要注意的是<code>YES</code>的值是1，而不是非0值。</p>
<h4 id="空值"><a href="#空值" class="headerlink" title="空值"></a>空值</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define nil  __DARWIN_NULL</span><br><span class="line">#define Nil  __DARWIN_NULL</span><br></pre></td></tr></table></figure>

<p>其中<code>nil</code>用于空的实例对象，而<code>Nil</code>用于空类对象。</p>
<h4 id="分发函数原型"><a href="#分发函数原型" class="headerlink" title="分发函数原型"></a>分发函数原型</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define OBJC_OLD_DISPATCH_PROTOTYPES  1</span><br></pre></td></tr></table></figure>

<p>该宏指明分发函数是否必须转换为合适的函数指针类型。当值为0时，必须进行转换</p>
<h4 id="Objective-C根类"><a href="#Objective-C根类" class="headerlink" title="Objective-C根类"></a>Objective-C根类</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define OBJC_ROOT_CLASS</span><br></pre></td></tr></table></figure>

<p>如果我们定义了一个<code>Objective-C</code>根类，则编译器会报错，指明我们定义的类没有指定一个基类。这种情况下，我们就可以使用这个宏定义来避过这个编译错误。该宏在iOS 7.0后可用。</p>
<p>其实在NSObject的声明中，我们就可以看到这个宏的身影，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">__OSX_AVAILABLE_STARTING(__MAC_10_0, __IPHONE_2_0)</span><br><span class="line"></span><br><span class="line">OBJC_ROOT_CLASS</span><br><span class="line">OBJC_EXPORT</span><br><span class="line"></span><br><span class="line">@interface NSObject &lt;NSObject&gt; &#123;</span><br><span class="line">    Class isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以参考这种方式来定义我们自己的根类。</p>
<h4 id="局部变量存储时长"><a href="#局部变量存储时长" class="headerlink" title="局部变量存储时长"></a>局部变量存储时长</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define NS_VALID_UNTIL_END_OF_SCOPE</span><br></pre></td></tr></table></figure>

<p>该宏表明存储在某些局部变量中的值在优化时不应该被编译器强制释放。</p>
<p>我们将局部变量标记为<code>id</code>类型或者是指向<code>ObjC</code>对象类型的指针，以便存储在这些局部变量中的值在优化时不会被编译器强制释放。相反，这些值会在变量再次被赋值之前或者局部变量的作用域结束之前都会被保存。</p>
<h4 id="关联对象行为"><a href="#关联对象行为" class="headerlink" title="关联对象行为"></a>关联对象行为</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">enum &#123;</span><br><span class="line">   OBJC_ASSOCIATION_ASSIGN  &#x3D; 0,</span><br><span class="line">   OBJC_ASSOCIATION_RETAIN_NONATOMIC  &#x3D; 1,</span><br><span class="line">   OBJC_ASSOCIATION_COPY_NONATOMIC  &#x3D; 3,</span><br><span class="line">   OBJC_ASSOCIATION_RETAIN  &#x3D; 01401,</span><br><span class="line">   OBJC_ASSOCIATION_COPY  &#x3D; 01403</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="Objective-C-Runtime-实际应用"><a href="#Objective-C-Runtime-实际应用" class="headerlink" title="Objective-C Runtime 实际应用"></a>Objective-C Runtime 实际应用</h2><h3 id="动态交换两个方法的实现"><a href="#动态交换两个方法的实现" class="headerlink" title="动态交换两个方法的实现"></a>动态交换两个方法的实现</h3><p>当第三方框架或系统原生方法功能不能满足我们的需求的时候，可以通过交换方法实现在保持原有方法功能的基础上，添加额外的功能。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+ (void)load &#123;</span><br><span class="line">  Method originalMethod	&#x3D; class_getClassMethod(self, @selector(originalMethodName));</span><br><span class="line">  Method targetMethod	&#x3D; class_getClassMethod(self, @selector(targetMethodName));</span><br><span class="line">  method_exchangeImplementations(originalMethod, targetMethod);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="动态添加属性"><a href="#动态添加属性" class="headerlink" title="动态添加属性"></a>动态添加属性</h3><p>属性赋值的本质就是让属性与一个对象产生关联。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@interface NSObject (AssociatedProperty)</span><br><span class="line">  </span><br><span class="line">@property NSString *propertyName;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line">  </span><br><span class="line">@implementation NSObject (AssociatedProperty)</span><br><span class="line">  </span><br><span class="line">- (void)setPropertyName:(NSString *)stringValue &#123;</span><br><span class="line">	objc_setAssociatedObject(self, @&quot;propertyName&quot;, stringValue, OBJC_ASSOCIATION_RETAIN_NONATOMIC);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSString *)propertyName &#123;</span><br><span class="line">	return objc_getAssociatedObject(self, @&quot;propertyName&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>



<h3 id="实现字典转模型的动态转换"><a href="#实现字典转模型的动态转换" class="headerlink" title="实现字典转模型的动态转换"></a>实现字典转模型的动态转换</h3><p>利用 <code>Runtime</code> 遍历模型中所有属性，根据模型的属性名，去字典中查找 key，去除对应的值，给模型的属性赋值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 最简单实现，不考虑字典中含有数组或对象的情况</span><br><span class="line">+ (instancetype)modelWithDict:(NSDictionary *)dict &#123;</span><br><span class="line">  id objc				&#x3D;	[[self alloc] init];</span><br><span class="line">  unsigned int count	&#x3D;	0;</span><br><span class="line">  Ivar *ivarList		&#x3D;	class_copyIvarList(self, &amp;count);</span><br><span class="line">  for (int index &#x3D; 0; index &lt; count; index++) &#123;</span><br><span class="line">    Ivar ivar	&#x3D; ivarList[index];</span><br><span class="line">    NSString *ivarName	&#x3D;	[NSString stringWithUTF8String:ivar_getName(ivar)];</span><br><span class="line">    NSString *key		&#x3D;	[ivarName substringFromIndex:1];</span><br><span class="line">    id value			&#x3D;	dict[key];</span><br><span class="line">    if (value) &#123;</span><br><span class="line">      [objc setValue:value forKey:key];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return objc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="动态添加方法"><a href="#动态添加方法" class="headerlink" title="动态添加方法"></a>动态添加方法</h3><p>如果一个类的方法很多，加载类到内存的时候比较耗费资源，使用动态给类添加方法的方式可以解决。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void methodAddWhenRun(id self, SEL _cmd, id argument ···) &#123;&#125;</span><br><span class="line"></span><br><span class="line">+ (BOOL)resolveInstanceMethod:(SEL)self &#123;</span><br><span class="line">  if (sel &#x3D;&#x3D;  NSSelectorFromString(@&quot;methodAddWhenRun&quot;)) &#123;</span><br><span class="line">    class_addMethod(self, sel, (IMP)methodAddWhenRun, &quot;v@:@&quot;);</span><br><span class="line">    return YES;</span><br><span class="line">  &#125;</span><br><span class="line">  return [super resolveInstanceMethod:sel];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="动态变量控制"><a href="#动态变量控制" class="headerlink" title="动态变量控制"></a>动态变量控制</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 假设要修改 &#96;_propertyName&#96;</span><br><span class="line">unsigned int count &#x3D; 0;</span><br><span class="line">Ivar *ivarList	&#x3D;	class_copyIvarList([self class], &amp;count);</span><br><span class="line">for (int index &#x3D; 0; index &lt; count; index++) &#123;</span><br><span class="line">  Ivar ivar		&#x3D;	ivarList[index];</span><br><span class="line">  const char *varName	&#x3D;	ivar_getName(ivar);</span><br><span class="line">  NSString *name		&#x3D;	[NSString stringWithUTF8String:varName];</span><br><span class="line">  if ([name isEqualToString:@&quot;_propertyName&quot;]) &#123;</span><br><span class="line">    object_setIvar([self class], var, (id)newValue);</span><br><span class="line">    break;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="实现-NSCoding-的自动归解档"><a href="#实现-NSCoding-的自动归解档" class="headerlink" title="实现 NSCoding 的自动归解档"></a>实现 NSCoding 的自动归解档</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">- (void)encodeWithCoder:(NSCoder *)encoder &#123;</span><br><span class="line">  unsigned int count &#x3D; 0;</span><br><span class="line">  Ivar *ivarList	 &#x3D; class_copyIvarList([TargetClass class], &amp;count);</span><br><span class="line">  for (int index &#x3D; 0; index &lt; count; index++) &#123;</span><br><span class="line">    Ivar ivar	&#x3D;	ivarList[index];</span><br><span class="line">    const char *name	&#x3D;	ivar_getName(ivar);</span><br><span class="line">    NSString *key		&#x3D;	[NSString stringWithUTF8String:name];</span><br><span class="line">    id value			&#x3D;	[self valueForKey:key];</span><br><span class="line">    [encoder encodObject:value forKey:key];</span><br><span class="line">  &#125;</span><br><span class="line">  free(ivarList);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (id)initWithCoder:(NSCoder *)decoder &#123;</span><br><span class="line">  if (self &#x3D; [super init]) &#123;</span><br><span class="line">    unsigned int count &#x3D; 0;</span><br><span class="line">    Ivar *ivarList	   &#x3D; class_copyIvaarList([TargetClass class], &amp;count);</span><br><span class="line">    for (int index &#x3D; 0; index &lt; count; index++) &#123;</span><br><span class="line">      Ivar ivar &#x3D; ivarList[index];</span><br><span class="line">      const char *name	&#x3D;	ivar_getName:(ivar);</span><br><span class="line">      NSString *key		&#x3D;	[NSString stringWithUTF8String:name];</span><br><span class="line">      id value			&#x3D;	[decoder decodeObjectForKey:key];</span><br><span class="line">      [self setValue:value forKey:key];</span><br><span class="line">    &#125;</span><br><span class="line">    free(ivarList);</span><br><span class="line">  &#125;</span><br><span class="line">  return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p><strong>转载整理自 <a href="http://southpeak.github.io/categories/objectivec/" target="_blank" rel="noopener">南风子的技术博客</a></strong></p>
</blockquote>
<blockquote>
<p>参考 <a href="https://baike.baidu.com/item/%E5%8A%A8%E6%80%81%E8%AF%AD%E8%A8%80/797407?fr=aladdin" target="_blank" rel="noopener">百度百科 动态语言</a></p>
</blockquote>
<blockquote>
<p>参考 <a href="http://www.jianshu.com/p/19f280afcb24" target="_blank" rel="noopener">白水ln的简书</a></p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.chenglei.tech/blogs/2016/01/06/%E7%BC%93%E5%AD%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blogs/images/avatar.gif">
      <meta itemprop="name" content="CocoaLei">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CocoaLei">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blogs/2016/01/06/%E7%BC%93%E5%AD%98/" class="post-title-link" itemprop="url">缓存</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-01-06 00:00:00" itemprop="dateCreated datePublished" datetime="2016-01-06T00:00:00+08:00">2016-01-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-07-17 13:46:36" itemprop="dateModified" datetime="2020-07-17T13:46:36+08:00">2020-07-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/CS/" itemprop="url" rel="index"><span itemprop="name">CS</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="强制缓存"><a href="#强制缓存" class="headerlink" title="强制缓存"></a>强制缓存</h2><p>强缓存策略在请求数据时，如果浏览器缓存中存在未失效的缓存数据，则直接从缓存中获取数据，不与服务器进行交互。只有在缓存中不存在要请求的数据或在缓存中的数据失效时，才会从服务器获取数据。</p>
<p><img src="https://raw.githubusercontent.com/CocoaLei/images/master/img/%E5%BC%BA%E5%88%B6%E7%BC%93%E5%AD%9801.png" alt="强制缓存01"></p>
<p>强缓存由 <code>Expires</code>/<code>Cache-control</code>/<code>Pragma</code> 三个 Header 属性进行控制。</p>
<ul>
<li><p><code>Expires</code></p>
<p>Expires 的值是一个 HTTP 日期，表示资源的过期时间。</p>
<p>在发起请求时，将 Expires 日期与系统时间进行对比，如果系统时间超过了 Expires 日期，则认为资源过期失效。</p>
<p>但由于系统时间和服务器时间可能不一致，会造成判断不准的问题。</p>
<p>Expires 在三个强缓存控制属性中<strong>优先级最低</strong>。</p>
</li>
<li><p><code>Cache-control</code></p>
<p>Cache-control 是 HTTP/1.1 中新增的特性，在请求头和响应头中都能使用，可用值如下</p>
<ul>
<li><p>max-age</p>
<p>max-age 的值是一个秒数，表示从起发起时到缓存过期的时间</p>
<p><code>max-age=10</code></p>
</li>
<li><p>no-cache</p>
<p>不使用强缓存，每次请求都需要和服务器验证</p>
</li>
<li><p>no-store</p>
<p>禁止使用缓存(<strong>包括协商缓存</strong>)，每次请求都向服务器请求最新的资源</p>
</li>
<li><p>private</p>
<p>不允许中间代理、CDN等缓存</p>
</li>
<li><p>public</p>
<p>允许中间代理、CDN等缓存</p>
</li>
<li><p>must-revalidate</p>
<p>缓存过期后必须向服务器验证</p>
</li>
</ul>
</li>
<li><p><code>Pragma</code></p>
<p>Pragma 只有一个属性值，就是 no-cache ，效果和 Cache-Control 中的 no-cache 一致，不使用强缓存，需要与服务器验证缓存是否新鲜，在 3 个头部属性中的<strong>优先级最高</strong>。</p>
</li>
</ul>
<h2 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h2><p>当浏览器的强缓存失效或在请求头中设置了不使用强缓存，并在请求头中设置了 <code>if-modified-since</code> 或 <code>if-none-match</code> 时，会将这两个属性值到服务器验证是否命中协商缓存。</p>
<p><img src="https://raw.githubusercontent.com/CocoaLei/images/master/img/%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%9801.png" alt="协商缓存01"></p>
<ul>
<li><p><code>ETag/If-None-Match</code></p>
<p>ETag/If-None-Match 的值是一串 hash 码，代表的是一个资源的标识符，当服务端的文件变化的时候，它的 hash码会随之改变，通过请求头中的 If-None-Match 和当前文件的 hash 值进行比较，如果相等则表示命中协商缓存。</p>
</li>
<li><p><code>Last-Modified/If-Modified-Since</code></p>
<p>Last-Modified/If-Modified-Since 的值代表的是文件的最后修改时间，第一次请求服务端会把资源的最后修改时间放到 Last-Modified 响应头中，第二次发起请求的时候，请求头会带上上一次响应头中的 Last-Modified 的时间，并放到 If-Modified-Since 请求头属性中，服务端根据文件最后一次修改时间和 If-Modified-Since 的值进行比较，如果相等，返回 304 ，并加载浏览器缓存。</p>
</li>
</ul>
<h2 id="缓存用处"><a href="#缓存用处" class="headerlink" title="缓存用处"></a>缓存用处</h2><ul>
<li>减少了冗余的数据传递，节省宽带流量</li>
<li>减少了服务器的负担，大大提高了网站性能</li>
<li>加快了客户端加载网页的速度 这也正是HTTP缓存属于客户端缓存的原因</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.chenglei.tech/blogs/2016/01/04/TCP&IP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blogs/images/avatar.gif">
      <meta itemprop="name" content="CocoaLei">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CocoaLei">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blogs/2016/01/04/TCP&IP/" class="post-title-link" itemprop="url">TCP/IP 协议族</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-01-04 00:00:00" itemprop="dateCreated datePublished" datetime="2016-01-04T00:00:00+08:00">2016-01-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-07-14 22:21:56" itemprop="dateModified" datetime="2020-07-14T22:21:56+08:00">2020-07-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/CS/" itemprop="url" rel="index"><span itemprop="name">CS</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="TCP-IP-协议族"><a href="#TCP-IP-协议族" class="headerlink" title="TCP/IP 协议族"></a>TCP/IP 协议族</h1><p><code>TCP/IP</code> 协议不是 <code>TCP</code> 和 <code>IP</code> 这两个协议的合称，而是指因特网整个 <code>TCP/IP</code> 协议族。</p>
<h2 id="参考模型"><a href="#参考模型" class="headerlink" title="参考模型"></a>参考模型</h2><h3 id="TCP-IP-参考模型"><a href="#TCP-IP-参考模型" class="headerlink" title="TCP/IP 参考模型"></a>TCP/IP 参考模型</h3><p><code>TCP/IP</code> 参考模型是首先由 ARPANET 所使用的网络体系结构。这个体系结构在它的两个主要协议出现以后被称为 <code>TCP/IP</code> 参考模型。这一网络协议一般分为四层：</p>
<ul>
<li><p>网络访问层/链路层，用来处理连接网络的硬件部分。</p>
</li>
<li><p>互联网层/网络层用来处理在网络上流动的数据包，是整个体系结构的关键部分，其功能是使主机可以把分组发往任何网络，并使分组独立地传向目标。这些分组可能经过不同的网络，到达的顺序和发送的顺序也可能不同。高层如果需要顺序收发，那就必须自行处理对分组的排序。互联网层使用因特网协议(<code>IP</code>)。</p>
</li>
<li><p>传输层为处于网络连接中的计算机之间的通信提供数据传输服务。在这一层定义了两个端到端的协议：传输控制协议(<code>TCP</code>)和用户数据报协议(<code>UDP</code>)。</p>
<ul>
<li><p><code>TCP</code> 是面向连接的协议，它提供可靠的报文传输和对上层应用的连接服务。为此，除了基本的数据传输外，它还有可靠性保证、流量控制、多路复用、优先权和安全性控制等功能。</p>
</li>
<li><p><code>UDP</code> 是面向无连接的不可靠传输协议，主要用于不需要 <code>TCP</code> 的排序和流量控制等功能的应用程序。</p>
</li>
</ul>
</li>
<li><p>应用层包含所有的高层协议，包括：虚拟终端协议(TELNET)、文件传输协议(FPT)、电子邮件传输协议(SMTP)、域名服务(DNS,)、网上新闻传输协议(NNTP)和超文本传输协议(HTTP)，这些协议为应用提供对应的通信服务。</p>
<ul>
<li><code>TELNET</code> 是远程登录服务的标准协议和主要方式，为用户提供了在本地计算机上完成远程主机工作的能力。<ul>
<li><code>FTP</code> 是用于在网络上进行文件传输的一套标准协议。</li>
</ul>
</li>
<li><code>SMTP</code> 是一个提供可靠且有效的电子邮件传输的协议，它建立在 <code>FTP</code> 服务之上，主要用于完成系统之间的邮件信息传递，并提供有关来信的通知。<ul>
<li><code>DNS</code> 主要用于域名和 IP 之间的相互转换，是一种分布式网络目录服务。</li>
</ul>
</li>
<li><code>NNTP</code> 用于新闻的发布、检索和获取。<ul>
<li><code>HTTP</code> 是一个基于 <code>TCP</code> 协议的用于客户端和服务端通信的 <code>请求-响应</code> 协议。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/CocoaLei/images/master/img/20200714091921.png" alt="image-20200714091919812"></p>
<h3 id="OSI-参考模型"><a href="#OSI-参考模型" class="headerlink" title="OSI 参考模型"></a>OSI 参考模型</h3><p>OSI 参考模型是国际标准化组织指定的一个用于计算机或通信系统之间互联的标准体系。</p>
<ul>
<li><p>物理层 - 通过物理媒体传输原始字节流</p>
</li>
<li><p>链路层 - 定义网络上数据的格式</p>
</li>
<li><p>网络层 - 决定数据通过哪条物理路径进行传输</p>
</li>
<li><p>传输层 - 通过传输协议传输数据</p>
</li>
<li><p>会话层 - 维护链接并负责控制端口和会话</p>
</li>
<li><p>展示层 - 保证数据的格式时可用并加密的</p>
</li>
<li><p>应用层 - 计算机交互层，在这里应用可以访问网络服务</p>
</li>
</ul>
<h2 id="TCP-IP-特点"><a href="#TCP-IP-特点" class="headerlink" title="TCP/IP 特点"></a>TCP/IP 特点</h2><ul>
<li>TCP/IP 协议不依赖于任何特定的计算机硬件或操作系统，提供开放的协议标准。</li>
<li>TCP/IP 并不依赖于特定的网络传输硬件，所以 TCP/IP 协议能够集成各种各样的网络。</li>
<li>统一的网络地址分配方案，使整个 TCP/IP 设备在网中都有唯一的地址。</li>
<li>标准化的高层协议，可以提供多种可靠的服务。</li>
</ul>
<h2 id="TCP-IP-通信传输流"><a href="#TCP-IP-通信传输流" class="headerlink" title="TCP/IP 通信传输流"></a>TCP/IP 通信传输流</h2><p>利用 TCP/IP 协议族进行网络通信时， 会通过分层顺序与对方进行通信。发送端从应用层往下走，接收端则往应用层往上走。</p>
<p>发送端在层与层之间传输数据时，每经过一层时必定会被打上一个 该层所属的首部信息。反之，接收端在层与层传输数据时，每经过一层 时会把对应的首部消去。</p>
<p>这种把数据信息包装起来的做法称为封装。</p>
<p><img src="https://raw.githubusercontent.com/CocoaLei/images/master/img/20200714103749.png" alt="image-20200714103627565"></p>
<h2 id="IP-协议"><a href="#IP-协议" class="headerlink" title="IP 协议"></a>IP 协议</h2><p><code>IP</code> 协议位于 <code>TCP/IP</code> 参考模型中的网络层，是整个 <code>TCP/IP</code> 协议族的核心，也是构成互联网的基础。它的主要内容包括：</p>
<ul>
<li>IP 编址方案</li>
<li>分组封装格式</li>
<li>分组转发规则</li>
</ul>
<h2 id="TCP-协议"><a href="#TCP-协议" class="headerlink" title="TCP 协议"></a>TCP 协议</h2><p><code>TCP</code> 协议位于参考模型中的传输层，是一种面向连接的、可靠的、基于字节流的传输层通信协议。当应用层向传输层发送用于网间传输的、用8位字节表示的数据流，<code>TCP</code> 则把数据流分割成适当长度的报文段( segment )，最大传输段大小通常受该计算机连接的网络的数据链路层的最大传送单元( MTU )限制。之后TCP把数据包传给IP层，由它来通过网络将包传送给接收端实体的TCP层。 </p>
<p>为了准确无误地将数据送达目标处，<code>TCP</code> 协议采用了三次握手策略来建立连接：</p>
<ol>
<li><p>发送端首先向接收端发送一个带有 <code>SYN</code> 标志的数据包</p>
</li>
<li><p>接收端接收到带有 <code>SYN</code> 标志的数据包后，返回带有 <code>ACK/SYN</code> 标志的数据包</p>
</li>
<li><p>发送端在接收到接收端回传的带有 <code>ACK/SYN</code> 标志的数据包后，发送带有 <code>ACK</code> 标志的数据包表示握手结束</p>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/CocoaLei/images/master/img/20200714140408.png" alt="三次握手"></p>
<p>连接建立后，就可以开始传输数据了。</p>
<p><code>TCP</code> 连接其实是接收端和客户端保存的一份关于对方的信息，如果 <code>IP</code> 地址、端口号等。</p>
<p>同样的，在断开连接时，<code>TCP</code> 会采用四次挥手策略来保证接数据发送安全和完整：</p>
<ol>
<li><p>当发送端的数据都传输完成后，发送端会向接收端发送连接释放报文 <code>FIN</code>。需要注意的是发送端发送 <code>FIN</code> 报文后，只是不能发送数据了，但是能正常接收数据的。</p>
</li>
<li><p>接收端收到发送端的 <code>FIN</code> 报文后，回复包含 <code>ACK</code> 标志的确认报文，此时接收端处于等待关闭状态，而不是马上给发送端发送 <code>FIN</code> 报文，因为可能还有数据没有发送完成。</p>
</li>
<li><p>接收端的数据发送完成后，发送带有 <code>ACK</code> 和 <code>FIN</code> 标志的连接释放报文给发送端。</p>
</li>
<li><p>发送端收到接收端的 <code>FIN</code> 报文后，向接收端发送 <code>ACK</code> 报文。此时接收端并不是立刻释放 <code>TCP</code> 连接，而是等待 2MSL( 最大报文段寿命的两倍时长 )后才释放连接。但是接收端一旦收到发送端的 <code>ACK</code> 报文后就会立马释放连接。</p>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/CocoaLei/images/master/img/20200714144614.png" alt="四次挥手"></p>
<h2 id="TCP-和-UDP"><a href="#TCP-和-UDP" class="headerlink" title="TCP 和 UDP"></a>TCP 和 UDP</h2><p><code>TCP</code> 是面向连接的传输控制协议，而 <code>UDP</code> 提供了无连接的数据报服务；</p>
<p><code>TCP</code> 具有高可靠性，确保传输数据的正确性，不出现丢失或乱序；<code>UDP</code> 在传输数据前不建立连接，不对数据报进行检查与修改，无须等待对方的应答，所以会出现分组丢失、重复、乱序，应用程序需要负责传输可靠性方面的所有工作；</p>
<p><code>UDP</code> 具有较好的实时性，工作效率较 <code>TCP</code> 协议高；</p>
<p><code>UDP</code> 段结构比 <code>TCP</code> 的段结构简单，因此网络开销也小。</p>
<p><code>TCP</code> 协议可以保证接收端毫无差错地接收到发送端发出的字节流，为应用程序提供可靠的通信服务。对可靠性要求高的通信系统往往使用 <code>TCP</code> 传输数据。比如 <code>HTTP</code> 运用 <code>TCP</code> 进行数据的传输。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.chenglei.tech/blogs/2016/01/02/HTTP%E6%A6%82%E8%A7%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blogs/images/avatar.gif">
      <meta itemprop="name" content="CocoaLei">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CocoaLei">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blogs/2016/01/02/HTTP%E6%A6%82%E8%A7%88/" class="post-title-link" itemprop="url">HTTP 概览</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-01-02 00:00:00" itemprop="dateCreated datePublished" datetime="2016-01-02T00:00:00+08:00">2016-01-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-07-14 22:20:51" itemprop="dateModified" datetime="2020-07-14T22:20:51+08:00">2020-07-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/CS/" itemprop="url" rel="index"><span itemprop="name">CS</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="HTTP-协议"><a href="#HTTP-协议" class="headerlink" title="HTTP 协议"></a>HTTP 协议</h2><p>开发中，我们经常需要向服务器端发送数据或从服务器端请求特定数据，为了完成数据在客户端和服务器端的传输，我们在传输数据时必须用到 HTTP 协议。</p>
<h3 id="什么是-HTTP-协议？"><a href="#什么是-HTTP-协议？" class="headerlink" title="什么是 HTTP 协议？"></a>什么是 HTTP 协议？</h3><p><code>HTTP</code> 协议，即 HyperText Transmission Protocol，超文本传输协议，定义了客户端与服务器端的数据传输规则，让客户端和服务器能够有效地进行数据沟通。</p>
<h3 id="HTTP-的基本性质"><a href="#HTTP-的基本性质" class="headerlink" title="HTTP 的基本性质"></a>HTTP 的基本性质</h3><ul>
<li>HTTP 是简单的</li>
<li>HTTP 是可扩展的 - 通过 HTTP headers 可以轻松对协议进行扩展</li>
<li>HTTP 是无状态，有会话的 - 在同一个连接中，两个执行成功的请求之间是没有关系的</li>
</ul>
<h3 id="HTTP-请求与响应"><a href="#HTTP-请求与响应" class="headerlink" title="HTTP 请求与响应"></a>HTTP 请求与响应</h3><h4 id="HTTP-请求"><a href="#HTTP-请求" class="headerlink" title="HTTP 请求"></a>HTTP 请求</h4><p>HTTP 协议规定，一个完整的 HTTP 请求应包含如下内容</p>
<ul>
<li><p>请求行 ：包含请求方法、请求统一资源标示符和 HTTP 版本号。</p>
</li>
<li><p>请求头 ：请求头包含客户端传送给服务器端的附加信息。</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>Host</td>
<td>目标服务器的网络地址</td>
</tr>
<tr>
<td>Accept</td>
<td>告知服务器端客户端能够接收的数据类型，如 ‘text/html’等</td>
</tr>
<tr>
<td>Content-Type</td>
<td>请求体中的数据类型，如 ‘Application/Json; charset=UTF-8’等</td>
</tr>
<tr>
<td>Accept-Language</td>
<td>客户端的语言环境，如 ‘zh-cn’ 等</td>
</tr>
<tr>
<td>Accept_Encoding</td>
<td>客户端支持的数据压缩格式，如 ‘gzip’ 等</td>
</tr>
<tr>
<td>User-Agent</td>
<td>客户端的软件环境</td>
</tr>
<tr>
<td>Connection : keep-alive</td>
<td>告知服务器这是一个持久连接</td>
</tr>
<tr>
<td>Content-Length</td>
<td>请求体的长度</td>
</tr>
<tr>
<td>Cookie</td>
<td>记录着用户保存在本地的用户数据</td>
</tr>
</tbody></table>
</li>
<li><p>请求体 ：发送给服务器端的数据</p>
<p>在使用 POST-Multipart 上传请求中请求体就是上传文件的二进制数据。</p>
<p>在使用 GET 请求时，请求体为空。</p>
<p>在普通的 POST 请求中，请求体就是表单数据。</p>
</li>
<li><p>响应状态行 ： 服务器返回给客户端的状态信息，一般包含 HTTP 版本号、状态码和状态码对应的英文名称。</p>
<p>一个典型的状态行如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HTTP&#x2F;1.1 200 OK</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h4 id="HTTP-响应"><a href="#HTTP-响应" class="headerlink" title="HTTP 响应"></a>HTTP 响应</h4><p>基本与 HTTP 请求相同。</p>
<h3 id="HTTP-的版本"><a href="#HTTP-的版本" class="headerlink" title="HTTP 的版本"></a>HTTP 的版本</h3><p>HTTP 的主要版本如下</p>
<table>
<thead>
<tr>
<th>Version</th>
<th>Feature</th>
</tr>
</thead>
<tbody><tr>
<td>&lt; HTTP 1.1</td>
<td>不支持持久连接；无请求头和响应头；客户端的前后请求是同步的。</td>
</tr>
<tr>
<td>HTTP 1.1</td>
<td>增加请求头和响应头；支持持久连接；客户端的不同请求之间是异步的。</td>
</tr>
<tr>
<td>HTTP 2.0</td>
<td>向下兼容 HTTP 1.1，但只用于 https 网址。</td>
</tr>
</tbody></table>
<h3 id="HTTP-缓存"><a href="#HTTP-缓存" class="headerlink" title="HTTP 缓存"></a>HTTP 缓存</h3><p>缓存是一种保存资源副本并在下次请求时直接使用该副本的技术。当 web 缓存发现请求的资源已经被存储，它会拦截请求，返回该资源的拷贝，而不会去源服务器重新下载。这样带来的好处有：缓解服务器端压力，提升性能(获取资源的耗时更短了)。对于网站来说，缓存是达到高性能的重要组成部分。缓存需要合理配置，因为并不是所有资源都是永久不变的：重要的是对一个资源的缓存应截止到其下一次发生改变（即不能缓存过期的资源）。</p>
<h4 id="缓存操作的目标"><a href="#缓存操作的目标" class="headerlink" title="缓存操作的目标"></a>缓存操作的目标</h4><p>虽然 HTTP 缓存不是必须的，但重用缓存的资源通常是必要的。然而常见的 HTTP 缓存智能存储 GET 响应。</p>
<h4 id="缓存控制"><a href="#缓存控制" class="headerlink" title="缓存控制"></a>缓存控制</h4><h5 id="Cache-control-头"><a href="#Cache-control-头" class="headerlink" title="Cache-control 头"></a><code>Cache-control</code> 头</h5><p>HTTP/1.1 定义的 <code>Cache-Control</code> 头用来区分对缓存机制的支持情况，请求头和响应头都支持这个属性，你可以通过它提供的不同的值来定义缓存策略。</p>
<ul>
<li><p>禁止进行缓存</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Canche-Control: no-store,</span><br><span class="line">Canche-Control: no-cache, no-store</span><br></pre></td></tr></table></figure>
</li>
<li><p>强制确认缓存</p>
<p>每次有请求发出时，缓存会将次请求发送到服务器，服务器端会验证请求中所描述的缓存是否过期，若未过期，则缓存才使用本地缓存副本</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: must-revalidate</span><br></pre></td></tr></table></figure>
</li>
<li><p>私有缓存和公共缓存</p>
<p><code>public</code> 指令表示该响应可以被任何中间人缓存。若指定了 <code>public</code> ，则一些通常不被中间人缓存的页面，将被缓存。</p>
<p><code>private</code> 则表示该响应是专用于某单个用户的，中间人不能缓存此响应。</p>
</li>
<li><p>缓存过期机制</p>
<p><code>max-age=&lt;seconds&gt;</code> 指令表示资源能够被缓存的最大时间，这个时间是距离请求发起的时间的秒数。一般用来缓存应用中不会改变的文件，通过手动设置一定的时长以保证缓存有效。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: max-age=10000</span><br></pre></td></tr></table></figure>
</li>
<li><p>缓存验证确认</p>
<p>当使用了 <code>must-revalidate</code> 指令，那就意味着缓存在考虑使用一个资源时，必须先验证它的状态，已过期的缓存将不被使用</p>
</li>
</ul>
<h5 id="Pargma-头"><a href="#Pargma-头" class="headerlink" title="Pargma 头"></a><code>Pargma</code> 头</h5><p><code>Pargma</code> 是 HTTP/1.1 标准中定义的一个 header 属性，请求中包含 <code>Pargma</code> 的效果跟在头信息中定义 <code>Cache-Control: no-cache</code> 相同，但是 HTTP 的响应头不支持这个属性，所以它不能完全替代 <code>Cache-Control</code> 头。</p>
<h4 id="新鲜度"><a href="#新鲜度" class="headerlink" title="新鲜度"></a>新鲜度</h4><p>在过期时间之前，缓存资源是新鲜的，否则是陈旧的。一个陈旧的资源是不会被直接清除的，当客户端发起一个请求时，检索到已经有一个对应的缓存副本，则会在此次请求上附加一个 <code>If-None-Match</code> 头，然后再发送给服务器，以此来检查此资源是否依然是新鲜的，若返回 <code>304 (Not Modified)</code> ，则表示该副本是新鲜的，否则返回新的资源。</p>
<h4 id="缓存验证"><a href="#缓存验证" class="headerlink" title="缓存验证"></a>缓存验证</h4><p>用户点击刷新按钮时会开始缓存验证。如果缓存的响应头信息里含有 <code>Cache-control: must-revalidate</code> 的定义，在浏览的过程中也会触发缓存验证。另外，在浏览器偏好设置里设置 <code>Advanced-&gt;Cache</code> 为强制验证缓存也能达到相同的效果。</p>
<p>当缓存的文档过期后，需要进行缓存验证或者重新获取资源。只有在服务器返回强校验器或者弱校验器时才会进行验证。</p>
<h5 id="ETag"><a href="#ETag" class="headerlink" title="ETag"></a><code>ETag</code></h5><p>作为缓存的一种强校验器，<code>ETag</code> 响应头是一个对用户代理不透明的值。对于像浏览器这样的 HTTP UA，不知道 <code>ETag</code> 代表什么，不能预测它的值是多少。如果资源请求的响应头里含有 <code>ETag</code>， 客户端可以在后续的请求的头中带上 <code>If-None-Match</code> 头来验证缓存。</p>
<p><code>Last-Modified</code> 响应头可以作为一种弱校验器。说它弱是因为它只能精确到一秒。如果响应头里含有这个信息，客户端可以在后续的请求中带上 <code>If-Modified-Since</code> 来验证缓存。</p>
<p>当向服务端发起缓存校验的请求时，服务端会返回 <code>200 ok</code> 表示返回正常的结果或者 <code>304 Not Modified</code>表示浏览器可以使用本地缓存文件。<code>304</code> 的响应头也可以同时更新缓存文档的过期时间。</p>
<p>需要注意的是 <code>If-None-Match</code> 的优先级高于 <code>If-Modified-Since</code>，两者同时存在的话，按照前者进行校验。</p>
<h4 id="带-Vary-头的响应"><a href="#带-Vary-头的响应" class="headerlink" title="带 Vary 头的响应"></a>带 <code>Vary</code> 头的响应</h4><p><code>Vary</code> HTTP 响应头决定了对于后续的请求头，如何判断是请求一个新的资源还会使用缓存的文件。</p>
<p>当缓存服务器收到一个请求，只有当前的请求和原始（缓存）的请求头跟缓存的响应头里的Vary都匹配，才能使用缓存的响应。</p>
<h3 id="HTTP-Cookies"><a href="#HTTP-Cookies" class="headerlink" title="HTTP Cookies"></a>HTTP Cookies</h3><p>HTTP Cookie（也叫Web Cookie或浏览器Cookie）是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。Cookie 使基于无状态的 HTTP 协议记录稳定的状态信息成为了可能。</p>
<h4 id="创建-Cookie"><a href="#创建-Cookie" class="headerlink" title="创建 Cookie"></a>创建 Cookie</h4><p>服务器通过在响应头里面添加一个 <code>Set-Cookie</code> 选项，来使浏览器保存下 Cookie，之后对该服务器的每一次请求中都通过 Cookie 请求头部将 Cookie 信息发送给服务器。</p>
<ul>
<li><p><code>Set-Cookie</code> 响应头部和 <code>Cookie</code> 请求头部</p>
<p>服务器使用 <code>Set-Cookie</code> 响应头部向用户代理发送 Cookie 信息</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: <span class="tag">&lt;<span class="name">name</span>&gt;</span>=<span class="tag">&lt;<span class="name">value</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>保存 Cookie 信息后，对该服务器发起的每一次新请求，浏览器都会将保存的 Cookie 信息通过 Cookeie 请求头再发送给服务器。</p>
</li>
<li><p>会话期 Cookie</p>
<p>会话期 Cookie 是最简单的 Cookie：浏览器关闭后它会被自动删除，即它仅在会话期内有效。</p>
<p>会话期 Cookie 不需要指定过期时间或者有效期</p>
</li>
<li><p>持久性 Cookie</p>
<p>持久性 Cookie 指定了特定的过期时间或有效期，不会随着浏览器的关闭而被删除。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Set-Cookie</span>: id=asfwa; </span><br><span class="line">Expires=Wed, 21 Oct 2015 07:28:00 GMT;</span><br></pre></td></tr></table></figure>

<p>设定的过期时间只和客户端有关，而不是服务端。</p>
</li>
<li><p>Cookie 的 <code>Secure</code> 和 <code>HttpOnly</code> 标记</p>
<p>标记为 <code>Secure</code> 的 Cookie 只应通过被 HTTPS 协议加密过的请求发送给服务器，但由于 Cookie 固有的不安全性，敏感信息不应该通过 Cookie 传输。</p>
<p>为避免跨域脚本攻击，通过 JavaScript 的 <code>Document.cookie</code> API 无法访问带有 <code>HttpOnly</code> 标记的 Cookie，它们只应发送给服务器。</p>
</li>
<li><p>Cookie 的作用域</p>
<p>通过 <code>Domain</code> 和 <code>Path</code> 标识可以定义 Cookie 的作用域：即 Cookie 应该发送给哪些 URL。</p>
<p><code>Domain</code> 指定哪些主机可以接受 Cookie，如果不指定，则默认为当前文档的主机，且不包含子域名。如果指定了，则会包含子域名。</p>
<p><code>Path</code> 指定主机下的哪些路径可以接受 Cookie，以字符 <code>%x2F</code> (即 <code>/</code>) 作为路径分隔符，子路径也会被匹配。</p>
</li>
<li><p><code>SameSite</code> Cookies</p>
<p><code>SameSite</code> Cookie 允许服务器要求某个 Cookie 在跨站请求时不会被发送，从而可以组织跨站请求伪造攻击。</p>
</li>
<li><p>JavaScript 通过 <code>document.cookies</code> 访问 Cookie</p>
<p>通过 <code>Document.cookie</code> 属性可创建新的 Cookie，也可以通过该属性访问非 <code>HttpOnly</code> 标记的 Cookie。</p>
</li>
</ul>
<h4 id="Cookie-安全"><a href="#Cookie-安全" class="headerlink" title="Cookie 安全"></a>Cookie 安全</h4><p>当机器处于不安全环境时，切记不能通过 Cookie 存储传输敏感信息。</p>
<ul>
<li><p>会话劫持和 XSS</p>
<p>在 Web 应用中， Cookie 常用来标记用户或授权会话。因此，如果 Web 应用的 Cookie 被窃取，可能导致授权用户的会话受到攻击。</p>
<p><code>HttpOnly</code> 类型的 Cookie 由于阻止了 JavaScript 对其的访问性能而在一定程度上缓解了此类攻击。</p>
</li>
<li><p>跨站请求伪造</p>
<p>通过以下方式可以一定程度上阻止宽展请求伪造：</p>
<ul>
<li>对用户输入进行过滤来阻止 XSS</li>
<li>任何敏感操作都需要确认</li>
<li>用于敏感信息的 Cookie 只能拥有较短的生命周期</li>
</ul>
</li>
</ul>
<h4 id="追踪和隐私"><a href="#追踪和隐私" class="headerlink" title="追踪和隐私"></a>追踪和隐私</h4><ul>
<li><p>第三方 Cookie</p>
<p>每个 Cookie 都会有与之关联的域（Domain），如果 Cookie 的域和页面的域相同，那么我们称这个 Cookie 为第一方 Cookie ，如果 Cookie 的域和页面的域不同，则称之为第三方Cookie。一个页面包含图片或存放在其他域上的资源（如图片广告）时，第一方的 Cookie 也只会发送给设置它们的服务器。通过第三方组件发送的第三方 Cookie 主要用于广告和网络追踪。</p>
</li>
<li><p>禁止追踪 Do-Not-Track</p>
<p>虽然并没有法律或者技术手段强制要求使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/DNT" target="_blank" rel="noopener"><code>DNT</code></a>，但是通过<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/DNT" target="_blank" rel="noopener"><code>DNT</code></a>可以告诉Web程序不要对用户行为进行追踪或者跨站追踪。</p>
</li>
<li><p>欧盟 Cookie 指令</p>
</li>
<li><p>僵尸 Cookie 和删不掉的 Cookie</p>
</li>
</ul>
<h3 id="HTTP-访问控制"><a href="#HTTP-访问控制" class="headerlink" title="HTTP 访问控制"></a>HTTP 访问控制</h3><p>跨域资源共享（CORS）是一种使用额外的 HTTP 头来使运行在一个 origin 上的 web 应用被准许访问来自不同源服务器上的指定的资源的机制，即当一个资源从与该资源本身所在的服务器不同的域、协议或端口请求一个资源时，就会发起一个跨域 HTTP请求。</p>
<p>跨域资源共享标准新增了一组 HTTP 首部字段，允许服务器声明哪些源站通过浏览器有权限访问哪些资源。对那些可能对服务器数据产生副作用的 HTTP 请求方法，浏览器必须首先使用 <code>OPTIONS</code> 方法发起一个预检请求（Preflight Request），从而获知服务端是否允许该跨域请求。服务端确认允许后，才发起实际的 HTTP 请求。</p>
<h3 id="HTTP-消息"><a href="#HTTP-消息" class="headerlink" title="HTTP 消息"></a>HTTP 消息</h3><p>HTTP 消息是客户端和服务器之间交换数据的方式。它们分为两种类型：由客户端发送的用来在服务器上触发动作的消息和从服务器得到的回应。</p>
<p>HTTP 消息由跨越多行的用 ASCII 编码的文本信息组成。在 HTTP/1.1 和更早期的版本的协议中，消息通过连接明文发送。在 HTTP/2 中，为了优化和性能提升，人类可读的消息被分割成 HTTP 帧。</p>
<h4 id="HTTP-Request"><a href="#HTTP-Request" class="headerlink" title="HTTP Request"></a>HTTP Request</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 请求头的名称是大小写不敏感的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Start line</span></span><br><span class="line"><span class="comment">// [HTTP Method] [Request Target] [HTTP Version]</span></span><br><span class="line">GET /img/me.png HTTP/<span class="number">1.1</span></span><br><span class="line">GET http:<span class="comment">//developer.mozilla.org/en-US/docs/Web/HTTP/Messages HTTP/1.1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Headers</span></span><br><span class="line"><span class="comment">// Request Headers : 对请求的设置</span></span><br><span class="line">User-Agent</span><br><span class="line">Accept</span><br><span class="line">Accept-Language</span><br><span class="line">Accept-Encoding</span><br><span class="line"></span><br><span class="line"><span class="comment">// General Headers : 作用于消息整体</span></span><br><span class="line">Connection</span><br><span class="line"></span><br><span class="line"><span class="comment">// Entity Headers : 作用与请求的 body 部分，如果 body 部分没有数据，则没有这部分头</span></span><br><span class="line">Content-Type</span><br><span class="line">Content-Length</span><br><span class="line"></span><br><span class="line"><span class="comment">// Body</span></span><br><span class="line"><span class="comment">// 大体上分为两类 : 单一资源 body 和多资源 body</span></span><br></pre></td></tr></table></figure>



<h4 id="HTTP-Response"><a href="#HTTP-Response" class="headerlink" title="HTTP Response"></a>HTTP Response</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Status line</span></span><br><span class="line"><span class="comment">// [HTTP Version] [Status Code] [Status Text]</span></span><br><span class="line">HTTP/<span class="number">1.1</span> <span class="number">404</span> Not Found</span><br><span class="line"></span><br><span class="line"><span class="comment">// Headers</span></span><br><span class="line"><span class="comment">// 与 HTTP Request 结构相似</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Body</span></span><br></pre></td></tr></table></figure>



<h4 id="HTTP-2-帧"><a href="#HTTP-2-帧" class="headerlink" title="HTTP/2 帧"></a>HTTP/2 帧</h4><p>HTTP/1.1 的消息在性能上有着一系列的缺点：</p>
<ul>
<li>Header 不像 body，它不会被压缩</li>
<li>两个报文之间的 header 通常非常相似，但它们仍然在连接中重复传输</li>
<li>无法复用。当在同一个服务器打开几个连接时：TCP 热连接比冷连接更加有效</li>
</ul>
<p>所以在 HTTP/2 中，消息被分割成嵌入到流中的帧。Headers 和 Body 的帧是分开的，这使得 Headers 帧也可以被压缩。多个流可以被组合在一起，这是一种称为多路复用的技术，它使得 TCP 连接下的传输更有效率。</p>
<h3 id="HTTP-会话"><a href="#HTTP-会话" class="headerlink" title="HTTP 会话"></a>HTTP 会话</h3><p>在类似 HTTP 的客户端-服务器协议中，会话由三个部分组成：</p>
<ul>
<li>客户端建立一个 TCP 连接</li>
<li>客户端发送请求，等待回应</li>
<li>服务器处理请求，做出回应</li>
</ul>
<p>从 HTTP/1.1 起，连接在完成第三部后不再被关闭，客户端被允许发起新的请求，这意味着第二和第三部可以重复进行多次。</p>
<p>客户端-服务器协议中，在 HTTP 中打开一个连接，意味着在底层传输层初始化连接。使用 TCP 时，HTTP 服务器默认的端口号是 80。</p>
<h3 id="HTTP-、Scoket-和-TCP-的区别"><a href="#HTTP-、Scoket-和-TCP-的区别" class="headerlink" title="HTTP 、Scoket 和 TCP 的区别"></a>HTTP 、Scoket 和 TCP 的区别</h3><p>HTTP 是应用层的协议，TCP 是传输层的协议，而 Socket 是从传输层抽象的一个抽象层，本质是接口。</p>
<ol>
<li><p>TCP 连接与 HTTP 连接的区别</p>
<p>HTTP 是基于 TCP的，客户端向服务器端发送一个 HTTP 请求时，第一步就是要建立与服务端的 TCP 连接。</p>
</li>
<li><p>TCP 连接与 Socket 连接的区别</p>
<p>Socket 层只是在 TCP/UDP 传输层上做的一个抽象接口层。</p>
<p>基于 TCP 协议的 Socket 连接同样需要通过三次握手建立连接，是可靠的。</p>
<p>基于 UDP 协议的 Socket 连接不需要建立连接的过程，不管对方能不能收到都会发送过去，是不可靠的。</p>
</li>
<li><p>HTTP 连接与 Socket 连接的区别</p>
<ul>
<li><p>HTTP 是短连接，基于 TCP 协议的 Socket 连接是长连接。尽管 HTTP 1.1 开始支持持久连接，但仍无法保证始终连接。</p>
<p>而基于 TCP 协议的 Socket 连接一旦建立成功，除非一方主动断开，否则连接状态一直保持。</p>
</li>
<li><p>HTTP 连接，服务器无法主动发送消息，而 Socket 连接，双发请求的发送没有先后限制。</p>
<p>HTTP 采用 ‘请求-响应’ 机制，在客户端没有发送请求给服务端时，服务端无法推送消息给客服端。</p>
<p>Socket 连接双方类似于 P2P 的关系，可以随时互相发送消息。</p>
</li>
</ul>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.chenglei.tech/blogs/2016/01/02/http-summary/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blogs/images/avatar.gif">
      <meta itemprop="name" content="CocoaLei">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CocoaLei">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blogs/2016/01/02/http-summary/" class="post-title-link" itemprop="url">网络编程基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-01-02 00:00:00" itemprop="dateCreated datePublished" datetime="2016-01-02T00:00:00+08:00">2016-01-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-09-03 15:17:34" itemprop="dateModified" datetime="2019-09-03T15:17:34+08:00">2019-09-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/CS/" itemprop="url" rel="index"><span itemprop="name">CS</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1><h2 id="TCP-IP-协议"><a href="#TCP-IP-协议" class="headerlink" title="TCP/IP 协议"></a>TCP/IP 协议</h2><h3 id="TCP-IP-协议的基本概念"><a href="#TCP-IP-协议的基本概念" class="headerlink" title="TCP/IP 协议的基本概念"></a>TCP/IP 协议的基本概念</h3><p><strong>TCP/IP 协议不是 TCP 和 IP 这两个协议的合称，而是指因特网整个 TCP/IP 协议族。</strong></p>
<p>TCP/IP 是 Transmission Control Protocol / Internet Protocol 的简写，即 ‘传输控制协议/因特网互联协议’，又名网络通讯协议，是 Internet 最基本的协议、Internet 国际互联网络的基础。</p>
<p>TCP/IP 由网络层的 IP 协议和传输层的 TCP 协议组成。</p>
<p>TCP/IP 定义了电子设备如何连如因特网，以及数据如何在它们之间传输的标准。协议采用了4层的层级架构，每一层都呼叫它的下一层所提供的协议来完成自己的需求。通俗而言，TCP  负责发现传输的问题，一旦发现问题就发出信号，要求重新传输，直到所有数据正确地传输到目的地。而 IP 是给因特网每一台联网设备规定一个地址。</p>
<h3 id="参考模型"><a href="#参考模型" class="headerlink" title="参考模型"></a>参考模型</h3><h4 id="TCP-IP-参考模型"><a href="#TCP-IP-参考模型" class="headerlink" title="TCP/IP 参考模型"></a>TCP/IP 参考模型</h4><p>TCP/IP 参考模型是首先由 ARPANET 所使用的网络体系结构。这个体系结构在它的两个主要协议出现以后被称为 TCP/IP 参考模型。这一网络协议共分为四层：</p>
<ul>
<li><p>网络访问层，即 Network Access Layer，在 TCP/IP 参考模型中并没有信息描述，只是指出主机必须使用某种协议与网络相连。</p>
</li>
<li><p>互联网层，即 Internet Layer，是整个体系结构的关键部分，其功能是使主机可以把分组发往任何网络，并使分组独立地传向目标。这些分组可能是经过不同的网络，到达的顺序和发送的顺序也可能不同。高层如果需要顺序收发，那就必须自行处理对分组的排序。互联网层使用因特网协议(IP, Internet Protocol)。</p>
</li>
<li><p>传输层，即 Transport Layer，使源端和目的端机器上的对等实体可以进行会话。在这一层定义了两个端到端的协议：传输控制协议(TCP，Transmission Control Protocol)和用户数据报协议(UDP，User Datagram Protocol)。</p>
<p>TCP 是面向连接的协议，它提供可靠的报文传输和对上层应用的连接服务。为此，除了基本的数据传输外，它还有可靠性保证、流量控制、多路复用、优先权和安全性控制等功能。</p>
<p>UDP 是面向无连接 的不可靠传输协议，主要用于不需要 TCP 的排序和流量控制等功能的应用程序。</p>
</li>
<li><p>应用层，即 Application Layer，包含所有的高层协议，包括：虚拟终端协议(TELNET, TELecommunications NETwork)、文件传输协议(FPT, File Transfer Protocol)、电子邮件传输协议(SMTP, Simple  Mail Transfer Protocol)、域名服务(DNS, Domain Name Service)、网上新闻传输协议(NNTP, Net News Transfer Protocol)和超文本传输协议(HTTP, HyperText Transfer Protocol)。</p>
<p>TELNET 允许一台机器上的用户登录到远程机器上，并进行工作。</p>
<p>FTP 提供了有效地将文件从一台机器上转移到另一台机器上的方法。</p>
<p>SMTP 用于电子邮件的收发。</p>
<p>DNS 用于把主机名映射到网络地址。</p>
<p>NNTP 用于新闻的发布、检索和获取。</p>
<p>HTTP 用于在 WWW 上获取网页。</p>
</li>
</ul>
<h4 id="OSI-参考模型"><a href="#OSI-参考模型" class="headerlink" title="OSI 参考模型"></a>OSI 参考模型</h4><p>OSI 参考模型是国际标准化组织指定的一个用于计算机或通信系统之间互联的标准体系。</p>
<ul>
<li><p>物理层 - 通过物理媒体传输原始字节流</p>
</li>
<li><p>链路层 - 定义网络上数据的格式</p>
</li>
<li><p>网络层 - 决定数据通过哪条物理路径进行传输</p>
</li>
<li><p>传输层 - 通过传输协议传输数据</p>
</li>
<li><p>会话层 - 维护链接并负责控制端口和会话</p>
</li>
<li><p>展示层 - 保证数据的格式时可用并加密的</p>
</li>
<li><p>应用层 - 计算机交互层，在这里应用可以访问网络服务</p>
</li>
</ul>
<h3 id="TCP-IP-特点"><a href="#TCP-IP-特点" class="headerlink" title="TCP/IP 特点"></a>TCP/IP 特点</h3><ul>
<li>TCP/IP 协议不依赖于任何特定的计算机硬件或操作系统，提供开放的协议标准。</li>
<li>TCP/IP 并不依赖于特定的网络传输硬件，所以 TCP/IP 协议能够集成各种各样的网络。</li>
<li>统一的网络地址分配方案，使整个 TCP/IP 设备在网中都有唯一的地址。</li>
<li>标准化的高层协议，可以提供多种可靠的服务。</li>
</ul>
<h2 id="HTTP-协议"><a href="#HTTP-协议" class="headerlink" title="HTTP 协议"></a>HTTP 协议</h2><p>开发中，我们经常需要向服务器端发送数据或从服务器端请求特定数据，为了完成数据在客户端和服务器端的传输，我们在传输数据时必须用到 HTTP 协议。</p>
<h3 id="什么是-HTTP-协议？"><a href="#什么是-HTTP-协议？" class="headerlink" title="什么是 HTTP 协议？"></a>什么是 HTTP 协议？</h3><p>HTTP 协议，即 HyperText Transmission Protocol，超文本传输协议，定义了客户端与服务器端的数据传输规则，让客户端和服务器能够有效地进行数据沟通。</p>
<h3 id="HTTP-的基本性质"><a href="#HTTP-的基本性质" class="headerlink" title="HTTP 的基本性质"></a>HTTP 的基本性质</h3><ul>
<li>HTTP 是简单的</li>
<li>HTTP 是可扩展的 - 通过 HTTP headers 可以轻松对协议进行扩展</li>
<li>HTTP 是无状态，有会话的 - 在同一个连接中，两个执行成功的请求之间是没有关系的</li>
</ul>
<h3 id="HTTP-请求与响应"><a href="#HTTP-请求与响应" class="headerlink" title="HTTP 请求与响应"></a>HTTP 请求与响应</h3><h4 id="HTTP-请求"><a href="#HTTP-请求" class="headerlink" title="HTTP 请求"></a>HTTP 请求</h4><p>HTTP 协议规定，一个完整的 HTTP 请求应包含如下内容</p>
<ul>
<li><p>请求行 ：包含请求方法、请求统一资源标示符和 HTTP 版本号。</p>
</li>
<li><p>请求头 ：请求头包含客户端传送给服务器端的附加信息。</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>Host</td>
<td>目标服务器的网络地址</td>
</tr>
<tr>
<td>Accept</td>
<td>告知服务器端客户端能够接收的数据类型，如 ‘text/html’等</td>
</tr>
<tr>
<td>Content-Type</td>
<td>请求体中的数据类型，如 ‘Application/Json; charset=UTF-8’等</td>
</tr>
<tr>
<td>Accept-Language</td>
<td>客户端的语言环境，如 ‘zh-cn’ 等</td>
</tr>
<tr>
<td>Accept_Encoding</td>
<td>客户端支持的数据压缩格式，如 ‘gzip’ 等</td>
</tr>
<tr>
<td>User-Agent</td>
<td>客户端的软件环境</td>
</tr>
<tr>
<td>Connection : keep-alive</td>
<td>告知服务器这是一个持久连接</td>
</tr>
<tr>
<td>Content-Length</td>
<td>请求体的长度</td>
</tr>
<tr>
<td>Cookie</td>
<td>记录着用户保存在本地的用户数据</td>
</tr>
</tbody></table>
</li>
<li><p>请求体 ：发送给服务器端的数据</p>
<p>在使用 POST-Multipart 上传请求中请求体就是上传文件的二进制数据。</p>
<p>在使用 GET 请求时，请求体为空。</p>
<p>在普通的 POST 请求中，请求体就是表单数据。</p>
</li>
<li><p>响应状态行 ： 服务器返回给客户端的状态信息，一般包含 HTTP 版本号、状态码和状态码对应的英文名称。</p>
<p>一个典型的状态行如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HTTP&#x2F;1.1 200 OK</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h4 id="HTTP-响应"><a href="#HTTP-响应" class="headerlink" title="HTTP 响应"></a>HTTP 响应</h4><p>基本与 HTTP 请求相同。</p>
<h3 id="HTTP-的版本"><a href="#HTTP-的版本" class="headerlink" title="HTTP 的版本"></a>HTTP 的版本</h3><p>HTTP 的主要版本如下</p>
<table>
<thead>
<tr>
<th>Version</th>
<th>Feature</th>
</tr>
</thead>
<tbody><tr>
<td>&lt; HTTP 1.1</td>
<td>不支持持久连接；无请求头和响应头；客户端的前后请求是同步的。</td>
</tr>
<tr>
<td>HTTP 1.1</td>
<td>增加请求头和响应头；支持持久连接；客户端的不同请求之间是异步的。</td>
</tr>
<tr>
<td>HTTP 2.0</td>
<td>向下兼容 HTTP 1.1，但只用于 https 网址。</td>
</tr>
</tbody></table>
<h3 id="HTTP-缓存"><a href="#HTTP-缓存" class="headerlink" title="HTTP 缓存"></a>HTTP 缓存</h3><p>缓存是一种保存资源副本并在下次请求时直接使用该副本的技术。当 web 缓存发现请求的资源已经被存储，它会拦截请求，返回该资源的拷贝，而不会去源服务器重新下载。这样带来的好处有：缓解服务器端压力，提升性能(获取资源的耗时更短了)。对于网站来说，缓存是达到高性能的重要组成部分。缓存需要合理配置，因为并不是所有资源都是永久不变的：重要的是对一个资源的缓存应截止到其下一次发生改变（即不能缓存过期的资源）。</p>
<h4 id="缓存操作的目标"><a href="#缓存操作的目标" class="headerlink" title="缓存操作的目标"></a>缓存操作的目标</h4><p>虽然 HTTP 缓存不是必须的，但重用缓存的资源通常是必要的。然而常见的 HTTP 缓存智能存储 GET 响应。</p>
<h4 id="缓存控制"><a href="#缓存控制" class="headerlink" title="缓存控制"></a>缓存控制</h4><h5 id="Cache-control-头"><a href="#Cache-control-头" class="headerlink" title="Cache-control 头"></a><code>Cache-control</code> 头</h5><p>HTTP/1.1 定义的 <code>Cache-Control</code> 头用来区分对缓存机制的支持情况，请求头和响应头都支持这个属性，你可以通过它提供的不同的值来定义缓存策略。</p>
<ul>
<li><p>禁止进行缓存</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Canche-Control: no-store,</span><br><span class="line">Canche-Control: no-cache, no-store</span><br></pre></td></tr></table></figure>
</li>
<li><p>强制确认缓存</p>
<p>每次有请求发出时，缓存会将次请求发送到服务器，服务器端会验证请求中所描述的缓存是否过期，若未过期，则缓存才使用本地缓存副本</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: must-revalidate</span><br></pre></td></tr></table></figure>
</li>
<li><p>私有缓存和公共缓存</p>
<p><code>public</code> 指令表示该响应可以被任何中间人缓存。若指定了 <code>public</code> ，则一些通常不被中间人缓存的页面，将被缓存。</p>
<p><code>private</code> 则表示该响应是专用于某单个用户的，中间人不能缓存此响应。</p>
</li>
<li><p>缓存过期机制</p>
<p><code>max-age=&lt;seconds&gt;</code> 指令表示资源能够被缓存的最大时间，这个时间是距离请求发起的时间的秒数。一般用来缓存应用中不会改变的文件，通过手动设置一定的时长以保证缓存有效。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: max-age=10000</span><br></pre></td></tr></table></figure>
</li>
<li><p>缓存验证确认</p>
<p>当使用了 <code>must-revalidate</code> 指令，那就意味着缓存在考虑使用一个资源时，必须先验证它的状态，已过期的缓存将不被使用</p>
</li>
</ul>
<h5 id="Pargma-头"><a href="#Pargma-头" class="headerlink" title="Pargma 头"></a><code>Pargma</code> 头</h5><p><code>Pargma</code> 是 HTTP/1.1 标准中定义的一个 header 属性，请求中包含 <code>Pargma</code> 的效果跟在头信息中定义 <code>Cache-Control: no-cache</code> 相同，但是 HTTP 的响应头不支持这个属性，所以它不能完全替代 <code>Cache-Control</code> 头。</p>
<h4 id="新鲜度"><a href="#新鲜度" class="headerlink" title="新鲜度"></a>新鲜度</h4><p>在过期时间之前，缓存资源是新鲜的，否则是陈旧的。一个陈旧的资源是不会被直接清除的，当客户端发起一个请求时，检索到已经有一个对应的缓存副本，则会在此次请求上附加一个 <code>If-None-Match</code> 头，然后再发送给服务器，以此来检查此资源是否依然是新鲜的，若返回 <code>304 (Not Modified)</code> ，则表示该副本是新鲜的，否则返回新的资源。</p>
<h4 id="缓存验证"><a href="#缓存验证" class="headerlink" title="缓存验证"></a>缓存验证</h4><p>用户点击刷新按钮时会开始缓存验证。如果缓存的响应头信息里含有 <code>Cache-control: must-revalidate</code> 的定义，在浏览的过程中也会触发缓存验证。另外，在浏览器偏好设置里设置 <code>Advanced-&gt;Cache</code> 为强制验证缓存也能达到相同的效果。</p>
<p>当缓存的文档过期后，需要进行缓存验证或者重新获取资源。只有在服务器返回强校验器或者弱校验器时才会进行验证。</p>
<h5 id="ETag"><a href="#ETag" class="headerlink" title="ETag"></a><code>ETag</code></h5><p>作为缓存的一种强校验器，<code>ETag</code> 响应头是一个对用户代理不透明的值。对于像浏览器这样的 HTTP UA，不知道 <code>ETag</code> 代表什么，不能预测它的值是多少。如果资源请求的响应头里含有 <code>ETag</code>， 客户端可以在后续的请求的头中带上 <code>If-None-Match</code> 头来验证缓存。</p>
<p><code>Last-Modified</code> 响应头可以作为一种弱校验器。说它弱是因为它只能精确到一秒。如果响应头里含有这个信息，客户端可以在后续的请求中带上 <code>If-Modified-Since</code> 来验证缓存。</p>
<p>当向服务端发起缓存校验的请求时，服务端会返回 <code>200 ok</code> 表示返回正常的结果或者 <code>304 Not Modified</code>表示浏览器可以使用本地缓存文件。<code>304</code> 的响应头也可以同时更新缓存文档的过期时间。</p>
<p>需要注意的是 <code>If-None-Match</code> 的优先级高于 <code>If-Modified-Since</code>，两者同时存在的话，按照前者进行校验。</p>
<h4 id="带-Vary-头的响应"><a href="#带-Vary-头的响应" class="headerlink" title="带 Vary 头的响应"></a>带 <code>Vary</code> 头的响应</h4><p><code>Vary</code> HTTP 响应头决定了对于后续的请求头，如何判断是请求一个新的资源还会使用缓存的文件。</p>
<p>当缓存服务器收到一个请求，只有当前的请求和原始（缓存）的请求头跟缓存的响应头里的Vary都匹配，才能使用缓存的响应。</p>
<h3 id="HTTP-Cookies"><a href="#HTTP-Cookies" class="headerlink" title="HTTP Cookies"></a>HTTP Cookies</h3><p>HTTP Cookie（也叫Web Cookie或浏览器Cookie）是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。Cookie 使基于无状态的 HTTP 协议记录稳定的状态信息成为了可能。</p>
<h4 id="创建-Cookie"><a href="#创建-Cookie" class="headerlink" title="创建 Cookie"></a>创建 Cookie</h4><p>服务器通过在响应头里面添加一个 <code>Set-Cookie</code> 选项，来使浏览器保存下 Cookie，之后对该服务器的每一次请求中都通过 Cookie 请求头部将 Cookie 信息发送给服务器。</p>
<ul>
<li><p><code>Set-Cookie</code> 响应头部和 <code>Cookie</code> 请求头部</p>
<p>服务器使用 <code>Set-Cookie</code> 响应头部向用户代理发送 Cookie 信息</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: <span class="tag">&lt;<span class="name">name</span>&gt;</span>=<span class="tag">&lt;<span class="name">value</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>保存 Cookie 信息后，对该服务器发起的每一次新请求，浏览器都会将保存的 Cookie 信息通过 Cookeie 请求头再发送给服务器。</p>
</li>
<li><p>会话期 Cookie</p>
<p>会话期 Cookie 是最简单的 Cookie：浏览器关闭后它会被自动删除，即它仅在会话期内有效。</p>
<p>会话期 Cookie 不需要指定过期时间或者有效期</p>
</li>
<li><p>持久性 Cookie</p>
<p>持久性 Cookie 指定了特定的过期时间或有效期，不会随着浏览器的关闭而被删除。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Set-Cookie</span>: id=asfwa; </span><br><span class="line">Expires=Wed, 21 Oct 2015 07:28:00 GMT;</span><br></pre></td></tr></table></figure>

<p>设定的过期时间只和客户端有关，而不是服务端。</p>
</li>
<li><p>Cookie 的 <code>Secure</code> 和 <code>HttpOnly</code> 标记</p>
<p>标记为 <code>Secure</code> 的 Cookie 只应通过被 HTTPS 协议加密过的请求发送给服务器，但由于 Cookie 固有的不安全性，敏感信息不应该通过 Cookie 传输。</p>
<p>为避免跨域脚本攻击，通过 JavaScript 的 <code>Document.cookie</code> API 无法访问带有 <code>HttpOnly</code> 标记的 Cookie，它们只应发送给服务器。</p>
</li>
<li><p>Cookie 的作用域</p>
<p>通过 <code>Domain</code> 和 <code>Path</code> 标识可以定义 Cookie 的作用域：即 Cookie 应该发送给哪些 URL。</p>
<p><code>Domain</code> 指定哪些主机可以接受 Cookie，如果不指定，则默认为当前文档的主机，且不包含子域名。如果指定了，则会包含子域名。</p>
<p><code>Path</code> 指定主机下的哪些路径可以接受 Cookie，以字符 <code>%x2F</code> (即 <code>/</code>) 作为路径分隔符，子路径也会被匹配。</p>
</li>
<li><p><code>SameSite</code> Cookies</p>
<p><code>SameSite</code> Cookie 允许服务器要求某个 Cookie 在跨站请求时不会被发送，从而可以组织跨站请求伪造攻击。</p>
</li>
<li><p>JavaScript 通过 <code>document.cookies</code> 访问 Cookie</p>
<p>通过 <code>Document.cookie</code> 属性可创建新的 Cookie，也可以通过该属性访问非 <code>HttpOnly</code> 标记的 Cookie。</p>
</li>
</ul>
<h4 id="Cookie-安全"><a href="#Cookie-安全" class="headerlink" title="Cookie 安全"></a>Cookie 安全</h4><p>当机器处于不安全环境时，切记不能通过 Cookie 存储传输敏感信息。</p>
<ul>
<li><p>会话劫持和 XSS</p>
<p>在 Web 应用中， Cookie 常用来标记用户或授权会话。因此，如果 Web 应用的 Cookie 被窃取，可能导致授权用户的会话受到攻击。</p>
<p><code>HttpOnly</code> 类型的 Cookie 由于阻止了 JavaScript 对其的访问性能而在一定程度上缓解了此类攻击。</p>
</li>
<li><p>跨站请求伪造</p>
<p>通过以下方式可以一定程度上阻止宽展请求伪造：</p>
<ul>
<li>对用户输入进行过滤来阻止 XSS</li>
<li>任何敏感操作都需要确认</li>
<li>用于敏感信息的 Cookie 只能拥有较短的生命周期</li>
</ul>
</li>
</ul>
<h4 id="追踪和隐私"><a href="#追踪和隐私" class="headerlink" title="追踪和隐私"></a>追踪和隐私</h4><ul>
<li><p>第三方 Cookie</p>
<p>每个 Cookie 都会有与之关联的域（Domain），如果 Cookie 的域和页面的域相同，那么我们称这个 Cookie 为第一方 Cookie ，如果 Cookie 的域和页面的域不同，则称之为第三方Cookie。一个页面包含图片或存放在其他域上的资源（如图片广告）时，第一方的 Cookie 也只会发送给设置它们的服务器。通过第三方组件发送的第三方 Cookie 主要用于广告和网络追踪。</p>
</li>
<li><p>禁止追踪 Do-Not-Track</p>
<p>虽然并没有法律或者技术手段强制要求使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/DNT" target="_blank" rel="noopener"><code>DNT</code></a>，但是通过<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/DNT" target="_blank" rel="noopener"><code>DNT</code></a>可以告诉Web程序不要对用户行为进行追踪或者跨站追踪。</p>
</li>
<li><p>欧盟 Cookie 指令</p>
</li>
<li><p>僵尸 Cookie 和删不掉的 Cookie</p>
</li>
</ul>
<h3 id="HTTP-访问控制"><a href="#HTTP-访问控制" class="headerlink" title="HTTP 访问控制"></a>HTTP 访问控制</h3><p>跨域资源共享（CORS）是一种使用额外的 HTTP 头来使运行在一个 origin 上的 web 应用被准许访问来自不同源服务器上的指定的资源的机制，即当一个资源从与该资源本身所在的服务器不同的域、协议或端口请求一个资源时，就会发起一个跨域 HTTP请求。</p>
<p>跨域资源共享标准新增了一组 HTTP 首部字段，允许服务器声明哪些源站通过浏览器有权限访问哪些资源。对那些可能对服务器数据产生副作用的 HTTP 请求方法，浏览器必须首先使用 <code>OPTIONS</code> 方法发起一个预检请求（Preflight Request），从而获知服务端是否允许该跨域请求。服务端确认允许后，才发起实际的 HTTP 请求。</p>
<h3 id="HTTP-消息"><a href="#HTTP-消息" class="headerlink" title="HTTP 消息"></a>HTTP 消息</h3><p>HTTP 消息是客户端和服务器之间交换数据的方式。它们分为两种类型：由客户端发送的用来在服务器上触发动作的消息和从服务器得到的回应。</p>
<p>HTTP 消息由跨越多行的用 ASCII 编码的文本信息组成。在 HTTP/1.1 和更早期的版本的协议中，消息通过连接明文发送。在 HTTP/2 中，为了优化和性能提升，人类可读的消息被分割成 HTTP 帧。</p>
<h4 id="HTTP-Request"><a href="#HTTP-Request" class="headerlink" title="HTTP Request"></a>HTTP Request</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 请求头的名称是大小写不敏感的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Start line</span></span><br><span class="line"><span class="comment">// [HTTP Method] [Request Target] [HTTP Version]</span></span><br><span class="line">GET /img/me.png HTTP/<span class="number">1.1</span></span><br><span class="line">GET http:<span class="comment">//developer.mozilla.org/en-US/docs/Web/HTTP/Messages HTTP/1.1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Headers</span></span><br><span class="line"><span class="comment">// Request Headers : 对请求的设置</span></span><br><span class="line">User-Agent</span><br><span class="line">Accept</span><br><span class="line">Accept-Language</span><br><span class="line">Accept-Encoding</span><br><span class="line"></span><br><span class="line"><span class="comment">// General Headers : 作用于消息整体</span></span><br><span class="line">Connection</span><br><span class="line"></span><br><span class="line"><span class="comment">// Entity Headers : 作用与请求的 body 部分，如果 body 部分没有数据，则没有这部分头</span></span><br><span class="line">Content-Type</span><br><span class="line">Content-Length</span><br><span class="line"></span><br><span class="line"><span class="comment">// Body</span></span><br><span class="line"><span class="comment">// 大体上分为两类 : 单一资源 body 和多资源 body</span></span><br></pre></td></tr></table></figure>



<h4 id="HTTP-Response"><a href="#HTTP-Response" class="headerlink" title="HTTP Response"></a>HTTP Response</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Status line</span></span><br><span class="line"><span class="comment">// [HTTP Version] [Status Code] [Status Text]</span></span><br><span class="line">HTTP/<span class="number">1.1</span> <span class="number">404</span> Not Found</span><br><span class="line"></span><br><span class="line"><span class="comment">// Headers</span></span><br><span class="line"><span class="comment">// 与 HTTP Request 结构相似</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Body</span></span><br></pre></td></tr></table></figure>



<h4 id="HTTP-2-帧"><a href="#HTTP-2-帧" class="headerlink" title="HTTP/2 帧"></a>HTTP/2 帧</h4><p>HTTP/1.1 的消息在性能上有着一系列的缺点：</p>
<ul>
<li>Header 不像 body，它不会被压缩</li>
<li>两个报文之间的 header 通常非常相似，但它们仍然在连接中重复传输</li>
<li>无法复用。当在同一个服务器打开几个连接时：TCP 热连接比冷连接更加有效</li>
</ul>
<p>所以在 HTTP/2 中，消息被分割成嵌入到流中的帧。Headers 和 Body 的帧是分开的，这使得 Headers 帧也可以被压缩。多个流可以被组合在一起，这是一种称为多路复用的技术，它使得 TCP 连接下的传输更有效率。</p>
<h3 id="HTTP-会话"><a href="#HTTP-会话" class="headerlink" title="HTTP 会话"></a>HTTP 会话</h3><p>在类似 HTTP 的客户端-服务器协议中，会话由三个部分组成：</p>
<ul>
<li>客户端建立一个 TCP 连接</li>
<li>客户端发送请求，等待回应</li>
<li>服务器处理请求，做出回应</li>
</ul>
<p>从 HTTP/1.1 起，连接在完成第三部后不再被关闭，客户端被允许发起新的请求，这意味着第二和第三部可以重复进行多次。</p>
<p>客户端-服务器协议中，在 HTTP 中打开一个连接，意味着在底层传输层初始化连接。使用 TCP 时，HTTP 服务器默认的端口号是 80。</p>
<h3 id="HTTP-、Scoket-和-TCP-的区别"><a href="#HTTP-、Scoket-和-TCP-的区别" class="headerlink" title="HTTP 、Scoket 和 TCP 的区别"></a>HTTP 、Scoket 和 TCP 的区别</h3><p>HTTP 是应用层的协议，TCP 是传输层的协议，而 Socket 是从传输层抽象的一个抽象层，本质是接口。</p>
<ol>
<li><p>TCP 连接与 HTTP 连接的区别</p>
<p>HTTP 是基于 TCP的，客户端向服务器端发送一个 HTTP 请求时，第一步就是要建立与服务端的 TCP 连接。</p>
</li>
<li><p>TCP 连接与 Socket 连接的区别</p>
<p>Socket 层只是在 TCP/UDP 传输层上做的一个抽象接口层。</p>
<p>基于 TCP 协议的 Socket 连接同样需要通过三次握手建立连接，是可靠的。</p>
<p>基于 UDP 协议的 Socket 连接不需要建立连接的过程，不管对方能不能收到都会发送过去，是不可靠的。</p>
</li>
<li><p>HTTP 连接与 Socket 连接的区别</p>
<ul>
<li><p>HTTP 是短连接，基于 TCP 协议的 Socket 连接是长连接。尽管 HTTP 1.1 开始支持持久连接，但仍无法保证始终连接。</p>
<p>而基于 TCP 协议的 Socket 连接一旦建立成功，除非一方主动断开，否则连接状态一直保持。</p>
</li>
<li><p>HTTP 连接，服务器无法主动发送消息，而 Socket 连接，双发请求的发送没有先后限制。</p>
<p>HTTP 采用 ‘请求-响应’ 机制，在客户端没有发送请求给服务端时，服务端无法推送消息给客服端。</p>
<p>Socket 连接双方类似于 P2P 的关系，可以随时互相发送消息。</p>
</li>
</ul>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.chenglei.tech/blogs/2015/12/01/iOS-Memory-Management/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blogs/images/avatar.gif">
      <meta itemprop="name" content="CocoaLei">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CocoaLei">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blogs/2015/12/01/iOS-Memory-Management/" class="post-title-link" itemprop="url">内存管理理解与分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2015-12-01 00:00:00" itemprop="dateCreated datePublished" datetime="2015-12-01T00:00:00+08:00">2015-12-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-01-17 11:36:08" itemprop="dateModified" datetime="2019-01-17T11:36:08+08:00">2019-01-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="iOS-内存管理"><a href="#iOS-内存管理" class="headerlink" title="iOS 内存管理"></a>iOS 内存管理</h1><h3 id="iOS-中的程序内存结构"><a href="#iOS-中的程序内存结构" class="headerlink" title="iOS 中的程序内存结构"></a>iOS 中的程序内存结构</h3><hr>
<p>在 iOS 程序中，内存可以粗略的分为五个区域：</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Descroption</th>
</tr>
</thead>
<tbody><tr>
<td>栈</td>
<td>由操作系统自动分配和释放，常用来存放函数的参数值、局部变量的值等。优点是快速高效，缺点是有限制，数据</td>
</tr>
<tr>
<td>堆</td>
<td>一般由程序员分配和释放，常用来存储对象</td>
</tr>
<tr>
<td>全局区</td>
<td>用来存储已经初始化的全局变量和静态变量，程序结束时才会被释放回收</td>
</tr>
<tr>
<td>常量区</td>
<td>用来存储常量的区域，程序结束时才会被释放回收</td>
</tr>
<tr>
<td>代码段</td>
<td>用来存放程序的执行代码，直到程序结束才会释放回首</td>
</tr>
</tbody></table>
<p>在 iOS程序中，只有堆区中存放的数据是需要手动释放回收的，其它区域存储的数据的释放和回收都由系统进行管理。当一个 iOS 程序启动后，它的全局区、常量区和代码区就已经确定了。</p>
<ul>
<li><p>栈区 (stack) 是由编译器自动分配和释放，用来存放函数的参数值、局部变量等。栈是系统数据结构，对应进程/线程是唯一的。优点是快速高效，缺点是有限制，数据不灵活。</p>
</li>
<li><p>堆区 (heap) 由程序员分配和释放，如果程序员不释放，程序结束时，可能由操作系统回收。优点是灵活方便，数据适应面广泛，但是效率有一定降低。</p>
</li>
<li><p>全局区/静态区 (static) 存放全局变量和静态变量，初始话的全局变量和静态变量存放在一块区域，未初始化的全局变量和静态变量在另一块区域，程序结束后由系统自动释放。</p>
</li>
<li><p>文字常量区，用来存储常量字符串，程序结束后由系统释放。</p>
</li>
<li><p>代码区，存放函数的二进制代码</p>
<p>​</p>
</li>
</ul>
<h3 id="iOS-中的内存管理"><a href="#iOS-中的内存管理" class="headerlink" title="iOS 中的内存管理"></a>iOS 中的内存管理</h3><hr>
<p>因为 iOS 程序的内存分配中，只有堆区是有程序员进行管理的，所以 iOS 的内存管理大致上就是可以认为是堆区内存的管理。</p>
<p>在 Objective-C 中，使用引用计数来确定一个对象所占有的内存空间是否应该被回收。它的工作原理可以描述为：</p>
<blockquote>
<p><strong>Objective-C 中的每一个对象都有一个类型为 unsigned long 的 retainCount 的属性，这个属性由拥有它的对象进行维护。当我们新创建出这个对象的一个实例时，这个对象实例的 retainCount 值为1，每当一个新的引用指向对象，对象的 retainCount 值就会增加1，每当这个对象实例的引用减少一个，retainCount 的值就减少1。当着对象实例的 retainCount 的值为0时，代表这个对象实例没有被引用，系统会自动将这个对象实例的内存空间回收并同时调用这个实例对象的 dealloc 方法。</strong></p>
</blockquote>
<p>需要注意的几个问题：</p>
<ul>
<li>常量是没有引用计数的</li>
<li>使用对象实例的属性值进行赋值，不会引用这个对象</li>
<li>释放对象实例时会调用 dealloc 方法，如果没有调用则会造成内存泄漏</li>
<li>对引用计数为1的对象实例发送 release 消息时，系统不会再对其进行 retainCount - 1 的操作。</li>
</ul>
<h4 id="MRC-和-ARC"><a href="#MRC-和-ARC" class="headerlink" title="MRC 和 ARC"></a>MRC 和 ARC</h4><p>使用对象实例的引用计数来进行 iOS的内存管理，分为两种方式：</p>
<ul>
<li>MRC ：手动引用计数，由程序员手动的管理对象实例的引用计数</li>
<li>ARC ：自动引用计数，是基于 MRC 的，系统自动的管理对象实例的引用计数</li>
</ul>
<p>实际上在 iOS 5 之后，Apple 就开始推荐使用 ARC 来进行 iOS 程序的内存管理工作，目前 MRC 已经非常少见。</p>
<p>ARC 中，编译器会在编译时在代码中插入合适的 retain 和 release 语句。</p>
<h5 id="ARC-中的修饰符"><a href="#ARC-中的修饰符" class="headerlink" title="ARC 中的修饰符"></a>ARC 中的修饰符</h5><p>ARC 中有四种修饰符</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>__strong</td>
<td>强引用，默认值，持有所指向对象的所有权</td>
</tr>
<tr>
<td>__weak</td>
<td>弱引用，不持有所指向对象的所有权，所指向的对象销毁后，引用会自动置为 nil</td>
</tr>
<tr>
<td>__autoreleasing</td>
<td>自动释放对象的引用，一般用来传递参数</td>
</tr>
<tr>
<td>__unsafe_unretained</td>
<td>为兼容 MRC 出现的修饰符，可看成 MRC 下的 weak</td>
</tr>
</tbody></table>
<h5 id="属性的内存管理"><a href="#属性的内存管理" class="headerlink" title="属性的内存管理"></a>属性的内存管理</h5><p>常见的属性修饰符</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>assign</td>
<td>直接赋值，一般用来修饰基本数据类型。修饰 Objc 对会造成野指针</td>
</tr>
<tr>
<td>retain</td>
<td>保留新值，再释放旧值，再设置新值</td>
</tr>
<tr>
<td>copy</td>
<td>拷贝新值，再释放旧值，再设置新值</td>
</tr>
<tr>
<td>weak</td>
<td>ARC 新引入，可代替 assign，自动置 nil</td>
</tr>
<tr>
<td>strong</td>
<td>ARC 新引入，可代替 retain</td>
</tr>
</tbody></table>
<h5 id="block-的内存管理"><a href="#block-的内存管理" class="headerlink" title="block 的内存管理"></a>block 的内存管理</h5><p>使用@property声明一个 block 时，使用 copy 来修饰。</p>
<p>block 会对内部使用的对象进行强应用，在使用时可能会造成循环引用，可通过添加弱引用标记来解决：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__weak typeof(self) weakSelf	&#x3D;	self;</span><br></pre></td></tr></table></figure>

<h4 id="Autorelease-amp-AutoreleasePool"><a href="#Autorelease-amp-AutoreleasePool" class="headerlink" title="Autorelease &amp; AutoreleasePool"></a>Autorelease &amp; AutoreleasePool</h4><p>在实际的情境中，经常会遇到不知道一个对象实例再什么时候不再使用，因而造成不知道应该何时才能将其释放的情况。Objective-C 中提供了 autorelease 方法来解决这个问题。</p>
<p>当给一个对象实例发送 autorelease 消息时，它会被添加到合适的自动释放池中，当自动释放池销毁时，会给自动释放池中的所有对象实例发送 release 消息。</p>
<p><strong>autorelease 不会改变对象的引用计数。</strong></p>
<p>创建自动释放池的两种方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 1</span><br><span class="line">NSAutoreleasePool	*pool	&#x3D;	[[NSAutoreleasePool alloc] init];</span><br><span class="line">[pool release];</span><br><span class="line">&#x2F;&#x2F; 2</span><br><span class="line">@autoreleasepool &#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>值得注意的是自动释放池实质上只是在销毁时给其中的所有对象发送了 release 消息，并不保证对象一定会被销毁。</p>
<h3 id="内存管理问题和解决方案"><a href="#内存管理问题和解决方案" class="headerlink" title="内存管理问题和解决方案"></a>内存管理问题和解决方案</h3><h4 id="僵尸对象和野指针"><a href="#僵尸对象和野指针" class="headerlink" title="僵尸对象和野指针"></a>僵尸对象和野指针</h4><p>僵尸对象是指内存已经被回收的对象，而野指针是指向僵尸对象的指针。</p>
<p>向野指针发送消息会导致程序崩溃，就是经典的 : EXC_BAD_ACCESS 错误。</p>
<p>所以为了避免产生僵尸对象和野指针，在对象释放后，应将其指针置为 nil。</p>
<h4 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h4><p>当对象之间相互拥有彼此的强引用，形成闭环引用时，就称为循环引用。</p>
<p>循环引用会造成程序内存消耗过高、程序闪退等问题。</p>
<p>以下几种情况可能会造成循环引用：</p>
<ul>
<li><p>由于父类指针可以指向子类对象，当父类对象和子类对象相互引用时，就造成了循环引用</p>
</li>
<li><p>作为对象属性的 block 中强引用了对象，造成循环引用，解决方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__weak typeof(self) weakSelf &#x3D; self;</span><br><span class="line"> self.testObject.testCircleBlock &#x3D; ^&#123;</span><br><span class="line">      __strong typeof (weakSelf) strongSelf &#x3D; weakSelf;</span><br><span class="line">      [strongSelf doSomething];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 strong 修饰符修饰代理属性，造成循环引用</p>
</li>
<li><p>作为属性的 NSTimer，造成循环引用</p>
</li>
</ul>
<h4 id="循环中对象占用内存大"><a href="#循环中对象占用内存大" class="headerlink" title="循环中对象占用内存大"></a>循环中对象占用内存大</h4><p>常见于循环次数较大，循环体生成的对象占用内存较大的情景。</p>
<p>可通过在循环中创建自己的 autoreleasePool 或及时释放占用内存大的 临时变量来解决。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.chenglei.tech/blogs/2015/11/20/iOS-RunLoop/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blogs/images/avatar.gif">
      <meta itemprop="name" content="CocoaLei">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CocoaLei">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blogs/2015/11/20/iOS-RunLoop/" class="post-title-link" itemprop="url">RunLoop 探索与分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2015-11-20 00:00:00" itemprop="dateCreated datePublished" datetime="2015-11-20T00:00:00+08:00">2015-11-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-01-17 11:36:00" itemprop="dateModified" datetime="2019-01-17T11:36:00+08:00">2019-01-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="RunLoop-基础"><a href="#RunLoop-基础" class="headerlink" title="RunLoop 基础"></a>RunLoop 基础</h2><h3 id="什么是RunLoop？"><a href="#什么是RunLoop？" class="headerlink" title="什么是RunLoop？"></a>什么是RunLoop？</h3><p>RunLoop 是一种让线程能随时处理事件但并不退出的机制，是一个用来调度工作的和协调接受的事件的循环。</p>
<p>iOS系统中，提供了 NSRunLoop 和 CFRunLoopRef 两个对象来实现 RunLoop。RunLoop 对象管理其需要处理的事件和消息，并提供了一个入口函数来执行事件循环的逻辑。线程执行了这个函数之后，就会一直处于这个函数内部的循环中，直到这个循环结束，函数返回。</p>
<p>CFRunLoopRef 是在 CoreFoundation 框架内的，提供了纯C函数的API，所有这些API都是线程安全的。</p>
<p>NSRunLoop 是基于 CFRunLoopRef 的封装，提供了面向对象的API，但这些API不是线程安全的。</p>
<h3 id="RunLoop与线程的关系"><a href="#RunLoop与线程的关系" class="headerlink" title="RunLoop与线程的关系"></a>RunLoop与线程的关系</h3><p>线程和 RunLoop 之间是一一对应的，其关系保存在一个全局的 Dictionary 中。线程刚创建是并没有 RunLoop，如果你不主动获取，那它一直不会有。RunLoop 的创建是在第一次获取时发生的，RunLoop 的销毁是在线程结束时发生的。</p>
<p>你只能在一个线程内部获取它的 RunLoop(主线程除外)。</p>
<h3 id="RunLoop的对外接口"><a href="#RunLoop的对外接口" class="headerlink" title="RunLoop的对外接口"></a>RunLoop的对外接口</h3><p>在 CoreFoundation 中关于 RunLoop 的类有以下几个：</p>
<ul>
<li>CFRunLoopRef</li>
<li>CFRunLoopModeRef</li>
<li>CFRunLoopSourceRef</li>
<li>CFRunLoopTImerRef</li>
<li>CFRunLoopObserverRef</li>
</ul>
<p>一个 RunLoop 包含若干个 Mode ，每个 Mode 又包含若干个 Source/Timer/Observer。每次调用 RunLoop 的主函数时，只能指定其中一个 Mode。如果需要切换 Mode ，只能退出 RunLoop，再重新指定一个 Mode 进入。这样做的目的是为了分隔开不同组的 Source/Timer/Observer，使其不能互相影响。</p>
<p>CFRunLoopSourceRef 是事件产生的地方，有两个版本 Source0 和 Source1：</p>
<ul>
<li>Source0 只包含了一个回调(函数指针)，它并不能主动触发事件。使用时，你需要先调用 CFRunLoopSourceSignal(source)，将这个 Source 标记为待处理，然后手动调用 CFRunLoopWakeUp(runLoop) 来唤醒 RunLoop ，让其处理这个事件。</li>
<li>Source1 包含了一个 mach_port 和一个回调(函数指针)，被用于通过内核和其它线程相互发送消息，它能主动唤醒 RunLoop 的线程。</li>
</ul>
<p>CFRunLoopTimerRef 是基于时间的触发器，他和 NSTimer 是 toll-free bridge 的，可以混用。包含一个时间长度和一个回调(函数指针)。当其加入到 RunLoop 中时，RunLoop 会注册对应的时间点，当时间点到时，RunLoop 会被唤醒执行那个回调。</p>
<p>CFRunLoopObserverRef 是观察者，每个 Observer 都包含了一个回调(函数指针)，当 RunLoop的状态发生变化时，观察者就能通过回调接收到这个变化。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActiviry) &#123;</span><br><span class="line">	kCFRunLoopEntry			&#x3D;	(1UL &lt;&lt; 0),	&#x2F;&#x2F; 即将进入 RunLoop</span><br><span class="line">  	kCFRunLoopBeforeTimers	&#x3D;	(1UL &lt;&lt; 1), &#x2F;&#x2F; 即将处理 Timer</span><br><span class="line">    kCFRunLoopBeforeSources	&#x3D;	(1UL &lt;&lt; 2), &#x2F;&#x2F; 即将处理 Source</span><br><span class="line">  	kCFRunLoopBeforeWaiting	&#x3D;	(1UL &lt;&lt; 5), &#x2F;&#x2F; 即将进入休眠</span><br><span class="line">    kCFRunLoopAfterWaiting	&#x3D;	(1UL &lt;&lt; 6), &#x2F;&#x2F; 刚从休眠中唤醒</span><br><span class="line">    kCFRunLoopExit			&#x3D;	(1UL &lt;&lt; 7), &#x2F;&#x2F; 即将退出 RunLoop</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Source/Timer/Observer 被统称为 Mode Item，一个 item 可以被同时加入多个 Mode。但是一个item被重复加入一个 Mode 不会产生效果。如果一个 Mode 中没有一个 item，则 RunLoop会直接退出，不进入循环。</p>
<h3 id="RunLoop-的Mode"><a href="#RunLoop-的Mode" class="headerlink" title="RunLoop 的Mode"></a>RunLoop 的Mode</h3><p>CFRunLoopMode 和 CFRunLoop 的结构大致如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">CFRunLoopMode</span> &#123;</span></span><br><span class="line">	CFStringRef			_name;</span><br><span class="line">  	CFMutableSetRef		_source0;</span><br><span class="line">  	CFMutableSetRef		_source1;</span><br><span class="line">  	CFMutableArrayRef	_observers;</span><br><span class="line">  	CFMutableArrayRef	_timers;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struce __CFRunLoop &#123;</span><br><span class="line">	CFMutableSetRef		_commonModes;</span><br><span class="line">  	CFMutableSetRef		_commonModeItems;</span><br><span class="line">  	CFRunLoopModeRef	_currentMode;</span><br><span class="line">  	CFMutableSetRef		_modes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个 Mode 可以将自己标记为 “Common” 属性(通过将其 ModeName 添加到 RunLoop 的 “CommonModes”中)。每当 RunLoop 的内容发生变化时，RunLoop 都会自动将 _commonModeItmes 里的 Source/Observer/Timer 同步到具有 “Common” 标记的所有 Mode 里。</p>
<p>CFRunLoop对外暴露的管理 Mode 的接口只有两个：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CFRunLoopAddCommonMode(CFRunLoopRef runloop, CFStringRef modeName);</span><br><span class="line">CFRunLoopRunInMode(CFStringRef modeName);</span><br></pre></td></tr></table></figure>

<p>CFRunLoopModeRef 暴露的管理 Mode Item 接口有：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CFRunLoopAddSource(CFRunLoopRef runloop, CFRunLoopSourceRef source, CFStringRef modeName);</span><br><span class="line">CFRunLoopAddObserver(CFRunLoopRef runloop, CFRunLoopObserverRef observer, CFStringRef modeName);</span><br><span class="line">CFRunLoopAddTimer(CFRunLoopRef runloop, CFRunLoopTimerRef timer, CFStringRef modeName);</span><br><span class="line">CFRunLoopRemoveSource(CFRunLoopRef runloop, CFRunLoopSourceRef source, CFStringRef modeName);</span><br><span class="line">CFRunLoopRemoveObserver(CFRunLoopRef runloop, CFRunLoopObserverRef observer, CFStringRef modeName);</span><br><span class="line">CFRunLoopRemoveTimer(CFRunLoopRef runloop, CFRunLoopTimerRef timer, CFStringRef modeName);</span><br></pre></td></tr></table></figure>

<p>你只能通过 mode name 来操作内部的 mode，当你传入一个新的 mode name 时但 RunLoop内部没有对应的 mode 时，RunLoop 会自动的帮你创建对应的 CFRunLoopModeRef。对于一个 RunLoop ，其内部的 mode 只能添加不能删除。</p>
<p>Apple公开提供的 Mode 只有两个：kCFRunLoopDefaultMode(NSDefaultRunLoopMode) 和 UITrackingRunLoopMode，你可以用这两个 Mode Name 来操作其对应的 Mode。</p>
<p>同时 Apple 还提供了一个操作 Common 标记的字符串 : kCFRunLoopModes(NSDefaultRunLoopCommonModes)，你可以用这个字符串来操作 Common Items，或标记一个 Mode 为 “Common”。使用时要注意区分这个字符串和其它 Mode Name。</p>
<h3 id="RunLoop-的内部逻辑"><a href="#RunLoop-的内部逻辑" class="headerlink" title="RunLoop 的内部逻辑"></a>RunLoop 的内部逻辑</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; DefaultMode 启动</span><br><span class="line">void CFRunLoopRun(void) &#123;</span><br><span class="line">  CFRunLoopRunSpecific(CFRunLoopGetCurrent(),kCFRunLoopDefaultMode, 1.0e10, false);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 用指定的 Mode 启动，允许设置 RunLoop 超时时间</span><br><span class="line">int CFRunLoopRunInMode(CFStringRef ModeName, CFTimeInterval seconds, Boolean stopAfterHandle) &#123;</span><br><span class="line">  return CFRunLoopSpecific(CFRunLoopGetCurrent(), modeName , seconds ,returnAfterSourceHandle)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; RunLoop 的实现</span><br><span class="line">int CFRunLoopRunSpecific(runloop, modeName ,seconds , stopeAfterHandle) &#123;</span><br><span class="line">  &#x2F;&#x2F; 根据 ModeName 找到对应 Mode</span><br><span class="line">  CFRunLoopModeRef currentMode &#x3D; __CFRunLoopFinMode(runloop, modeName, false);</span><br><span class="line">  &#x2F;&#x2F; 如果 Mode 里没有 source&#x2F;timer&#x2F;observer，直接返回</span><br><span class="line">  if (__CFRunLoopModeIsEmpty(currentMode)) &#123;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 通知 Observer , RunLoop 即将进入 loop</span><br><span class="line">  __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopEntry);</span><br><span class="line">  &#x2F;&#x2F; 进入 loop</span><br><span class="line">  __CFRunLoopRun(runloop, currentMode, seconds, returnAfterSourceHandle) &#123;</span><br><span class="line">    Boolean sourceHandledThisLoop	&#x3D;	NO;</span><br><span class="line">    int retVal	&#x3D;	0;</span><br><span class="line">    do &#123;</span><br><span class="line">      &#x2F;&#x2F; 通知 Observers : RunLoop 即将触发 Timer 回调</span><br><span class="line">      __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeTimers);</span><br><span class="line">      &#x2F;&#x2F; 通知 Observers : RunLoop 即将触发 Source0 (非port) 回调</span><br><span class="line">      __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeSources);</span><br><span class="line">      &#x2F;&#x2F; 执行被加入的 block</span><br><span class="line">      __CFRunLoopDoBlocks(runloop, currentMode);</span><br><span class="line">      &#x2F;&#x2F; RunLoop 触发 Source0(非port) 回调</span><br><span class="line">      sourceHandledThisLoop	&#x3D;	__CFRunLoopDoSource0(runloop, currentMode, stopAfterHandele);</span><br><span class="line">      &#x2F;&#x2F; 执行被加入的 block</span><br><span class="line">      __CFRunLoopDoBlocks(runloop, currentMode);</span><br><span class="line">      </span><br><span class="line">      &#x2F;&#x2F; 如果有 Source1 处于 ready 状态，直接处理这个 Source1 然后跳转去处理消息</span><br><span class="line">      if (__Source0DidDispatchPortLastTime) &#123;</span><br><span class="line">        Boolean hasMsg	&#x3D;	__CFRunLoopServiceMachPort(dispatchPort, &amp;msg);</span><br><span class="line">        if (hasMsg)</span><br><span class="line">        &#123;</span><br><span class="line">          goto handle_msg;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      &#x2F;&#x2F; 通知 Observers : RunLoop 的线程即将结束进入休眠(Sleep)</span><br><span class="line">      if (!sourceHandleThisLoop) &#123;</span><br><span class="line">        __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeWaiting);</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      &#x2F;&#x2F; 调用 mach_msg 等待接受 mach_port 的消息。线程进入休眠，直到被下面一个事件唤醒</span><br><span class="line">      &#x2F;&#x2F; 1.一个基于 port 的 Source 的事件</span><br><span class="line">      &#x2F;&#x2F; 2.一个 Timer 时间到了</span><br><span class="line">      &#x2F;&#x2F; 3.RunLoop 自身的超时时间到了</span><br><span class="line">      &#x2F;&#x2F; 4.被其它调用者手动唤醒了</span><br><span class="line">      __CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort) &#123;</span><br><span class="line">        mach_msg(msg, MACH_RCV_MSG, port);</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      &#x2F;&#x2F; 通知 Observers : RunLoop 的线程刚刚被唤醒了</span><br><span class="line">      __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopAfterWaiting);</span><br><span class="line">      </span><br><span class="line">      &#x2F;&#x2F; 收到消息，处理消息</span><br><span class="line">      handle_msg;</span><br><span class="line">      </span><br><span class="line">      &#x2F;&#x2F; 如果一个 Timer 的时间到了，触发这个 Timer 的回调</span><br><span class="line">      if (msg_is_timer) &#123;</span><br><span class="line">        __CFRunLoopDoTimers(runloop, currentMode, mach_absolute_time());</span><br><span class="line">      &#125; else if (msg_is_dispatch) &#123;</span><br><span class="line">      &#x2F;&#x2F; 如果有 dispatch 到  main_queue 的 block ，执行 block  </span><br><span class="line">        __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE_(msg);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">      &#x2F;&#x2F; 如果有一个 Source1 发出事件了， 处理这个事件</span><br><span class="line">        CFRunLoopSourceRef	source1	&#x3D;	__CFRunLoopModeFindSourceForMachPort(runloop, currentMode, livePort);</span><br><span class="line">        sourceHandleThisLoop	&#x3D;	__CFRunLoopDoSource1(runloop, currentMode, source1,  msg);</span><br><span class="line">        if (sourceHandleThisLoop) &#123;</span><br><span class="line">          mach_msg(reply, MACH_SEND_MSG, reply);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F; 执行加入到 Loop 的 block</span><br><span class="line">      __CFRunLoopDoBlocks(runloop, currentMode);</span><br><span class="line">      </span><br><span class="line">      if (sourceHandleThisLoop &amp;&amp; stopAfterHandle) &#123;</span><br><span class="line">        &#x2F;&#x2F; 进入 loop 时参数说处理完事件就返回</span><br><span class="line">        retVal	&#x3D;	kCFRunLoopRunHandledSource;</span><br><span class="line">      &#125; else if (timeOut) &#123;</span><br><span class="line">        &#x2F;&#x2F; 超出传入参数标记的超时时间了</span><br><span class="line">        retVal	&#x3D;	kCFRunLoopRunTimeOut;</span><br><span class="line">      &#125; else if (__CFRunLoopIsStoped(runloop)) &#123;</span><br><span class="line">        &#x2F;&#x2F; 被外部调用者强行停止了</span><br><span class="line">        retVal	&#x3D;	kCFRunLoopRunStoped;</span><br><span class="line">      &#125; else if (__CFRunLoopModeIsEmpty(runloop, currentMode)) &#123;</span><br><span class="line">        &#x2F;&#x2F; Source&#x2F;Timer&#x2F;Observer 一个都没有了</span><br><span class="line">        retVal	&#x3D;	kCFRunLoopRunFinished;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      &#x2F;&#x2F; 如果没超时，mode 里没空， loop 也没有被停止，那就继续 loop</span><br><span class="line">    &#125; while (retVal &#x3D;&#x3D; 0)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="RunLoop有什么用？"><a href="#RunLoop有什么用？" class="headerlink" title="RunLoop有什么用？"></a>RunLoop有什么用？</h2><p>App 启动后 RunLoop 的状态 ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">CFRunLoop &#123;</span><br><span class="line">    current mode &#x3D; kCFRunLoopDefaultMode</span><br><span class="line">    common modes &#x3D; &#123;</span><br><span class="line">        UITrackingRunLoopMode</span><br><span class="line">        kCFRunLoopDefaultMode</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    common mode items &#x3D; &#123;</span><br><span class="line">  </span><br><span class="line">        &#x2F;&#x2F; source0 (manual)</span><br><span class="line">        CFRunLoopSource &#123;order &#x3D;-1, &#123;</span><br><span class="line">            callout &#x3D; _UIApplicationHandleEventQueue&#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;order &#x3D;-1, &#123;</span><br><span class="line">            callout &#x3D; PurpleEventSignalCallback &#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;order &#x3D; 0, &#123;</span><br><span class="line">            callout &#x3D; FBSSerialQueueRunLoopSourceHandler&#125;&#125;</span><br><span class="line">  </span><br><span class="line">        &#x2F;&#x2F; source1 (mach port)</span><br><span class="line">        CFRunLoopSource &#123;order &#x3D; 0,  &#123;port &#x3D; 17923&#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;order &#x3D; 0,  &#123;port &#x3D; 12039&#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;order &#x3D; 0,  &#123;port &#x3D; 16647&#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;order &#x3D;-1, &#123;</span><br><span class="line">            callout &#x3D; PurpleEventCallback&#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;order &#x3D; 0, &#123;port &#x3D; 2407,</span><br><span class="line">            callout &#x3D; _ZL20notify_port_callbackP12__CFMachPortPvlS1_&#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;order &#x3D; 0, &#123;port &#x3D; 1c03,</span><br><span class="line">            callout &#x3D; __IOHIDEventSystemClientAvailabilityCallback&#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;order &#x3D; 0, &#123;port &#x3D; 1b03,</span><br><span class="line">            callout &#x3D; __IOHIDEventSystemClientQueueCallback&#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;order &#x3D; 1, &#123;port &#x3D; 1903,</span><br><span class="line">            callout &#x3D; __IOMIGMachPortPortCallback&#125;&#125;</span><br><span class="line">  </span><br><span class="line">        &#x2F;&#x2F; Ovserver</span><br><span class="line">        CFRunLoopObserver &#123;order &#x3D; -2147483647, activities &#x3D; 0x1, &#x2F;&#x2F; Entry</span><br><span class="line">            callout &#x3D; _wrapRunLoopWithAutoreleasePoolHandler&#125;</span><br><span class="line">        CFRunLoopObserver &#123;order &#x3D; 0, activities &#x3D; 0x20,          &#x2F;&#x2F; BeforeWaiting</span><br><span class="line">            callout &#x3D; _UIGestureRecognizerUpdateObserver&#125;</span><br><span class="line">        CFRunLoopObserver &#123;order &#x3D; 1999000, activities &#x3D; 0xa0,    &#x2F;&#x2F; BeforeWaiting | Exit</span><br><span class="line">            callout &#x3D; _afterCACommitHandler&#125;</span><br><span class="line">        CFRunLoopObserver &#123;order &#x3D; 2000000, activities &#x3D; 0xa0,    &#x2F;&#x2F; BeforeWaiting | Exit</span><br><span class="line">            callout &#x3D; _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv&#125;</span><br><span class="line">        CFRunLoopObserver &#123;order &#x3D; 2147483647, activities &#x3D; 0xa0, &#x2F;&#x2F; BeforeWaiting | Exit</span><br><span class="line">            callout &#x3D; _wrapRunLoopWithAutoreleasePoolHandler&#125;</span><br><span class="line">  </span><br><span class="line">        &#x2F;&#x2F; Timer</span><br><span class="line">        CFRunLoopTimer &#123;firing &#x3D; No, interval &#x3D; 3.1536e+09, tolerance &#x3D; 0,</span><br><span class="line">            next fire date &#x3D; 453098071 (-4421.76019 @ 96223387169499),</span><br><span class="line">            callout &#x3D; _ZN2CAL14timer_callbackEP16__CFRunLoopTimerPv (QuartzCore.framework)&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  </span><br><span class="line">    modes ＝ &#123;</span><br><span class="line">        CFRunLoopMode  &#123;</span><br><span class="line">            sources0 &#x3D;  &#123; &#x2F;* same as &#39;common mode items&#39; *&#x2F; &#125;,</span><br><span class="line">            sources1 &#x3D;  &#123; &#x2F;* same as &#39;common mode items&#39; *&#x2F; &#125;,</span><br><span class="line">            observers &#x3D; &#123; &#x2F;* same as &#39;common mode items&#39; *&#x2F; &#125;,</span><br><span class="line">            timers &#x3D;    &#123; &#x2F;* same as &#39;common mode items&#39; *&#x2F; &#125;,</span><br><span class="line">          	</span><br><span class="line">        CFRunLoopMode  &#123;</span><br><span class="line">            sources0 &#x3D;  &#123; &#x2F;* same as &#39;common mode items&#39; *&#x2F; &#125;,</span><br><span class="line">            sources1 &#x3D;  &#123; &#x2F;* same as &#39;common mode items&#39; *&#x2F; &#125;,</span><br><span class="line">            observers &#x3D; &#123; &#x2F;* same as &#39;common mode items&#39; *&#x2F; &#125;,</span><br><span class="line">            timers &#x3D;    &#123; &#x2F;* same as &#39;common mode items&#39; *&#x2F; &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">  </span><br><span class="line">        CFRunLoopMode  &#123;</span><br><span class="line">            sources0 &#x3D; &#123;</span><br><span class="line">                CFRunLoopSource &#123;order &#x3D; 0, &#123;</span><br><span class="line">                    callout &#x3D; FBSSerialQueueRunLoopSourceHandler&#125;&#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            sources1 &#x3D; (null),</span><br><span class="line">            observers &#x3D; &#123;</span><br><span class="line">                CFRunLoopObserver &gt;&#123;activities &#x3D; 0xa0, order &#x3D; 2000000,</span><br><span class="line">                    callout &#x3D; _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv&#125;</span><br><span class="line">            )&#125;,</span><br><span class="line">            timers &#x3D; (null),</span><br><span class="line">        &#125;,</span><br><span class="line">  </span><br><span class="line">        CFRunLoopMode  &#123;</span><br><span class="line">            sources0 &#x3D; &#123;</span><br><span class="line">                CFRunLoopSource &#123;order &#x3D; -1, &#123;</span><br><span class="line">                    callout &#x3D; PurpleEventSignalCallback&#125;&#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            sources1 &#x3D; &#123;</span><br><span class="line">                CFRunLoopSource &#123;order &#x3D; -1, &#123;</span><br><span class="line">                    callout &#x3D; PurpleEventCallback&#125;&#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            observers &#x3D; (null),</span><br><span class="line">            timers &#x3D; (null),</span><br><span class="line">        &#125;,</span><br><span class="line">         </span><br><span class="line">        CFRunLoopMode  &#123;</span><br><span class="line">            sources0 &#x3D; (null),</span><br><span class="line">            sources1 &#x3D; (null),</span><br><span class="line">            observers &#x3D; (null),</span><br><span class="line">            timers &#x3D; (null),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>系统注册了五个默认的 Mode：</p>
<p>1.kCFRunLoopDefaultMode ：App 的默认 Mode，通常主线程就是在这个 Mode 下运行的。</p>
<p>2.UITrackingRunLoopMode : 界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其它 Mode 影响。</p>
<p>3.UIInitializationRunLoopMode ：在刚启动 App 时进入的第一个 Mode，启动完成后就不再使用。</p>
<p>4.GSEventReceiveRunLoopMode ：接受系统事件的内部 Mode，通常用不到。</p>
<p>5.kCFRunLoopCommonModes ：这是一个占位的 Mode，没有实际作用。</p>
<p>当 RunLoop 进行回调时，一般都是通过一个很长的函数调用出去(call out)，当你在你的代码中下断点时，通常能在调用栈中看到这些函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 1. 通知Observers，即将进入RunLoop</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 此处有Observer会创建AutoreleasePool: _objc_autoreleasePoolPush();</span><br><span class="line">    __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopEntry);</span><br><span class="line">    do &#123;</span><br><span class="line">  </span><br><span class="line">        &#x2F;&#x2F;&#x2F; 2. 通知 Observers: 即将触发 Timer 回调。</span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeTimers);</span><br><span class="line">        &#x2F;&#x2F;&#x2F; 3. 通知 Observers: 即将触发 Source (非基于port的,Source0) 回调。</span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeSources);</span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__(block);</span><br><span class="line">  </span><br><span class="line">        &#x2F;&#x2F;&#x2F; 4. 触发 Source0 (非基于port的) 回调。</span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__(source0);</span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__(block);</span><br><span class="line">  </span><br><span class="line">        &#x2F;&#x2F;&#x2F; 6. 通知Observers，即将进入休眠</span><br><span class="line">        &#x2F;&#x2F;&#x2F; 此处有Observer释放并新建AutoreleasePool: _objc_autoreleasePoolPop(); _objc_autoreleasePoolPush();</span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeWaiting);</span><br><span class="line">  </span><br><span class="line">        &#x2F;&#x2F;&#x2F; 7. sleep to wait msg.</span><br><span class="line">        mach_msg() -&gt; mach_msg_trap();</span><br><span class="line">         </span><br><span class="line">  </span><br><span class="line">        &#x2F;&#x2F;&#x2F; 8. 通知Observers，线程被唤醒</span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopAfterWaiting);</span><br><span class="line">  </span><br><span class="line">        &#x2F;&#x2F;&#x2F; 9. 如果是被Timer唤醒的，回调Timer</span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__(timer);</span><br><span class="line">  </span><br><span class="line">        &#x2F;&#x2F;&#x2F; 9. 如果是被dispatch唤醒的，执行所有调用 dispatch_async 等方法放入main queue 的 block</span><br><span class="line">        __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(dispatched_block);</span><br><span class="line">  </span><br><span class="line">        &#x2F;&#x2F;&#x2F; 9. 如果如果Runloop是被 Source1 (基于port的) 的事件唤醒了，处理这个事件</span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__(source1);</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    &#125; while (...);</span><br><span class="line">  </span><br><span class="line">    &#x2F;&#x2F;&#x2F; 10. 通知Observers，即将退出RunLoop</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 此处有Observer释放AutoreleasePool: _objc_autoreleasePoolPop();</span><br><span class="line">    __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopExit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AutoreleasePool"><a href="#AutoreleasePool" class="headerlink" title="AutoreleasePool"></a>AutoreleasePool</h3><p>App 启动后，Apple 在主线程的 RunLoop 里注册了两个 Observer，其回调都是 _wrapRunLoopWithAutoreleasePoolHandler()。</p>
<p>第一个 Observer 监视的事件是 Entry(即将进入 Loop)，其回调内会调用 _objc_autoreleasePoolPush() 创建自动释放池，优先级最高，保证创建释放池发生在其它所有回调之前。</p>
<p>第二个 Observer 监视了两个事件：BeforeWaiting(准备进入休眠)时调用 _objc_autoreleasePoolPop() 和 _objc_auroreleasePoolPush() 释放旧的池并创建新池。Exit(即将退出Loop)时调用 _objc_autoreleasePoolPop() 来释放自动释放池，优先级最低，保证其释放发生在其它所有回调之后。</p>
<p>在主线程执行的代码，通常是写在诸如事件回调、Timer 回调内的。这些回调会被 RunLoop 创建好的 AutoreleasePool 环绕着，所以不会出现内存泄漏。</p>
<h3 id="事件响应"><a href="#事件响应" class="headerlink" title="事件响应"></a>事件响应</h3><p>Apple 注册了一个 Source1 (基于 mach port) 用来接收系统事件，其回调函数为 __IOHIDEventSystemClientQueueCallBack()。</p>
<p>当一个硬件事件发生后，首先由 IOKit.framework 生成一个 IOHIDEvent 事件并由 SpringBoard 接收。SpingBoard 只接收按键、触摸、加速、接近传感器等几种 Event，随后用 mach port 转发给需要的 App 进程。随后 Apple 注册的那个 Source1 就会触发回调，并调用 _UIApplicationHandleEventQueue() 进行应用内的分发。</p>
<p>_UIApplicationHandleEventQueue() 会把 IOHIDEvent 处理并包装成 UIEvent 进行处理或分发，其中包括识别 UIGesture、处理屏幕旋转、发送给 UIWindow等。通常事件比如 UIButton 点击、touchesBegin/Move/End/Cancle 事件都是在这个回调中完成的。</p>
<h3 id="手势识别"><a href="#手势识别" class="headerlink" title="手势识别"></a>手势识别</h3><p>当 _UIApplicationHandleEventQueue() 识别了一个手势时，其首先会调用 Cancel 将当前的 touchesBegin/Move/End 系列回调打断。随后系统将对应的 UIGestureRecognizer 标记为待处理。</p>
<p>Apple 注册了一个 Observer 检测 BeforeWaiting 事件，这个 Observer 的回调函数是 _UIGestureRecognizerUpdateObsever(), 其内部会获取所有刚被标记为待处理的 GestureRecognizer，并执行 GestureRecognizer 的回调。</p>
<p>当有 UIGestureRecognizer 的变化(创建/销毁/状态改变)时，这个回调都会进行相应处理。</p>
<h3 id="界面更新"><a href="#界面更新" class="headerlink" title="界面更新"></a>界面更新</h3><p>当在操作 UI 时，比如改变了 Frame、更新了 UIView/CALayer 的层次时，或者手动调用了 UIView/CALayer 的 setNeedsLayout/setNeedsDisplay方法后，这个 UIView/CALayer 就被标记为待处理，并被提交到一个全局的容器去。</p>
<p>苹果注册了一个 Observer 监听 BeforeWaiting(即将进入休眠) 和 Exit (即将退出Loop) 事件，回调去执行一个很长的函数：</p>
<p>_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()。这个函数里会遍历所有待处理的 UIView/CAlayer 以执行实际的绘制和调整，并更新 UI 界面。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()</span><br><span class="line">    QuartzCore:CA::Transaction::observer_callback:</span><br><span class="line">        CA::Transaction::commit();</span><br><span class="line">            CA::Context::commit_transaction();</span><br><span class="line">                CA::Layer::layout_and_display_if_needed();</span><br><span class="line">                    CA::Layer::layout_if_needed();</span><br><span class="line">                        [CALayer layoutSublayers];</span><br><span class="line">                            [UIView layoutSubviews];</span><br><span class="line">                    CA::Layer::display_if_needed();</span><br><span class="line">                        [CALayer display];</span><br><span class="line">                            [UIView drawRect];</span><br></pre></td></tr></table></figure>

<h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><p>NSTimer 其实就是 CFRunLoopTimerRef，他们之间是 toll-free bridged 的。一个 NSTimer 注册到 RunLoop 后，RunLoop 会为其重复的时间点注册好事件。例如 10:00, 10:10, 10:20 这几个时间点。RunLoop为了节省资源，并不会在非常准确的时间点回调这个Timer。Timer 有个属性叫做 Tolerance (宽容度)，标示了当时间点到后，容许有多少最大误差。</p>
<p>如果某个时间点被错过了，例如执行了一个很长的任务，则那个时间点的回调也会跳过去，不会延后执行。就比如等公交，如果 10:10 时我忙着玩手机错过了那个点的公交，那我只能等 10:20 这一趟了。</p>
<p>CADisplayLink 是一个和屏幕刷新率一致的定时器（但实际实现原理更复杂，和 NSTimer 并不一样，其内部实际是操作了一个 Source）。如果在两次屏幕刷新之间执行了一个长任务，那其中就会有一帧被跳过去（和 NSTimer 相似），造成界面卡顿的感觉。在快速滑动TableView时，即使一帧的卡顿也会让用户有所察觉。Facebook 开源的 AsyncDisplayLink 就是为了解决界面卡顿的问题，其内部也用到了 RunLoop。</p>
<h3 id="PerformSelector"><a href="#PerformSelector" class="headerlink" title="PerformSelector"></a>PerformSelector</h3><p>当调用 NSObject 的 performSelecter:afterDelay: 后，实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 中。所以如果当前线程没有 RunLoop，则这个方法会失效。</p>
<p>当调用 performSelector:onThread: 时，实际上其会创建一个 Timer 加到对应的线程去，同样的，如果对应线程没有 RunLoop 该方法也会失效。</p>
<h3 id="关于GCD"><a href="#关于GCD" class="headerlink" title="关于GCD"></a>关于GCD</h3><p>实际上 RunLoop 底层也会用到 GCD 的东西，比如 RunLoop 是用 dispatch_source_t 实现的 Timer。但同时 GCD 提供的某些接口也用到了 RunLoop， 例如 dispatch_async()。</p>
<p>当调用 dispatch_async(dispatch_get_main_queue(), block) 时，libDispatch 会向主线程的 RunLoop 发送消息，RunLoop会被唤醒，并从消息中取得这个 block，并在回调 <strong>CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE</strong>() 里执行这个 block。但这个逻辑仅限于 dispatch 到主线程，dispatch 到其他线程仍然是由 libDispatch 处理的。</p>
<h3 id="关于网络请求"><a href="#关于网络请求" class="headerlink" title="关于网络请求"></a>关于网络请求</h3><p>iOS 中，关于网络请求的接口自下至上有如下几层:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CFSocket</span><br><span class="line">CFNetwork       -&gt;ASIHttpRequest</span><br><span class="line">NSURLConnection -&gt;AFNetworking</span><br><span class="line">NSURLSession    -&gt;AFNetworking2, Alamofire</span><br></pre></td></tr></table></figure>

<ul>
<li>CFSocket 是最底层的接口，只负责 socket 通信。</li>
<li>CFNetwork 是基于 CFSocket 等接口的上层封装，ASIHttpRequest 工作于这一层。</li>
<li>NSURLConnection 是基于 CFNetwork 的更高层的封装，提供面向对象的接口，AFNetworking 工作于这一层。</li>
<li>NSURLSession 是 iOS7 中新增的接口，表面上是和 NSURLConnection 并列的，但底层仍然用到了 NSURLConnection 的部分功能 (比如 com.apple.NSURLConnectionLoader 线程)，AFNetworking2 和 Alamofire 工作于这一层。</li>
</ul>
<p>通常使用 NSURLConnection 时，你会传入一个 Delegate，当调用了 [connection start] 后，这个 Delegate 就会不停收到事件回调。实际上，start 这个函数的内部会会获取 CurrentRunLoop，然后在其中的 DefaultMode 添加了4个 Source0 (即需要手动触发的Source)。CFMultiplexerSource 是负责各种 Delegate 回调的，CFHTTPCookieStorage 是处理各种 Cookie 的。</p>
<p>当开始网络传输时，我们可以看到 NSURLConnection 创建了两个新线程：com.apple.NSURLConnectionLoader 和 com.apple.CFSocket.private。其中 CFSocket 线程是处理底层 socket 连接的。NSURLConnectionLoader 这个线程内部会使用 RunLoop 来接收底层 socket 的事件，并通过之前添加的 Source0 通知到上层的 Delegate。</p>
<p>NSURLConnectionLoader 中的 RunLoop 通过一些基于 mach port 的 Source 接收来自底层 CFSocket 的通知。当收到通知后，其会在合适的时机向 CFMultiplexerSource 等 Source0 发送通知，同时唤醒 Delegate 线程的 RunLoop 来让其处理这些通知。CFMultiplexerSource 会在 Delegate 线程的 RunLoop 对 Delegate 执行实际的回调。</p>
<h2 id="RunLoop-怎么用？"><a href="#RunLoop-怎么用？" class="headerlink" title="RunLoop 怎么用？"></a>RunLoop 怎么用？</h2><h3 id="AFNetWorking"><a href="#AFNetWorking" class="headerlink" title="AFNetWorking"></a>AFNetWorking</h3><p><a href="https://github.com/AFNetworking/AFNetworking/blob/master/AFNetworking%2FAFURLConnectionOperation.m" target="_blank" rel="noopener">AFURLConnectionOperation</a> 这个类是基于 NSURLConnection 构建的，其希望能在后台线程接收 Delegate 回调。为此 AFNetworking 单独创建了一个线程，并在这个线程中启动了一个 RunLoop：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">+ (void)networkRequestThreadEntryPoint:(id)__unused object &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        [[NSThread currentThread] setName:@&quot;AFNetworking&quot;];</span><br><span class="line">        NSRunLoop *runLoop &#x3D; [NSRunLoop currentRunLoop];</span><br><span class="line">        [runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode];</span><br><span class="line">        [runLoop run];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">+ (NSThread *)networkRequestThread &#123;</span><br><span class="line">    static NSThread *_networkRequestThread &#x3D; nil;</span><br><span class="line">    static dispatch_once_t oncePredicate;</span><br><span class="line">    dispatch_once(&amp;oncePredicate, ^&#123;</span><br><span class="line">        _networkRequestThread &#x3D; [[NSThread alloc] initWithTarget:self selector:@selector(networkRequestThreadEntryPoint:) object:nil];</span><br><span class="line">        [_networkRequestThread start];</span><br><span class="line">    &#125;);</span><br><span class="line">    return _networkRequestThread;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>RunLoop 启动前内部必须要有至少一个 Timer/Observer/Source，所以 AFNetworking 在 [runLoop run] 之前先创建了一个新的 NSMachPort 添加进去了。通常情况下，调用者需要持有这个 NSMachPort (mach_port) 并在外部线程通过这个 port 发送消息到 loop 内；但此处添加 port 只是为了让 RunLoop 不至于退出，并没有用于实际的发送消息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (void)start &#123;</span><br><span class="line">    [self.lock lock];</span><br><span class="line">    if ([self isCancelled]) &#123;</span><br><span class="line">        [self performSelector:@selector(cancelConnection) onThread:[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]];</span><br><span class="line">    &#125; else if ([self isReady]) &#123;</span><br><span class="line">        self.state &#x3D; AFOperationExecutingState;</span><br><span class="line">        [self performSelector:@selector(operationDidStart) onThread:[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]];</span><br><span class="line">    &#125;</span><br><span class="line">    [self.lock unlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当需要这个后台线程执行任务时，AFNetworking 通过调用 [NSObject performSelector:onThread:..] 将这个任务扔到了后台线程的 RunLoop 中。</p>
<h3 id="AsyncDisplayKit"><a href="#AsyncDisplayKit" class="headerlink" title="AsyncDisplayKit"></a>AsyncDisplayKit</h3><p><a href="https://github.com/facebook/AsyncDisplayKit" target="_blank" rel="noopener">AsyncDisplayKit</a> 是 Facebook 推出的用于保持界面流畅性的框架，其原理大致如下：</p>
<p>UI 线程中一旦出现繁重的任务就会导致界面卡顿，这类任务通常分为3类：排版，绘制，UI对象操作。</p>
<p>排版通常包括计算视图大小、计算文本高度、重新计算子式图的排版等操作。</p>
<p>绘制一般有文本绘制 (例如 CoreText)、图片绘制 (例如预先解压)、元素绘制 (Quartz)等操作。</p>
<p>UI对象操作通常包括 UIView/CALayer 等 UI 对象的创建、设置属性和销毁。</p>
<p>其中前两类操作可以通过各种方法扔到后台线程执行，而最后一类操作只能在主线程完成，并且有时后面的操作需要依赖前面操作的结果 （例如TextView创建时可能需要提前计算出文本的大小）。ASDK 所做的，就是尽量将能放入后台的任务放入后台，不能的则尽量推迟 (例如视图的创建、属性的调整)。</p>
<p>为此，ASDK 创建了一个名为 ASDisplayNode 的对象，并在内部封装了 UIView/CALayer，它具有和 UIView/CALayer 相似的属性，例如 frame、backgroundColor等。所有这些属性都可以在后台线程更改，开发者可以只通过 Node 来操作其内部的 UIView/CALayer，这样就可以将排版和绘制放入了后台线程。但是无论怎么操作，这些属性总需要在某个时刻同步到主线程的 UIView/CALayer 去。</p>
<p>ASDK 仿照 QuartzCore/UIKit 框架的模式，实现了一套类似的界面更新的机制：即在主线程的 RunLoop 中添加一个 Observer，监听了 kCFRunLoopBeforeWaiting 和 kCFRunLoopExit 事件，在收到回调时，遍历所有之前放入队列的待处理的任务，然后一一执行。</p>
<blockquote>
<p>转载整理自 ： <a href="https://blog.ibireme.com/author/ibireme/" target="_blank" rel="noopener">ibireme</a> 的博客 <a href="https://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="noopener">深入理解RunLoop</a></p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.chenglei.tech/blogs/2015/11/01/iOS-Multi-Thread/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blogs/images/avatar.gif">
      <meta itemprop="name" content="CocoaLei">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CocoaLei">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blogs/2015/11/01/iOS-Multi-Thread/" class="post-title-link" itemprop="url">多线程编程基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2015-11-01 00:00:00" itemprop="dateCreated datePublished" datetime="2015-11-01T00:00:00+08:00">2015-11-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-01-17 11:35:49" itemprop="dateModified" datetime="2019-01-17T11:35:49+08:00">2019-01-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="iOS-多线程"><a href="#iOS-多线程" class="headerlink" title="iOS 多线程"></a>iOS 多线程</h1><h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>进程(Process)是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础，是正在运行的程序的实例(An instance of a computer program that is being executed)。</p>
<p>进程的概念主要有两点：</p>
<ul>
<li>进程是一个实体。每一个进程都有它自己的地址空间，一般情况下，包括文本区域(Text Region)、数据区域(Data Region)和堆栈(Stack Region)。文本区域存储处理器执行的代码；数据区域存储变量和进程执行期间使用的动态分配的内存；堆栈区存储着活动过程调用的指令和本地变量。</li>
<li>进程是一个执行中的程序。</li>
</ul>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>线程是程序执行流的最小单元。一个标准的线程由线程ID、当前指令指针、寄存器集合和堆栈组成。另外，线程是进程中的一个实体，是被系统独立调度和分配的基本单位，线程自己不拥有系统资源，只拥有一点在运行中必不可少的资源，但它可以与同属一个进程的其它线程共享进程所拥有的全部资源。</p>
<h3 id="进程与线程的关系与区别"><a href="#进程与线程的关系与区别" class="headerlink" title="进程与线程的关系与区别"></a>进程与线程的关系与区别</h3><p>进程是资源分配的基本单位。所有与该进程有关的资源，都被记录在进程控制块PCB中，以表示该进程拥有这些资源或正在使用它们。另外，进程也是抢占处理机的基本单位，它拥有一个完整的虚拟地址空间。当进程发生调度时，不同的进程拥有不同的虚拟地址空间，而同一进程内的不同线程共享同一地址空间。</p>
<p>与进程相对应，线程与资源分配无关，它属于某一个进程，并与进程内的其它线程一起共享进程的资源。线程只由相关堆栈、寄存器和线程控制表TCB组成。寄存器可被用来存储线程内的局部变量，但不能存储其它线程的相关变量。</p>
<p>通常在一个进程中可以包含多个线程，它们可以利用进程所拥有的资源。在引入线程的操作系统中，通常都是把进程作为分配资源的基本单位，而把线程作为独立运行和独立调度的基本单位。由于线程比进程更小，基本上不拥有系统资源，故对它的调度所付出的开销就会小得多，能更叫高效的提高系统内多个程序之间并发执行的程度。</p>
<p>线程和进程区别：</p>
<ul>
<li>地址空间和其它资源：进程之间相互独立，同一进程的各线程间共享。某进程内的线程在其它进程不可见。</li>
<li>通信：进程间通信主要方式有管道、系统IPC(消息队列、信号、共享存储)、套接字(Socket)。而线程间可以直接读写进程数据段来进行通信(需要进程同步和互斥手段的辅助，以保证数据的异质性)</li>
<li>调度和切换：线程上下文切换比进程快的多。</li>
<li>在多线程OS中，进程不是一个可执行的实体</li>
</ul>
<h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><p>线程安全就是多线程访问时，采用了加锁机制，当一个线程访问该类的某个数据时，进行保护，其它线程不能进行访问直到该线程读取完，其它线程才可以使用。</p>
<h2 id="iOS中的多线程"><a href="#iOS中的多线程" class="headerlink" title="iOS中的多线程"></a>iOS中的多线程</h2><p>目前在iOS中有四种多线程解决方案：</p>
<ul>
<li>Pthreads</li>
<li>NSThread</li>
<li>GCD</li>
<li>NSOperation &amp; NSOperationQueue</li>
</ul>
<h3 id="Pthreads"><a href="#Pthreads" class="headerlink" title="Pthreads"></a>Pthreads</h3><p>POSIX线程，简称Pthreads，是线程的POSIX标准。该标准定义了创建和操作线程的一整套API。在类Unix操作系统中，都使用Pthreads作为操作系统的线程。</p>
<h3 id="NSThread"><a href="#NSThread" class="headerlink" title="NSThread"></a>NSThread</h3><p>NSThread是经常Apple封装的完全面向对象的。你可以直观方便的操控线程对象，但是生命周期需要手动管理。</p>
<h3 id="GCD"><a href="#GCD" class="headerlink" title="GCD"></a>GCD</h3><p>GCD是Apple为多核的并行运算提出的的解决方案，能够自动合理地利用更多的CPU内核，并自动管理线程的声明周期。GCD使用C进行编写，并使用了Block。</p>
<p>####任务</p>
<p>即代码所要完成的操作。</p>
<p>任务的执行方式有两种：同步执行和异步执行。</p>
<p>同步执行操作，它会阻塞当前线程并等待任务执行完毕，然后当前线程才会继续往下运行。</p>
<p>异步执行操作，则不会阻塞当前线程，当前线程会直接往下执行。</p>
<h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><p>用于存放要执行的任务。</p>
<p>串行队列中的任务，GCD会遵循FIFO原则来执行，串行队列的同步执行任务，会在当前线程一个一个执行，而异步执行任务，则会在它线程中一个一个执行。</p>
<p>并行队列中的任务执行顺序则要复杂一点，任务会根据同步或异步有不同的执行方式。并行队列中的同步执行任务会在当前线程中一个一个执行，而异步执行则会开很多线程一起执行。</p>
<h5 id="如何创建队列？"><a href="#如何创建队列？" class="headerlink" title="如何创建队列？"></a><strong>如何创建队列？</strong></h5><ul>
<li>主队列：特殊的串行队列，主要用于刷新UI，任何需要刷新UI的工作都必须在主队列中执行。</li>
</ul>
<figure class="highlight plain"><figcaption><span>mainQueue </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">+ 自己创建的队列：</span><br><span class="line"></span><br><span class="line">  创建串行队列</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;dispatch_queue_t serialQueue &#x3D; dispatch_queue_create(&quot;CustomSerialQueue&quot;,DISPATCH_QUEUE_SERIAL);</span><br></pre></td></tr></table></figure>

<p>​    创建并行队列</p>
<figure class="highlight plain"><figcaption><span>concurrentQueue </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">+ 全局队列：这是一个并行队列，并行任务一般都加入到这个队列。</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;dispatch_queue_t globalQueue &#x3D; dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,0)</span><br></pre></td></tr></table></figure>

<p><strong>如何创建任务？</strong></p>
<ul>
<li><p>创建同步任务</p>
<figure class="highlight plain"><figcaption><span>execute code));```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">+ 创建异步任务</span><br><span class="line"></span><br><span class="line">  &#96;&#96;&#96;dispatch_async(,^&#123;&#x2F;&#x2F; execute code&#125;);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="队列组"><a href="#队列组" class="headerlink" title="队列组"></a>队列组</h5><p>队列组可以将很多队列添加到一个组里，当组中的所有任务都执行完了，队列组将会通知给用户。</p>
<p><code>dispatch_group_enter</code> 和 <code>dispatch_group_leave</code> 分别表示一个任务追加到队列组和一个任务执行完毕离开了队列组。</p>
<p>只有当group中未执行完毕的任务数量为0时，才会使 <code>dispatch_group_wait</code> 解除阻塞，以及执行追加到 <code>dispatch_group_notify</code> 的任务。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">dispatch_group_t group &#x3D; dispatch_group_create();</span><br><span class="line">dispatch_queue_t queue &#x3D; dispatch_get_global_queue(DISPATCH_QUEUE_PRIOITY_DEFAULT,0);</span><br><span class="line">dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">  &#x2F;&#x2F; execute code</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F; 向group中添加在主队列中执行的任务</span><br><span class="line">dispatch_group_async(group, dispatch_get_main_queue(),^&#123;</span><br><span class="line">  &#x2F;&#x2F; execute code</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F; 向group中追加任务</span><br><span class="line">dispatch_group_enter(group);</span><br><span class="line">dispatch_async(queue，^&#123;</span><br><span class="line">    &#x2F;&#x2F; execute code</span><br><span class="line">    dispatch_group_leave(group);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 直到前面加入到group中的所有任务都执行完毕后，才会执行</span><br><span class="line">dispatch_group_notify(group,dispatch_get_main_queue(),^&#123;</span><br><span class="line">  &#x2F;&#x2F; execute code</span><br><span class="line">&#125;);</span><br><span class="line">OR</span><br><span class="line">&#x2F;&#x2F; 直到前面加入到group中的所有任务都执行完成后，才会继续往下执行</span><br><span class="line">dispatch_group_wait(group, DISPATCH_TIME_FOREVER);</span><br></pre></td></tr></table></figure>



<h4 id="GCD的信号量机制"><a href="#GCD的信号量机制" class="headerlink" title="GCD的信号量机制"></a>GCD的信号量机制</h4><p>并发队列可以分配多个线程，同时处理不同的任务，虽然提升了效率，但是多线程的并发是通过时间片轮转的方法实现的，线程的创建、销毁、上下文切换等会消耗资源。适当的并发可以提高效率，但是无节制的并发，则会抢占CPU资源，造成性能下降。此外，提交给并发队列的任务中，有些任务内部会有全局的锁，会导致线程休眠、阻塞，一旦这类任务过多，并发队列还需要创建新的线程来执行其它任务，会造成线程数量的增加。</p>
<p>因此控制并发队列中的线程数量就成了不能忽视的问题。</p>
<h5 id="GCD并发线程数量控制"><a href="#GCD并发线程数量控制" class="headerlink" title="GCD并发线程数量控制"></a>GCD并发线程数量控制</h5><p>GCD中的信号量（dispatch_semaphore）是一个整形值，有初始计数值，可以接收通知信号和等待信号。当信号量收到通知信号时，计数+1；当信号量收到等待信号时，计数-1。如果信号量为0，线程会被阻塞，直到信号量大于0，才会继续执行。</p>
<p>使用信号量机制可以实现线程的同步，也可以控制最大并发数。</p>
<h5 id="使用GCD信号量机制实现并发线程数量控制"><a href="#使用GCD信号量机制实现并发线程数量控制" class="headerlink" title="使用GCD信号量机制实现并发线程数量控制"></a>使用GCD信号量机制实现并发线程数量控制</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t	workConcurrentQueue	&#x3D;	dispatch_queue_create(@&quot;WORK_CONCURRENT_QUEUE&quot;,DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">dispatch_queue_t	workSerialQueue	&#x3D;	dispatch_queue_create(@&quot;WORK_SERIAL_QUEUE&quot;,DISPATCH_QUEUE_SERIAL);</span><br><span class="line">int	maxConcurrent	&#x3D;	10;</span><br><span class="line">dispatch_semaphore_t	semaphore	&#x3D;	dispatch_semaphore_create(maxConcurrent);</span><br><span class="line">for (NSInteger i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">  dispatch_async(workSerialQueue, ^&#123;</span><br><span class="line">      &#x2F;&#x2F; 使信号量-1，当信号量为0时就一直等待，即阻塞所在线程</span><br><span class="line">      &#x2F;&#x2F; 这里使信号量 maxConcurrent-1，表示最大并发数量已被占用一个位置</span><br><span class="line">      dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">      dispatch_async(workConcurrentQueue, ^&#123;</span><br><span class="line">          &#x2F;&#x2F; 发送一个信号，让信号量+1</span><br><span class="line">          &#x2F;&#x2F; 这里使信号量 maxConcurrent+1，表示任务被执行，释放了最大并发数量中的一个位置</span><br><span class="line">          dispatch_semaphore_signal(semaphore);</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="使用GCD信号量机制实现线程同步"><a href="#使用GCD信号量机制实现线程同步" class="headerlink" title="使用GCD信号量机制实现线程同步"></a>使用GCD信号量机制实现线程同步</h5><p>有时候我们会遇到需要异步执行一些耗时任务，并在这些任务完成后进行一些额外的操作，相当于将异步执行任务转化为同步执行任务。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t queue &#x3D; dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">dispatch_semaphore_t semaphore &#x3D; dispatch_semaphore_create(0);</span><br><span class="line">     </span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">    	&#x2F;&#x2F; 执行耗时任务</span><br><span class="line">    	···</span><br><span class="line">        &#x2F;&#x2F; 任务完成后使信号量+1，被阻塞的线程继续执行</span><br><span class="line">        dispatch_semaphore_signal(semaphore);</span><br><span class="line">    &#125;);</span><br><span class="line">&#x2F;&#x2F; 如果信号量为0，则会阻塞当前线程，直到信号量</span><br><span class="line">dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br></pre></td></tr></table></figure>

<h5 id="使用GCD信号量机制实现线程安全"><a href="#使用GCD信号量机制实现线程安全" class="headerlink" title="使用GCD信号量机制实现线程安全"></a>使用GCD信号量机制实现线程安全</h5><p>如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其它变量的值也和预期的是一样的，就是线程安全的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dispatch_semaphore_t semaphoreLock	&#x3D;	dispatch_semaphore_create(1);</span><br><span class="line">&#x2F;&#x2F; 相当于加锁</span><br><span class="line">dispatch_semaphore_wait(semaphoreLock, DISPATCH_TIME_FOREVER);</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; 需要保证安全的执行代码</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 相当于解锁</span><br><span class="line">dispatch_semaphore_singal(semaphoreLock);</span><br></pre></td></tr></table></figure>

<h4 id="GCD的一些使用场景"><a href="#GCD的一些使用场景" class="headerlink" title="GCD的一些使用场景"></a>GCD的一些使用场景</h4><h5 id="使用GCD实现延迟执行"><a href="#使用GCD实现延迟执行" class="headerlink" title="使用GCD实现延迟执行"></a>使用GCD实现延迟执行</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t queue	&#x3D;	dispatch_ger_gloabl_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">double delay			&#x3D;	3;</span><br><span class="line">dispatch_after(dispatch_time(DISPATCH_TIME_NOW), (int64_t)(delay*NSEC_PER_SEC)), queue, ^&#123;</span><br><span class="line">  &#x2F;&#x2F; execute code</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h5 id="使用GCD实现单例模式"><a href="#使用GCD实现单例模式" class="headerlink" title="使用GCD实现单例模式"></a>使用GCD实现单例模式</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">static id _instance;</span><br><span class="line">+ (instancetype)sharedInstance &#123;</span><br><span class="line">  static dispatch_once_t onceToken;</span><br><span class="line">  dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">    &#x2F;&#x2F; initial code</span><br><span class="line">  &#125;);</span><br><span class="line">  retur _instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="任务同步"><a href="#任务同步" class="headerlink" title="任务同步"></a>任务同步</h5><p>我们有时需要异步执行两组操作，而且第一组操作执行完之后，才能开始执行第二组操作。这样我们就需要一个相当于 栅栏 一样的一个方法将两组异步执行的操作组给分割起来，当然这里的操作组里可以包含一个或多个任务。这就需要用到dispatch_barrier_async方法在两个操作组间形成栅栏。</p>
<p><code>dispatch_barrier_async</code> 函数会等待前边追加到并发队列中的任务全部执行完毕之后，再将指定的任务追加到该异步队列中。然后在 <code>dispatch_barrier_async</code> 函数追加的任务执行完毕之后，异步队列才恢复为一般动作，接着追加任务到该异步队列并开始执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t queue &#x3D; dispatch_queue_create(&quot;com.codelei.queue&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">     </span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">  		&#x2F;&#x2F; Task 1</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        &#x2F;&#x2F; Task 2</span><br><span class="line">    &#125;);</span><br><span class="line">     </span><br><span class="line">    dispatch_barrier_async(queue, ^&#123;</span><br><span class="line">        &#x2F;&#x2F; 追加的任务 Task 3</span><br><span class="line">    &#125;);</span><br><span class="line">     </span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        &#x2F;&#x2F; 追加的任务 Task 4</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        &#x2F;&#x2F; 追加的任务 Task 5</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<p>直到 Task 1 和 Task 2 执行完成后，才会执行使用 <code>dispatch_barrier_asynce</code> 追加的任务 Task 3，然后在 Task 3 执行完成后，并行队列会正常执行。</p>
<h3 id="NSOperation-amp-NSOperationQueue"><a href="#NSOperation-amp-NSOperationQueue" class="headerlink" title="NSOperation &amp; NSOperationQueue"></a>NSOperation &amp; NSOperationQueue</h3><p>NSOperation是Apple对GCD的封装，完全面向对象。NSOperation和NSOperationQueue分别对应GCD的任务和队列。</p>
<h4 id="添加任务"><a href="#添加任务" class="headerlink" title="添加任务"></a>添加任务</h4><p>NSOperation只是一个抽象类，并不能直接封装任务。它有两个子类NSInvocationOperation和NSBlockOperation用来完成封装任务的操作。创建一个Operation后，需要调用<code>start</code>方法来启动任务，它默认在当前队列同步执行。如果需要在执行途中取消执行一个任务，调用<code>cancel</code>方法即可。</p>
<ul>
<li><p>NSInvocationOperation</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSInvocationOperation *invocationOperation &#x3D; [[NSInvocation alloc] initWithTarget:self selector:@selector(executeMethod)];</span><br><span class="line">invocationOperation start];</span><br></pre></td></tr></table></figure>
</li>
<li><p>NSBlockOperation</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NSBlockOperation *blockOperation &#x3D; [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">  &#x2F;&#x2F; execute code</span><br><span class="line">&#125;];</span><br><span class="line">[blockOperation start];</span><br></pre></td></tr></table></figure>
<p>上面提到，NSInvocationOperation和NSBlockOperation创建的任务默认在当前线程执行，但是NSBlockOperation可以通过<code>addExecutionBlock:</code>方法向Operation中添加多个可执行的Block。这样的Operation中的任务会并发执行，它会在主线程和其它多个线程执行这些任务。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NSBlockOperation *blockOperation &#x3D; [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">  &#x2F;&#x2F; execute code</span><br><span class="line">&#125;];</span><br><span class="line">[blockOpertation addExecutionBlock:^&#123;</span><br><span class="line">  &#x2F;&#x2F; execute code</span><br><span class="line">&#125;];</span><br><span class="line">[blockOperation start];</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>NOTE</strong>:<code>addExecutionBlock:</code>方法必须在<code>start</code>方法之前执行，否则会报错。</p>
</blockquote>
</li>
<li><p>自定义的Operation</p>
<p>自定义Operation类需要继承Operation类，并实现其<code>main()</code>方法，因为在调用<code>start()</code>方法的时候，内部会调用<code>main()</code>方法完成相关逻辑。</p>
</li>
</ul>
<h4 id="创建队列"><a href="#创建队列" class="headerlink" title="创建队列"></a>创建队列</h4><p>通过调用一个NSOperation类的<code>start()</code>方法来启动的任务，默认在当前线程同步执行。如果要避免占用当前线程，就需要使用到队列NSOperationQueue。只要将Operation添加到队列，就会自动调用任务的<code>start()</code>方法。</p>
<ul>
<li><p>主队列</p>
<p>添加到主队列中的任务时串行执行的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSOperationQueue *mainQueue &#x3D; [NSOperationQueue mainQueue];</span><br></pre></td></tr></table></figure>
</li>
<li><p>其它队列</p>
<p>其它队列中的任务会在其它线程并行执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NSOperationQueue *queue &#x3D; [NSOperatin alloc] init];</span><br><span class="line">NSBlockOperatin	 *blockOperation &#x3D; [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">  &#x2F;&#x2F; execute code</span><br><span class="line">&#125;]</span><br><span class="line">[queue addOperation:blockOperation];</span><br></pre></td></tr></table></figure>

<p>如果需要任务在队列中串行执行，可以通过设置NSOperationQueue的<code>maxConcurrentOperationCount</code>来实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSOperationQueue *queue &#x3D; [NSOperatin alloc] init];</span><br><span class="line">[queue setMaxConcurrentOperationCount:1];</span><br></pre></td></tr></table></figure>

<p>你还可以通过<code>addOperationWithBlock:</code>方法来向队列中添加新任务。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NSOperationQueue *queue &#x3D; [NSOperatin alloc] init];</span><br><span class="line">[queue addOperationWithBlock:^&#123;</span><br><span class="line">  &#x2F;&#x2F; cxecute code</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="添加任务依赖"><a href="#添加任务依赖" class="headerlink" title="添加任务依赖"></a>添加任务依赖</h4>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">NSBlockOperation	*blockOperationFirst  &#x3D; [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">	&#x2F;&#x2F; execute code</span><br><span class="line">&#125;];</span><br><span class="line">NSBlockOperation	*blockOperationSecond &#x3D; [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">	&#x2F;&#x2F; execute code</span><br><span class="line">&#125;];</span><br><span class="line">NSBlockOperation	*blockOperationThird  &#x3D; [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">	&#x2F;&#x2F; execute code</span><br><span class="line">&#125;];</span><br><span class="line">[blockOperationSecond addDependency:blockOperationFirst];</span><br><span class="line">[blockOperationThird addDependency:blockOperationSecond];</span><br><span class="line">NSOperationQueue *queue &#x3D; [NSOperatin alloc] init];</span><br><span class="line">[queue addOperations:@[blockOperationFirst,blockOperationSecond,blockOperationThird]];</span><br></pre></td></tr></table></figure>


<blockquote>
<p><strong>NOTE</strong>:</p>
<ul>
<li>添加相互依赖会造成死锁。</li>
<li>使用<code>removeDependency</code>方法来移除依赖关系</li>
</ul>
</blockquote>
<h4 id="其它方法"><a href="#其它方法" class="headerlink" title="其它方法"></a>其它方法</h4><ul>
<li><p>NSOperation类的一些其它方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 判断任务是否正在执行</span><br><span class="line">BOOL exccuting;</span><br><span class="line">&#x2F;&#x2F; 判断任务是否完成</span><br><span class="line">BOOL finished；</span><br><span class="line">&#x2F;&#x2F; 设置任务完成后的后续操作</span><br><span class="line">void (^completionBlock) (void);</span><br><span class="line">&#x2F;&#x2F; 取消任务</span><br><span class="line">- (void)cancle;</span><br><span class="line">&#x2F;&#x2F; 阻塞当前线程直到此任务执行完毕</span><br><span class="line">- (void)waitUntilFinished;</span><br></pre></td></tr></table></figure>
</li>
<li><p>NSOperationQueue</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 获取队列的任务数量</span><br><span class="line">NSUInteger operationCount;</span><br><span class="line">&#x2F;&#x2F; 取消队列中的所有任务</span><br><span class="line">- (void)cancelAllOperations;</span><br><span class="line">&#x2F;&#x2F; 阻塞当前线程直到此队列中的所有任务执行完毕</span><br><span class="line">- (void)waitUntilAllOperationsAreFinished;</span><br><span class="line">&#x2F;&#x2F; 暂停或继续队列</span><br><span class="line">BOOL suspended;</span><br></pre></td></tr></table></figure>

<p>​</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.chenglei.tech/blogs/2015/10/21/ios-background-execution/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blogs/images/avatar.gif">
      <meta itemprop="name" content="CocoaLei">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CocoaLei">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blogs/2015/10/21/ios-background-execution/" class="post-title-link" itemprop="url">后台运行探索与解析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2015-10-21 00:00:00" itemprop="dateCreated datePublished" datetime="2015-10-21T00:00:00+08:00">2015-10-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-01-17 11:35:39" itemprop="dateModified" datetime="2019-01-17T11:35:39+08:00">2019-01-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="iOS-后台运行"><a href="#iOS-后台运行" class="headerlink" title="iOS 后台运行"></a>iOS 后台运行</h1><hr>
<p>当用户没有主动的使用你的应用程序时，系统会将它转换为后台运行状态。对于大多说应用程序来说，后台运行状态只是应用程序在被系统挂起前的一个阶段。挂起应用程序是一个改善电池寿命并让系统为前台应用程序释放重要资源的方式。</p>
<p>大多数应用程序都能很容易的挂起，但是拥有合理的理由在后台继续运行的应用程序也是有的。一个远足应用程序想要随着时间来定位用户的位置，让它能够在地图上显示用户的运动进程。一个音频应用程序可能需要在屏幕锁定时继续播放音乐。其它的应用程序可能想要在后台下载内容以便能够减少将内容呈献给用户的延迟。当你发现你的应用程序需要保持在后台继续运行的时候，iOS系统能够帮助你有效率的且尽可能少地占用系统资源的完成这个目的。</p>
<p>iOS提供的技术分为三类：</p>
<ul>
<li>在前台开始短任务的应用程序可以在进入后台状态时向系统请求完成这个任务的额外时间。</li>
<li>在前台启动下载的应用程序可以将这些下载的管理移交给系统，从而允许在下载过程中暂停或终止该应用。</li>
<li>需要在后台运行以支持特定类型任务的应用程序可以声明对一个或多个后台执行模式的支持。</li>
</ul>
<p>尽可能避免在后台执行任何任务除非这样做能全面的提升用户的体验。应用程序可能会因为启动了另一个应用程序，锁定了屏幕或现在不使用它而被转入后台。在这些情况下，用户都表明你的应用程序现在不需要做任何有意义的工作。在这种情况下继续运行只会浪费设备的电量并可能导致用户强制的完全退出你的应用程序。所以你应该审慎的考虑在后台运行应用程序。</p>
<h2 id="执行有限长度的任务"><a href="#执行有限长度的任务" class="headerlink" title="执行有限长度的任务"></a>执行有限长度的任务</h2><p>被转入后台的应用程序期待尽可能快的进入非活动状态以便它们能够被系统挂起。如果你的应用程序正在执行某个任务而且完成这个任务还需要一些时间的话，你可用调用 <code>UIApplication</code> 的<code>beginBackgroundTaskWithName:expirationHandler:</code> 或<code>beginBackgroundTaskWithExpirationHandler:</code>方法来请求一些额外的执行时间。调用这两个方法的任一个都会暂时的推迟你的应用程序被挂起，从而为完成你正在进行的任务赢得一些额外的时间。一旦你的应用程序完成了任务，你必须调用<code>endBackgroundTask:</code>方法让系统知道你的应用程序已经完成了任务，可以被挂起了。</p>
<p>每个调用<code>beginBackgroundTaskWithName:expirationHandler:</code> 或 <code>beginBackgroundTaskWithExpirationHandler:</code> 方法的应用程序都会生成一个与相应的任务相关的标记。当你的应用程序完成任务时，它必须以这个标记来调用 <code>endBackgroundTask:</code>方法告知系统任务已经完成。调用 <code>endBackgroundTask:</code>方法失败会导致你的应用程序被终止。如果你在启动任务的时候提供了一个完成处理模块，系统会调用这个模块并给你最后一次结束任务避免程序被终止的机会。</p>
<p>你不需要一直到等到应用程序进入后台才指定后台任务。一个更有用的设计是在开始任务之前调用<code>beginBackgroundTaskWithName：expirationHandler：</code>或<code>beginBackgroundTaskWithExpirationHandler：</code>方法，一旦完成就调用<code>endBackgroundTask：</code>方法.</p>
<p>下面的的代码展示了当你的应用程序进入后台时如何开始一个长时运行的任务。在这个例子中，开始后台任务的请求包含了一个完成处理模块以防这个任务耗时太长。这个任务稍后会被提交到一个异步执行的队列中以便<code>applicationDidEnterBackground:</code>方法能够正常返回。blocks的使用简化了维护一些重要变量引用所需要的代码。<code>bgTask</code>变量是指向存储当前任务标识符的指针的类的成员变量，它在调用这个方法之前被初始化。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (void)applicationDidEnterBackground:(UIApplication *)application &#123;</span><br><span class="line">    bgTask &#x3D; [application beginBackgroundTaskWithName:@&quot;MyTask&quot; expirationHandler:^&#123;</span><br><span class="line">        &#x2F;&#x2F; Clean up any unfinished task business by marking where you</span><br><span class="line">        &#x2F;&#x2F; stopped or ending the task outright.</span><br><span class="line">        [application endBackgroundTask:bgTask];</span><br><span class="line">        bgTask &#x3D; UIBackgroundTaskInvalid;</span><br><span class="line">    &#125;];</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; Start the long-running task and return immediately.</span><br><span class="line">    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F; Do the work associated with the task, preferably in chunks.</span><br><span class="line"> </span><br><span class="line">        [application endBackgroundTask:bgTask];</span><br><span class="line">        bgTask &#x3D; UIBackgroundTaskInvalid;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意:</strong> 你总是要在开始一个任务的时候提供完成处理模块，但是如果你想知道你的应用程序还能运行多长时间，你可以通过<code>UIApplication</code>对象的<code>backgroundTimeRemaining</code>属性来获得。</p>
</blockquote>
<p>在你的完成处理模块中，你可以加入一些必须的代码来关闭你的任务。但是，完成处理模块中的任何代码都不应该耗费太长的时间去执行，因为你的完成处理模块一旦被调用，就说明你的应用程序已经快要被关闭了。因此，只执行最少的清理状态信息并结束任务。</p>
<h2 id="在后台执行下载任务"><a href="#在后台执行下载任务" class="headerlink" title="在后台执行下载任务"></a>在后台执行下载任务</h2><p>当下载文件时，应用程序应该使用<code>NSURLSession</code>对象来开始下载，这样系统就能控制下载的进程即使应用程序被挂起或终止。当你配置<code>NSURLSession</code>对象进行后台传输时，系统用一个单独的队列管理这些任务并以常规方式将传输的状态报告给你的应用程序。如果你的应用程序在传输正在进行时被终止，系统会在后台继续传输，并在传输完成或一个甚至多个任务需要你的应用程序时启动你的应用程序(若果使用)。</p>
<p>为了支持后台传输，你必须合适地配置你的<code>NSURLSession</code>对象。为了配置<code>NSURLSession</code>有必须先创建一个<code>NSURLSessionConfiguration</code>对象并给它的一些属性赋予合适的值。然后将这个<code>NSURLSessionConfiguration</code>对象在初始化<code>NSURLSession</code>对象时传递过去。</p>
<p>创建支持后台下载的<code>NSURLSessionConfiguration</code>对象的过程如下：</p>
<p>   1.使用<code>NSURLSessionConfiguration</code>的<code>backgroundSessionConfigurationWithIdentifier：</code>方法创建配置对象。</p>
<p>   2.将配置对象的<code>sessionSendLaunchEvents</code>属性的值设置为<code>YES</code>。</p>
<p>   3.如果你的应用程序在前台进行转移，建议你将<code>sessionSendsLaunchEvents</code>属性设置为<code>YES</code>。</p>
<p>   4.根据需要配置配置对象的任何其他属性。</p>
<p>   5.使用配置对象创建您的<code>NSURLSession</code>对象。</p>
<p>一旦配置完成，你的<code>NSURLSession</code>对象会在合适的时间将上传和下载任务移交给系统。如果任务在你的应用程序仍在运行时完成(无论是在前台或是后台)，<code>NSURLSession</code>对象都会以常规方式通知它的代理。如果任务还未完成时你的应用程序就被终止，系统会自动地在后台管理任务。如果用户终止了你的应用程序，系统会停止任何待处理的任务。</p>
<p>当所有与后台会话管理的任务完成时，系统会重启被终止的应用程序(假定<code>sessionSendsLaunchEvents</code>属性被设置为<code>YES</code>而且这个应用程序不是被用户强制终止的)并调用应用代理的<code>application:handleEventsForBackgroundURLSession:completionHandler:</code>方法。(系统还可以重新启动应用程序来处理身份验证或其他需要你的应用程序注意的任务的相关事件)在执行该委托方法时，请使用提供的标识符创建一个新的与之前相同的<code>NSURLSessionConfiguration</code>和<code>NSURLSession</code>对象。 系统将你的新会话对象重新连接到先前的任务，并将其状态报告给会话对象的委托。</p>
<h2 id="执行长时间运行的任务"><a href="#执行长时间运行的任务" class="headerlink" title="执行长时间运行的任务"></a>执行长时间运行的任务</h2><p>对于需要更多后台执行时间的任务，你必须请求特定的权限才能在后台运行它们而不被挂起。iOS中，只有特定类型的应用程序被允许在后台运行：</p>
<ul>
<li>在后台播放音频内容给用户，比如音乐播放器</li>
<li>在后台录制音频文件</li>
<li>使用户随时了解其位置的应用程序，比如导航应用程序</li>
<li>支持VoIP的应用程序</li>
<li>需要经常性的下载和处理新内容的应用程序</li>
<li>周期性的从外部配件接收更新的应用程序</li>
</ul>
<p>使用这些服务的应用程序必须声明其支持的服务，并使用系统框架来实现这些服务的相关方面。</p>
<h3 id="声明你的应用程序支持的后台模式"><a href="#声明你的应用程序支持的后台模式" class="headerlink" title="声明你的应用程序支持的后台模式"></a>声明你的应用程序支持的后台模式</h3><p>你必须在应用程序使用后台任务之前声明你要支持的后台任务类型。在Xcode 5和之后，你需要在你工程的Capabilities选项卡中声明你要支持哪些后台模式。启用后台模式选项将<code>UIBackgroundModes</code>键添加到应用程序的<code>Info.plist</code>文件中。</p>
<p>下表列出了你可以指定的后台模式的值：</p>
<table>
<thead>
<tr>
<th>Xcode后台模式</th>
<th>UIBackgroundModes 值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>音频和AirPlay</td>
<td><code>audio</code></td>
<td>应用程序在后台播放或录制音频内容。用户必须在第一次使用前就授权使用麦克风。</td>
</tr>
<tr>
<td>位置更新</td>
<td><code>location</code></td>
<td>使用户随时知道他们的位置，即使应用在后台运行。</td>
</tr>
<tr>
<td>网络电话</td>
<td><code>voip</code></td>
<td>应用程序提供给用户通过网络连接进行通话的能力。</td>
</tr>
<tr>
<td>Newsstand下载</td>
<td><code>newsstand-content</code></td>
<td>Newsstand类型的应用程序在后台下载并处理报纸或杂志内容。</td>
</tr>
<tr>
<td>外部附件通信</td>
<td><code>external-accessory</code></td>
<td>应用程序与需要通过外部附件框架定期提供更新的硬件配件配合使用。</td>
</tr>
<tr>
<td>使用蓝牙设备</td>
<td><code>bluetooth-central</code></td>
<td>应用程序使用需要通过Core Bluetooth框架定期发送更新的蓝牙设备。</td>
</tr>
<tr>
<td>作为蓝牙LE附件</td>
<td><code>bluetooth-peripheral</code></td>
<td>应用程序通过Core Bluetooth框架支持外设模式下的蓝牙通信。使用此模式需要用户授权</td>
</tr>
<tr>
<td>后台抓取</td>
<td><code>fetch</code></td>
<td>应用程序定期的从网路下载并处理少量数据。</td>
</tr>
<tr>
<td>远程推送</td>
<td><code>remote-notification</code></td>
<td>应用程序想要在接收到一个远程推送时开始下载内容。</td>
</tr>
</tbody></table>
<p>以上每种模式都让系统知道应该在合适的时间唤醒或启动应用程序来响应相关的事件。</p>
<h4 id="追踪用户位置"><a href="#追踪用户位置" class="headerlink" title="追踪用户位置"></a>追踪用户位置</h4><p>在后台追踪用户的位置的方式有好几种，大多数方式实际上并不需要你的应用程序在后台不断的运行。</p>
<ul>
<li>重大位置变更</li>
<li>仅在前台定位服务</li>
<li>后台定位服务</li>
</ul>
<p>对于不需要高精度位置数据的应用程序来说，推荐使用重大位置变更定位服务。这个服务只有在用户的位置发生非常重大的变化时才会产生位置更新；它对社交类应用程序或者给用户提供不是很重要的位置相关信息的应用程序来说是非常理想的定位方式。如果当一个位置更新发生时应用程序被终止，系统会在后台唤醒它来处理这个更新。如果应用程序开始使用了这个服务然后被终止，当新的位置更新产生时，系统会自动重启它。</p>
<p>仅前台定位服务和后台定位服务都使用标准的Core Location服务获取位置数据。唯一的区别是，如果应用程序被挂起，则仅前台定位服务停止发送更新。 前台定位服务适用于只在前台需要位置数据的应用程序。</p>
<p>你可以在Xcode工程中的<code>Capabilities</code>选项卡中启用支持定位服务(你也可以通过在<code>Info.plist</code>文件中设置<code>UIBackgroundModes</code>的值为<code>location</code>来启用这个服务)。启用这个服务并不会阻止系统挂起你的应用程序，但是它会告知系统无论何时新的位置更新被发送过来都应该唤醒应用程序来处理。</p>
<blockquote>
<p><strong>重要提示:</strong>鼓励你谨慎使用标准的定位服务或改用重要的位置更改服务。 定位服务需要经常使用iOS设备的板载无线电硬件。 连续运行这个硬件会消耗大量的电量。 如果你的应用程序不需要向用户提供精确且连续的位置信息，则最好尽量减少使用位置服务。</p>
</blockquote>
<h4 id="在后台播放或录制音频"><a href="#在后台播放或录制音频" class="headerlink" title="在后台播放或录制音频"></a>在后台播放或录制音频</h4><p>一个需要连续播放或录制音频的应用程序(即使应用处在后台)可以注册后台服务，实现即使在后台也能执行这些任务。你可以在Xcode工程中的<code>Capabilities</code>选项卡中启用服务(你也可以通过在<code>Info.plist</code>文件中设置<code>UIBackgroundModes</code>的值为<code>audio</code>来启用这个服务)。在后台播放音频内容的应用程序必须播放听得见的内容而不能是无声的。</p>
<p>后台音频应用程序的典型例子包括：</p>
<ul>
<li>音乐播放程序</li>
<li>音频录制程序</li>
<li>支持通过AirPlay播放音频或视频的程序</li>
<li>VoIP程序</li>
</ul>
<p>当<code>UIBackgroundModes</code>键包含<code>audio</code>值时，系统的媒体框架会自动阻止相关的应用程序被挂起。只要应用程序还在播放视屏或音频内容，录制音频，它就还能在后台运行。然而，一旦录制或播放停止，就会被系统挂起。</p>
<p>你可以使用任何系统音频框架来处理后台音频播放，并且使用这些框架的过程和在前台使用相同(对于通过AriPlay播放视频内容来说，你可以使用Media Player或AVFoundation框架来实现)。因为应用程序在播放媒体文件时不会被挂起，所以即使应用程序在后台也能正常的进行回调操作。在你的回调中，你应该只做为播放提供数据的工作，不应该在回调中执行任何与播放无关的任务。</p>
<p>在任何给定的时刻，因为可能有不止一个应用程序支持音频服务，所以由系统来决定哪个应用程序能够播放或录制音频。前台应用程序总是有优先的音频操作权利。可能有不止一个应用程序被允许在后台播放音频，这个时候决定哪个应用程序能够播放音频就取决于每个应用程序的音频会话的配置。</p>
<h4 id="实现一个VoIP应用程序"><a href="#实现一个VoIP应用程序" class="headerlink" title="实现一个VoIP应用程序"></a>实现一个VoIP应用程序</h4><p>一个Voice over Internet Protocol应用程序允许用户通过互联网而不是设备的蜂窝网络设备进行语音通话。这样的一个应用程序需要为它的服务维持一个持续的网络连接，以便它能接收到打进来的电话和其它相关数据。系统允许VoIP应用程序被挂起并给它提供了监测它们的sockets的便利，而不是让它一直处于唤醒状态。当检测到传入流量时，系统唤醒VoIP程序并将socket的控制权交还给它。</p>
<p>为了配置VoIP应用程序，你必须：</p>
<ul>
<li>在Xcode工程中的<code>Capabilities</code>选项卡中启用服务(你也可以通过在<code>Info.plist</code>文件中设置<code>UIBackgroundModes</code>的值为<code>voip</code>来启用这个服务)。</li>
<li>为VoIP应用程序配置一个socket。</li>
<li>在移动到后台之前，调用<code>setKeepAliveTimeout:handler:</code>方法来安装一个定期执行的程序。你的应用程序可以使用这个处理程序来保持服务连接。</li>
<li>配置你的音频会话来操作进入或退出活跃的使用状态的转换。</li>
</ul>
<p>设置<code>UIBackgroundModes</code>的值为<code>voip</code>让系统知道，当VoIP应用程序需要管理它的网络会话时，系统应该允许它在后台运行。为了让VoIP应用程序总是可用，系统会在启动后立刻重新启动拥有这个键值的应用程序。</p>
<p>大多数的VoIP应用程序也需要配置后台音频模式，因为它也需要在后台发送音频内容。因此，你应该将<code>UIBackgroundModes</code>的值设置为<code>audio</code>和<code>voip</code>。如果你不这样做的话，你的应用程序将不能在后台播放或录制音频内容。</p>
<h4 id="适时的获取少量内容"><a href="#适时的获取少量内容" class="headerlink" title="适时的获取少量内容"></a>适时的获取少量内容</h4><p>需要定期的检查新内容的应用程序可以请求系统唤醒它们，以便它们可以初始化一个获取内容的拉取操作。为了支持这种模式，你需要在Xcode工程中的<code>Capabilities</code>选项卡中启用服务(你也可以通过在<code>Info.plist</code>文件中设置<code>UIBackgroundModes</code>的值为<code>fetch</code>来启用这个服务)。启用这个服务并不能保证系统会给你的应用程序任何时间来执行后台拉取操作。系统必须在你的应用程序拉取内容的请求和其它应用程序以及系统自身之间做出平衡。在评估所有信息后，如果有很好的机会的话，系统会给请求拉取内容的应用程序一些执行时间。</p>
<p>当有好机会产生时，系统会唤醒或启动你的应用程序到后台并调用应用程序代理对象的<code>application:performFetchWithCompletionHandler:</code>方法。使用这个方法来检查新内容，如果新内容可用则开始下载操作。一旦新内容下载完成，你必须将新内容是否可用的结果传递给提供好的完成处理块。执行这个块告诉系统它可以将你的应用程序转换到挂起状态并评估其使用功率。可以快速下载少量内容并在它们有可用的下载内容时准确反应的应用程序，比起花费更长的下载时间或声称有可用的下载内容但没有下载任何东西的应用程序，更可能在未来获得执行时间。</p>
<p>在下载任何内容时，推荐你使用<code>NSURLSession</code>类来开始和管理你的下载。</p>
<h4 id="使用推送通知来开始下载"><a href="#使用推送通知来开始下载" class="headerlink" title="使用推送通知来开始下载"></a>使用推送通知来开始下载</h4><p>如果你的服务器在有新的应用程序可用内容时向用户的设备发送了一个推送通知，你可以请求系统在后台运行你的应用程序并立即开始下载新的可用内容。这种后台模式意图在于尽可能减少从你的用户看见推送通知到你的应用程序可以展示相关内容之间的时间。应用程序通常会在用户看见推送通知的差不多相同的时间被唤醒，但是仍会给你更多的准备时间。</p>
<p>为了支持这种模式，你需要在Xcode工程中的<code>Capabilities</code>选项卡中启这项用服务(你也可以通过在<code>Info.plist</code>文件中设置<code>UIBackgroundModes</code>的值为<code>remote-notification</code>来启用这个服务)。</p>
<p>对于一个使用推送通知来触发下载操作的应用程序来说，通知的有效内容必须包含值为<code>1</code>的<code>content-available</code>的键。当这个键值对被检测到时，系统会启动或唤醒你的应用程序到后台同时调用应用程序的代理对象的<code>application:didReceiveRemoteNotification:fetchCompletionHandler:</code>方法。你应该在这个方法里实现对相关内容的下载并将下载好的内容在加入到你的应用程序中。</p>
<p>在下载任何内容时，推荐你使用<code>NSURLSession</code>类来开始和管理你的下载。</p>
<h4 id="在后台下载新闻站内容"><a href="#在后台下载新闻站内容" class="headerlink" title="在后台下载新闻站内容"></a>在后台下载新闻站内容</h4><p>下载新闻和新的杂志文章的新闻站应用程序可以注册在后台进行这些下载。你需要在Xcode工程中的<code>Capabilities</code>选项卡中启这项用服务(你也可以通过在<code>Info.plist</code>文件中设置<code>UIBackgroundModes</code>的值为<code>newsstand-content</code>来启用这个服务)。当你提供这个关键字时，如果你的应用程序没有在运行，系统会启动你的应用程序以便它能开始下载新的文章。</p>
<p>当你使用Newsstand Kit框架来开始一个下载时，由系统为你的应用程序操作下载的进程。即使你的应用程序被挂起或终止，系统仍会继续下载文件。当下载操作完成后，系统将下载好的文件传输到你的应用程序的沙盒并向你的应用程序发送一个通知。如果应用程序没有在运行，这个通知会唤醒它并给它一个处理新的下载文件的机会。如果在下载过程中发生了错误，你的应用程序也会这样被唤醒来处理这个错误。</p>
<h4 id="与外部附件通信"><a href="#与外部附件通信" class="headerlink" title="与外部附件通信"></a>与外部附件通信</h4><p>使用外部附件的应用程序可以请求在附件发送了一个更新时被唤醒，即使它处在挂起状态。这种支持对于某些定期发送数据的附件来说是非常重要的，比如心率监视器。你需要在Xcode工程中的<code>Capabilities</code>选项卡中启这项用服务(你也可以通过在<code>Info.plist</code>文件中设置<code>UIBackgroundModes</code>的值为<code>external-accessory</code>来启用这个服务)。当你启用这个模式时，外部附件框架不会关闭活跃的外部附件会话。当外部附件发送来新的内容时，这个框架唤醒你的应用程序以便它能处理这些数据内容。在外部附件建立连接或失去连接时，系统也会唤醒应用程序来进行处理。</p>
<p>任何支持附件更新后台处理的应用程序都必须遵循以下基本准则：</p>
<ul>
<li><p>应用程序必须提供一个界面，让用户来开始或者停止附件更新事件的发送。</p>
</li>
<li><p>一旦被唤醒，应用程序大约有10S时间来处理数据。理想情况下，它应该尽可能快速地处理数据然后转换到挂起状态。但是，如果需要更多的时间，应用程序可以使用<code>beginBackgroundTaskWithExpirationHandler:</code>方法来申请额外的执行时间。</p>
</li>
</ul>
<h4 id="与蓝牙附件通信"><a href="#与蓝牙附件通信" class="headerlink" title="与蓝牙附件通信"></a>与蓝牙附件通信</h4><p>使用蓝牙外设的应用程序可以请求在外设发送了一个更新时被唤醒，即使它处在挂起状态。这种支持对于需要定期发送数据的Bluetooth-LE外设来说是非常重要的。你需要在Xcode工程中的<code>Capabilities</code>选项卡中启这项用服务(你也可以通过在<code>Info.plist</code>文件中设置<code>UIBackgroundModes</code>的值为<code>bluetooth-central</code>来启用这个服务)。当你启用这个模式时，Core Bluetooth框架会保持相应外设的任何活跃会话连接。此外，当有新的数据从外设传来，系统会唤醒应用程序让他能够处理数据。在外设建立连接或失去连接时，系统也会唤醒应用程序来进行处理。</p>
<p>iOS 6中，一个使用蓝牙外设的应用程序也可以在外设模式下运行。要充当蓝牙外设，你需要在Xcode工程中的<code>Capabilities</code>选项卡中启这项用服务(您也可以通过在应用程序<code>Info.plis</code>t文件中包含<code>UIBackgroundModes</code>键和<code>bluetooth-peripheral</code>值来启用此支持)。启用此模式可让Core Bluetooth框架在后台简单地唤醒应用程序，以便它可以处理外设的相关请求。</p>
<p>支持蓝牙数据后台处理的任何应用程序都必须基于会话，并遵循以下基本准则：</p>
<ul>
<li><p>应用程序必须提供一个界面，允许用户启动和停止蓝牙事件的传递。</p>
</li>
<li><p>被唤醒后，应用程序大概需要10秒钟才能处理数据。理想情况下，它应该尽可能快地处理数据，并允许自己再次暂停。但是，如果需要更多的时间，应用程序可以使用<code>beginBackgroundTaskWithExpirationHandler</code>：方法来请求更多的时间，它应该只有在绝对必要的时候才这样做。</p>
<p>​</p>
</li>
</ul>
<h2 id="在后台获得用户的注意"><a href="#在后台获得用户的注意" class="headerlink" title="在后台获得用户的注意"></a>在后台获得用户的注意</h2><p>通知是处在挂起，在后台运行或没有运行的应用程序获得用户的注意的一种方式。应用程序可以使用本地通知来显示提醒框，播放声音，标记应用程序的图标或者全部一起使用。比如，一个闹钟应用程序可能会使用本地通知来播放闹铃声并显示一个提醒框来使闹钟不可用。当一个通知被发送给用户，用户必须决定是否授权让应用程序来到前台。如果应用程序已经在前台，本地通知将会被静默的发送给你的应用程序而不是发送给用户。</p>
<p>为了安排本地通知的发送，需要创建一个配置了通知的各个参数的<code>UILocalNotification</code>类的实例并调用<code>UIApplication</code>类的方法。本地通知对象包含了发送通知的类型和在什么时间发送它的信息。<code>UIApplication</code>类的方法提供了是立即发送还是按时间表发送通知的选项。</p>
<p>下面的代码片段展示了如何安排一个由用户设置的使用了日期和时间的闹钟的例子。这个例子在一个时间只配置了一个闹钟并在安排它之前终止了前一个闹钟(你的应用程序在任何给定的时刻都不能拥有超过128个处在活跃状态的本地通知，它们每一个都能设置成以固定的时间间隔重复)。如果闹钟被触发时，应用程序没有运行或者处在后台，闹钟会弹出提醒框并在后台播放音频。如果应用程序是活动且处在前台，则会调用应用程序的代理对象的<code>application:didReceiveLocalNotification:</code>方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (void)scheduleAlarmForDate:(NSDate*)theDate &#123;</span><br><span class="line">    UIApplication* app &#x3D; [UIApplication sharedApplication];</span><br><span class="line">    NSArray*    oldNotifications &#x3D; [app scheduledLocalNotifications];</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; Clear out the old notification before scheduling a new one.</span><br><span class="line">    if ([oldNotifications count] &gt; 0)</span><br><span class="line">        [app cancelAllLocalNotifications];</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; Create a new notification.</span><br><span class="line">    UILocalNotification* alarm &#x3D; [[UILocalNotification alloc] init];</span><br><span class="line">    if (alarm)</span><br><span class="line">    &#123;</span><br><span class="line">        alarm.fireDate &#x3D; theDate;</span><br><span class="line">        alarm.timeZone &#x3D; [NSTimeZone defaultTimeZone];</span><br><span class="line">        alarm.repeatInterval &#x3D; 0;</span><br><span class="line">        alarm.soundName &#x3D; @&quot;alarmsound.caf&quot;;</span><br><span class="line">        alarm.alertBody &#x3D; @&quot;Time to wake up!&quot;;</span><br><span class="line"> </span><br><span class="line">        [app scheduleLocalNotification:alarm];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本地通知使用的音频文件和推送通知使用的要求相同。自定义的音频文件必须位于你应用程序主要包中且必须是以下几种格式：Linear PCM，MA4，μ-Law或者a-Law。你也可以指定<code>UILocalNotificationDefaultSoundName</code>常量来使设备播放默认的提醒声音。当通知被发送且音频被播放时，系统也会触发设备震动来配合。</p>
<h2 id="何时启动应用程序进入后台"><a href="#何时启动应用程序进入后台" class="headerlink" title="何时启动应用程序进入后台"></a>何时启动应用程序进入后台</h2><p>支持后台执行的应用程序可能会被系统重启来处理发生的事件。如果应用程序不是被用户强制退出，系统会启动应用程序在下列事件发生时：</p>
<ul>
<li>对于定位应用程序<ul>
<li>系统收到一个满足发送给应用程序标准的位置更新。</li>
<li>设备进入或退出一个已注册的区域。</li>
</ul>
</li>
<li>对于音频应用程序，音频框架需要应用程序来处理某些数据。</li>
<li>对于蓝牙应用程序<ul>
<li>应用程序作为从连接的外设接收数据的核心角色。</li>
<li>应用程序作为从连接核心接收命令的外设。</li>
</ul>
</li>
<li>对于后台下载应用程序<ul>
<li>应用程序收到一个包含 <code>content-available</code> 键并且值为 <code>1</code>的远程通知。</li>
<li>系统在随机时间唤醒应用程序来开始新内容的下载。</li>
<li>使用<code>NSURLSession</code>对象在后台下载内容的应用程序，当这个会话相关的任务全部成功完成或发生了一个错误。</li>
<li>Newsstand应用程序内容下载完成。</li>
</ul>
</li>
</ul>
<p>在大多数情况下，系统并不会重启被用户强制退出的应用程序。定位应用程序是个例外，在iOS8和之后。如果不是的话，用户必须显式的启动应用程序或者重启设备，系统才能自动的启动程序进入后台。当启用密码保护时，在用户第一次解锁设备之前，系统不会启动任何应用程序进入后台。</p>
<h2 id="成为一个负责的后台运行应用程序"><a href="#成为一个负责的后台运行应用程序" class="headerlink" title="成为一个负责的后台运行应用程序"></a>成为一个负责的后台运行应用程序</h2><p>在使用系统资源和硬件时，前台应用程序始终比后台应用程序的优先级高。后台应用程序需要为这个差异做准备并调整它们的行为：</p>
<ul>
<li><strong>不要在你的代码中进行任何OpenGL ES调用</strong>。在后台运行时，你绝不能创建<code>EAGLContext</code>对象或发出任何OpenGL ES绘图命令。使用这些会使你的应用程序被立即终止。应用程序必须保证任何先前提交的命令在移入后台之前完成。</li>
</ul>
<ul>
<li><strong>在挂起之前停止任何Bonjour-related服务</strong>。在你的应用程序移入后台但未被挂起之前，它应该从Bonjour注销并关闭任何与网络服务相关的监听sockets。一个挂起的应用程序无论如何不能响应任何传入的服务请求。如果你没有关闭Bonjour服务，在应用程序挂起时，系统会自动的关闭它们。</li>
<li><strong>准备好处理基于网络的sockets的连接失败</strong>。系统可能会销毁socket连接，当你的应用程序因为某些原因被挂起时。只要你的基于网络的socket代码准备好了如何处理其他类型的网络失败，比如使用失败信号或网络转化，socket被销毁就不会导致出现任何不寻常的问题。当你的应用程序重新开始运行时，如果使用socket遭遇故障，只需重新建立一个。</li>
<li><strong>在转入后台之前保存你的应用程序的状态</strong>。处于低内存的情况下，后台应用程序可能会被从内存中移除以释放空间。挂起的应用程序首先被移除，并且不会在移除之前通知应用程序。因此，应用程序应该利用iOS 6及之后提供的状态保存机制将应用程序状态信息保存到磁盘。</li>
<li><strong>在转入后台时移除对任何不需要的对象的强引用</strong>。</li>
<li><strong>在挂起之前停止使用共享系统资源</strong>。与共享系统资源进行交互的应用程序应该在被挂起之前停止使用这些资源。前台应用程序总是拥有这些资源的优先使用权。当你的应用程序挂起时，如果被发现它在使用这些共享资源，则会被系统杀死进程。</li>
<li><strong>避免更新窗口和视图</strong>。因为你的应用程序的窗口和视图在后台是不可见的，你应该避免更新它们。如果你的应用程序需要在系统拍摄快照前更新窗口的内容的话则是一种例外情况。</li>
<li><strong>响应外部附件的连接和断开通知</strong>。对于和外部附件通信的应用程序来说，当应用程序转入后台时系统会自动的发送一个断开通知。应用程序必须注册这个通知并用它来关闭当前附件的会话。当应用程序转入前台时，一个匹配连接的通知被发送，给应用程序重新连接的机会。</li>
<li><strong>在转入后台时清理活动的提醒框的资源</strong>。为了在各个应用程序之间进行切换时保存上下文，在你的应用程序进入后台时，系统不会自动地释放上拉菜单或提醒视图。在应用程序转入后台之前，你需要提供合适的清理行为。</li>
<li><strong>在转入后台之前从视图中移除敏感信息</strong>。当应用程序转入后台时，系统会对应用程序的主窗口拍摄快照，当应用程序转入到前台时，这个快照会短暂的显示。在从<code>applicationDidEnterBackground:</code>方法返回之前，你应该隐藏或混淆可能被作为快照一部分拍摄的密码和其它敏感的个人信息</li>
<li><strong>在后台运行时尽可能的少做工作</strong>。给与后台应用程序的执行时间相比于前台应用程序来说有更多的限制。应用程序不应该在后台执行太长时间，这可能导致应用程序被终止。</li>
</ul>
<h2 id="选择退出后台执行"><a href="#选择退出后台执行" class="headerlink" title="选择退出后台执行"></a>选择退出后台执行</h2><p>如果你不希望你的应用程序在后台运行，你可以通过将值为<code>YES</code>的<code>UIApplicationExitsOnSuspend</code>键加入<code>Info.plist</code>来显式的退出后台模式。当一个应用程序选择退出后台，它的生命周期将在未运行，非活动和活动状态之间转换，永远不会进入后台或被挂起状态。当用户按下Home按钮来退出应用程序时，应用程序代理对象的<code>applicationWillTerminate:</code>方法将会被调用，应用程序将有大约5秒时间在它被终止或移入未运行状态之前来执行清理任务并退出。</p>
<p>强烈不鼓励退出后台执行，但在某些情况下可能是首选。 具体来说，如果后台执行的编码对你的应用程序来说增加了很大的复杂性，那么终止应用程序可能会更简单。 此外，如果你的应用程序消耗大量内存，并且无法轻松释放任何内存，系统可能会迅速杀死你的应用程序，为其他应用程序腾出空间。 因此，选择终止，而不是切换到后台，可能会产生相同的结果，并节省你的开发时间和精力。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/blogs/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/blogs/">1</a><a class="page-number" href="/blogs/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/blogs/page/4/">4</a><a class="extend next" rel="next" href="/blogs/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">CocoaLei</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/blogs/archives/">
        
          <span class="site-state-item-count">32</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/blogs/categories">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/blogs/tags/">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">CocoaLei</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/blogs/lib/anime.min.js"></script>
  <script src="/blogs/lib/velocity/velocity.min.js"></script>
  <script src="/blogs/lib/velocity/velocity.ui.min.js"></script>

<script src="/blogs/js/utils.js"></script>

<script src="/blogs/js/motion.js"></script>


<script src="/blogs/js/schemes/pisces.js"></script>


<script src="/blogs/js/next-boot.js"></script>




  















  

  

</body>
</html>
