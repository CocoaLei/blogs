<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>关于代码的碎碎念</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="LeiTech"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="LeiTech"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="ODQ4NjUwMTI5QHFxLmNvbQ&amp;#x3D;&amp;#x3D;"><meta property="og:type" content="blog"><meta property="og:title" content="关于代码的碎碎念"><meta property="og:url" content="https://cocoalei.github.io/blogs"><meta property="og:site_name" content="关于代码的碎碎念"><meta property="og:description" content="ODQ4NjUwMTI5QHFxLmNvbQ&amp;#x3D;&amp;#x3D;"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://cocoalei.github.io/img/og_image.png"><meta property="article:author" content="Y2hlbmdsZWk="><meta property="article:tag" content="iOS,HTML,CSS,JavaScript,Vue.js"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://cocoalei.github.io/blogs"},"headline":"关于代码的碎碎念","image":["https://cocoalei.github.io/img/og_image.png"],"author":{"@type":"Person","name":"Y2hlbmdsZWk="},"publisher":{"@type":"Organization","name":"关于代码的碎碎念","logo":{"@type":"ImageObject","url":"https://cocoalei.github.io/img/logo.svg"}},"description":"ODQ4NjUwMTI5QHFxLmNvbQ&#x3D;&#x3D;"}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-dark.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.4.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="关于代码的碎碎念" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2015-11-19T16:00:00.000Z" title="2015/11/20 上午12:00:00">2015-11-20</time>发表</span><span class="level-item"><a class="link-muted" href="/categories/iOS/">iOS</a></span><span class="level-item">34 分钟读完 (大约5120个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2015/11/20/iOS-RunLoop/">RunLoop 探索与分析</a></h1><div class="content"><h2 id="RunLoop-基础"><a href="#RunLoop-基础" class="headerlink" title="RunLoop 基础"></a>RunLoop 基础</h2><h3 id="什么是RunLoop？"><a href="#什么是RunLoop？" class="headerlink" title="什么是RunLoop？"></a>什么是RunLoop？</h3><p>RunLoop 是一种让线程能随时处理事件但并不退出的机制，是一个用来调度工作的和协调接受的事件的循环。</p>
<p>iOS系统中，提供了 NSRunLoop 和 CFRunLoopRef 两个对象来实现 RunLoop。RunLoop 对象管理其需要处理的事件和消息，并提供了一个入口函数来执行事件循环的逻辑。线程执行了这个函数之后，就会一直处于这个函数内部的循环中，直到这个循环结束，函数返回。</p>
<p>CFRunLoopRef 是在 CoreFoundation 框架内的，提供了纯C函数的API，所有这些API都是线程安全的。</p>
<p>NSRunLoop 是基于 CFRunLoopRef 的封装，提供了面向对象的API，但这些API不是线程安全的。</p>
<h3 id="RunLoop与线程的关系"><a href="#RunLoop与线程的关系" class="headerlink" title="RunLoop与线程的关系"></a>RunLoop与线程的关系</h3><p>线程和 RunLoop 之间是一一对应的，其关系保存在一个全局的 Dictionary 中。线程刚创建是并没有 RunLoop，如果你不主动获取，那它一直不会有。RunLoop 的创建是在第一次获取时发生的，RunLoop 的销毁是在线程结束时发生的。</p>
<p>你只能在一个线程内部获取它的 RunLoop(主线程除外)。</p>
<h3 id="RunLoop的对外接口"><a href="#RunLoop的对外接口" class="headerlink" title="RunLoop的对外接口"></a>RunLoop的对外接口</h3><p>在 CoreFoundation 中关于 RunLoop 的类有以下几个：</p>
<ul>
<li>CFRunLoopRef</li>
<li>CFRunLoopModeRef</li>
<li>CFRunLoopSourceRef</li>
<li>CFRunLoopTImerRef</li>
<li>CFRunLoopObserverRef</li>
</ul>
<p>一个 RunLoop 包含若干个 Mode ，每个 Mode 又包含若干个 Source/Timer/Observer。每次调用 RunLoop 的主函数时，只能指定其中一个 Mode。如果需要切换 Mode ，只能退出 RunLoop，再重新指定一个 Mode 进入。这样做的目的是为了分隔开不同组的 Source/Timer/Observer，使其不能互相影响。</p>
<p>CFRunLoopSourceRef 是事件产生的地方，有两个版本 Source0 和 Source1：</p>
<ul>
<li>Source0 只包含了一个回调(函数指针)，它并不能主动触发事件。使用时，你需要先调用 CFRunLoopSourceSignal(source)，将这个 Source 标记为待处理，然后手动调用 CFRunLoopWakeUp(runLoop) 来唤醒 RunLoop ，让其处理这个事件。</li>
<li>Source1 包含了一个 mach_port 和一个回调(函数指针)，被用于通过内核和其它线程相互发送消息，它能主动唤醒 RunLoop 的线程。</li>
</ul>
<p>CFRunLoopTimerRef 是基于时间的触发器，他和 NSTimer 是 toll-free bridge 的，可以混用。包含一个时间长度和一个回调(函数指针)。当其加入到 RunLoop 中时，RunLoop 会注册对应的时间点，当时间点到时，RunLoop 会被唤醒执行那个回调。</p>
<p>CFRunLoopObserverRef 是观察者，每个 Observer 都包含了一个回调(函数指针)，当 RunLoop的状态发生变化时，观察者就能通过回调接收到这个变化。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActiviry) &#123;</span><br><span class="line">	kCFRunLoopEntry			=	(1UL &lt;&lt; 0),	// 即将进入 RunLoop</span><br><span class="line">  	kCFRunLoopBeforeTimers	=	(1UL &lt;&lt; 1), // 即将处理 Timer</span><br><span class="line">    kCFRunLoopBeforeSources	=	(1UL &lt;&lt; 2), // 即将处理 Source</span><br><span class="line">  	kCFRunLoopBeforeWaiting	=	(1UL &lt;&lt; 5), // 即将进入休眠</span><br><span class="line">    kCFRunLoopAfterWaiting	=	(1UL &lt;&lt; 6), // 刚从休眠中唤醒</span><br><span class="line">    kCFRunLoopExit			=	(1UL &lt;&lt; 7), // 即将退出 RunLoop</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Source/Timer/Observer 被统称为 Mode Item，一个 item 可以被同时加入多个 Mode。但是一个item被重复加入一个 Mode 不会产生效果。如果一个 Mode 中没有一个 item，则 RunLoop会直接退出，不进入循环。</p>
<h3 id="RunLoop-的Mode"><a href="#RunLoop-的Mode" class="headerlink" title="RunLoop 的Mode"></a>RunLoop 的Mode</h3><p>CFRunLoopMode 和 CFRunLoop 的结构大致如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">CFRunLoopMode</span> &#123;</span></span><br><span class="line">	CFStringRef			_name;</span><br><span class="line">  	CFMutableSetRef		_source0;</span><br><span class="line">  	CFMutableSetRef		_source1;</span><br><span class="line">  	CFMutableArrayRef	_observers;</span><br><span class="line">  	CFMutableArrayRef	_timers;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struce __CFRunLoop &#123;</span><br><span class="line">	CFMutableSetRef		_commonModes;</span><br><span class="line">  	CFMutableSetRef		_commonModeItems;</span><br><span class="line">  	CFRunLoopModeRef	_currentMode;</span><br><span class="line">  	CFMutableSetRef		_modes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个 Mode 可以将自己标记为 “Common” 属性(通过将其 ModeName 添加到 RunLoop 的 “CommonModes”中)。每当 RunLoop 的内容发生变化时，RunLoop 都会自动将 _commonModeItmes 里的 Source/Observer/Timer 同步到具有 “Common” 标记的所有 Mode 里。</p>
<p>CFRunLoop对外暴露的管理 Mode 的接口只有两个：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CFRunLoopAddCommonMode(CFRunLoopRef runloop, CFStringRef modeName);</span><br><span class="line">CFRunLoopRunInMode(CFStringRef modeName);</span><br></pre></td></tr></table></figure>

<p>CFRunLoopModeRef 暴露的管理 Mode Item 接口有：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CFRunLoopAddSource(CFRunLoopRef runloop, CFRunLoopSourceRef source, CFStringRef modeName);</span><br><span class="line">CFRunLoopAddObserver(CFRunLoopRef runloop, CFRunLoopObserverRef observer, CFStringRef modeName);</span><br><span class="line">CFRunLoopAddTimer(CFRunLoopRef runloop, CFRunLoopTimerRef timer, CFStringRef modeName);</span><br><span class="line">CFRunLoopRemoveSource(CFRunLoopRef runloop, CFRunLoopSourceRef source, CFStringRef modeName);</span><br><span class="line">CFRunLoopRemoveObserver(CFRunLoopRef runloop, CFRunLoopObserverRef observer, CFStringRef modeName);</span><br><span class="line">CFRunLoopRemoveTimer(CFRunLoopRef runloop, CFRunLoopTimerRef timer, CFStringRef modeName);</span><br></pre></td></tr></table></figure>

<p>你只能通过 mode name 来操作内部的 mode，当你传入一个新的 mode name 时但 RunLoop内部没有对应的 mode 时，RunLoop 会自动的帮你创建对应的 CFRunLoopModeRef。对于一个 RunLoop ，其内部的 mode 只能添加不能删除。</p>
<p>Apple公开提供的 Mode 只有两个：kCFRunLoopDefaultMode(NSDefaultRunLoopMode) 和 UITrackingRunLoopMode，你可以用这两个 Mode Name 来操作其对应的 Mode。</p>
<p>同时 Apple 还提供了一个操作 Common 标记的字符串 : kCFRunLoopModes(NSDefaultRunLoopCommonModes)，你可以用这个字符串来操作 Common Items，或标记一个 Mode 为 “Common”。使用时要注意区分这个字符串和其它 Mode Name。</p>
<h3 id="RunLoop-的内部逻辑"><a href="#RunLoop-的内部逻辑" class="headerlink" title="RunLoop 的内部逻辑"></a>RunLoop 的内部逻辑</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">// DefaultMode 启动</span><br><span class="line">void CFRunLoopRun(void) &#123;</span><br><span class="line">  CFRunLoopRunSpecific(CFRunLoopGetCurrent(),kCFRunLoopDefaultMode, 1.0e10, false);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 用指定的 Mode 启动，允许设置 RunLoop 超时时间</span><br><span class="line">int CFRunLoopRunInMode(CFStringRef ModeName, CFTimeInterval seconds, Boolean stopAfterHandle) &#123;</span><br><span class="line">  return CFRunLoopSpecific(CFRunLoopGetCurrent(), modeName , seconds ,returnAfterSourceHandle)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// RunLoop 的实现</span><br><span class="line">int CFRunLoopRunSpecific(runloop, modeName ,seconds , stopeAfterHandle) &#123;</span><br><span class="line">  // 根据 ModeName 找到对应 Mode</span><br><span class="line">  CFRunLoopModeRef currentMode = __CFRunLoopFinMode(runloop, modeName, false);</span><br><span class="line">  // 如果 Mode 里没有 source/timer/observer，直接返回</span><br><span class="line">  if (__CFRunLoopModeIsEmpty(currentMode)) &#123;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  // 通知 Observer , RunLoop 即将进入 loop</span><br><span class="line">  __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopEntry);</span><br><span class="line">  // 进入 loop</span><br><span class="line">  __CFRunLoopRun(runloop, currentMode, seconds, returnAfterSourceHandle) &#123;</span><br><span class="line">    Boolean sourceHandledThisLoop	=	NO;</span><br><span class="line">    int retVal	=	0;</span><br><span class="line">    do &#123;</span><br><span class="line">      // 通知 Observers : RunLoop 即将触发 Timer 回调</span><br><span class="line">      __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeTimers);</span><br><span class="line">      // 通知 Observers : RunLoop 即将触发 Source0 (非port) 回调</span><br><span class="line">      __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeSources);</span><br><span class="line">      // 执行被加入的 block</span><br><span class="line">      __CFRunLoopDoBlocks(runloop, currentMode);</span><br><span class="line">      // RunLoop 触发 Source0(非port) 回调</span><br><span class="line">      sourceHandledThisLoop	=	__CFRunLoopDoSource0(runloop, currentMode, stopAfterHandele);</span><br><span class="line">      // 执行被加入的 block</span><br><span class="line">      __CFRunLoopDoBlocks(runloop, currentMode);</span><br><span class="line">      </span><br><span class="line">      // 如果有 Source1 处于 ready 状态，直接处理这个 Source1 然后跳转去处理消息</span><br><span class="line">      if (__Source0DidDispatchPortLastTime) &#123;</span><br><span class="line">        Boolean hasMsg	=	__CFRunLoopServiceMachPort(dispatchPort, &amp;msg);</span><br><span class="line">        if (hasMsg)</span><br><span class="line">        &#123;</span><br><span class="line">          goto handle_msg;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      // 通知 Observers : RunLoop 的线程即将结束进入休眠(Sleep)</span><br><span class="line">      if (!sourceHandleThisLoop) &#123;</span><br><span class="line">        __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeWaiting);</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      // 调用 mach_msg 等待接受 mach_port 的消息。线程进入休眠，直到被下面一个事件唤醒</span><br><span class="line">      // 1.一个基于 port 的 Source 的事件</span><br><span class="line">      // 2.一个 Timer 时间到了</span><br><span class="line">      // 3.RunLoop 自身的超时时间到了</span><br><span class="line">      // 4.被其它调用者手动唤醒了</span><br><span class="line">      __CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort) &#123;</span><br><span class="line">        mach_msg(msg, MACH_RCV_MSG, port);</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      // 通知 Observers : RunLoop 的线程刚刚被唤醒了</span><br><span class="line">      __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopAfterWaiting);</span><br><span class="line">      </span><br><span class="line">      // 收到消息，处理消息</span><br><span class="line">      handle_msg;</span><br><span class="line">      </span><br><span class="line">      // 如果一个 Timer 的时间到了，触发这个 Timer 的回调</span><br><span class="line">      if (msg_is_timer) &#123;</span><br><span class="line">        __CFRunLoopDoTimers(runloop, currentMode, mach_absolute_time());</span><br><span class="line">      &#125; else if (msg_is_dispatch) &#123;</span><br><span class="line">      // 如果有 dispatch 到  main_queue 的 block ，执行 block  </span><br><span class="line">        __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE_(msg);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">      // 如果有一个 Source1 发出事件了， 处理这个事件</span><br><span class="line">        CFRunLoopSourceRef	source1	=	__CFRunLoopModeFindSourceForMachPort(runloop, currentMode, livePort);</span><br><span class="line">        sourceHandleThisLoop	=	__CFRunLoopDoSource1(runloop, currentMode, source1,  msg);</span><br><span class="line">        if (sourceHandleThisLoop) &#123;</span><br><span class="line">          mach_msg(reply, MACH_SEND_MSG, reply);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      // 执行加入到 Loop 的 block</span><br><span class="line">      __CFRunLoopDoBlocks(runloop, currentMode);</span><br><span class="line">      </span><br><span class="line">      if (sourceHandleThisLoop &amp;&amp; stopAfterHandle) &#123;</span><br><span class="line">        // 进入 loop 时参数说处理完事件就返回</span><br><span class="line">        retVal	=	kCFRunLoopRunHandledSource;</span><br><span class="line">      &#125; else if (timeOut) &#123;</span><br><span class="line">        // 超出传入参数标记的超时时间了</span><br><span class="line">        retVal	=	kCFRunLoopRunTimeOut;</span><br><span class="line">      &#125; else if (__CFRunLoopIsStoped(runloop)) &#123;</span><br><span class="line">        // 被外部调用者强行停止了</span><br><span class="line">        retVal	=	kCFRunLoopRunStoped;</span><br><span class="line">      &#125; else if (__CFRunLoopModeIsEmpty(runloop, currentMode)) &#123;</span><br><span class="line">        // Source/Timer/Observer 一个都没有了</span><br><span class="line">        retVal	=	kCFRunLoopRunFinished;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      // 如果没超时，mode 里没空， loop 也没有被停止，那就继续 loop</span><br><span class="line">    &#125; while (retVal == 0)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="RunLoop有什么用？"><a href="#RunLoop有什么用？" class="headerlink" title="RunLoop有什么用？"></a>RunLoop有什么用？</h2><p>App 启动后 RunLoop 的状态 ：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">CFRunLoop &#123;</span><br><span class="line">    current mode = kCFRunLoopDefaultMode</span><br><span class="line">    common modes = &#123;</span><br><span class="line">        UITrackingRunLoopMode</span><br><span class="line">        kCFRunLoopDefaultMode</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    common mode items = &#123;</span><br><span class="line">  </span><br><span class="line">        // source0 (manual)</span><br><span class="line">        CFRunLoopSource &#123;order =-1, &#123;</span><br><span class="line">            callout = _UIApplicationHandleEventQueue&#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;order =-1, &#123;</span><br><span class="line">            callout = PurpleEventSignalCallback &#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;order = 0, &#123;</span><br><span class="line">            callout = FBSSerialQueueRunLoopSourceHandler&#125;&#125;</span><br><span class="line">  </span><br><span class="line">        // source1 (mach port)</span><br><span class="line">        CFRunLoopSource &#123;order = 0,  &#123;port = 17923&#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;order = 0,  &#123;port = 12039&#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;order = 0,  &#123;port = 16647&#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;order =-1, &#123;</span><br><span class="line">            callout = PurpleEventCallback&#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;order = 0, &#123;port = 2407,</span><br><span class="line">            callout = _ZL20notify_port_callbackP12__CFMachPortPvlS1_&#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;order = 0, &#123;port = 1c03,</span><br><span class="line">            callout = __IOHIDEventSystemClientAvailabilityCallback&#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;order = 0, &#123;port = 1b03,</span><br><span class="line">            callout = __IOHIDEventSystemClientQueueCallback&#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;order = 1, &#123;port = 1903,</span><br><span class="line">            callout = __IOMIGMachPortPortCallback&#125;&#125;</span><br><span class="line">  </span><br><span class="line">        // Ovserver</span><br><span class="line">        CFRunLoopObserver &#123;order = -2147483647, activities = 0x1, // Entry</span><br><span class="line">            callout = _wrapRunLoopWithAutoreleasePoolHandler&#125;</span><br><span class="line">        CFRunLoopObserver &#123;order = 0, activities = 0x20,          // BeforeWaiting</span><br><span class="line">            callout = _UIGestureRecognizerUpdateObserver&#125;</span><br><span class="line">        CFRunLoopObserver &#123;order = 1999000, activities = 0xa0,    // BeforeWaiting | Exit</span><br><span class="line">            callout = _afterCACommitHandler&#125;</span><br><span class="line">        CFRunLoopObserver &#123;order = 2000000, activities = 0xa0,    // BeforeWaiting | Exit</span><br><span class="line">            callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv&#125;</span><br><span class="line">        CFRunLoopObserver &#123;order = 2147483647, activities = 0xa0, // BeforeWaiting | Exit</span><br><span class="line">            callout = _wrapRunLoopWithAutoreleasePoolHandler&#125;</span><br><span class="line">  </span><br><span class="line">        // Timer</span><br><span class="line">        CFRunLoopTimer &#123;firing = No, interval = 3.1536e+09, tolerance = 0,</span><br><span class="line">            next fire date = 453098071 (-4421.76019 @ 96223387169499),</span><br><span class="line">            callout = _ZN2CAL14timer_callbackEP16__CFRunLoopTimerPv (QuartzCore.framework)&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  </span><br><span class="line">    modes ＝ &#123;</span><br><span class="line">        CFRunLoopMode  &#123;</span><br><span class="line">            sources0 =  &#123; /* same as &#x27;common mode items&#x27; */ &#125;,</span><br><span class="line">            sources1 =  &#123; /* same as &#x27;common mode items&#x27; */ &#125;,</span><br><span class="line">            observers = &#123; /* same as &#x27;common mode items&#x27; */ &#125;,</span><br><span class="line">            timers =    &#123; /* same as &#x27;common mode items&#x27; */ &#125;,</span><br><span class="line">          	</span><br><span class="line">        CFRunLoopMode  &#123;</span><br><span class="line">            sources0 =  &#123; /* same as &#x27;common mode items&#x27; */ &#125;,</span><br><span class="line">            sources1 =  &#123; /* same as &#x27;common mode items&#x27; */ &#125;,</span><br><span class="line">            observers = &#123; /* same as &#x27;common mode items&#x27; */ &#125;,</span><br><span class="line">            timers =    &#123; /* same as &#x27;common mode items&#x27; */ &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">  </span><br><span class="line">        CFRunLoopMode  &#123;</span><br><span class="line">            sources0 = &#123;</span><br><span class="line">                CFRunLoopSource &#123;order = 0, &#123;</span><br><span class="line">                    callout = FBSSerialQueueRunLoopSourceHandler&#125;&#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            sources1 = (null),</span><br><span class="line">            observers = &#123;</span><br><span class="line">                CFRunLoopObserver &gt;&#123;activities = 0xa0, order = 2000000,</span><br><span class="line">                    callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv&#125;</span><br><span class="line">            )&#125;,</span><br><span class="line">            timers = (null),</span><br><span class="line">        &#125;,</span><br><span class="line">  </span><br><span class="line">        CFRunLoopMode  &#123;</span><br><span class="line">            sources0 = &#123;</span><br><span class="line">                CFRunLoopSource &#123;order = -1, &#123;</span><br><span class="line">                    callout = PurpleEventSignalCallback&#125;&#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            sources1 = &#123;</span><br><span class="line">                CFRunLoopSource &#123;order = -1, &#123;</span><br><span class="line">                    callout = PurpleEventCallback&#125;&#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            observers = (null),</span><br><span class="line">            timers = (null),</span><br><span class="line">        &#125;,</span><br><span class="line">         </span><br><span class="line">        CFRunLoopMode  &#123;</span><br><span class="line">            sources0 = (null),</span><br><span class="line">            sources1 = (null),</span><br><span class="line">            observers = (null),</span><br><span class="line">            timers = (null),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>系统注册了五个默认的 Mode：</p>
<p>1.kCFRunLoopDefaultMode ：App 的默认 Mode，通常主线程就是在这个 Mode 下运行的。</p>
<p>2.UITrackingRunLoopMode : 界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其它 Mode 影响。</p>
<p>3.UIInitializationRunLoopMode ：在刚启动 App 时进入的第一个 Mode，启动完成后就不再使用。</p>
<p>4.GSEventReceiveRunLoopMode ：接受系统事件的内部 Mode，通常用不到。</p>
<p>5.kCFRunLoopCommonModes ：这是一个占位的 Mode，没有实际作用。</p>
<p>当 RunLoop 进行回调时，一般都是通过一个很长的函数调用出去(call out)，当你在你的代码中下断点时，通常能在调用栈中看到这些函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    /// 1. 通知Observers，即将进入RunLoop</span><br><span class="line">    /// 此处有Observer会创建AutoreleasePool: _objc_autoreleasePoolPush();</span><br><span class="line">    __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopEntry);</span><br><span class="line">    do &#123;</span><br><span class="line">  </span><br><span class="line">        /// 2. 通知 Observers: 即将触发 Timer 回调。</span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeTimers);</span><br><span class="line">        /// 3. 通知 Observers: 即将触发 Source (非基于port的,Source0) 回调。</span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeSources);</span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__(block);</span><br><span class="line">  </span><br><span class="line">        /// 4. 触发 Source0 (非基于port的) 回调。</span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__(source0);</span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__(block);</span><br><span class="line">  </span><br><span class="line">        /// 6. 通知Observers，即将进入休眠</span><br><span class="line">        /// 此处有Observer释放并新建AutoreleasePool: _objc_autoreleasePoolPop(); _objc_autoreleasePoolPush();</span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeWaiting);</span><br><span class="line">  </span><br><span class="line">        /// 7. sleep to wait msg.</span><br><span class="line">        mach_msg() -&gt; mach_msg_trap();</span><br><span class="line">         </span><br><span class="line">  </span><br><span class="line">        /// 8. 通知Observers，线程被唤醒</span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopAfterWaiting);</span><br><span class="line">  </span><br><span class="line">        /// 9. 如果是被Timer唤醒的，回调Timer</span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__(timer);</span><br><span class="line">  </span><br><span class="line">        /// 9. 如果是被dispatch唤醒的，执行所有调用 dispatch_async 等方法放入main queue 的 block</span><br><span class="line">        __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(dispatched_block);</span><br><span class="line">  </span><br><span class="line">        /// 9. 如果如果Runloop是被 Source1 (基于port的) 的事件唤醒了，处理这个事件</span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__(source1);</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    &#125; while (...);</span><br><span class="line">  </span><br><span class="line">    /// 10. 通知Observers，即将退出RunLoop</span><br><span class="line">    /// 此处有Observer释放AutoreleasePool: _objc_autoreleasePoolPop();</span><br><span class="line">    __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopExit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AutoreleasePool"><a href="#AutoreleasePool" class="headerlink" title="AutoreleasePool"></a>AutoreleasePool</h3><p>App 启动后，Apple 在主线程的 RunLoop 里注册了两个 Observer，其回调都是 _wrapRunLoopWithAutoreleasePoolHandler()。</p>
<p>第一个 Observer 监视的事件是 Entry(即将进入 Loop)，其回调内会调用 _objc_autoreleasePoolPush() 创建自动释放池，优先级最高，保证创建释放池发生在其它所有回调之前。</p>
<p>第二个 Observer 监视了两个事件：BeforeWaiting(准备进入休眠)时调用 _objc_autoreleasePoolPop() 和 _objc_auroreleasePoolPush() 释放旧的池并创建新池。Exit(即将退出Loop)时调用 _objc_autoreleasePoolPop() 来释放自动释放池，优先级最低，保证其释放发生在其它所有回调之后。</p>
<p>在主线程执行的代码，通常是写在诸如事件回调、Timer 回调内的。这些回调会被 RunLoop 创建好的 AutoreleasePool 环绕着，所以不会出现内存泄漏。</p>
<h3 id="事件响应"><a href="#事件响应" class="headerlink" title="事件响应"></a>事件响应</h3><p>Apple 注册了一个 Source1 (基于 mach port) 用来接收系统事件，其回调函数为 __IOHIDEventSystemClientQueueCallBack()。</p>
<p>当一个硬件事件发生后，首先由 IOKit.framework 生成一个 IOHIDEvent 事件并由 SpringBoard 接收。SpingBoard 只接收按键、触摸、加速、接近传感器等几种 Event，随后用 mach port 转发给需要的 App 进程。随后 Apple 注册的那个 Source1 就会触发回调，并调用 _UIApplicationHandleEventQueue() 进行应用内的分发。</p>
<p>_UIApplicationHandleEventQueue() 会把 IOHIDEvent 处理并包装成 UIEvent 进行处理或分发，其中包括识别 UIGesture、处理屏幕旋转、发送给 UIWindow等。通常事件比如 UIButton 点击、touchesBegin/Move/End/Cancle 事件都是在这个回调中完成的。</p>
<h3 id="手势识别"><a href="#手势识别" class="headerlink" title="手势识别"></a>手势识别</h3><p>当 _UIApplicationHandleEventQueue() 识别了一个手势时，其首先会调用 Cancel 将当前的 touchesBegin/Move/End 系列回调打断。随后系统将对应的 UIGestureRecognizer 标记为待处理。</p>
<p>Apple 注册了一个 Observer 检测 BeforeWaiting 事件，这个 Observer 的回调函数是 _UIGestureRecognizerUpdateObsever(), 其内部会获取所有刚被标记为待处理的 GestureRecognizer，并执行 GestureRecognizer 的回调。</p>
<p>当有 UIGestureRecognizer 的变化(创建/销毁/状态改变)时，这个回调都会进行相应处理。</p>
<h3 id="界面更新"><a href="#界面更新" class="headerlink" title="界面更新"></a>界面更新</h3><p>当在操作 UI 时，比如改变了 Frame、更新了 UIView/CALayer 的层次时，或者手动调用了 UIView/CALayer 的 setNeedsLayout/setNeedsDisplay方法后，这个 UIView/CALayer 就被标记为待处理，并被提交到一个全局的容器去。</p>
<p>苹果注册了一个 Observer 监听 BeforeWaiting(即将进入休眠) 和 Exit (即将退出Loop) 事件，回调去执行一个很长的函数：</p>
<p>_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()。这个函数里会遍历所有待处理的 UIView/CAlayer 以执行实际的绘制和调整，并更新 UI 界面。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()</span><br><span class="line">    QuartzCore:CA::Transaction::observer_callback:</span><br><span class="line">        CA::Transaction::commit();</span><br><span class="line">            CA::Context::commit_transaction();</span><br><span class="line">                CA::Layer::layout_and_display_if_needed();</span><br><span class="line">                    CA::Layer::layout_if_needed();</span><br><span class="line">                        [CALayer layoutSublayers];</span><br><span class="line">                            [UIView layoutSubviews];</span><br><span class="line">                    CA::Layer::display_if_needed();</span><br><span class="line">                        [CALayer display];</span><br><span class="line">                            [UIView drawRect];</span><br></pre></td></tr></table></figure>

<h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><p>NSTimer 其实就是 CFRunLoopTimerRef，他们之间是 toll-free bridged 的。一个 NSTimer 注册到 RunLoop 后，RunLoop 会为其重复的时间点注册好事件。例如 10:00, 10:10, 10:20 这几个时间点。RunLoop为了节省资源，并不会在非常准确的时间点回调这个Timer。Timer 有个属性叫做 Tolerance (宽容度)，标示了当时间点到后，容许有多少最大误差。</p>
<p>如果某个时间点被错过了，例如执行了一个很长的任务，则那个时间点的回调也会跳过去，不会延后执行。就比如等公交，如果 10:10 时我忙着玩手机错过了那个点的公交，那我只能等 10:20 这一趟了。</p>
<p>CADisplayLink 是一个和屏幕刷新率一致的定时器（但实际实现原理更复杂，和 NSTimer 并不一样，其内部实际是操作了一个 Source）。如果在两次屏幕刷新之间执行了一个长任务，那其中就会有一帧被跳过去（和 NSTimer 相似），造成界面卡顿的感觉。在快速滑动TableView时，即使一帧的卡顿也会让用户有所察觉。Facebook 开源的 AsyncDisplayLink 就是为了解决界面卡顿的问题，其内部也用到了 RunLoop。</p>
<h3 id="PerformSelector"><a href="#PerformSelector" class="headerlink" title="PerformSelector"></a>PerformSelector</h3><p>当调用 NSObject 的 performSelecter:afterDelay: 后，实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 中。所以如果当前线程没有 RunLoop，则这个方法会失效。</p>
<p>当调用 performSelector:onThread: 时，实际上其会创建一个 Timer 加到对应的线程去，同样的，如果对应线程没有 RunLoop 该方法也会失效。</p>
<h3 id="关于GCD"><a href="#关于GCD" class="headerlink" title="关于GCD"></a>关于GCD</h3><p>实际上 RunLoop 底层也会用到 GCD 的东西，比如 RunLoop 是用 dispatch_source_t 实现的 Timer。但同时 GCD 提供的某些接口也用到了 RunLoop， 例如 dispatch_async()。</p>
<p>当调用 dispatch_async(dispatch_get_main_queue(), block) 时，libDispatch 会向主线程的 RunLoop 发送消息，RunLoop会被唤醒，并从消息中取得这个 block，并在回调 <strong>CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE</strong>() 里执行这个 block。但这个逻辑仅限于 dispatch 到主线程，dispatch 到其他线程仍然是由 libDispatch 处理的。</p>
<h3 id="关于网络请求"><a href="#关于网络请求" class="headerlink" title="关于网络请求"></a>关于网络请求</h3><p>iOS 中，关于网络请求的接口自下至上有如下几层:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CFSocket</span><br><span class="line">CFNetwork       -&gt;ASIHttpRequest</span><br><span class="line">NSURLConnection -&gt;AFNetworking</span><br><span class="line">NSURLSession    -&gt;AFNetworking2, Alamofire</span><br></pre></td></tr></table></figure>

<ul>
<li>CFSocket 是最底层的接口，只负责 socket 通信。</li>
<li>CFNetwork 是基于 CFSocket 等接口的上层封装，ASIHttpRequest 工作于这一层。</li>
<li>NSURLConnection 是基于 CFNetwork 的更高层的封装，提供面向对象的接口，AFNetworking 工作于这一层。</li>
<li>NSURLSession 是 iOS7 中新增的接口，表面上是和 NSURLConnection 并列的，但底层仍然用到了 NSURLConnection 的部分功能 (比如 com.apple.NSURLConnectionLoader 线程)，AFNetworking2 和 Alamofire 工作于这一层。</li>
</ul>
<p>通常使用 NSURLConnection 时，你会传入一个 Delegate，当调用了 [connection start] 后，这个 Delegate 就会不停收到事件回调。实际上，start 这个函数的内部会会获取 CurrentRunLoop，然后在其中的 DefaultMode 添加了4个 Source0 (即需要手动触发的Source)。CFMultiplexerSource 是负责各种 Delegate 回调的，CFHTTPCookieStorage 是处理各种 Cookie 的。</p>
<p>当开始网络传输时，我们可以看到 NSURLConnection 创建了两个新线程：com.apple.NSURLConnectionLoader 和 com.apple.CFSocket.private。其中 CFSocket 线程是处理底层 socket 连接的。NSURLConnectionLoader 这个线程内部会使用 RunLoop 来接收底层 socket 的事件，并通过之前添加的 Source0 通知到上层的 Delegate。</p>
<p>NSURLConnectionLoader 中的 RunLoop 通过一些基于 mach port 的 Source 接收来自底层 CFSocket 的通知。当收到通知后，其会在合适的时机向 CFMultiplexerSource 等 Source0 发送通知，同时唤醒 Delegate 线程的 RunLoop 来让其处理这些通知。CFMultiplexerSource 会在 Delegate 线程的 RunLoop 对 Delegate 执行实际的回调。</p>
<h2 id="RunLoop-怎么用？"><a href="#RunLoop-怎么用？" class="headerlink" title="RunLoop 怎么用？"></a>RunLoop 怎么用？</h2><h3 id="AFNetWorking"><a href="#AFNetWorking" class="headerlink" title="AFNetWorking"></a>AFNetWorking</h3><p><a target="_blank" rel="noopener" href="https://github.com/AFNetworking/AFNetworking/blob/master/AFNetworking%2FAFURLConnectionOperation.m">AFURLConnectionOperation</a> 这个类是基于 NSURLConnection 构建的，其希望能在后台线程接收 Delegate 回调。为此 AFNetworking 单独创建了一个线程，并在这个线程中启动了一个 RunLoop：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">+ (void)networkRequestThreadEntryPoint:(id)__unused object &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        [[NSThread currentThread] setName:@&quot;AFNetworking&quot;];</span><br><span class="line">        NSRunLoop *runLoop = [NSRunLoop currentRunLoop];</span><br><span class="line">        [runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode];</span><br><span class="line">        [runLoop run];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">+ (NSThread *)networkRequestThread &#123;</span><br><span class="line">    static NSThread *_networkRequestThread = nil;</span><br><span class="line">    static dispatch_once_t oncePredicate;</span><br><span class="line">    dispatch_once(&amp;oncePredicate, ^&#123;</span><br><span class="line">        _networkRequestThread = [[NSThread alloc] initWithTarget:self selector:@selector(networkRequestThreadEntryPoint:) object:nil];</span><br><span class="line">        [_networkRequestThread start];</span><br><span class="line">    &#125;);</span><br><span class="line">    return _networkRequestThread;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>RunLoop 启动前内部必须要有至少一个 Timer/Observer/Source，所以 AFNetworking 在 [runLoop run] 之前先创建了一个新的 NSMachPort 添加进去了。通常情况下，调用者需要持有这个 NSMachPort (mach_port) 并在外部线程通过这个 port 发送消息到 loop 内；但此处添加 port 只是为了让 RunLoop 不至于退出，并没有用于实际的发送消息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (void)start &#123;</span><br><span class="line">    [self.lock lock];</span><br><span class="line">    if ([self isCancelled]) &#123;</span><br><span class="line">        [self performSelector:@selector(cancelConnection) onThread:[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]];</span><br><span class="line">    &#125; else if ([self isReady]) &#123;</span><br><span class="line">        self.state = AFOperationExecutingState;</span><br><span class="line">        [self performSelector:@selector(operationDidStart) onThread:[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]];</span><br><span class="line">    &#125;</span><br><span class="line">    [self.lock unlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当需要这个后台线程执行任务时，AFNetworking 通过调用 [NSObject performSelector:onThread:..] 将这个任务扔到了后台线程的 RunLoop 中。</p>
<h3 id="AsyncDisplayKit"><a href="#AsyncDisplayKit" class="headerlink" title="AsyncDisplayKit"></a>AsyncDisplayKit</h3><p><a target="_blank" rel="noopener" href="https://github.com/facebook/AsyncDisplayKit">AsyncDisplayKit</a> 是 Facebook 推出的用于保持界面流畅性的框架，其原理大致如下：</p>
<p>UI 线程中一旦出现繁重的任务就会导致界面卡顿，这类任务通常分为3类：排版，绘制，UI对象操作。</p>
<p>排版通常包括计算视图大小、计算文本高度、重新计算子式图的排版等操作。</p>
<p>绘制一般有文本绘制 (例如 CoreText)、图片绘制 (例如预先解压)、元素绘制 (Quartz)等操作。</p>
<p>UI对象操作通常包括 UIView/CALayer 等 UI 对象的创建、设置属性和销毁。</p>
<p>其中前两类操作可以通过各种方法扔到后台线程执行，而最后一类操作只能在主线程完成，并且有时后面的操作需要依赖前面操作的结果 （例如TextView创建时可能需要提前计算出文本的大小）。ASDK 所做的，就是尽量将能放入后台的任务放入后台，不能的则尽量推迟 (例如视图的创建、属性的调整)。</p>
<p>为此，ASDK 创建了一个名为 ASDisplayNode 的对象，并在内部封装了 UIView/CALayer，它具有和 UIView/CALayer 相似的属性，例如 frame、backgroundColor等。所有这些属性都可以在后台线程更改，开发者可以只通过 Node 来操作其内部的 UIView/CALayer，这样就可以将排版和绘制放入了后台线程。但是无论怎么操作，这些属性总需要在某个时刻同步到主线程的 UIView/CALayer 去。</p>
<p>ASDK 仿照 QuartzCore/UIKit 框架的模式，实现了一套类似的界面更新的机制：即在主线程的 RunLoop 中添加一个 Observer，监听了 kCFRunLoopBeforeWaiting 和 kCFRunLoopExit 事件，在收到回调时，遍历所有之前放入队列的待处理的任务，然后一一执行。</p>
<blockquote>
<p>转载整理自 ： <a target="_blank" rel="noopener" href="https://blog.ibireme.com/author/ibireme/">ibireme</a> 的博客 <a target="_blank" rel="noopener" href="https://blog.ibireme.com/2015/05/18/runloop/">深入理解RunLoop</a></p>
</blockquote>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2015-10-31T16:00:00.000Z" title="2015/11/1 上午12:00:00">2015-11-01</time>发表</span><span class="level-item"><a class="link-muted" href="/categories/iOS/">iOS</a></span><span class="level-item">26 分钟读完 (大约3865个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2015/11/01/iOS-Multi-Thread/">多线程编程基础</a></h1><div class="content"><h1 id="iOS-多线程"><a href="#iOS-多线程" class="headerlink" title="iOS 多线程"></a>iOS 多线程</h1><h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>进程(Process)是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础，是正在运行的程序的实例(An instance of a computer program that is being executed)。</p>
<p>进程的概念主要有两点：</p>
<ul>
<li>进程是一个实体。每一个进程都有它自己的地址空间，一般情况下，包括文本区域(Text Region)、数据区域(Data Region)和堆栈(Stack Region)。文本区域存储处理器执行的代码；数据区域存储变量和进程执行期间使用的动态分配的内存；堆栈区存储着活动过程调用的指令和本地变量。</li>
<li>进程是一个执行中的程序。</li>
</ul>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>线程是程序执行流的最小单元。一个标准的线程由线程ID、当前指令指针、寄存器集合和堆栈组成。另外，线程是进程中的一个实体，是被系统独立调度和分配的基本单位，线程自己不拥有系统资源，只拥有一点在运行中必不可少的资源，但它可以与同属一个进程的其它线程共享进程所拥有的全部资源。</p>
<h3 id="进程与线程的关系与区别"><a href="#进程与线程的关系与区别" class="headerlink" title="进程与线程的关系与区别"></a>进程与线程的关系与区别</h3><p>进程是资源分配的基本单位。所有与该进程有关的资源，都被记录在进程控制块PCB中，以表示该进程拥有这些资源或正在使用它们。另外，进程也是抢占处理机的基本单位，它拥有一个完整的虚拟地址空间。当进程发生调度时，不同的进程拥有不同的虚拟地址空间，而同一进程内的不同线程共享同一地址空间。</p>
<p>与进程相对应，线程与资源分配无关，它属于某一个进程，并与进程内的其它线程一起共享进程的资源。线程只由相关堆栈、寄存器和线程控制表TCB组成。寄存器可被用来存储线程内的局部变量，但不能存储其它线程的相关变量。</p>
<p>通常在一个进程中可以包含多个线程，它们可以利用进程所拥有的资源。在引入线程的操作系统中，通常都是把进程作为分配资源的基本单位，而把线程作为独立运行和独立调度的基本单位。由于线程比进程更小，基本上不拥有系统资源，故对它的调度所付出的开销就会小得多，能更叫高效的提高系统内多个程序之间并发执行的程度。</p>
<p>线程和进程区别：</p>
<ul>
<li>地址空间和其它资源：进程之间相互独立，同一进程的各线程间共享。某进程内的线程在其它进程不可见。</li>
<li>通信：进程间通信主要方式有管道、系统IPC(消息队列、信号、共享存储)、套接字(Socket)。而线程间可以直接读写进程数据段来进行通信(需要进程同步和互斥手段的辅助，以保证数据的异质性)</li>
<li>调度和切换：线程上下文切换比进程快的多。</li>
<li>在多线程OS中，进程不是一个可执行的实体</li>
</ul>
<h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><p>线程安全就是多线程访问时，采用了加锁机制，当一个线程访问该类的某个数据时，进行保护，其它线程不能进行访问直到该线程读取完，其它线程才可以使用。</p>
<h2 id="iOS中的多线程"><a href="#iOS中的多线程" class="headerlink" title="iOS中的多线程"></a>iOS中的多线程</h2><p>目前在iOS中有四种多线程解决方案：</p>
<ul>
<li>Pthreads</li>
<li>NSThread</li>
<li>GCD</li>
<li>NSOperation &amp; NSOperationQueue</li>
</ul>
<h3 id="Pthreads"><a href="#Pthreads" class="headerlink" title="Pthreads"></a>Pthreads</h3><p>POSIX线程，简称Pthreads，是线程的POSIX标准。该标准定义了创建和操作线程的一整套API。在类Unix操作系统中，都使用Pthreads作为操作系统的线程。</p>
<h3 id="NSThread"><a href="#NSThread" class="headerlink" title="NSThread"></a>NSThread</h3><p>NSThread是经常Apple封装的完全面向对象的。你可以直观方便的操控线程对象，但是生命周期需要手动管理。</p>
<h3 id="GCD"><a href="#GCD" class="headerlink" title="GCD"></a>GCD</h3><p>GCD是Apple为多核的并行运算提出的的解决方案，能够自动合理地利用更多的CPU内核，并自动管理线程的声明周期。GCD使用C进行编写，并使用了Block。</p>
<p>####任务</p>
<p>即代码所要完成的操作。</p>
<p>任务的执行方式有两种：同步执行和异步执行。</p>
<p>同步执行操作，它会阻塞当前线程并等待任务执行完毕，然后当前线程才会继续往下运行。</p>
<p>异步执行操作，则不会阻塞当前线程，当前线程会直接往下执行。</p>
<h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><p>用于存放要执行的任务。</p>
<p>串行队列中的任务，GCD会遵循FIFO原则来执行，串行队列的同步执行任务，会在当前线程一个一个执行，而异步执行任务，则会在它线程中一个一个执行。</p>
<p>并行队列中的任务执行顺序则要复杂一点，任务会根据同步或异步有不同的执行方式。并行队列中的同步执行任务会在当前线程中一个一个执行，而异步执行则会开很多线程一起执行。</p>
<h5 id="如何创建队列？"><a href="#如何创建队列？" class="headerlink" title="如何创建队列？"></a><strong>如何创建队列？</strong></h5><ul>
<li>主队列：特殊的串行队列，主要用于刷新UI，任何需要刷新UI的工作都必须在主队列中执行。</li>
</ul>
<p><code>dispatch_queue_t mainQueue = ispatch_get_main_queue();</code></p>
<ul>
<li><p>自己创建的队列：</p>
<p>创建串行队列</p>
</li>
</ul>
<p><code>dispatch_queue_t serialQueue = dispatch_queue_create(&quot;CustomSerialQueue&quot;,DISPATCH_QUEUE_SERIAL);</code></p>
<p>​    创建并行队列</p>
<p><code>dispatch_queue_t concurrentQueue = dispatch_queue_create(&quot;CustomConcurrentQueue&quot;,DISPATCH_QUEUE_CONCURRENT);</code></p>
<ul>
<li>全局队列：这是一个并行队列，并行任务一般都加入到这个队列。</li>
</ul>
<p><code>dispatch_queue_t globalQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,0)</code></p>
<p><strong>如何创建任务？</strong></p>
<ul>
<li><p>创建同步任务</p>
<p><code>dispatch_sync(,^&#123;// execute code));</code></p>
</li>
<li><p>创建异步任务</p>
<p><code>dispatch_async(,^&#123;// execute code&#125;);</code></p>
</li>
</ul>
<h5 id="队列组"><a href="#队列组" class="headerlink" title="队列组"></a>队列组</h5><p>队列组可以将很多队列添加到一个组里，当组中的所有任务都执行完了，队列组将会通知给用户。</p>
<p><code>dispatch_group_enter</code> 和 <code>dispatch_group_leave</code> 分别表示一个任务追加到队列组和一个任务执行完毕离开了队列组。</p>
<p>只有当group中未执行完毕的任务数量为0时，才会使 <code>dispatch_group_wait</code> 解除阻塞，以及执行追加到 <code>dispatch_group_notify</code> 的任务。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">dispatch_group_t group = dispatch_group_create();</span><br><span class="line">dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIOITY_DEFAULT,0);</span><br><span class="line">dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">  // execute code</span><br><span class="line">&#125;);</span><br><span class="line">// 向group中添加在主队列中执行的任务</span><br><span class="line">dispatch_group_async(group, dispatch_get_main_queue(),^&#123;</span><br><span class="line">  // execute code</span><br><span class="line">&#125;);</span><br><span class="line">// 向group中追加任务</span><br><span class="line">dispatch_group_enter(group);</span><br><span class="line">dispatch_async(queue，^&#123;</span><br><span class="line">    // execute code</span><br><span class="line">    dispatch_group_leave(group);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 直到前面加入到group中的所有任务都执行完毕后，才会执行</span><br><span class="line">dispatch_group_notify(group,dispatch_get_main_queue(),^&#123;</span><br><span class="line">  // execute code</span><br><span class="line">&#125;);</span><br><span class="line">OR</span><br><span class="line">// 直到前面加入到group中的所有任务都执行完成后，才会继续往下执行</span><br><span class="line">dispatch_group_wait(group, DISPATCH_TIME_FOREVER);</span><br></pre></td></tr></table></figure>



<h4 id="GCD的信号量机制"><a href="#GCD的信号量机制" class="headerlink" title="GCD的信号量机制"></a>GCD的信号量机制</h4><p>并发队列可以分配多个线程，同时处理不同的任务，虽然提升了效率，但是多线程的并发是通过时间片轮转的方法实现的，线程的创建、销毁、上下文切换等会消耗资源。适当的并发可以提高效率，但是无节制的并发，则会抢占CPU资源，造成性能下降。此外，提交给并发队列的任务中，有些任务内部会有全局的锁，会导致线程休眠、阻塞，一旦这类任务过多，并发队列还需要创建新的线程来执行其它任务，会造成线程数量的增加。</p>
<p>因此控制并发队列中的线程数量就成了不能忽视的问题。</p>
<h5 id="GCD并发线程数量控制"><a href="#GCD并发线程数量控制" class="headerlink" title="GCD并发线程数量控制"></a>GCD并发线程数量控制</h5><p>GCD中的信号量（dispatch_semaphore）是一个整形值，有初始计数值，可以接收通知信号和等待信号。当信号量收到通知信号时，计数+1；当信号量收到等待信号时，计数-1。如果信号量为0，线程会被阻塞，直到信号量大于0，才会继续执行。</p>
<p>使用信号量机制可以实现线程的同步，也可以控制最大并发数。</p>
<h5 id="使用GCD信号量机制实现并发线程数量控制"><a href="#使用GCD信号量机制实现并发线程数量控制" class="headerlink" title="使用GCD信号量机制实现并发线程数量控制"></a>使用GCD信号量机制实现并发线程数量控制</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t	workConcurrentQueue	=	dispatch_queue_create(@&quot;WORK_CONCURRENT_QUEUE&quot;,DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">dispatch_queue_t	workSerialQueue	=	dispatch_queue_create(@&quot;WORK_SERIAL_QUEUE&quot;,DISPATCH_QUEUE_SERIAL);</span><br><span class="line">int	maxConcurrent	=	10;</span><br><span class="line">dispatch_semaphore_t	semaphore	=	dispatch_semaphore_create(maxConcurrent);</span><br><span class="line">for (NSInteger i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">  dispatch_async(workSerialQueue, ^&#123;</span><br><span class="line">      // 使信号量-1，当信号量为0时就一直等待，即阻塞所在线程</span><br><span class="line">      // 这里使信号量 maxConcurrent-1，表示最大并发数量已被占用一个位置</span><br><span class="line">      dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">      dispatch_async(workConcurrentQueue, ^&#123;</span><br><span class="line">          // 发送一个信号，让信号量+1</span><br><span class="line">          // 这里使信号量 maxConcurrent+1，表示任务被执行，释放了最大并发数量中的一个位置</span><br><span class="line">          dispatch_semaphore_signal(semaphore);</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="使用GCD信号量机制实现线程同步"><a href="#使用GCD信号量机制实现线程同步" class="headerlink" title="使用GCD信号量机制实现线程同步"></a>使用GCD信号量机制实现线程同步</h5><p>有时候我们会遇到需要异步执行一些耗时任务，并在这些任务完成后进行一些额外的操作，相当于将异步执行任务转化为同步执行任务。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);</span><br><span class="line">     </span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">    	// 执行耗时任务</span><br><span class="line">    	···</span><br><span class="line">        // 任务完成后使信号量+1，被阻塞的线程继续执行</span><br><span class="line">        dispatch_semaphore_signal(semaphore);</span><br><span class="line">    &#125;);</span><br><span class="line">// 如果信号量为0，则会阻塞当前线程，直到信号量</span><br><span class="line">dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br></pre></td></tr></table></figure>

<h5 id="使用GCD信号量机制实现线程安全"><a href="#使用GCD信号量机制实现线程安全" class="headerlink" title="使用GCD信号量机制实现线程安全"></a>使用GCD信号量机制实现线程安全</h5><p>如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其它变量的值也和预期的是一样的，就是线程安全的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dispatch_semaphore_t semaphoreLock	=	dispatch_semaphore_create(1);</span><br><span class="line">// 相当于加锁</span><br><span class="line">dispatch_semaphore_wait(semaphoreLock, DISPATCH_TIME_FOREVER);</span><br><span class="line">&#123;</span><br><span class="line">    // 需要保证安全的执行代码</span><br><span class="line">&#125;</span><br><span class="line">// 相当于解锁</span><br><span class="line">dispatch_semaphore_singal(semaphoreLock);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="GCD的一些使用场景"><a href="#GCD的一些使用场景" class="headerlink" title="GCD的一些使用场景"></a>GCD的一些使用场景</h4><h5 id="使用GCD实现延迟执行"><a href="#使用GCD实现延迟执行" class="headerlink" title="使用GCD实现延迟执行"></a>使用GCD实现延迟执行</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t queue	=	dispatch_ger_gloabl_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">double delay			=	3;</span><br><span class="line">dispatch_after(dispatch_time(DISPATCH_TIME_NOW), (int64_t)(delay*NSEC_PER_SEC)), queue, ^&#123;</span><br><span class="line">  // execute code</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h5 id="使用GCD实现单例模式"><a href="#使用GCD实现单例模式" class="headerlink" title="使用GCD实现单例模式"></a>使用GCD实现单例模式</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">static id _instance;</span><br><span class="line">+ (instancetype)sharedInstance &#123;</span><br><span class="line">  static dispatch_once_t onceToken;</span><br><span class="line">  dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">    // initial code</span><br><span class="line">  &#125;);</span><br><span class="line">  retur _instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="任务同步"><a href="#任务同步" class="headerlink" title="任务同步"></a>任务同步</h5><p>我们有时需要异步执行两组操作，而且第一组操作执行完之后，才能开始执行第二组操作。这样我们就需要一个相当于 栅栏 一样的一个方法将两组异步执行的操作组给分割起来，当然这里的操作组里可以包含一个或多个任务。这就需要用到dispatch_barrier_async方法在两个操作组间形成栅栏。</p>
<p><code>dispatch_barrier_async</code> 函数会等待前边追加到并发队列中的任务全部执行完毕之后，再将指定的任务追加到该异步队列中。然后在 <code>dispatch_barrier_async</code> 函数追加的任务执行完毕之后，异步队列才恢复为一般动作，接着追加任务到该异步队列并开始执行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t queue = dispatch_queue_create(&quot;com.codelei.queue&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">     </span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">  		// Task 1</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        // Task 2</span><br><span class="line">    &#125;);</span><br><span class="line">     </span><br><span class="line">    dispatch_barrier_async(queue, ^&#123;</span><br><span class="line">        // 追加的任务 Task 3</span><br><span class="line">    &#125;);</span><br><span class="line">     </span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        // 追加的任务 Task 4</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        // 追加的任务 Task 5</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<p>直到 Task 1 和 Task 2 执行完成后，才会执行使用 <code>dispatch_barrier_asynce</code> 追加的任务 Task 3，然后在 Task 3 执行完成后，并行队列会正常执行。</p>
<h3 id="NSOperation-amp-NSOperationQueue"><a href="#NSOperation-amp-NSOperationQueue" class="headerlink" title="NSOperation &amp; NSOperationQueue"></a>NSOperation &amp; NSOperationQueue</h3><p>NSOperation是Apple对GCD的封装，完全面向对象。NSOperation和NSOperationQueue分别对应GCD的任务和队列。</p>
<h4 id="添加任务"><a href="#添加任务" class="headerlink" title="添加任务"></a>添加任务</h4><p>NSOperation只是一个抽象类，并不能直接封装任务。它有两个子类NSInvocationOperation和NSBlockOperation用来完成封装任务的操作。创建一个Operation后，需要调用<code>start</code>方法来启动任务，它默认在当前队列同步执行。如果需要在执行途中取消执行一个任务，调用<code>cancel</code>方法即可。</p>
<ul>
<li><p>NSInvocationOperation</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSInvocationOperation *invocationOperation = [[NSInvocation alloc] initWithTarget:self selector:@selector(executeMethod)];</span><br><span class="line">invocationOperation start];</span><br></pre></td></tr></table></figure>
</li>
<li><p>NSBlockOperation</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NSBlockOperation *blockOperation = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">  // execute code</span><br><span class="line">&#125;];</span><br><span class="line">[blockOperation start];</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上面提到，NSInvocationOperation和NSBlockOperation创建的任务默认在当前线程执行，但是NSBlockOperation可以通过<code>addExecutionBlock:</code>方法向Operation中添加多个可执行的Block。这样的Operation中的任务会并发执行，它会在主线程和其它多个线程执行这些任务。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NSBlockOperation *blockOperation = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">  // execute code</span><br><span class="line">&#125;];</span><br><span class="line">[blockOpertation addExecutionBlock:^&#123;</span><br><span class="line">  // execute code</span><br><span class="line">&#125;];</span><br><span class="line">[blockOperation start];</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>NOTE</strong>:<code>addExecutionBlock:</code>方法必须在<code>start</code>方法之前执行，否则会报错。</p>
</blockquote>
</li>
<li><p>自定义的Operation</p>
<p>自定义Operation类需要继承Operation类，并实现其<code>main()</code>方法，因为在调用<code>start()</code>方法的时候，内部会调用<code>main()</code>方法完成相关逻辑。</p>
</li>
</ul>
<h4 id="创建队列"><a href="#创建队列" class="headerlink" title="创建队列"></a>创建队列</h4><p>通过调用一个NSOperation类的<code>start()</code>方法来启动的任务，默认在当前线程同步执行。如果要避免占用当前线程，就需要使用到队列NSOperationQueue。只要将Operation添加到队列，就会自动调用任务的<code>start()</code>方法。</p>
<ul>
<li><p>主队列</p>
<p>添加到主队列中的任务时串行执行的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSOperationQueue *mainQueue = [NSOperationQueue mainQueue];</span><br></pre></td></tr></table></figure>
</li>
<li><p>其它队列</p>
<p>其它队列中的任务会在其它线程并行执行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NSOperationQueue *queue = [NSOperatin alloc] init];</span><br><span class="line">NSBlockOperatin	 *blockOperation = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">  // execute code</span><br><span class="line">&#125;]</span><br><span class="line">[queue addOperation:blockOperation];</span><br></pre></td></tr></table></figure>

<p>如果需要任务在队列中串行执行，可以通过设置NSOperationQueue的<code>maxConcurrentOperationCount</code>来实现。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSOperationQueue *queue = [NSOperatin alloc] init];</span><br><span class="line">[queue setMaxConcurrentOperationCount:1];</span><br></pre></td></tr></table></figure>

<p>你还可以通过<code>addOperationWithBlock:</code>方法来向队列中添加新任务。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NSOperationQueue *queue = [NSOperatin alloc] init];</span><br><span class="line">[queue addOperationWithBlock:^&#123;</span><br><span class="line">  // cxecute code</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="添加任务依赖"><a href="#添加任务依赖" class="headerlink" title="添加任务依赖"></a>添加任务依赖</h4>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">NSBlockOperation	*blockOperationFirst  = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">	// execute code</span><br><span class="line">&#125;];</span><br><span class="line">NSBlockOperation	*blockOperationSecond = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">	// execute code</span><br><span class="line">&#125;];</span><br><span class="line">NSBlockOperation	*blockOperationThird  = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">	// execute code</span><br><span class="line">&#125;];</span><br><span class="line">[blockOperationSecond addDependency:blockOperationFirst];</span><br><span class="line">[blockOperationThird addDependency:blockOperationSecond];</span><br><span class="line">NSOperationQueue *queue = [NSOperatin alloc] init];</span><br><span class="line">[queue addOperations:@[blockOperationFirst,blockOperationSecond,blockOperationThird]];</span><br></pre></td></tr></table></figure>


<blockquote>
<p><strong>NOTE</strong>:</p>
<ul>
<li>添加相互依赖会造成死锁。</li>
<li>使用<code>removeDependency</code>方法来移除依赖关系</li>
</ul>
</blockquote>
<h4 id="其它方法"><a href="#其它方法" class="headerlink" title="其它方法"></a>其它方法</h4><ul>
<li><p>NSOperation类的一些其它方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 判断任务是否正在执行</span><br><span class="line">BOOL exccuting;</span><br><span class="line">// 判断任务是否完成</span><br><span class="line">BOOL finished；</span><br><span class="line">// 设置任务完成后的后续操作</span><br><span class="line">void (^completionBlock) (void);</span><br><span class="line">// 取消任务</span><br><span class="line">- (void)cancle;</span><br><span class="line">// 阻塞当前线程直到此任务执行完毕</span><br><span class="line">- (void)waitUntilFinished;</span><br></pre></td></tr></table></figure>
</li>
<li><p>NSOperationQueue</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 获取队列的任务数量</span><br><span class="line">NSUInteger operationCount;</span><br><span class="line">// 取消队列中的所有任务</span><br><span class="line">- (void)cancelAllOperations;</span><br><span class="line">// 阻塞当前线程直到此队列中的所有任务执行完毕</span><br><span class="line">- (void)waitUntilAllOperationsAreFinished;</span><br><span class="line">// 暂停或继续队列</span><br><span class="line">BOOL suspended;</span><br></pre></td></tr></table></figure>

<p>​</p>
</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2015-10-20T16:00:00.000Z" title="2015/10/21 上午12:00:00">2015-10-21</time>发表</span><span class="level-item"><a class="link-muted" href="/categories/iOS/">iOS</a></span><span class="level-item">1 小时读完 (大约9115个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2015/10/21/ios-background-execution/">后台运行探索与解析</a></h1><div class="content"><h1 id="iOS-后台运行"><a href="#iOS-后台运行" class="headerlink" title="iOS 后台运行"></a>iOS 后台运行</h1><hr>
<p>当用户没有主动的使用你的应用程序时，系统会将它转换为后台运行状态。对于大多说应用程序来说，后台运行状态只是应用程序在被系统挂起前的一个阶段。挂起应用程序是一个改善电池寿命并让系统为前台应用程序释放重要资源的方式。</p>
<p>大多数应用程序都能很容易的挂起，但是拥有合理的理由在后台继续运行的应用程序也是有的。一个远足应用程序想要随着时间来定位用户的位置，让它能够在地图上显示用户的运动进程。一个音频应用程序可能需要在屏幕锁定时继续播放音乐。其它的应用程序可能想要在后台下载内容以便能够减少将内容呈献给用户的延迟。当你发现你的应用程序需要保持在后台继续运行的时候，iOS系统能够帮助你有效率的且尽可能少地占用系统资源的完成这个目的。</p>
<p>iOS提供的技术分为三类：</p>
<ul>
<li>在前台开始短任务的应用程序可以在进入后台状态时向系统请求完成这个任务的额外时间。</li>
<li>在前台启动下载的应用程序可以将这些下载的管理移交给系统，从而允许在下载过程中暂停或终止该应用。</li>
<li>需要在后台运行以支持特定类型任务的应用程序可以声明对一个或多个后台执行模式的支持。</li>
</ul>
<p>尽可能避免在后台执行任何任务除非这样做能全面的提升用户的体验。应用程序可能会因为启动了另一个应用程序，锁定了屏幕或现在不使用它而被转入后台。在这些情况下，用户都表明你的应用程序现在不需要做任何有意义的工作。在这种情况下继续运行只会浪费设备的电量并可能导致用户强制的完全退出你的应用程序。所以你应该审慎的考虑在后台运行应用程序。</p>
<h2 id="执行有限长度的任务"><a href="#执行有限长度的任务" class="headerlink" title="执行有限长度的任务"></a>执行有限长度的任务</h2><p>被转入后台的应用程序期待尽可能快的进入非活动状态以便它们能够被系统挂起。如果你的应用程序正在执行某个任务而且完成这个任务还需要一些时间的话，你可用调用 <code>UIApplication</code> 的<code>beginBackgroundTaskWithName:expirationHandler:</code> 或<code>beginBackgroundTaskWithExpirationHandler:</code>方法来请求一些额外的执行时间。调用这两个方法的任一个都会暂时的推迟你的应用程序被挂起，从而为完成你正在进行的任务赢得一些额外的时间。一旦你的应用程序完成了任务，你必须调用<code>endBackgroundTask:</code>方法让系统知道你的应用程序已经完成了任务，可以被挂起了。</p>
<p>每个调用<code>beginBackgroundTaskWithName:expirationHandler:</code> 或 <code>beginBackgroundTaskWithExpirationHandler:</code> 方法的应用程序都会生成一个与相应的任务相关的标记。当你的应用程序完成任务时，它必须以这个标记来调用 <code>endBackgroundTask:</code>方法告知系统任务已经完成。调用 <code>endBackgroundTask:</code>方法失败会导致你的应用程序被终止。如果你在启动任务的时候提供了一个完成处理模块，系统会调用这个模块并给你最后一次结束任务避免程序被终止的机会。</p>
<p>你不需要一直到等到应用程序进入后台才指定后台任务。一个更有用的设计是在开始任务之前调用<code>beginBackgroundTaskWithName：expirationHandler：</code>或<code>beginBackgroundTaskWithExpirationHandler：</code>方法，一旦完成就调用<code>endBackgroundTask：</code>方法.</p>
<p>下面的的代码展示了当你的应用程序进入后台时如何开始一个长时运行的任务。在这个例子中，开始后台任务的请求包含了一个完成处理模块以防这个任务耗时太长。这个任务稍后会被提交到一个异步执行的队列中以便<code>applicationDidEnterBackground:</code>方法能够正常返回。blocks的使用简化了维护一些重要变量引用所需要的代码。<code>bgTask</code>变量是指向存储当前任务标识符的指针的类的成员变量，它在调用这个方法之前被初始化。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (void)applicationDidEnterBackground:(UIApplication *)application &#123;</span><br><span class="line">    bgTask = [application beginBackgroundTaskWithName:@&quot;MyTask&quot; expirationHandler:^&#123;</span><br><span class="line">        // Clean up any unfinished task business by marking where you</span><br><span class="line">        // stopped or ending the task outright.</span><br><span class="line">        [application endBackgroundTask:bgTask];</span><br><span class="line">        bgTask = UIBackgroundTaskInvalid;</span><br><span class="line">    &#125;];</span><br><span class="line"> </span><br><span class="line">    // Start the long-running task and return immediately.</span><br><span class="line">    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line"> </span><br><span class="line">        // Do the work associated with the task, preferably in chunks.</span><br><span class="line"> </span><br><span class="line">        [application endBackgroundTask:bgTask];</span><br><span class="line">        bgTask = UIBackgroundTaskInvalid;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意:</strong> 你总是要在开始一个任务的时候提供完成处理模块，但是如果你想知道你的应用程序还能运行多长时间，你可以通过<code>UIApplication</code>对象的<code>backgroundTimeRemaining</code>属性来获得。</p>
</blockquote>
<p>在你的完成处理模块中，你可以加入一些必须的代码来关闭你的任务。但是，完成处理模块中的任何代码都不应该耗费太长的时间去执行，因为你的完成处理模块一旦被调用，就说明你的应用程序已经快要被关闭了。因此，只执行最少的清理状态信息并结束任务。</p>
<h2 id="在后台执行下载任务"><a href="#在后台执行下载任务" class="headerlink" title="在后台执行下载任务"></a>在后台执行下载任务</h2><p>当下载文件时，应用程序应该使用<code>NSURLSession</code>对象来开始下载，这样系统就能控制下载的进程即使应用程序被挂起或终止。当你配置<code>NSURLSession</code>对象进行后台传输时，系统用一个单独的队列管理这些任务并以常规方式将传输的状态报告给你的应用程序。如果你的应用程序在传输正在进行时被终止，系统会在后台继续传输，并在传输完成或一个甚至多个任务需要你的应用程序时启动你的应用程序(若果使用)。</p>
<p>为了支持后台传输，你必须合适地配置你的<code>NSURLSession</code>对象。为了配置<code>NSURLSession</code>有必须先创建一个<code>NSURLSessionConfiguration</code>对象并给它的一些属性赋予合适的值。然后将这个<code>NSURLSessionConfiguration</code>对象在初始化<code>NSURLSession</code>对象时传递过去。</p>
<p>创建支持后台下载的<code>NSURLSessionConfiguration</code>对象的过程如下：</p>
<p>   1.使用<code>NSURLSessionConfiguration</code>的<code>backgroundSessionConfigurationWithIdentifier：</code>方法创建配置对象。</p>
<p>   2.将配置对象的<code>sessionSendLaunchEvents</code>属性的值设置为<code>YES</code>。</p>
<p>   3.如果你的应用程序在前台进行转移，建议你将<code>sessionSendsLaunchEvents</code>属性设置为<code>YES</code>。</p>
<p>   4.根据需要配置配置对象的任何其他属性。</p>
<p>   5.使用配置对象创建您的<code>NSURLSession</code>对象。</p>
<p>一旦配置完成，你的<code>NSURLSession</code>对象会在合适的时间将上传和下载任务移交给系统。如果任务在你的应用程序仍在运行时完成(无论是在前台或是后台)，<code>NSURLSession</code>对象都会以常规方式通知它的代理。如果任务还未完成时你的应用程序就被终止，系统会自动地在后台管理任务。如果用户终止了你的应用程序，系统会停止任何待处理的任务。</p>
<p>当所有与后台会话管理的任务完成时，系统会重启被终止的应用程序(假定<code>sessionSendsLaunchEvents</code>属性被设置为<code>YES</code>而且这个应用程序不是被用户强制终止的)并调用应用代理的<code>application:handleEventsForBackgroundURLSession:completionHandler:</code>方法。(系统还可以重新启动应用程序来处理身份验证或其他需要你的应用程序注意的任务的相关事件)在执行该委托方法时，请使用提供的标识符创建一个新的与之前相同的<code>NSURLSessionConfiguration</code>和<code>NSURLSession</code>对象。 系统将你的新会话对象重新连接到先前的任务，并将其状态报告给会话对象的委托。</p>
<h2 id="执行长时间运行的任务"><a href="#执行长时间运行的任务" class="headerlink" title="执行长时间运行的任务"></a>执行长时间运行的任务</h2><p>对于需要更多后台执行时间的任务，你必须请求特定的权限才能在后台运行它们而不被挂起。iOS中，只有特定类型的应用程序被允许在后台运行：</p>
<ul>
<li>在后台播放音频内容给用户，比如音乐播放器</li>
<li>在后台录制音频文件</li>
<li>使用户随时了解其位置的应用程序，比如导航应用程序</li>
<li>支持VoIP的应用程序</li>
<li>需要经常性的下载和处理新内容的应用程序</li>
<li>周期性的从外部配件接收更新的应用程序</li>
</ul>
<p>使用这些服务的应用程序必须声明其支持的服务，并使用系统框架来实现这些服务的相关方面。</p>
<h3 id="声明你的应用程序支持的后台模式"><a href="#声明你的应用程序支持的后台模式" class="headerlink" title="声明你的应用程序支持的后台模式"></a>声明你的应用程序支持的后台模式</h3><p>你必须在应用程序使用后台任务之前声明你要支持的后台任务类型。在Xcode 5和之后，你需要在你工程的Capabilities选项卡中声明你要支持哪些后台模式。启用后台模式选项将<code>UIBackgroundModes</code>键添加到应用程序的<code>Info.plist</code>文件中。</p>
<p>下表列出了你可以指定的后台模式的值：</p>
<table>
<thead>
<tr>
<th>Xcode后台模式</th>
<th>UIBackgroundModes 值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>音频和AirPlay</td>
<td><code>audio</code></td>
<td>应用程序在后台播放或录制音频内容。用户必须在第一次使用前就授权使用麦克风。</td>
</tr>
<tr>
<td>位置更新</td>
<td><code>location</code></td>
<td>使用户随时知道他们的位置，即使应用在后台运行。</td>
</tr>
<tr>
<td>网络电话</td>
<td><code>voip</code></td>
<td>应用程序提供给用户通过网络连接进行通话的能力。</td>
</tr>
<tr>
<td>Newsstand下载</td>
<td><code>newsstand-content</code></td>
<td>Newsstand类型的应用程序在后台下载并处理报纸或杂志内容。</td>
</tr>
<tr>
<td>外部附件通信</td>
<td><code>external-accessory</code></td>
<td>应用程序与需要通过外部附件框架定期提供更新的硬件配件配合使用。</td>
</tr>
<tr>
<td>使用蓝牙设备</td>
<td><code>bluetooth-central</code></td>
<td>应用程序使用需要通过Core Bluetooth框架定期发送更新的蓝牙设备。</td>
</tr>
<tr>
<td>作为蓝牙LE附件</td>
<td><code>bluetooth-peripheral</code></td>
<td>应用程序通过Core Bluetooth框架支持外设模式下的蓝牙通信。使用此模式需要用户授权</td>
</tr>
<tr>
<td>后台抓取</td>
<td><code>fetch</code></td>
<td>应用程序定期的从网路下载并处理少量数据。</td>
</tr>
<tr>
<td>远程推送</td>
<td><code>remote-notification</code></td>
<td>应用程序想要在接收到一个远程推送时开始下载内容。</td>
</tr>
</tbody></table>
<p>以上每种模式都让系统知道应该在合适的时间唤醒或启动应用程序来响应相关的事件。</p>
<h4 id="追踪用户位置"><a href="#追踪用户位置" class="headerlink" title="追踪用户位置"></a>追踪用户位置</h4><p>在后台追踪用户的位置的方式有好几种，大多数方式实际上并不需要你的应用程序在后台不断的运行。</p>
<ul>
<li>重大位置变更</li>
<li>仅在前台定位服务</li>
<li>后台定位服务</li>
</ul>
<p>对于不需要高精度位置数据的应用程序来说，推荐使用重大位置变更定位服务。这个服务只有在用户的位置发生非常重大的变化时才会产生位置更新；它对社交类应用程序或者给用户提供不是很重要的位置相关信息的应用程序来说是非常理想的定位方式。如果当一个位置更新发生时应用程序被终止，系统会在后台唤醒它来处理这个更新。如果应用程序开始使用了这个服务然后被终止，当新的位置更新产生时，系统会自动重启它。</p>
<p>仅前台定位服务和后台定位服务都使用标准的Core Location服务获取位置数据。唯一的区别是，如果应用程序被挂起，则仅前台定位服务停止发送更新。 前台定位服务适用于只在前台需要位置数据的应用程序。</p>
<p>你可以在Xcode工程中的<code>Capabilities</code>选项卡中启用支持定位服务(你也可以通过在<code>Info.plist</code>文件中设置<code>UIBackgroundModes</code>的值为<code>location</code>来启用这个服务)。启用这个服务并不会阻止系统挂起你的应用程序，但是它会告知系统无论何时新的位置更新被发送过来都应该唤醒应用程序来处理。</p>
<blockquote>
<p><strong>重要提示:</strong>鼓励你谨慎使用标准的定位服务或改用重要的位置更改服务。 定位服务需要经常使用iOS设备的板载无线电硬件。 连续运行这个硬件会消耗大量的电量。 如果你的应用程序不需要向用户提供精确且连续的位置信息，则最好尽量减少使用位置服务。</p>
</blockquote>
<h4 id="在后台播放或录制音频"><a href="#在后台播放或录制音频" class="headerlink" title="在后台播放或录制音频"></a>在后台播放或录制音频</h4><p>一个需要连续播放或录制音频的应用程序(即使应用处在后台)可以注册后台服务，实现即使在后台也能执行这些任务。你可以在Xcode工程中的<code>Capabilities</code>选项卡中启用服务(你也可以通过在<code>Info.plist</code>文件中设置<code>UIBackgroundModes</code>的值为<code>audio</code>来启用这个服务)。在后台播放音频内容的应用程序必须播放听得见的内容而不能是无声的。</p>
<p>后台音频应用程序的典型例子包括：</p>
<ul>
<li>音乐播放程序</li>
<li>音频录制程序</li>
<li>支持通过AirPlay播放音频或视频的程序</li>
<li>VoIP程序</li>
</ul>
<p>当<code>UIBackgroundModes</code>键包含<code>audio</code>值时，系统的媒体框架会自动阻止相关的应用程序被挂起。只要应用程序还在播放视屏或音频内容，录制音频，它就还能在后台运行。然而，一旦录制或播放停止，就会被系统挂起。</p>
<p>你可以使用任何系统音频框架来处理后台音频播放，并且使用这些框架的过程和在前台使用相同(对于通过AriPlay播放视频内容来说，你可以使用Media Player或AVFoundation框架来实现)。因为应用程序在播放媒体文件时不会被挂起，所以即使应用程序在后台也能正常的进行回调操作。在你的回调中，你应该只做为播放提供数据的工作，不应该在回调中执行任何与播放无关的任务。</p>
<p>在任何给定的时刻，因为可能有不止一个应用程序支持音频服务，所以由系统来决定哪个应用程序能够播放或录制音频。前台应用程序总是有优先的音频操作权利。可能有不止一个应用程序被允许在后台播放音频，这个时候决定哪个应用程序能够播放音频就取决于每个应用程序的音频会话的配置。</p>
<h4 id="实现一个VoIP应用程序"><a href="#实现一个VoIP应用程序" class="headerlink" title="实现一个VoIP应用程序"></a>实现一个VoIP应用程序</h4><p>一个Voice over Internet Protocol应用程序允许用户通过互联网而不是设备的蜂窝网络设备进行语音通话。这样的一个应用程序需要为它的服务维持一个持续的网络连接，以便它能接收到打进来的电话和其它相关数据。系统允许VoIP应用程序被挂起并给它提供了监测它们的sockets的便利，而不是让它一直处于唤醒状态。当检测到传入流量时，系统唤醒VoIP程序并将socket的控制权交还给它。</p>
<p>为了配置VoIP应用程序，你必须：</p>
<ul>
<li>在Xcode工程中的<code>Capabilities</code>选项卡中启用服务(你也可以通过在<code>Info.plist</code>文件中设置<code>UIBackgroundModes</code>的值为<code>voip</code>来启用这个服务)。</li>
<li>为VoIP应用程序配置一个socket。</li>
<li>在移动到后台之前，调用<code>setKeepAliveTimeout:handler:</code>方法来安装一个定期执行的程序。你的应用程序可以使用这个处理程序来保持服务连接。</li>
<li>配置你的音频会话来操作进入或退出活跃的使用状态的转换。</li>
</ul>
<p>设置<code>UIBackgroundModes</code>的值为<code>voip</code>让系统知道，当VoIP应用程序需要管理它的网络会话时，系统应该允许它在后台运行。为了让VoIP应用程序总是可用，系统会在启动后立刻重新启动拥有这个键值的应用程序。</p>
<p>大多数的VoIP应用程序也需要配置后台音频模式，因为它也需要在后台发送音频内容。因此，你应该将<code>UIBackgroundModes</code>的值设置为<code>audio</code>和<code>voip</code>。如果你不这样做的话，你的应用程序将不能在后台播放或录制音频内容。</p>
<h4 id="适时的获取少量内容"><a href="#适时的获取少量内容" class="headerlink" title="适时的获取少量内容"></a>适时的获取少量内容</h4><p>需要定期的检查新内容的应用程序可以请求系统唤醒它们，以便它们可以初始化一个获取内容的拉取操作。为了支持这种模式，你需要在Xcode工程中的<code>Capabilities</code>选项卡中启用服务(你也可以通过在<code>Info.plist</code>文件中设置<code>UIBackgroundModes</code>的值为<code>fetch</code>来启用这个服务)。启用这个服务并不能保证系统会给你的应用程序任何时间来执行后台拉取操作。系统必须在你的应用程序拉取内容的请求和其它应用程序以及系统自身之间做出平衡。在评估所有信息后，如果有很好的机会的话，系统会给请求拉取内容的应用程序一些执行时间。</p>
<p>当有好机会产生时，系统会唤醒或启动你的应用程序到后台并调用应用程序代理对象的<code>application:performFetchWithCompletionHandler:</code>方法。使用这个方法来检查新内容，如果新内容可用则开始下载操作。一旦新内容下载完成，你必须将新内容是否可用的结果传递给提供好的完成处理块。执行这个块告诉系统它可以将你的应用程序转换到挂起状态并评估其使用功率。可以快速下载少量内容并在它们有可用的下载内容时准确反应的应用程序，比起花费更长的下载时间或声称有可用的下载内容但没有下载任何东西的应用程序，更可能在未来获得执行时间。</p>
<p>在下载任何内容时，推荐你使用<code>NSURLSession</code>类来开始和管理你的下载。</p>
<h4 id="使用推送通知来开始下载"><a href="#使用推送通知来开始下载" class="headerlink" title="使用推送通知来开始下载"></a>使用推送通知来开始下载</h4><p>如果你的服务器在有新的应用程序可用内容时向用户的设备发送了一个推送通知，你可以请求系统在后台运行你的应用程序并立即开始下载新的可用内容。这种后台模式意图在于尽可能减少从你的用户看见推送通知到你的应用程序可以展示相关内容之间的时间。应用程序通常会在用户看见推送通知的差不多相同的时间被唤醒，但是仍会给你更多的准备时间。</p>
<p>为了支持这种模式，你需要在Xcode工程中的<code>Capabilities</code>选项卡中启这项用服务(你也可以通过在<code>Info.plist</code>文件中设置<code>UIBackgroundModes</code>的值为<code>remote-notification</code>来启用这个服务)。</p>
<p>对于一个使用推送通知来触发下载操作的应用程序来说，通知的有效内容必须包含值为<code>1</code>的<code>content-available</code>的键。当这个键值对被检测到时，系统会启动或唤醒你的应用程序到后台同时调用应用程序的代理对象的<code>application:didReceiveRemoteNotification:fetchCompletionHandler:</code>方法。你应该在这个方法里实现对相关内容的下载并将下载好的内容在加入到你的应用程序中。</p>
<p>在下载任何内容时，推荐你使用<code>NSURLSession</code>类来开始和管理你的下载。</p>
<h4 id="在后台下载新闻站内容"><a href="#在后台下载新闻站内容" class="headerlink" title="在后台下载新闻站内容"></a>在后台下载新闻站内容</h4><p>下载新闻和新的杂志文章的新闻站应用程序可以注册在后台进行这些下载。你需要在Xcode工程中的<code>Capabilities</code>选项卡中启这项用服务(你也可以通过在<code>Info.plist</code>文件中设置<code>UIBackgroundModes</code>的值为<code>newsstand-content</code>来启用这个服务)。当你提供这个关键字时，如果你的应用程序没有在运行，系统会启动你的应用程序以便它能开始下载新的文章。</p>
<p>当你使用Newsstand Kit框架来开始一个下载时，由系统为你的应用程序操作下载的进程。即使你的应用程序被挂起或终止，系统仍会继续下载文件。当下载操作完成后，系统将下载好的文件传输到你的应用程序的沙盒并向你的应用程序发送一个通知。如果应用程序没有在运行，这个通知会唤醒它并给它一个处理新的下载文件的机会。如果在下载过程中发生了错误，你的应用程序也会这样被唤醒来处理这个错误。</p>
<h4 id="与外部附件通信"><a href="#与外部附件通信" class="headerlink" title="与外部附件通信"></a>与外部附件通信</h4><p>使用外部附件的应用程序可以请求在附件发送了一个更新时被唤醒，即使它处在挂起状态。这种支持对于某些定期发送数据的附件来说是非常重要的，比如心率监视器。你需要在Xcode工程中的<code>Capabilities</code>选项卡中启这项用服务(你也可以通过在<code>Info.plist</code>文件中设置<code>UIBackgroundModes</code>的值为<code>external-accessory</code>来启用这个服务)。当你启用这个模式时，外部附件框架不会关闭活跃的外部附件会话。当外部附件发送来新的内容时，这个框架唤醒你的应用程序以便它能处理这些数据内容。在外部附件建立连接或失去连接时，系统也会唤醒应用程序来进行处理。</p>
<p>任何支持附件更新后台处理的应用程序都必须遵循以下基本准则：</p>
<ul>
<li><p>应用程序必须提供一个界面，让用户来开始或者停止附件更新事件的发送。</p>
</li>
<li><p>一旦被唤醒，应用程序大约有10S时间来处理数据。理想情况下，它应该尽可能快速地处理数据然后转换到挂起状态。但是，如果需要更多的时间，应用程序可以使用<code>beginBackgroundTaskWithExpirationHandler:</code>方法来申请额外的执行时间。</p>
</li>
</ul>
<h4 id="与蓝牙附件通信"><a href="#与蓝牙附件通信" class="headerlink" title="与蓝牙附件通信"></a>与蓝牙附件通信</h4><p>使用蓝牙外设的应用程序可以请求在外设发送了一个更新时被唤醒，即使它处在挂起状态。这种支持对于需要定期发送数据的Bluetooth-LE外设来说是非常重要的。你需要在Xcode工程中的<code>Capabilities</code>选项卡中启这项用服务(你也可以通过在<code>Info.plist</code>文件中设置<code>UIBackgroundModes</code>的值为<code>bluetooth-central</code>来启用这个服务)。当你启用这个模式时，Core Bluetooth框架会保持相应外设的任何活跃会话连接。此外，当有新的数据从外设传来，系统会唤醒应用程序让他能够处理数据。在外设建立连接或失去连接时，系统也会唤醒应用程序来进行处理。</p>
<p>iOS 6中，一个使用蓝牙外设的应用程序也可以在外设模式下运行。要充当蓝牙外设，你需要在Xcode工程中的<code>Capabilities</code>选项卡中启这项用服务(您也可以通过在应用程序<code>Info.plis</code>t文件中包含<code>UIBackgroundModes</code>键和<code>bluetooth-peripheral</code>值来启用此支持)。启用此模式可让Core Bluetooth框架在后台简单地唤醒应用程序，以便它可以处理外设的相关请求。</p>
<p>支持蓝牙数据后台处理的任何应用程序都必须基于会话，并遵循以下基本准则：</p>
<ul>
<li><p>应用程序必须提供一个界面，允许用户启动和停止蓝牙事件的传递。</p>
</li>
<li><p>被唤醒后，应用程序大概需要10秒钟才能处理数据。理想情况下，它应该尽可能快地处理数据，并允许自己再次暂停。但是，如果需要更多的时间，应用程序可以使用<code>beginBackgroundTaskWithExpirationHandler</code>：方法来请求更多的时间，它应该只有在绝对必要的时候才这样做。</p>
<p>​</p>
</li>
</ul>
<h2 id="在后台获得用户的注意"><a href="#在后台获得用户的注意" class="headerlink" title="在后台获得用户的注意"></a>在后台获得用户的注意</h2><p>通知是处在挂起，在后台运行或没有运行的应用程序获得用户的注意的一种方式。应用程序可以使用本地通知来显示提醒框，播放声音，标记应用程序的图标或者全部一起使用。比如，一个闹钟应用程序可能会使用本地通知来播放闹铃声并显示一个提醒框来使闹钟不可用。当一个通知被发送给用户，用户必须决定是否授权让应用程序来到前台。如果应用程序已经在前台，本地通知将会被静默的发送给你的应用程序而不是发送给用户。</p>
<p>为了安排本地通知的发送，需要创建一个配置了通知的各个参数的<code>UILocalNotification</code>类的实例并调用<code>UIApplication</code>类的方法。本地通知对象包含了发送通知的类型和在什么时间发送它的信息。<code>UIApplication</code>类的方法提供了是立即发送还是按时间表发送通知的选项。</p>
<p>下面的代码片段展示了如何安排一个由用户设置的使用了日期和时间的闹钟的例子。这个例子在一个时间只配置了一个闹钟并在安排它之前终止了前一个闹钟(你的应用程序在任何给定的时刻都不能拥有超过128个处在活跃状态的本地通知，它们每一个都能设置成以固定的时间间隔重复)。如果闹钟被触发时，应用程序没有运行或者处在后台，闹钟会弹出提醒框并在后台播放音频。如果应用程序是活动且处在前台，则会调用应用程序的代理对象的<code>application:didReceiveLocalNotification:</code>方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (void)scheduleAlarmForDate:(NSDate*)theDate &#123;</span><br><span class="line">    UIApplication* app = [UIApplication sharedApplication];</span><br><span class="line">    NSArray*    oldNotifications = [app scheduledLocalNotifications];</span><br><span class="line"> </span><br><span class="line">    // Clear out the old notification before scheduling a new one.</span><br><span class="line">    if ([oldNotifications count] &gt; 0)</span><br><span class="line">        [app cancelAllLocalNotifications];</span><br><span class="line"> </span><br><span class="line">    // Create a new notification.</span><br><span class="line">    UILocalNotification* alarm = [[UILocalNotification alloc] init];</span><br><span class="line">    if (alarm)</span><br><span class="line">    &#123;</span><br><span class="line">        alarm.fireDate = theDate;</span><br><span class="line">        alarm.timeZone = [NSTimeZone defaultTimeZone];</span><br><span class="line">        alarm.repeatInterval = 0;</span><br><span class="line">        alarm.soundName = @&quot;alarmsound.caf&quot;;</span><br><span class="line">        alarm.alertBody = @&quot;Time to wake up!&quot;;</span><br><span class="line"> </span><br><span class="line">        [app scheduleLocalNotification:alarm];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本地通知使用的音频文件和推送通知使用的要求相同。自定义的音频文件必须位于你应用程序主要包中且必须是以下几种格式：Linear PCM，MA4，μ-Law或者a-Law。你也可以指定<code>UILocalNotificationDefaultSoundName</code>常量来使设备播放默认的提醒声音。当通知被发送且音频被播放时，系统也会触发设备震动来配合。</p>
<h2 id="何时启动应用程序进入后台"><a href="#何时启动应用程序进入后台" class="headerlink" title="何时启动应用程序进入后台"></a>何时启动应用程序进入后台</h2><p>支持后台执行的应用程序可能会被系统重启来处理发生的事件。如果应用程序不是被用户强制退出，系统会启动应用程序在下列事件发生时：</p>
<ul>
<li>对于定位应用程序<ul>
<li>系统收到一个满足发送给应用程序标准的位置更新。</li>
<li>设备进入或退出一个已注册的区域。</li>
</ul>
</li>
<li>对于音频应用程序，音频框架需要应用程序来处理某些数据。</li>
<li>对于蓝牙应用程序<ul>
<li>应用程序作为从连接的外设接收数据的核心角色。</li>
<li>应用程序作为从连接核心接收命令的外设。</li>
</ul>
</li>
<li>对于后台下载应用程序<ul>
<li>应用程序收到一个包含 <code>content-available</code> 键并且值为 <code>1</code>的远程通知。</li>
<li>系统在随机时间唤醒应用程序来开始新内容的下载。</li>
<li>使用<code>NSURLSession</code>对象在后台下载内容的应用程序，当这个会话相关的任务全部成功完成或发生了一个错误。</li>
<li>Newsstand应用程序内容下载完成。</li>
</ul>
</li>
</ul>
<p>在大多数情况下，系统并不会重启被用户强制退出的应用程序。定位应用程序是个例外，在iOS8和之后。如果不是的话，用户必须显式的启动应用程序或者重启设备，系统才能自动的启动程序进入后台。当启用密码保护时，在用户第一次解锁设备之前，系统不会启动任何应用程序进入后台。</p>
<h2 id="成为一个负责的后台运行应用程序"><a href="#成为一个负责的后台运行应用程序" class="headerlink" title="成为一个负责的后台运行应用程序"></a>成为一个负责的后台运行应用程序</h2><p>在使用系统资源和硬件时，前台应用程序始终比后台应用程序的优先级高。后台应用程序需要为这个差异做准备并调整它们的行为：</p>
<ul>
<li><strong>不要在你的代码中进行任何OpenGL ES调用</strong>。在后台运行时，你绝不能创建<code>EAGLContext</code>对象或发出任何OpenGL ES绘图命令。使用这些会使你的应用程序被立即终止。应用程序必须保证任何先前提交的命令在移入后台之前完成。</li>
</ul>
<ul>
<li><strong>在挂起之前停止任何Bonjour-related服务</strong>。在你的应用程序移入后台但未被挂起之前，它应该从Bonjour注销并关闭任何与网络服务相关的监听sockets。一个挂起的应用程序无论如何不能响应任何传入的服务请求。如果你没有关闭Bonjour服务，在应用程序挂起时，系统会自动的关闭它们。</li>
<li><strong>准备好处理基于网络的sockets的连接失败</strong>。系统可能会销毁socket连接，当你的应用程序因为某些原因被挂起时。只要你的基于网络的socket代码准备好了如何处理其他类型的网络失败，比如使用失败信号或网络转化，socket被销毁就不会导致出现任何不寻常的问题。当你的应用程序重新开始运行时，如果使用socket遭遇故障，只需重新建立一个。</li>
<li><strong>在转入后台之前保存你的应用程序的状态</strong>。处于低内存的情况下，后台应用程序可能会被从内存中移除以释放空间。挂起的应用程序首先被移除，并且不会在移除之前通知应用程序。因此，应用程序应该利用iOS 6及之后提供的状态保存机制将应用程序状态信息保存到磁盘。</li>
<li><strong>在转入后台时移除对任何不需要的对象的强引用</strong>。</li>
<li><strong>在挂起之前停止使用共享系统资源</strong>。与共享系统资源进行交互的应用程序应该在被挂起之前停止使用这些资源。前台应用程序总是拥有这些资源的优先使用权。当你的应用程序挂起时，如果被发现它在使用这些共享资源，则会被系统杀死进程。</li>
<li><strong>避免更新窗口和视图</strong>。因为你的应用程序的窗口和视图在后台是不可见的，你应该避免更新它们。如果你的应用程序需要在系统拍摄快照前更新窗口的内容的话则是一种例外情况。</li>
<li><strong>响应外部附件的连接和断开通知</strong>。对于和外部附件通信的应用程序来说，当应用程序转入后台时系统会自动的发送一个断开通知。应用程序必须注册这个通知并用它来关闭当前附件的会话。当应用程序转入前台时，一个匹配连接的通知被发送，给应用程序重新连接的机会。</li>
<li><strong>在转入后台时清理活动的提醒框的资源</strong>。为了在各个应用程序之间进行切换时保存上下文，在你的应用程序进入后台时，系统不会自动地释放上拉菜单或提醒视图。在应用程序转入后台之前，你需要提供合适的清理行为。</li>
<li><strong>在转入后台之前从视图中移除敏感信息</strong>。当应用程序转入后台时，系统会对应用程序的主窗口拍摄快照，当应用程序转入到前台时，这个快照会短暂的显示。在从<code>applicationDidEnterBackground:</code>方法返回之前，你应该隐藏或混淆可能被作为快照一部分拍摄的密码和其它敏感的个人信息</li>
<li><strong>在后台运行时尽可能的少做工作</strong>。给与后台应用程序的执行时间相比于前台应用程序来说有更多的限制。应用程序不应该在后台执行太长时间，这可能导致应用程序被终止。</li>
</ul>
<h2 id="选择退出后台执行"><a href="#选择退出后台执行" class="headerlink" title="选择退出后台执行"></a>选择退出后台执行</h2><p>如果你不希望你的应用程序在后台运行，你可以通过将值为<code>YES</code>的<code>UIApplicationExitsOnSuspend</code>键加入<code>Info.plist</code>来显式的退出后台模式。当一个应用程序选择退出后台，它的生命周期将在未运行，非活动和活动状态之间转换，永远不会进入后台或被挂起状态。当用户按下Home按钮来退出应用程序时，应用程序代理对象的<code>applicationWillTerminate:</code>方法将会被调用，应用程序将有大约5秒时间在它被终止或移入未运行状态之前来执行清理任务并退出。</p>
<p>强烈不鼓励退出后台执行，但在某些情况下可能是首选。 具体来说，如果后台执行的编码对你的应用程序来说增加了很大的复杂性，那么终止应用程序可能会更简单。 此外，如果你的应用程序消耗大量内存，并且无法轻松释放任何内存，系统可能会迅速杀死你的应用程序，为其他应用程序腾出空间。 因此，选择终止，而不是切换到后台，可能会产生相同的结果，并节省你的开发时间和精力。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2015-10-17T16:00:00.000Z" title="2015/10/18 上午12:00:00">2015-10-18</time>发表</span><span class="level-item"><a class="link-muted" href="/categories/iOS/">iOS</a></span><span class="level-item">1 小时读完 (大约8088个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2015/10/18/ios-application-life-cycle/">应用程序生命周期和状态转换操作策略</a></h1><div class="content"><h1 id="iOS-应用程序生命周期"><a href="#iOS-应用程序生命周期" class="headerlink" title="iOS 应用程序生命周期"></a>iOS 应用程序生命周期</h1><hr>
<h2 id="基本概念介绍"><a href="#基本概念介绍" class="headerlink" title="基本概念介绍"></a>基本概念介绍</h2><h3 id="The-Main-Function-程序的入口"><a href="#The-Main-Function-程序的入口" class="headerlink" title="The Main Function - 程序的入口"></a>The Main Function - 程序的入口</h3><p><code>main</code>函数是每个基于C的应用程序的入口，iOS也是这样。在Xcode中开发iOS程序的话，Xcode会自动为你创建这个函数作为你工程的一部分。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>main</code>函数控制UIKit framework的工作。<code>UIApplicationMain</code>函数通过创建应用程序的核心对象，从可用的<code>storyboard</code>文件加载应用程序的用户界面，调用自定义代码，以便让你可以在程序启动时进行一些初始设置，并将应用程序的运行循环启动。 </p>
<h3 id="The-Structure-of-an-App-程序的结构"><a href="#The-Structure-of-an-App-程序的结构" class="headerlink" title="The Structure of  an App - 程序的结构"></a>The Structure of  an App - 程序的结构</h3><p>在启动过程中，<code>UIApplicationMain</code>函数设置了几个关键对象，启动应用程序并开始运行它。 每个iOS应用程序的核心都是<code>UIApplication</code>对象，其工作是为了方便系统与应用程序中的其他对象之间的交互。 </p>
<p>一个iOS应用程序中包含的关键对象：</p>
<img src="https://raw.githubusercontent.com/apple272487813/apple272487813.github.io/master/images/application_life_cycle/application_core_objects.png"  style="zoom:50%"/>



<p>一个iOS应用程序中各个对象的所起到的作用：</p>
<table>
<thead>
<tr>
<th align="left">Object</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>UIAppplication</code></td>
<td><code>UIApplication</code>对象管理着App的事件循环和一些高级App行为，并向它的委托对象报告App的状态转换和一些特殊事件。</td>
</tr>
<tr>
<td align="left"><code>Appdelegate</code></td>
<td><code>Appdelegate</code>是你编写的程序代码的核心 ，它与<code>UIApplication</code>对象一起工作，处理应用程序初始化，状态转换和许多高级App行为。 这个对象也是唯一一个保证在每个应用程序中都出现的对象，因此通常用于设置应用程序的初始数据结构。</td>
</tr>
<tr>
<td align="left"><code>ViewController</code></td>
<td><code>View Controller</code>对象管理着你的App内容在屏幕上是如何呈现的。一个<code>View Controller</code>对象管理着一个视图和这个视图的子视图。</td>
</tr>
<tr>
<td align="left"><code>UIWindow</code></td>
<td><code>UIWindow</code>对象协调屏幕上一个或多个视图的呈现。 大多数应用程序只有一个窗口，它在主屏幕上显示内容，但应用程序可能会在外部显示器上显示内容的附加窗口。要更改应用程序的内容，可以使用视图控制器更改相应窗口中显示的视图。 你永远不会更换窗口本身。除了托管视图之外，<code>Windows</code>还可以使用<code>UIApplication</code>对象将事件传递给的视图和控制器。</td>
</tr>
<tr>
<td align="left"><code>View,Control and Layer</code></td>
<td>View和Control提供了应用内容的可视化表示。 除了包含View和Control之外，应用程序还可以将Core Animation图层纳入其视图和控制层次结构中。 层对象实际上才是表示可视内容的数据对象。</td>
</tr>
</tbody></table>
<h3 id="The-Main-Run-Loop-主运行循环"><a href="#The-Main-Run-Loop-主运行循环" class="headerlink" title="The Main Run Loop - 主运行循环"></a>The Main Run Loop - 主运行循环</h3><p>应用程序的主运行循环处理所有与用户相关的事件。 <code>UIApplication</code>对象在启动时设置主运行循环，并使用它来处理事件并处理基于视图的接口的更新。</p>
<p> 顾名思义，主运行循环在应用程序的主线程上执行，这确保了与用户相关的事件按照接收的顺序连续处理。</p>
<p>当用户与设备进行交互时，与这些交互相关的事件由系统生成，并通过由UIKit设置的特殊端口传送到应用。 事件在应用程序内部进入队列，并逐个分派到主运行循环执行。<code>UIApplication</code>对象是接收事件的第一个对象，并且决定需要做什么来处理这个事件。 触摸事件通常被分派到主窗口对象，主窗口对象又将其发送到触摸发生的视图。 </p>
<img src="https://raw.githubusercontent.com/apple272487813/apple272487813.github.io/master/images/application_life_cycle/application_event_draw_cycle.png" style="zoom:50%"/>

<p>可以在iOS应用程式中分发许多类型的事件。 最常见的如下表所示。 这些事件大多是使用应用程序的主运行循环分发的，但也有些不是。 一些事件被分发到一个委托对象或被分发给你提供的一个block。</p>
<table>
<thead>
<tr>
<th>事件类型</th>
<th>分发对象</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>触摸事件</td>
<td>事件发生的视图</td>
<td>视图是响应者对象。任何没有被当前视图处理的触摸事件都会被沿着响应链继续向下分发进行处理。</td>
</tr>
<tr>
<td>遥控器事件和摇动运动事件</td>
<td>首要响应对象</td>
<td>遥控器事件用于控制媒体播放，并由耳机和其他附件产生。</td>
</tr>
<tr>
<td>加速度计、磁力仪和陀螺仪</td>
<td>你指定的对象</td>
<td>与加速度计，磁力计和陀螺仪硬件相关的事件传递给你指定的对象。</td>
</tr>
<tr>
<td>定位</td>
<td>你指定的对象</td>
<td>你注册定位服务以接收使用Core Location框架位置的事件。</td>
</tr>
<tr>
<td>重绘</td>
<td>需要更新的视图</td>
<td>重绘事件不涉及事件对象，而是简单地调用视图来绘制自身。</td>
</tr>
</tbody></table>
<p>一些事件，如触摸和遥控事件，由你的应用程序的响应者对象处理。响应者对象在你的应用程序中无处不在。 大多数事件都针对特定的响应者对象，但如果需要处理事件，则可以将其传递给其他响应方（通过响应者链）。 例如，不处理事件的视图可以将事件传递到其父视图或父视图控制器。</p>
<p>触摸控件（如按钮）中发生的事件的处理方式与在许多其他类型的视图中发生的触摸事件的处理方式不同。 通常只有有限数量的交互可能与控件相关联，因此这些交互被重新封装到动作消息中并传递到适当的目标对象。 这种目标动作(Target-Action)设计模式可以轻松地使用控件来触发你应用中自定义代码的执行。</p>
<h3 id="Execution-States-for-Apps-应用程序的执行状态"><a href="#Execution-States-for-Apps-应用程序的执行状态" class="headerlink" title="Execution States for Apps - 应用程序的执行状态"></a>Execution States for Apps - 应用程序的执行状态</h3><p>在任何给定的时刻，你的应用程序都处在下表所列的状态之一。 系统会改变应用程序的状态以响应整个系统中发生的操作。</p>
<table>
<thead>
<tr>
<th>状态</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Not running</td>
<td>应用程序没有运行或被系统终止运行。</td>
</tr>
<tr>
<td>Inactive</td>
<td>应用程序正在前台运行，但当前没有收到事件 (它可能正在执行其他代码)。应用程序通常在转换到不同的状态时暂时保持在此状态。</td>
</tr>
<tr>
<td>Active</td>
<td>应用程序正在前台运行，并且正在接收事件(这是前台应用程序的正常模式)。</td>
</tr>
<tr>
<td>Background</td>
<td>应用程序在后台执行代码。 大多数应用程序短暂地进入此状态。 但是，请求额外执行时间的应用程序可能会保持此状态一段时间。</td>
</tr>
<tr>
<td>Suspended</td>
<td>应用程序是在后台，但不执行代码。 系统将应用程序自动转换到这个状态，在这样做之前并不会通知应用程序。 挂起时，应用程序保留在内存中，但不执行任何代码。当出现低内存条件时，系统可能会清除已挂起的应用程序，以为前台应用程序腾出更多空间。</td>
</tr>
</tbody></table>
<p>下图展示了应用程序在各种状态之间的转换：</p>
<img src="https://raw.githubusercontent.com/apple272487813/apple272487813.github.io/master/images/application_life_cycle/application_high_level_flow.png" style="zoom:50%"/>

<p>大多数状态转换伴随着对应用程序委托对象的方法的相应调用 ，这些方法是你以适当方式响应状态变更的地方。 </p>
<ul>
<li><p><code>application:willFinishLaunchingWithOptions:</code></p>
<p>告诉代理对象启动过程已经开始，但还没有发生状态恢复。</p>
</li>
<li><p><code>application:didFinishLaunchingWithOptions:</code></p>
<p>告诉代理对象启动过程快要完成，应用程序快要准备好运行。</p>
</li>
<li><p><code>applicationDidBecomeActive:</code></p>
<p>告诉代理对象应用程序已经处于Active状态。</p>
</li>
<li><p><code>applicationWillResignActive:</code></p>
<p>告诉代理对象应用程序即将进入Inactive状态。</p>
</li>
<li><p><code>applicationDidEnterBackground:</code></p>
<p>告诉代理对象应用程序已经进入后台。</p>
</li>
<li><p><code>applicationWillEnterForeground:</code></p>
<p>告诉代理对象应用程序即将进入前台。</p>
</li>
<li><p><code>applicationWillTerminate:</code></p>
<p>告诉代理对象应用程序即将被终止。</p>
<p>​</p>
</li>
</ul>
<h3 id="App-Termination-应用程序的终止"><a href="#App-Termination-应用程序的终止" class="headerlink" title="App Termination - 应用程序的终止"></a>App Termination - 应用程序的终止</h3><p>应用程序必须随时准备终止运行，不应等待保存用户数据或执行其他关键任务。 System-initiated termination是应用程序生命周期的正常部分。该系统通常终止应用程序，以便它可以回收内存并为用户启动的其他应用程序腾出空间，但是系统也可能会终止行为不当或未及时响应事件的应用程序。</p>
<p>挂起的应用程序终止时不会收到通知，系统将杀死该进程并回收相应的内存。如果一个应用程序当前在后台运行并且没有挂起，系统会在终止之前调用应用程序委托的<code>applicationWillTerminate：</code>。当设备重新启动时，系统不会调用此方法。</p>
<p>除了系统终止你的应用程序，用户可以使用多任务UI显式地终止你的应用程序。System-initiated termination与终止挂起的应用程序具有相同的效果。该应用程序的进程被杀死，并且不会有通知发送到该应用程序。</p>
<h3 id="Threads-and-Concurrency-线程和并发"><a href="#Threads-and-Concurrency-线程和并发" class="headerlink" title="Threads and Concurrency - 线程和并发"></a>Threads and Concurrency - 线程和并发</h3><p>系统创建你的应用程序的主线程，你可以根据需要创建其他线程来执行其他任务。</p>
<p>对于iOS应用，首选技术是使用Grand Central Dispatch（GCD），操作对象和其它异步编程接口，而不是自己创建和管理线程。 GCD等技术可以让你定义想要执行的工作以及要执行的顺序，但让系统决定如何在可用的CPU上执行该工作。让系统处理线程管理简化了必须编写的代码，使得更容易确保代码的正确性，并提供更好的整体性能。</p>
<p>在考虑线程和并发时，请考虑以下几点：</p>
<ul>
<li><p>涉及视图，核心动画和许多其他UIKit类的工作通常必须发生在应用程序的主线程上。</p>
</li>
<li><p>长时间的任务（或潜在的长度任务）应始终在后台线程上执行。任何涉及网络访问，文件访问或大量数据处理的任务都应使用GCD或操作对象异步执行。</p>
</li>
<li><p>在启动时，尽可能将任务从主线程移出。在启动时，您的应用程序应尽可能快地设置用户界面。只有有助于设置用户界面的任务才能在主线程上执行。</p>
<p>所有其他任务应该是异步执行的。</p>
</li>
</ul>
<hr>
<h2 id="操作应用程序的状态转换"><a href="#操作应用程序的状态转换" class="headerlink" title="操作应用程序的状态转换"></a>操作应用程序的状态转换</h2><hr>
<p>对于应用程序的任何一个可能的运行状态，系统都对你的应用程序有不同的期望。当应用程序的状态发生转换时，系统会通知应用对象，应用对象又通知其代理。你可以使用<code>UIApplicationDelegate</code>协议的状态转换方法来检测这些状态变化并进行适当的响应。</p>
<h2 id="应用程序启动时应该做什么"><a href="#应用程序启动时应该做什么" class="headerlink" title="应用程序启动时应该做什么"></a>应用程序启动时应该做什么</h2><p>当应用程序启动(进入前台货后台)时，你应该使用应用程序委托对象的<code>application:willFinishLaunchingWithOptions:</code>和<code>application：didFinishLaunchingWithOptions：</code>方法执行一些操作：</p>
<ul>
<li><p>检查启动选项字典的内容(launch options dictionary)，了解应用程序启动的原因，并作出适当的响应。</p>
</li>
<li><p>初始化应用程序的关键数据结构。</p>
</li>
<li><p>准备应用程序的窗口和视图以进行内容显示。</p>
<ul>
<li><p>使用OpenGL ES进行绘图的应用程序不能使用这些方法来准备绘图环境，使用OpenGL ES绘图应该在<code>applicationDidBecomeActive:</code>方法中进行准备。</p>
</li>
<li><p>Show your app window from your <code>application:willFinishLaunchingWithOptions:</code> method. UIKit delays making the window visible until after the <code>application:didFinishLaunchingWithOptions:</code> method returns.</p>
</li>
<li><p>在<code>application:willFinishLaunchingWithOptions:</code>方法中配置如何显示应用程序的Window。UIKit延迟Window的显示直到<code>application:didFinishLaunchingWithOptions:</code>方法进行了返回。</p>
</li>
</ul>
</li>
</ul>
<p>在启动时，系统会自动的加载应用程序的主要storyBoard文件，并加载初始视图控制器。对于支持状态恢复的应用程序，状态恢复机制会在调用<code>application:willFinishLaunchingWithOptions:</code>和 <code>application:didFinishLaunchingWithOptions:</code>方法之间将应用程序恢复到以前的状态。使用<code>application:willFinishLaunchingWithOptions:</code>方法显示应用程序窗口，并确定状态恢复是否应该发生。使用<code>application:didFinishLaunchingWithOptions:</code>方法对应用程序的用户界面进行任何最终调整。</p>
<p><code>application:willFinishLaunchingWithOptions:</code>和<code>application:didFinishLaunchingWithOptions:</code>方法应始终尽可能轻量级，以减少应用程序的启动时间。如果应用程序没有及时完成其启动周期，系统将使其无法响应。因此，任何可能减慢启动速度的任务（如访问网络）都应该在辅助线程上执行。</p>
<h3 id="The-Launch-Cycle-启动周期"><a href="#The-Launch-Cycle-启动周期" class="headerlink" title="The Launch Cycle - 启动周期"></a>The Launch Cycle - 启动周期</h3><p>当你的应用程序启动后，在短暂的停留在非活动状态(Inactive)后，将会从非运行状态(Not Running)转换到活动状态(Active)或后台状态(Background)。作为启动周期的一部分，系统会为你的应用程序创建一个进程和一个主线程，并在主线程中调用应用程序的<code>main</code>函数。</p>
<p>下图显示了应用程序启动到前台时发生的事件序列，包括调用的应用程序委派方法。</p>
<img src="https://raw.githubusercontent.com/apple272487813/apple272487813.github.io/master/images/application_life_cycle/app_launch_fg.png" style="zoom:50%" />



<p>当你的应用程序启动到后台时，通常要处理一些后台事件，启动周期会有些许改变。主要的不同在于，在后台的应用程序不是处于活动状态，只是进入后台来处理一些事件，之后可能会被挂起。当启动到后台时，系统仍然会加载用户界面文件，但不会显示应用程序的窗口。</p>
<img src="https://raw.githubusercontent.com/apple272487813/apple272487813.github.io/master/images/application_life_cycle/app_launch_bg.png" style="zoom:50%"/>

<p>你可以通过在代理方法 <code>application:willFinishLaunchingWithOptions:</code> 和<code>application:didFinishLaunchingWithOptions:</code>中检查<code>UIApplication</code>的<code>applicationState</code>属性来决定应用程序是启动到前台还是后台。当你的应用程序启动到前台时，这个属性的值是<code>UIApplicationStateInactive</code>，当你的应用程序启动到后台时，这个属性的值是<code>UIApplicationStateBackground</code>。</p>
<h3 id="Launching-in-Landscape-Mode-以横屏模式启动"><a href="#Launching-in-Landscape-Mode-以横屏模式启动" class="headerlink" title="Launching in Landscape Mode - 以横屏模式启动"></a>Launching in Landscape Mode - 以横屏模式启动</h3><p>对于界面只使用横屏的应用程序来说，必须明确地请求系统以横屏模式启动。通常来说，应用程序以纵屏模式启动，只有在需要适应设备的方向的时候才旋转屏幕的方向。 对于支持纵向和横向方向的应用程序，应始终为纵向模式配置视图，然后让视图控制器处理任何旋转。<br>但是，如果您的应用程序支持横向而不是纵向方向，请执行以下任务，让使其以横向模式启动：</p>
<ul>
<li>像你应用程序中的<code>Infl.plist</code>文件中添加<code>UIInterfaceOrientation</code>字段，并将其值设为<code>UIInterfaceOrientationLandscapeLeft</code>或<code>UIInterfaceOrientationLandscapeRight</code>。</li>
<li>在横屏模式下布局你的视图并确保视图的布局和自动调整大小选项设置正确。</li>
<li>重写试图控制器的<code>shouldAutorotateToInterfaceOrientation:</code>方法并在左向横屏或右向横屏时返回<code>YES</code>，在纵屏模式下返回<code>NO</code>。</li>
</ul>
<blockquote>
<p><strong>重要提示:</strong> 应用程序应该总是用视图控制器来管理基于窗口(Window)的内容。</p>
</blockquote>
<p>在<code>Info.plist</code>文件中的<code>UIInterfaceOrientation</code>字段告诉iOS系统该如何配置应用程序状态栏的方向(如果显示的话)以及任何视图控制器管理的视图在启动时的方向。视图控制器根据这个字段设置它的视图的初始方向。 使用此字段相当于在执行你的<code>applicationDidFinishLaunching:</code>方法的早期调用应用程序的<code>setStatusBarOrientation：animated:</code>方法。</p>
<h3 id="Installing-App-Specific-Data-Files-at-First-Launch-配置应用程序数据文件"><a href="#Installing-App-Specific-Data-Files-at-First-Launch-配置应用程序数据文件" class="headerlink" title="Installing App-Specific Data Files at First Launch - 配置应用程序数据文件"></a>Installing App-Specific Data Files at First Launch - 配置应用程序数据文件</h3><p>你可以使用应用程序的第一个启动周期来设置任何应用程序运行所需要的数据或配置文件。 应用程序特定的数据文件应在应用程序沙箱的<code>Library/Application Support/&lt;bundleID&gt;/</code>目录中创建，其中<bundleID>是应用程序的标识符。你可以根据需要细分目录来组织你的数据文件。</p>
<p>如果应用程序包中包含你打算进行修改的数据文件，你应该将要修改的数据文件从应用程序的数据包中复制出来进行修改。你不能在应用程序包中修改数据文件，因为iOS应用程序是代码签名的，在应用程序包中修改数据文件会使应用程序的签名失效，使得你的应用程序无法启动。将打算修改的数据文件复制到<code>Application Support</code>(或者其它可写的目录)目录下进行修改是唯一安全的方式。</p>
<h2 id="应用程序临时被打断时应该做什么"><a href="#应用程序临时被打断时应该做什么" class="headerlink" title="应用程序临时被打断时应该做什么"></a>应用程序临时被打断时应该做什么</h2><p>基于警报的打断会导致你的应用程序临时性的失去控制。这种情况下，你的应用程序仍然运行在前台，但是不接收任何来自系统的触摸事件(但是会继续接收推送通知等其他类型的时间，比如加速度计时间等)。你应该在<code>applicationWillResignActive:</code>方法中进行如下操作来处理这种情况：</p>
<ul>
<li>保存数据以及任何相关的状态信息。</li>
<li>停止计时器和其他周期性任务。</li>
<li>停止任何进行的数据请求任务。</li>
<li>不要创建任何新的任务。</li>
<li>停止视屏播放(除了通过AriPlay播放的视屏)</li>
<li>如果你的应用程序是游戏的话，是游戏进入暂停状态。</li>
<li>提高OpenGL ES 帧速率。</li>
<li>暂停执行非关键代码的任何调度队列或操作队列。 (可以在不活动的情况下继续处理网络请求和其他时间敏感的后台任务)</li>
</ul>
<p>当你的应用程序返回活动状态时，在<code>applicationDidBecomeActive:</code>方法中应该进行与<code>applicationWillResignActive:</code>相反的操作步骤。因此，一但重新活动，你的应用程序应重新启动计时器，恢复调度队列，并再次调低OpenGL ES帧速率。 但是，游戏不应该自动恢复，它们应该保持暂停，直到用户选择恢复它们为止。</p>
<p>当用户按下睡眠或唤醒按钮时，含有<code>NSFileProtectionComplete</code>保护选项的文件的应用程序必须关闭这些被保护文件的任何引用。对于设置了相应密码的设备，按下睡眠或唤醒按钮时应该锁定屏幕并强制系统丢弃对拥有完全保护文件的解密密钥。当屏幕锁定时，任何尝试访问相关文件的操作都会失败。所以你如果有这样的文件，你应该在<code>applicationWillResignActive:</code>方法中关闭对它们的任何引用，在<code>applicationDidBecomeActive:</code>中打开新的引用。</p>
<p><strong>重要提示:</strong> 你应该总是在适当的时候保存用户数据。虽然你可以使用应用程序状态转换来强制对象将为保存的变更写入磁盘，但是合适的做法是永远不要等到状态转换时才去保存数据。</p>
<h3 id="Responding-to-Temporary-Interruptions-响应临时打断"><a href="#Responding-to-Temporary-Interruptions-响应临时打断" class="headerlink" title="Responding to Temporary Interruptions - 响应临时打断"></a>Responding to Temporary Interruptions - 响应临时打断</h3><p>当基于警报的打断发生时(比如打进电话)，应用程序暂时进入非活动状态已便系统可以提示用户如和继续操作。应用程序保持在这个状态直到用户拒绝了这个警报，这时应用程序会返回前台进入活动状态或进入后台。</p>
<img src="https://raw.githubusercontent.com/apple272487813/apple272487813.github.io/master/images/application_life_cycle/app_interruptions.png" style="zoom:50%"/>

<p>以横幅形式显示的通知不会像基于警报的通知那样是你的应用程序进入非活动状态。尽管横幅放置在你应用程序窗口的顶部边缘，但是你的应用程序还是能够继续接收触摸事件。然而如果用户下拉横幅以便查看通知中心，你的应用程序就会像基于警报的打断发生时那样进入非活动状态。你的应用程序保持在非活动状态直到用户退出通知中心或启动另一个应用程序，这时，你的应用程序相应的会进入非活动转台或后台。</p>
<p>按下睡眠或唤醒按钮是另一种类型的可以导致你的应用程序暂时进入非活动状态的打断。当用户按下这个按钮，系统会使触摸事件变得不可用并让应用程序进入后台，同时将<code>applicationState</code>的值设置为<code>UIApplicationStateBackground</code>并锁定屏幕。</p>
<h2 id="应用程序在前台时做什么"><a href="#应用程序在前台时做什么" class="headerlink" title="应用程序在前台时做什么"></a>应用程序在前台时做什么</h2><p>当你的应用程序返回前台进入活动状态时，你可以重新启动在进入后台时停止的任务。移动到前台时出现的步骤如下图所示，<code>applicationWillEnterForeground：</code>方法应该撤消在<code>applicationDidEnterBackground：</code>方法中完成的任何内容，并且<code>applicationDidBecomeActive：</code>方法应该继续执行与启动时相同的激活任务。</p>
<img src="https://raw.githubusercontent.com/apple272487813/apple272487813.github.io/master/images/application_life_cycle/app_enter_foreground.png" style="zoom:50%"/>



<h3 id="Be-Prepared-to-Process-Queued-Notifications-准备处理通知队列"><a href="#Be-Prepared-to-Process-Queued-Notifications-准备处理通知队列" class="headerlink" title="Be Prepared to Process Queued Notifications - 准备处理通知队列"></a>Be Prepared to Process Queued Notifications - 准备处理通知队列</h3><p>一个处于挂起状态的应用程序必须做好在返回前台或进入后台执行状态时处理任何在队列中的通知。处于挂起状态的应用程序不执行任何代码，因此不能处理通知引发的屏幕方向改变，时间改变，偏好改变以及其它会影响应用程序的外观和状态的改变。为了确保这些改变不会丢失，系统将相关的通知放入队列并在应用程序开始执行代码(无论在前台还是后台)时分发通知给它。为了防止应用程序在恢复通知时变得超负荷，系统会将事件合并，并提供一个单一的通知（每种相关类型），反映自您的应用程序被挂起以来的净变化。</p>
<p>下表列出了分发给你的应用程序的可以合并的通知。这些通知的大多数都直接分发给已经注册的观察者。</p>
<table>
<thead>
<tr>
<th>Event</th>
<th>Notifications</th>
</tr>
</thead>
<tbody><tr>
<td>An accessory is connected or disconnected.</td>
<td><code>EAAccessoryDidConnectNotification</code> <code>EAAccessoryDidDisconnectNotification</code></td>
</tr>
<tr>
<td>设备方向改变</td>
<td><code>UIDeviceOrientationDidChangeNotification</code>除了这个通知，视图控制器自动的改变自己的方向。</td>
</tr>
<tr>
<td>重要的时间改变</td>
<td><code>UIApplicationSignificantTimeChangeNotification</code></td>
</tr>
<tr>
<td>电池状态改变</td>
<td><code>UIDeviceBatteryLevelDidChangeNotification</code> <code>UIDeviceBatteryStateDidChangeNotification</code></td>
</tr>
<tr>
<td>The proximity state changes.</td>
<td><code>UIDeviceProximityStateDidChangeNotification</code></td>
</tr>
<tr>
<td>被保护的文件的状态的改变</td>
<td><code>UIApplicationProtectedDataWillBecomeUnavailable</code> <code>UIApplicationProtectedDataDidBecomeAvailable</code></td>
</tr>
<tr>
<td>内建显示器连接或失去连接</td>
<td><code>UIScreenDidConnectNotification</code> <code>UIScreenDidDisconnectNotification</code></td>
</tr>
<tr>
<td>屏幕显示模式改变</td>
<td><code>UIScreenModeDidChangeNotification</code></td>
</tr>
<tr>
<td>通过设置应用程序改变了应用程序的设置</td>
<td><code>NSUserDefaultsDidChangeNotification</code></td>
</tr>
<tr>
<td>当前语言或本地化设置改变</td>
<td><code>NSCurrentLocaleDidChangeNotification</code></td>
</tr>
<tr>
<td>用户的iCloud账户状态改变</td>
<td><code>NSUbiquityIdentityDidChangeNotification</code></td>
</tr>
</tbody></table>
<p>通常在任何触摸事件或用户输入事件之前，在主线程中分发队列化的通知。大多数的应用程序应该足够快地处理这些事件，避免在重启是导致可观察到的延迟。</p>
<p>应用程序返回前台时也会接收到要更新自从上次更新以来被标记为dirty的视图的通知。一个运行在后台的应用程序仍然能调用<code>setNeedsDisplay</code> 和 <code>setNeedsDisplayInRect:</code>方法来请求更新视图。然而，因为这些请求更新的视图不可见，系统合并了这些请求并在应用程序进入前台后才更新它们。</p>
<h3 id="Handle-iCloud-Changes-处理iCloud改变"><a href="#Handle-iCloud-Changes-处理iCloud改变" class="headerlink" title="Handle iCloud Changes - 处理iCloud改变"></a>Handle iCloud Changes - 处理iCloud改变</h3><p>当iCloud的状态发生改变时，系统会发送一个<code>NSUbiquityIdentityDidChangeNotification</code>通知给你的应用程序。用户登入或登出iCloud账号，关闭了文档和数据的同步，都会引起iCloud状态的改变。这个通知表示应用程序应该更新缓存和与iCloud有关的用户界面元素。</p>
<p>如果你的应用程序已经提示了用户是否要在iCloud存储文件的话，不要在iCloud状态发生改变时再次提醒。在第一次提醒了用户后，将用户的选择保存在本地的偏好设置中。</p>
<h3 id="Handle-Locale-Changes-处理本地化改变"><a href="#Handle-Locale-Changes-处理本地化改变" class="headerlink" title="Handle Locale Changes - 处理本地化改变"></a>Handle Locale Changes - 处理本地化改变</h3><p>如果用户在你的应用程序挂起时改变了当前的本地化方案，当你的应用程序返回前台时，你可以使用<code>NSCurrentLocaleDidChangeNotification</code>通知来强制更新包含了对本地化方案敏感的信息，比如日期，时间和数字。当然，最好的避免发生本地化相关的问题的方法是用能简单更新视图的方法来编写代码：</p>
<ul>
<li>使用<code>autoupdatingCurrentLocale</code>类方法当你检索到<code>NSLocal</code>对象。这个方法返回一个可以自动更新自己来响应本地化方案改变的本地化对象，所以你永远不需要重新创建它。然而，当本地化方案发生改变时，你仍然需要更新包含来自于当前本地化方案的信息的视图。</li>
<li>重新创建任何缓存的日期和数字格式，无论当前本地化方案何时发生变化。</li>
</ul>
<h3 id="Handle-Changes-to-Your-App’s-Settings-处理偏好设置的改变"><a href="#Handle-Changes-to-Your-App’s-Settings-处理偏好设置的改变" class="headerlink" title="Handle Changes to Your App’s Settings - 处理偏好设置的改变"></a>Handle Changes to Your App’s Settings - 处理偏好设置的改变</h3><p>如果你的应用程序含有被设置应用程序管理的设置选项，你应该监测<code>NSUserDefaultsDidChangeNotification</code>通知，因为用户可以改变这些设置当你的应用程序被挂起或在后台。你可以使用这个通知来响应并处理在这些设置上的重要改变。</p>
<p>一旦收到<code>NSUserDefaultsDidChangeNotification</code>通知，你的应用程序应该重新加载任何相关的设置，如果需要，恰当地重置用户界面。</p>
<h2 id="应用程序在后台时做什么"><a href="#应用程序在后台时做什么" class="headerlink" title="应用程序在后台时做什么"></a>应用程序在后台时做什么</h2><p>当应用程序从前台转为后台执行时，使用你的代理对象的<code>applicationDidEnterBackground:</code>方法来做：</p>
<ul>
<li>准备应用程序的照片。当你的<code>applicationDidEnterBackground:</code>返回时，系统会对你的应用程序的用户界面拍照并用这个照片来做过度动画。如果你的应用程序里的视图包含敏感信息，你应该在<code>applicationDidEnterBackground:</code>返回之前隐藏或更改这些视图。</li>
<li>保存任何应用程序状态的相关信息。在进入后台之前，你的应用程序应该已经保存好了所有重要的用户数据。使用转换到后台来保存应用程序状态的最后一分钟更改。</li>
</ul>
<p>你的应用程序代理对象的<code>applicationDidEnterBackground:</code>方法大约有5分钟的时间来结束任何任务并返回。实际上，这个方法应该可能快的返回。如果这个方法没有在时间耗尽前返回，你的应用程序将会被终止并被移出内存。如果你仍然需要更多的时间来执行任务，调用<code>beginBackgroundTaskWithExpirationHandler:</code>方法来请求后台执行时间，然后在一个次要线程里开始任何长时任务。不管你有没有开始一个后台任务，<code>applicationDidEnterBackground:</code>方法都会在5分钟内退出。</p>
<p><strong>提示:</strong> 除了调用<code>applicationDidEnterBackground:</code>方法外，系统还会发送<code>UIApplicationDidEnterBackgroundNotification</code>通知。你可以使用这个通知将清理任务分发给应用程序里的其它对象。</p>
<h3 id="The-Background-Transition-Cycle-后台转换周期"><a href="#The-Background-Transition-Cycle-后台转换周期" class="headerlink" title="The Background Transition Cycle - 后台转换周期"></a>The Background Transition Cycle - 后台转换周期</h3><p>When the user presses the Home button, presses the Sleep/Wake button, or the system launches another app, the foreground app transitions to the inactive state and then to the background state. These transitions result in calls to the app delegate’s <code>applicationWillResignActive:</code> and <code>applicationDidEnterBackground:</code> methods, as shown in Figure 4-5. After returning from the <code>applicationDidEnterBackground:</code> method, most apps move to the suspended state shortly afterward. Apps that request specific background tasks (such as playing music) or that request a little extra execution time from the system may continue to run for a while longer.</p>
<p>当用户按下Home键，按下睡眠或唤醒按钮，或者系统启动了另一个应用程序，运行在前台的应用程序会转换为非活动状态然后进入后台。这些状态转换会导致调用<code>applicationWillResignActive:</code> 和 <code>applicationDidEnterBackground:</code>方法，如下图所示。从<code>applicationDidEnterBackground：</code>方法返回后，大多数应用程序不久之后就会转换到挂起状态。 请求特定后台任务（如播放音乐）或从系统请求一点额外执行时间的应用程序可能会持续运行一段时间。</p>
<img src="https://raw.githubusercontent.com/apple272487813/apple272487813.github.io/master/images/application_life_cycle/app_bg_life_cycle.png" style="zoom:50%"/>



<h3 id="Prepare-for-the-App-Snapshot-准备应用程序快照"><a href="#Prepare-for-the-App-Snapshot-准备应用程序快照" class="headerlink" title="Prepare for the App Snapshot - 准备应用程序快照"></a>Prepare for the App Snapshot - 准备应用程序快照</h3><p>系统在应用程序代理对象<code>applicationDidEnterBackground:</code>方法返回的不久之前，对应用程序的窗口进行快照。相似的，当应用程序被唤醒执行后台任务时，系统会对应用程序进行一次新的反应改变的快照。</p>
<p>如果在进入后台更改视图时，可以调用主视图的<code>snapshotViewAfterScreenUpdates：</code>方法来强制执行这些更改。在一个视图上调用<code>setNeedsDisplay</code>方法对快照是无效的，因为快照发生在下一个绘制周期之前。调用值为“YES”的<code>snapshotViewAfterScreenUpdates：</code>方法将立即使用机器的底层缓冲区更新快照。</p>
<h3 id="Reduce-Your-Memory-Footprint"><a href="#Reduce-Your-Memory-Footprint" class="headerlink" title="Reduce Your Memory Footprint"></a>Reduce Your Memory Footprint</h3><p>每个应用程序应该在进入后台时释放尽可能多的内存。 系统尝试尽可能多地在内存中保留应用程序，但是当内存不足时，会终止挂起的应用程序以回收该内存。 在后台消耗大量内存的应用程序是第一个要终止的应用程序。</p>
<p>实际上，你的应用程序应该在不再需要的时候删除对对象的强引用。 删除强引用使编译器能够立即释放对象，以便可以回收对应的内存。 但是，如果要缓存某些对象以提高性能，则可以等到应用程序转换到后台再删除对它们的引用。</p>
<p>应该尽快删除强引用的对象的一些示例包括：</p>
<ul>
<li>你创建的图像对象。</li>
<li>可以从磁盘重新加载的大型媒体或数据文件</li>
<li>您的应用程序不需要的任何稍后可以重新创建其他对象。</li>
</ul>
<p>为了帮助你减少应用程序的内存占用空间，系统会自动清除在应用程序移动到后台时代表应用程序分配的数据。</p>
<ul>
<li>系统清除所有Core Animation层的后备存储。 此功能不会从应用程序的图层对象中删除内存，也不会更改当前图层属性。 它只是防止这些图层的内容出现在屏幕上，这表明应用程序在后台应该不会发生。</li>
<li>它删除任何系统对缓存图像的引用。</li>
<li>它删除了对其他系统管理的数据高速缓存的强引用。</li>
</ul>
<hr>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2015-09-01T16:00:00.000Z" title="2015/9/2 上午12:00:00">2015-09-02</time>发表</span><span class="level-item"><a class="link-muted" href="/categories/iOS/">iOS</a></span><span class="level-item">10 分钟读完 (大约1507个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2015/09/02/ios-property/">属性修饰符分析</a></h1><div class="content"><h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h3><hr>
<h5 id="atomic-amp-nonatomic"><a href="#atomic-amp-nonatomic" class="headerlink" title="atomic &amp; nonatomic"></a>atomic &amp; nonatomic</h5><p>决定编译器生成的setter/getter是否为原子操作 。<br>atomic是Objc使用的一种线程保护技术，防止在某个操作未完成时被另外一个线程操作，造成数据错误。然而这种多线程安全机制对资源的占用很大，在iPhone等小型设备中，除非需要使用多线程之间通讯编程，采用这种技术需要慎重考量。<br>一般情况下，使用nonatomic来修饰成员变量，存取器直接返回一个值，而不需要管当不同的线程同时访问时会发生什么。</p>
<h5 id="readwrite-amp-readonly"><a href="#readwrite-amp-readonly" class="headerlink" title="readwrite &amp; readonly"></a>readwrite &amp; readonly</h5><p>  任何属性都可以声明为readwrite或readonly，且默认设置为readwrite 。<br>  将一个属性声明为readwrite时，编译器将会为这个属性生成setter和getter。<br>  将一个属性生命为readonly时，编译器将只会生成getter。</p>
<h5 id="assign"><a href="#assign" class="headerlink" title="assign"></a>assign</h5><p>   直接赋值，不更改引用计数，一般用于基础数据类型和C语言类型数据。</p>
<h5 id="retain"><a href="#retain" class="headerlink" title="retain"></a>retain</h5><p>   释放旧对象，并使传入的新对象引用计数+1。<br>   此属性只能用于NSObject及其子类，而不能用于Core Foundation（因为其没有使用引用计数，需要另外使用CFRetain和CFRelease来进行CF的内存管理）。</p>
<h5 id="strong"><a href="#strong" class="headerlink" title="strong"></a>strong</h5><p>   释放旧对象，并使传入的新对象引用计数+1。<br>   在ARC下，strong为对象类型属性声明时的默认值。</p>
<h5 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h5><p>   创建一个引用计数为1的新对象，这个新对象是传入对象的拷贝。<br>   会拷贝传入的对象（即创建一个引用计数为1的新对象，但是内容与传入对象相同），并把新对象赋值给实例变量。</p>
<h5 id="weak"><a href="#weak" class="headerlink" title="weak"></a>weak</h5><p>  弱引用，要求不保留传入的属性（既不会使传入的对象引用计数+1）。<br>  类似于assign，但与assign不同的是，当它们指向的对象被释放后，weak会被自动置为nil，而assign则不会。</p>
<hr>
<h3 id="进阶问题"><a href="#进阶问题" class="headerlink" title="进阶问题"></a>进阶问题</h3><hr>
<h5 id="strong-amp-weak"><a href="#strong-amp-weak" class="headerlink" title="strong &amp; weak"></a>strong &amp; weak</h5><p>这里采用 stack overflow 上的一个对强/弱引用的解释</p>
<blockquote>
<p>如果将对象想象成一只想要逃跑(be deallocated)的狗的话。</p>
<p>强引用就像是拴住狗的绳子。只要你还还牵着拴住狗的绳子，狗就逃跑不了。如果有五个人都将绳子拴住了狗，那么除非五个人都解开了绳子，否则狗就不可能逃跑。</p>
<p>而弱引用，就像一个小孩子指着狗说：看，那里有一直狗。只要狗仍被狗绳拴着，小孩就还能看见狗，他们仍会指着它。然而一但狗绳被解开，狗就会逃跑而不管多少小孩子指着它。</p>
</blockquote>
<h5 id="copy-amp-retain"><a href="#copy-amp-retain" class="headerlink" title="copy &amp; retain"></a>copy &amp; retain</h5><p>copy实际上是建立了一个新的相同的对象，而retain是将传入对象的引用计数+1 。</p>
<h5 id="深拷贝-amp-浅拷贝"><a href="#深拷贝-amp-浅拷贝" class="headerlink" title="深拷贝 &amp; 浅拷贝"></a>深拷贝 &amp; 浅拷贝</h5><p>浅拷贝就是对内存地址的复制，让目标对象指针和源对象指向同一片内存空间 。浅拷贝只是对对象的简单拷贝，让几个对象共用一片内存，当内存销毁的时候，指向这片内存的几个指针需要重新定义才可以使用，要不然会成为野指针。<br>在iOS中，使用retain修饰的属性变量，就是一种浅拷贝。它既让几个指针共用同一片内存空间，又可以在release时由于计数的存在，不会轻易的销毁内存，达到更加简单使用的目的。<br>深拷贝是指拷贝对象的具体内容，而内存地址是自主分配的，拷贝结束之后，两个对象虽然存的值是相同的，但是内存地址不一样，两个对象也互不影响，互不干涉。<br>值得注意的是，对可变对象如NSMutableArray等无论是copy还是mutableCopy都是进行了深拷贝。</p>
<h5 id="property-amp-synthesize"><a href="#property-amp-synthesize" class="headerlink" title="@property &amp; @synthesize"></a>@property &amp; @synthesize</h5><p>如果我们希望使用默认的实例变量命名方式，那么我们在.m文件中就不需要使用@synthesize声明，系统会帮我们自动完成。如果我们希望自己命名实例变量命，那么我们就使用@synthesize显式声明我们希望的实例变量名 。</p>
<h5 id="block作为实例变量为何要用copy修饰？"><a href="#block作为实例变量为何要用copy修饰？" class="headerlink" title="block作为实例变量为何要用copy修饰？"></a>block作为实例变量为何要用copy修饰？</h5><p>因为block如果在栈上的话，其所属的变量作用域结束，该block就被释放掉，block中的__block变量也同时被释放掉。为了解决栈块在其变量作用域结束之后被释放掉的问题，我们就需要把block复制到堆中。</p>
<h5 id="为什么NSString、NSDictionary、NSArray要使用copy修饰？"><a href="#为什么NSString、NSDictionary、NSArray要使用copy修饰？" class="headerlink" title="为什么NSString、NSDictionary、NSArray要使用copy修饰？"></a>为什么NSString、NSDictionary、NSArray要使用copy修饰？</h5><p>对于NSString、NSDictionary、NSArray等经常使用copy关键字，是因为它们有对应的可变类型：NSMutableString、NSMutableDictionary、NSMutableArray，它们之间可能进行赋值操作，为确保对象中的字符串值不会无意间变动，应该在设置新属性时拷贝一份。</p>
<h5 id="weak、copy、strong、assgin分别用在什么地方？"><a href="#weak、copy、strong、assgin分别用在什么地方？" class="headerlink" title="weak、copy、strong、assgin分别用在什么地方？"></a>weak、copy、strong、assgin分别用在什么地方？</h5><p>什么情况下会使用weak关键字？</p>
<ul>
<li>在ARC中，出现循环引用的时候，会使用weak关键字。</li>
<li>自身已经对它进行了一次强引用，没有必要再强调引用一次。</li>
</ul>
<p>assgin适用于基本的数据类型，比如NSInteger、BOOL等。</p>
<p>NSString、NSArray、NSDictionary等经常使用copy关键字，是因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary；</p>
<p>除了上面的三种情况，剩下的就使用strong来进行修饰。</p>
<hr>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/page/10/">上一页</a></div><div class="pagination-next is-invisible is-hidden-mobile"><a href="/page/12/">下一页</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/">1</a></li><li><span class="pagination-ellipsis">&hellip;</span></li><li><a class="pagination-link" href="/page/10/">10</a></li><li><a class="pagination-link is-current" href="/page/11/">11</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="LeiTech"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">LeiTech</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>China</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">55</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">10</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">3</p></a></div></div></nav><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="/"><i class="fab fa-github"></i></a></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/CS/"><span class="level-start"><span class="level-item">CS</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/Git/"><span class="level-start"><span class="level-item">Git</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/JavaScript/"><span class="level-start"><span class="level-item">JavaScript</span></span><span class="level-end"><span class="level-item tag">19</span></span></a></li><li><a class="level is-mobile" href="/categories/Mac/"><span class="level-start"><span class="level-item">Mac</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/"><span class="level-start"><span class="level-item">Python</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/TypeScript/"><span class="level-start"><span class="level-item">TypeScript</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Vue/"><span class="level-start"><span class="level-item">Vue</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Web/"><span class="level-start"><span class="level-item">Web</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/iOS/"><span class="level-start"><span class="level-item">iOS</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"><span class="level-start"><span class="level-item">大前端</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li></ul></div></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2021/08/"><span class="level-start"><span class="level-item">八月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/04/"><span class="level-start"><span class="level-item">四月 2021</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/03/"><span class="level-start"><span class="level-item">三月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/01/"><span class="level-start"><span class="level-item">一月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/12/"><span class="level-start"><span class="level-item">十二月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/06/"><span class="level-start"><span class="level-item">六月 2020</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/09/"><span class="level-start"><span class="level-item">九月 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/06/"><span class="level-start"><span class="level-item">六月 2019</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/04/"><span class="level-start"><span class="level-item">四月 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/03/"><span class="level-start"><span class="level-item">三月 2019</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/02/"><span class="level-start"><span class="level-item">二月 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/12/"><span class="level-start"><span class="level-item">十二月 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/09/"><span class="level-start"><span class="level-item">九月 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/07/"><span class="level-start"><span class="level-item">七月 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/06/"><span class="level-start"><span class="level-item">六月 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/05/"><span class="level-start"><span class="level-item">五月 2018</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/04/"><span class="level-start"><span class="level-item">四月 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/03/"><span class="level-start"><span class="level-item">三月 2018</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/02/"><span class="level-start"><span class="level-item">二月 2018</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/01/"><span class="level-start"><span class="level-item">一月 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/05/"><span class="level-start"><span class="level-item">五月 2017</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/04/"><span class="level-start"><span class="level-item">四月 2017</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2016/06/"><span class="level-start"><span class="level-item">六月 2016</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2016/04/"><span class="level-start"><span class="level-item">四月 2016</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2016/03/"><span class="level-start"><span class="level-item">三月 2016</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2016/02/"><span class="level-start"><span class="level-item">二月 2016</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2016/01/"><span class="level-start"><span class="level-item">一月 2016</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/archives/2015/12/"><span class="level-start"><span class="level-item">十二月 2015</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2015/11/"><span class="level-start"><span class="level-item">十一月 2015</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2015/10/"><span class="level-start"><span class="level-item">十月 2015</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2015/09/"><span class="level-start"><span class="level-item">九月 2015</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Git/"><span class="tag">Git</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/JavaScript/"><span class="tag">JavaScript</span><span class="tag">12</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Web/"><span class="tag">Web</span><span class="tag">3</span></a></div></div></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><!--!--></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="关于代码的碎碎念" height="28"></a><p class="is-size-7"><span>&copy; 2021 Y2hlbmdsZWk=</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>