<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>分类: iOS - 关于代码的碎碎念</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="LeiTech"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="LeiTech"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="ODQ4NjUwMTI5QHFxLmNvbQ&amp;#x3D;&amp;#x3D;"><meta property="og:type" content="blog"><meta property="og:title" content="关于代码的碎碎念"><meta property="og:url" content="https://cocoalei.github.io/blogs"><meta property="og:site_name" content="关于代码的碎碎念"><meta property="og:description" content="ODQ4NjUwMTI5QHFxLmNvbQ&amp;#x3D;&amp;#x3D;"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://cocoalei.github.io/img/og_image.png"><meta property="article:author" content="Y2hlbmdsZWk="><meta property="article:tag" content="iOS,HTML,CSS,JavaScript,Vue.js"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://cocoalei.github.io/blogs"},"headline":"关于代码的碎碎念","image":["https://cocoalei.github.io/img/og_image.png"],"author":{"@type":"Person","name":"Y2hlbmdsZWk="},"publisher":{"@type":"Organization","name":"关于代码的碎碎念","logo":{"@type":"ImageObject","url":"https://cocoalei.github.io/img/logo.svg"}},"description":"ODQ4NjUwMTI5QHFxLmNvbQ&#x3D;&#x3D;"}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-dark.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.4.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="关于代码的碎碎念" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/categories">分类</a></li><li class="is-active"><a href="#" aria-current="page">iOS</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2017-04-05T16:00:00.000Z" title="2017/4/6 上午12:00:00">2017-04-06</time>发表</span><span class="level-item"><a class="link-muted" href="/categories/iOS/">iOS</a></span><span class="level-item">12 分钟读完 (大约1871个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2017/04/06/tableview-optimize/">iOS 中 UITableView 的优化</a></h1><div class="content"><h1 id="UITableView的性能优化"><a href="#UITableView的性能优化" class="headerlink" title="UITableView的性能优化"></a>UITableView的性能优化</h1><p>UITableView 是 iOS 开发中经常会用到的一种控件，复杂的 UITablView 如果不进行优化，会严重影响用户体验。那么我们可以从那些方面如后来对其进行优化呢？</p>
<p>首先 我们使用 UITableView 的大致流程如下 ：</p>
<ul>
<li>获取将要在 UITableView 中显示的数据；</li>
<li>把数据进行处理，封装为相应的 Model，并存入数组</li>
<li>UITableView 调用 <code>reloadData</code> 刷新数据</li>
<li>在代理方法中获取或创建 UITableViewCell ，并将数据赋值给它</li>
<li>UITableViewCell 根据拿到的数据对其中的 UI 控件进行赋值</li>
<li>在代理方法中计算 UITableViewCell 的行高</li>
<li>UITableViewCell 布局子控件</li>
</ul>
<p>我们的优化就是针对这几个步骤来进行的。</p>
<h2 id="针对-UITableView-的数据处理的优化"><a href="#针对-UITableView-的数据处理的优化" class="headerlink" title="针对 UITableView 的数据处理的优化"></a>针对 UITableView 的数据处理的优化</h2><p>需要显示在 UITableView 中的数据一般是通过网络请求从服务器获得的数据，我们需要发起网络请求获得数据后进行处理，以使其能够适合我们要显示的 Cell。然而网络请求和数据处理都是比较耗时的操作，将它们在后台异步线程中进行处理完成后，再来刷新 UITableView 会使得显示更加流畅。</p>
<h2 id="关于-UITableView-的重用机制"><a href="#关于-UITableView-的重用机制" class="headerlink" title="关于 UITableView 的重用机制"></a>关于 UITableView 的重用机制</h2><p>UITableView 只会创建在当前屏幕显示或多一点的 UITableViewCell，其它的都是从中取出来重用的。每当 Cell 不再屏幕中显示时，系统将其放入一个集合中，一般称为重用池。当要显示某一位置的 Cell 时，会优先去重用池中取，如果重用池中存在，则直接拿来显示，如果没有才会创建。这极大的减少了内存的开销。</p>
<p>UITableView 最主要的两个回调方法是 <code>tableView:cellForRowAtIndexPath:</code> 和 <code>tableView:heightForRowAtIndexPath:</code> 。在显示 Cell 时，UITableView 显示多次调用  <code>tableView:heightForRowAtIndexPath:</code>  以确定 contentSize 及 Cell 的位置，然后才会调用  <code>tableView:cellForRowAtIndexPath:</code> ，来显示当前屏幕上的 Cell。</p>
<p>UITableView 的显示优化实际上主要就是针对这两个回调方法的优化。</p>
<h3 id="UITableViewCell-高度计算"><a href="#UITableViewCell-高度计算" class="headerlink" title="UITableViewCell 高度计算"></a>UITableViewCell 高度计算</h3><p>固定高度的 Cell 的显示自不必说，直接设置固定的高度即可：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.tableView.rowHeight	=	HEIGHT_OF_CELL;</span><br></pre></td></tr></table></figure>

<p>而对于动态高度的 Cell 来说，则需要在 <code>tableView:heightForRowAtIndexPath:</code>  方法中给出相应的高度。动态高度的计算依赖于要显示在 Cell 中的数据内容，我们可以直接在处理数据时就进行高度的计算，而不是在 <code>tableView:heightForRowAtIndexPath:</code> 方法中进行计算，这也会节省一些时间。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath &#123;</span><br><span class="line">    DataModel	*model	=	self.dataSourceList[indexPath.row];</span><br><span class="line">    returen model.heightOfCell;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果不提前进行 Cell 高度的计算，将已经计算好的高度进行缓存，避免重复进行计算也是一个可以优化的地方。</p>
<h3 id="UITableViewCell-的内容布局"><a href="#UITableViewCell-的内容布局" class="headerlink" title="UITableViewCell 的内容布局"></a>UITableViewCell 的内容布局</h3><p>对象的调整也经常是消耗 CPU 资源的地方。这里特别说一下 CALayer：CALayer 内部并没有属性，当调用属性方法时，它内部是通过运行时 resolveInstanceMethod 为对象临时添加一个方法，并把对应属性值保存到内部的一个 Dictionary 里，同时还会通知 delegate、创建动画等等，非常消耗资源。UIView 的关于显示相关的属性（比如 frame/bounds/transform）等实际上都是 CALayer 属性映射来的，所以对 UIView 的这些属性进行调整时，消耗的资源要远大于一般的属性。对此你在应用中，应该尽量减少不必要的属性修改。</p>
<p>对于布局内容不固定的 Cell 来说，根据要显示的数据内容进行内容的布局即可，如果要进行布局的控件很多，则会极大的消耗系统的资源。</p>
<p>而实际上我们 Cell 添加控件时，实质上都是系统调用底层的接口进行绘制，因此对于控件较多的动态 Cell 来说，我们可以直接进行绘制，提高效率。</p>
<p>直接在 <code>drawRect</code> 方法中进行绘制：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (void)drawRect &#123;</span><br><span class="line">   // </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或将绘制好的内容作为图片返回后直接显示 ：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (UIImage *)draw &#123;</span><br><span class="line">    // 内容绘制</span><br><span class="line">    CGContextRef context	=	UIGraphicsGetCurrentContext();</span><br><span class="line">    ···</span><br><span class="line">    // 需要注意的是，绘制是比较耗时的操作，放入异步后台线程进行任务比较好</span><br><span class="line">    UIImage *contentImage	=	UIGraphicsGetImageFromCurrentImageContext();</span><br><span class="line">    UIGraphicsEndImageContext();</span><br><span class="line">    return contentImage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="异步处理耗时操作"><a href="#异步处理耗时操作" class="headerlink" title="异步处理耗时操作"></a>异步处理耗时操作</h2><p>获取数据并对其进新处理等耗时操作，应该放入后台线程异步处理，等到数据完成处理后再通知主线程刷新 UI。</p>
<p>另外，UIKit 和 CoreAnimation 相关的操作必须在主线程中进行，其它诸如图像的绘制等则应该在后台线程异步执行。</p>
<p>在 Cell 上添加系统控件时，实质上系统都需要调用底层的接口进行绘制，当 Cell 上有大量的控件需要添加时，对资源的开销也会很大，直接绘制将会大大地提高效率。在遇到需要显示复杂的 UITableViewCell 时，使用自定义绘制会更好。</p>
<h2 id="避免频繁的创建对象"><a href="#避免频繁的创建对象" class="headerlink" title="避免频繁的创建对象"></a>避免频繁的创建对象</h2><p>对象的创建会产生内存分配、属性调整等操作，频繁大量的创建对象会消耗大量的资源和时间，应尽量避免频繁大量的创建对象。应该使用轻量对象来代替重量对象，或将对象创建后进行缓存。</p>
<h2 id="减少对象的属性赋值操作"><a href="#减少对象的属性赋值操作" class="headerlink" title="减少对象的属性赋值操作"></a>减少对象的属性赋值操作</h2><p>对象的调整也经常是消耗 CPU 资源的地方。这里特别说一下 CALayer：CALayer 内部并没有属性，当调用属性方法时，它内部是通过运行时 resolveInstanceMethod 为对象临时添加一个方法，并把对应属性值保存到内部的一个 Dictionary 里，同时还会通知 delegate、创建动画等等，非常消耗资源。UIView 的关于显示相关的属性（比如 frame/bounds/transform）等实际上都是 CALayer 属性映射来的，所以对 UIView 的这些属性进行调整时，消耗的资源要远大于一般的属性。对此你在应用中，应该尽量减少不必要的属性修改。</p>
<h2 id="简化视图结构"><a href="#简化视图结构" class="headerlink" title="简化视图结构"></a>简化视图结构</h2><p>GPU在绘制图像前，会把重叠的视图进行混合，视图结构越复杂，这个操作就越耗时，如果存在透明视图，混合过程会更加复杂。</p>
<h2 id="减少离屏渲染"><a href="#减少离屏渲染" class="headerlink" title="减少离屏渲染"></a>减少离屏渲染</h2><p>下面的情况或操作会引发离屏渲染：</p>
<ul>
<li>为图层设置遮罩（layer.mask）</li>
<li>将图层的 layer.masksToBounds / view.clipsToBounds 属性设置为 true</li>
<li>将图层 layer.allowsGroupOpacity 属性设置为 YES 和 layer.opacity 小于1.0</li>
<li>为图层设置阴影（layer.shadow *）。</li>
<li>为图层设置 layer.shouldRasterize = true</li>
<li>具有 layer.cornerRadius，layer.edgeAntialiasingMask，layer.allowsEdgeAntialiasing 的图层</li>
<li>文本（任何种类，包括UILabel，CATextLayer，Core Text等）。</li>
<li>使用 CGContext 在 drawRect : 方法中绘制大部分情况下会导致离屏渲染，甚至仅仅是一个空的实现</li>
</ul>
<h2 id="按需加载"><a href="#按需加载" class="headerlink" title="按需加载"></a>按需加载</h2></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2016-02-04T16:00:00.000Z" title="2016/2/5 上午12:00:00">2016-02-05</time>发表</span><span class="level-item"><a class="link-muted" href="/categories/iOS/">iOS</a></span><span class="level-item">30 分钟读完 (大约4534个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2016/02/05/iOS-Design-Pattern/">iOS 与设计模式</a></h1><div class="content"><h1 id="iOS-与-设计模式"><a href="#iOS-与-设计模式" class="headerlink" title="iOS 与 设计模式"></a>iOS 与 设计模式</h1><p>设计模式 (Design Pattern) 是一套被反复使用、多数人知晓、经过分类的、代码设计经验的总结。</p>
<p>我们使用设计模式的目的是为了提高代码可重用性、让代码更容易被理解、保证代码可靠性，使人们可以更加简单方便地复用成功的设计和体系结构。</p>
<h2 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h2><h3 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h3><p>开闭原则就是说模块应该对扩展开放，而对修改关闭，即模块应该在尽量不修改原来代码的情况下进行扩展。</p>
<p>任何软件都需要面临一个很重要的问题，就是需求会随着时间的推移而发生变化。当软件系统需要面对新的需求时，应该尽量保证系统的设计框架是稳定的。如果一个软件符合开闭原则，那么就可以非常方便的对系统进行扩展并无需修改现有代码，使得系统在拥有适应性和灵活性的同时具备较好的稳定性和延续性。</p>
<p>为了满足开闭原则，需要对系统进行抽象化设计，抽象化是开闭原则的关键。为系统定义一个相对稳定的抽象层，而将不同的实现行为移至具体的实现层中完成。在很多面向对象语言中都提供了接口、抽象类等机制，可以通过它们定义系统的抽象层，再通过具体类来进行扩展。如果要修改系统的行为，无须对抽象层进行任何改动，只需要增加新的具体类来实现新的业务功能即可，这就实现了在不修改已有代码的基础上扩展系统的功能，达到开闭原则的要求。</p>
<h3 id="里氏代换原则"><a href="#里氏代换原则" class="headerlink" title="里氏代换原则"></a>里氏代换原则</h3><p>里氏代换原则严格表述是这样的 ：如果每一个类型为 S 的对象 o1，都有类型为 T 的对象 o2，使得以 T 定义的所有程序 P 在所有的对象 o1 代换 o2 时，程序的 P 的行为没有变化，那么类型 S 就是 类型 T 的子类型。即所有引用父类的地方必须能透明地使用其子类的对象。</p>
<p>里氏代换原则是实现开闭原则的重要方式之一，由于使用父类对象的地方都可以使用子类对象，因此在程序中尽量使用父类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象。</p>
<p>里氏代换原则需要注意的问题 ：</p>
<ul>
<li>子类的所有方法必须在父类中声明，或子类必须实现父类中声明的所有方法。为了保证系统的可扩展性，在程序中通常使用父类来进行定义，如果一个方法只存在子类中，在父类中不提供相应的声明，则无法在以父类定义的对象中使用该方法。</li>
<li>应该尽量把父类设计成抽象类或接口，让子类继承父类或实现接口，并实现在父类中声明的方法，运行时，子类实例替换父类实例。</li>
</ul>
<p>在依照里氏代换原则实现的软件中将一个父类对象替换成它的子类对象，程序将不会产生任何错误和异常，反之则不成立。</p>
<h3 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h3><p>依赖倒置原则，即抽象应该不依赖于细节，细节应该依赖于抽象，换言之，要针对接口编程，而不是针对实现编程。</p>
<p>依赖倒置原则要求我们在程序代码中传递参数时或在关联关系中，尽量引用层次高的抽象层类，即使用接口和抽象类进行变量类型声明、参数类型声明、方法返回类型声明，以及数据类型的转换等，而不要用具体类去做这些事情。为了确保该原则的应用，一个具体类应该只实现接口或抽象类中声明过的方法，而不要给出多余的方法。</p>
<p>在实现依赖倒置原则时，我们需要针对抽象层进行编程，而将具体类的对象通过依赖注入的方法注入到其它对象中，依赖注入是指当一个对象要与其他对象发生依赖关系时，通过抽象来注入所依赖的对象。常用的注入方式包括 ：构造注入、设值注入和接口注入。构造注入是通过构造函数来传入具体类的对象，设值注入是通过 <code>setter</code> 方法来传入具体类的对象，而接口注入是指通过在接口中声明的业务方法来传入具体类的对象。</p>
<p>在大多数情况下，以上三种设计原则一同出现，开闭原则是目标，里氏代换原则是基础，依赖倒转原则时手段。</p>
<h3 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h3><p>接口隔离原则，使用多个专门的接口，而不是使用单一的接口，即客户端不应该依赖那些它不需要的接口。每一个接口应该承担相对独立的角色，不干不该干的事情，该干的事情都要干。</p>
<p>这里的接口往往有两种不同的含义，一种是指一个类型所具有的方特征的集合，仅仅是一种逻辑上的抽象；另外一种是指某种语言的具体的接口定义，有严格的定义和结构。</p>
<ul>
<li>当把接口理解成一个类型所提供的所有方法特征的集合的时候，这就是一种逻辑上的概念，接口的划分将直接带来类型的划分。可以把接口理解成角色，一个接口只能代表一个角色，每个角色都有它特定的一个接口，此时，这个原则可称为角色隔离原则。</li>
<li>如果把接口理解成狭义的特定语言的接口，那么接口隔离原则是指接口仅仅提供客户端需要的行为，客户端不需要的行为则隐藏，应该为客户端提供尽可能小的单独的接口。在面向对象编程语言中，实现一个接口就需要实现该接口中定义的所有方法，因此大的总接口使用起来不一定很方便，为了使接口的指责单一，需要将大接口中的方法根据其指责不同分别放在不同的小接口中，确保每个接口使用起来都较为方便。接口应该尽量细化，同时接口中的方法应该尽量少。</li>
</ul>
<h3 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h3><p>单一职责原则是最简单的面向对象设计原则，它用于控制类的粒度大小，即一个类只负责一个功能领域中的相应职责，或者说 ：就一个类而言，应该只有一个引起它变化的原因。</p>
<p>单一职责原则是实现高内聚、低耦合的知道方针，它是最简单但又最难运用的原则。</p>
<h3 id="最少知识法则"><a href="#最少知识法则" class="headerlink" title="最少知识法则"></a>最少知识法则</h3><p>也叫迪米特法则，即一个软件实体应当尽可能少地与其它实体发生相互作用。</p>
<p>迪米特法则要求我们在设计系统时，应该尽量减少对象之间的交互，如果两个对象之间不必彼此直接通信，那么这两个对象就不应该发生任何直接的相互作用，如果其中的一个对象需要调用另一个对象的某一个方法的话，可以通过第三者转发这个调用。</p>
<h2 id="iOS-中的设计模式"><a href="#iOS-中的设计模式" class="headerlink" title="iOS 中的设计模式"></a>iOS 中的设计模式</h2><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>单例模式是一种常见的设计模式。在它的核心结构中只包含一个被称为单例的特殊类。通过单例模式可以保证系统中，应用该模式的类一个类只有一个实例。</p>
<p>我们为什么需要单例模式呢？这是因为，对于系统中的某些类来说，只有一个实例很重要。比如如果不使用机制对窗口对象唯一化，将弹出多个窗口，如果这些窗口现实的内容完全一致，则是重复对象，浪费资源。如果这些窗口现实的内容不一致，则意味着某一瞬间系统有多个状态，与实际不符。</p>
<p>如何保证一个类只有一个实例且这个实例易于被访问呢？一般的解决方法是让类自身负责保存它的唯一实例。这个类可以保证没有其它实例被创建，并且它可以提供一个访问该实例的方法。</p>
<h4 id="单例模式的优点"><a href="#单例模式的优点" class="headerlink" title="单例模式的优点"></a>单例模式的优点</h4><ul>
<li>单例模式会阻止其它对象实例化其自己的单例对象的副本，从而确保所有对象都访问唯一实例。</li>
<li>因为类控制了实例化过程，所以类可以灵活更改实例化过程。</li>
</ul>
<h4 id="单例模式的缺点"><a href="#单例模式的缺点" class="headerlink" title="单例模式的缺点"></a>单例模式的缺点</h4><ul>
<li>虽然数量很少，但是每次对象请求引用时都要检查是否存在类的实例，将仍然需要一些开销。</li>
<li>可能的开发混淆。</li>
<li>不能解决删除单个对象的问题。</li>
</ul>
<h4 id="单例模式的代码实现"><a href="#单例模式的代码实现" class="headerlink" title="单例模式的代码实现"></a>单例模式的代码实现</h4><p>Objective-C :</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+ (Singleton *)sharedInstance &#123;</span><br><span class="line">	static dispatch_once_t onceToken;</span><br><span class="line">    static Singleton *sharedInstance = nil;</span><br><span class="line">  	dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">    	sharedInstance	=	[[self alloc] init];</span><br><span class="line">  &#125;);</span><br><span class="line">  	return sharedInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Swift :</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">let</span> sharedInstance	<span class="operator">=</span>	<span class="type">Singleton</span>()</span><br><span class="line">  	<span class="keyword">private</span> <span class="function"><span class="keyword">init</span>()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p>代理模式也是一种常见的设计模式，为其它对象提供一种代理以控制对这个对象的访问。</p>
<h5 id="代理模式的优点-："><a href="#代理模式的优点-：" class="headerlink" title="代理模式的优点 ："></a>代理模式的优点 ：</h5><ul>
<li>真实的角色就是实现实际的业务逻辑，不用关心其它非本职责的事物，通过后期的代理完成一件事物，附带的结果就是编程简洁清晰。</li>
<li>代理对象在客户端和目标对象之间起到中介作用</li>
<li>高扩展性</li>
</ul>
<p>iOS 中的代理模式通过 <code>@protocol</code> 方式实现，用来传递事件或值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@protocol ObjectDelegate</span><br><span class="line">@required</span><br><span class="line">- (void)requiredImplementDelegateMethod;</span><br><span class="line">@optional</span><br><span class="line">- (void)optionalImplementDelegateMethod;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>一般使用 <code>weak</code> 关键字来修饰代理属性，这是为了便面形成循环引用。</p>
<h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>观察者模式也是 iOS 中常见的设计模式，观察者模式定义了一种一对多的依赖关系，一个或多个观察者对象同时监听某一个对象，当被观察者对象状态发生变化时，会通知所有观察者对象，至于观察者对象如何响应这个通知，则要看具体的实现。</p>
<p>在 iOS 中，观察者模式的实现具体表现为 ：通知机制 (Notification) 和 KVO 机制 (Kev-Value Observing)</p>
<h4 id="通知机制"><a href="#通知机制" class="headerlink" title="通知机制"></a>通知机制</h4><p>被观察者达到某些触发条件后，发送通知给它的观察者对象。</p>
<p>注册通知接收者 ：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[[NSNotificationCenter defaultCenter] addObserver:self									</span><br><span class="line">										 selector:@selector(respondNotificationMethod)</span><br><span class="line">											 name:@&quot;NotificationName&quot;</span><br><span class="line">										   object:nil];</span><br></pre></td></tr></table></figure>

<p>发布通知  ：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[[NSNotificationCenter defaultCenter] postNotificationName:@&quot;NotificationName&quot;</span><br><span class="line">													object:nil</span><br><span class="line">												  userInfo:@&#123;&#125;];</span><br></pre></td></tr></table></figure>

<p>在 iOS 9 之后，你不需要在观察者的销毁方法中注销观察者，但是在之前的 iOS 版本中，你必须在销毁方法中注销观察者。</p>
<h4 id="KVO-机制"><a href="#KVO-机制" class="headerlink" title="KVO 机制"></a>KVO 机制</h4><p>被观察的对象的属性变化时，发送通知给它的观察者对象。</p>
<p>KVO 机制的观察者对象观察的是对象的属性的变化，只有遵循 KVO 变更属性值的方式才会执行 KVO 的回调部分。</p>
<p>添加监听者 ：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[self.aProperty addObserver:self</span><br><span class="line">			     forKeyPath:@&quot;propertyName&quot;,</span><br><span class="line">					options:NSKeyValueObservingOptionNew | NSKeyValueObservingOld</span><br><span class="line">					context:nil];</span><br></pre></td></tr></table></figure>

<p>接收到属性变化通知时的回调 ：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (void)observeValueForKeyPath:(NSString *)keyPath</span><br><span class="line">					  ofObject:(id)object</span><br><span class="line">						change:(NSDictionary *)change</span><br><span class="line">					   context:(void *)context &#123;</span><br><span class="line">	// execute code					   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>iOS 通过 <code>Runtime</code> 实现 KVO 机制 ：</p>
<p>假设我们要观察对象 <code>Computer</code> 的 <code>name</code> 属性的变化，运行时 KVO 机制会动态的创建一个名为 <code>NSKVONotifying_Computer</code> 的新类，该类继承自 <code>Computer</code> 对象的本类，且 KVO 机制会重写 <code>NSKVONotifying_Computer</code> 的 <code>name</code> 属性的 <code>setter</code> 方法。这个重写的 <code>setter</code> 方法负责在调用 <code>Computer</code> 的 <code>setter</code> 方法的之前和之后，通知所有观察者 <code>name</code> 属性的更改情况。</p>
<p>在这个过程中，<code>Computer</code> 的 <code>isa</code> 指针被 KVO 机制修改为指向 <code>NSKVONotifying_Computer</code> 类，来实现当前类属性值改变的监听。</p>
<p>KVO 机制的键值观察通知依赖于 <code>NSObject</code> 的 <code>willChangeValueForKey:</code> 和 <code>didChangeValueForKey:</code> 两个方法。</p>
<h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>工厂模式是常用的实例化对象模式，是用工厂方式代替 <code>new</code> 操作的一种模式。</p>
<h4 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h4><p>简单工厂模式，又称静态工厂方法模式，是一种创建型模式，是由一个工厂对象决定创建出哪一种产品类的实例。</p>
<h5 id="简单工厂的优缺点"><a href="#简单工厂的优缺点" class="headerlink" title="简单工厂的优缺点"></a>简单工厂的优缺点</h5><ul>
<li>优点 ：简单工厂模式能够根据外界给定的信息，决定究竟应该创建哪个具体类的对象。明确区分了各自的指责和权利，有利于整个软件体系结构的优化。</li>
<li>缺点 ：工厂类集中了所有实例的创建逻辑，包含了过度的判断条件，维护起来不方便。</li>
</ul>
<h5 id="简单工厂的实现"><a href="#简单工厂的实现" class="headerlink" title="简单工厂的实现"></a>简单工厂的实现</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_ENUM(NSInteger, InstanceType) &#123;</span><br><span class="line">	InstanceType_001	=	0,</span><br><span class="line">  	InstanceType_002	=	1,</span><br><span class="line">  	...					=	...</span><br><span class="line">  	InstanceType_n		=	n-1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (id)getInstanceWithParameter:(InstanceType)someType &#123;</span><br><span class="line">	Switch (someType) &#123;</span><br><span class="line">      case : InstanceType_001</span><br><span class="line">        reture [self initInstance_001];</span><br><span class="line">      break;</span><br><span class="line">      ...</span><br><span class="line">      case : InstanceType_n</span><br><span class="line">        reture [self initInstance_n];</span><br><span class="line">      break;</span><br><span class="line">      default :</span><br><span class="line">      break;</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (id)initInstance_001 &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">  </span><br><span class="line">- (id)initInstance_n &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h4><p>工厂方法模式，又称多态性工厂模式。在工厂方法模式中，核心的工厂类不再负责所有的产品的创建，而是将具体创建的工作交给子类去做。该核心类成为一个抽象工厂的角色，仅负责给出工厂子类必须实现的接口，而不负责哪一个产品类应当被实例化这种细节。</p>
<p>工厂方法模式就是简单工厂模式的衍生，解决了许多简单工厂模式的问题。它在基类中建立一个抽象方法，子类可以通过改写这个方法来改变创建对象的具体过程。工厂方法模式让子类来决定如何创建对象，来达到封装的目的。</p>
<h5 id="工厂方法的优点"><a href="#工厂方法的优点" class="headerlink" title="工厂方法的优点"></a>工厂方法的优点</h5><ul>
<li>优点 ：<ul>
<li>子类提供挂钩。基类为工厂方法提供缺省实现，子类可以重写新的实现，也可以集成父类的实现，增加了灵活性。</li>
<li>屏蔽产品类。产品类的实现如何变化，调用者都不需要关心，只需要关心产品的接口，只要接口保持不变，系统中的上层模块就不会发生变化。</li>
<li>典型的解耦框架。高层模块只需要知道产品的抽象类，其它的实现类都不需要关心。</li>
<li>多态性，客户代码可以做到与特定应用无关，适用于任何实体类。</li>
</ul>
</li>
</ul>
<h4 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h4><p>抽象工厂模式提供一个接口，用于创建一个对象家族，而无需指定具体类。工厂方法只涉及到创建一个对象的情况，有时候我们需要一族对象。</p>
<p>抽象工厂模式是所有形态的工厂模式中最为抽象和最具一般性的一种形态。抽象工厂模式是指当有多个抽象角色时，使用的一种工厂模式。抽象工厂模式可以向客户端提供一个接口，使客户端在不必指定产品的具体的情况下，创建多个产品族中的产品对象。根据里氏替换原则，任何接受父类型的地方，都应当能够接受子类型。因此，实际上系统所需要的，仅仅是类型与这些抽象产品角色相同的一些实例，而不是这些抽象产品的实例。换言之，也就是这些抽象产品的具体子类的实例。工厂类负责创建抽象产品的具体子类的实例。</p>
<h5 id="抽象工厂的优点-缺点"><a href="#抽象工厂的优点-缺点" class="headerlink" title="抽象工厂的优点/缺点"></a>抽象工厂的优点/缺点</h5><ul>
<li>优点：<ul>
<li>抽象工厂模式隔离了具体类的生产，使得客户并不需要知道什么被创建。</li>
<li>当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。</li>
<li>增加新的具体工厂和产品族很方便，无须修改已有系统，符合“开闭原则”。</li>
</ul>
</li>
<li>缺点：增加新的产品等级结构很复杂，需要修改抽象工厂和所有的具体工厂类，对“开闭原则”的支持呈现倾斜性。</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2016-01-24T16:00:00.000Z" title="2016/1/25 上午12:00:00">2016-01-25</time>发表</span><span class="level-item"><a class="link-muted" href="/categories/iOS/">iOS</a></span><span class="level-item">14 分钟读完 (大约2111个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2016/01/25/iOS-Responder-Chain/">事件传递与响应链探索</a></h1><div class="content"><hr>
<p>iOS App 使用响应者对象( <code>Responder</code>)来接收和处理事件。一个响应者对象是 <code>UIResponder</code> 类的实例，它常见的子类包括 <code>UIView</code> 、<code>UIViewController</code> 和 <code>UIApplication</code>。响应者对象接收原始事件数据，并且必须处理该事件或将它转发给另一个响应者对象。</p>
<p>当你的 App 接收到一个事件时，<code>UIKit</code> 自动将它发送给最适合的响应者对象，即第一响应者对象(First Responder)。未处理的事件从响应者对象被发送到正在活动的响应链中的响应者对象(响应者链是应用程序的响应者对象的动态配置,在应用程序中没有单个响应者链)。</p>
<p><code>UIKit</code> 为事件如何从一个响应者对象传递到另一个响应者对象预定义了规则，但是你可以通过覆盖响应者对象中的属性来改变这些规则。</p>
<br>

<h3 id="响应者对象-Responder-Object"><a href="#响应者对象-Responder-Object" class="headerlink" title="响应者对象 (Responder Object)"></a>响应者对象 (Responder Object)</h3><p><code>Responder</code> 对象是 <code>UIResponder</code> 类的实例，构成了 <code>UIKit</code> 应用程序事件处理的主干。许多重要对象也是响应者，包括 <code>UIApplication</code> 对象，<code>UIViewController</code> 对象和所有 <code>UIView</code> 对象（包括 <code>UIWindow</code>）。当事件发生时，<code>UIKit</code> 将它们分派给你的应用程序的响应者对象进行处理。<br><code>UIResponder</code> 对象能处理的事件，包括触摸事件，动作事件，远程控制事件和新闻事件。</p>
<p>为了处理特定类型的事件，响应者必须覆盖相应的方法。例如，为了处理触摸事件，响应者实现了 <code>touchesBegan:with:</code>，<code>touchesMoved:with:</code>，<code>touchesEnded:with:</code> 和 <code>touchesCancelled:with:</code>方法。在触摸事件发生时，响应者使用 <code>UIKit</code> 提供的事件信息来跟踪触摸的变化，并适当地更新应用的界面。</p>
<p>除了处理事件之外，<code>UIKit</code>响应者还负责将未处理事件转发到应用程序的其他部分。如果给定的响应者不处理事件，则将该事件转发给响应者链中的下一个响应者对象。 <code>UIKit</code> 动态地管理响应者链，使用预定义的规则来确定接下来哪个对象应该接收事件。</p>
<p>响应者处理 <code>UIEvent</code> 对象，但也可以通过输入视图接受自定义输入。系统的键盘是输入视图最明显的例子。当用户点击屏幕上的 <code>UITextField</code> 和  <code>UITextView</code> 对象时，视图成为第一响应者并显示其输入视图，这是系统键盘。同样，你可以创建自定义输入视图，并在其它响应者激活时显示它们。要将自定义输入视图与响应者相关联，请将该视图分配给响应者的 <code>inputView</code> 属性。</p>
<blockquote>
<p><strong>NOTE</strong></p>
<p>与加速度计、陀螺仪和磁力计相关的运动事件不遵循响应者链。Core Motion 会直接将这些事件发送给你指定的对象。</p>
</blockquote>
<br>

<h3 id="第一响应者对象-The-First-Responder"><a href="#第一响应者对象-The-First-Responder" class="headerlink" title="第一响应者对象 (The First Responder)"></a>第一响应者对象 (The First Responder)</h3><p><code>UIKit</code> 为各种类型的事件指定第一响应者对象并在事件发生时首先发送到第一响应者对象。</p>
<ul>
<li><p>Touch events</p>
<p> 第一响应者对象是触摸发生的视图</p>
</li>
<li><p>Press events</p>
<p>  第一响应者对象是获得焦点的响应者对象</p>
</li>
<li><p>Shake-motion events</p>
<p>   第一响应者对象是你或 <code>UIKit</code> 指定的对象</p>
</li>
<li><p>Remote-control events</p>
<p>第一响应者对象是你或 <code>UIKit</code> 指定的对象</p>
</li>
<li><p>Editing menu messages</p>
<p>第一响应者对象是你或 <code>UIKit</code> 指定的对象</p>
</li>
</ul>
<p>控件使用动作消息 (Action message) 与其关联的目标对象 (Target Object) 直接进行通信。当用户与控件进行交互时，控件调用其目标对象的动作方法 (Action Method)，向目标对象(Target object)发送一个动作消息。动作消息不是一个事件，但它们仍可利用响应链。当控件的目标对象为 <code>nil</code> 时，<code>UIKit</code> 从目标对象开始，遍历响应者链，直到寻找到实现了相应方法的对象。</p>
<p>如果视图中有添加手势，那么手势会在视图接收之前接收触摸和按下事件。如果视图中的所有手势都无法处理这个事件，则将事件传递给视图进行处理。如果视图也不能处理，则 <code>UIKit</code> 会将事件传递给响应者链。</p>
<br>

<h3 id="基于视图的点击测试-View-Based-Hit-Testing"><a href="#基于视图的点击测试-View-Based-Hit-Testing" class="headerlink" title="基于视图的点击测试 (View-Based Hit-Testing)"></a>基于视图的点击测试 (View-Based Hit-Testing)</h3><p><code>UIKit</code> 使用基于视图的点击测试来确定触摸事件到底发生在哪里。<code>UIKit</code> 将触摸位置与处在视图层级中的视图的 <code>bounds</code> 进行比较。<code>hitTest:withEvent:</code> 方法遍历视图层级，寻找包含指定触摸的层级最深的子视图。 然后这个视图就成为第一响应者对象。</p>
<p>当用户触摸屏幕进行交互时，系统检测到手指触摸操作，并将触摸以 <code>UIEvent</code> 的方式加入 <code>UIApplication</code>  的事件队列中。<code>UIApplication</code> 从事件队列中取出最新的触摸事件进行分发传递到 <code>UIWindow</code> 进行处理。而 <code>UIWindow</code> 会通过 <code>hitTest:withEvent:</code> 方法寻找触点所在的视图，这个过程称之为 Hit-Test。</p>
<p><code>UIKit</code> 将每个触摸永久绑定到包含它的视图对象。<code>UIKit</code> 在触摸第一次发生时创建 <code>UITouch</code> 对象，并只在触摸结束时释放它。当触摸位置或其它参数改变时，<code>UIKit</code> 使用新的信息来更新 <code>UITouch</code> 对象。唯一不改变的属性就是包含它的视图，即使触摸位置已经移出原始的视图。</p>
<p>Hit-Test 从顶级视图开始调用 <code>pointInside:withEvevt:</code> 方法判断触摸点是否在当前视图内，如果返回为 <code>NO</code>  ，则 <code>hitTest:withEvent:</code> 方法返回 nil；如果返回 <code>YES</code> ，则向当前视图的所有子视图发送 <code>hitTest:withEvent:</code> 消息，所有子视图的遍历顺序是从最顶层视图一直到最底层视图，直到有子视图返回非空对象或者全部子视图遍历完毕。</p>
<blockquote>
<p><strong>NOTE</strong></p>
<p>如果一个触摸的位置超出了视图的边界，<code>hitTest:withEvent:</code> 方法就会忽略这个视图及其所有子视图。</p>
</blockquote>
<br>

<h3 id="响应者链-（Resoponder-Chain）"><a href="#响应者链-（Resoponder-Chain）" class="headerlink" title="响应者链 （Resoponder Chain）"></a>响应者链 （Resoponder Chain）</h3><p>当系统通过 Hit-Test 找到触摸点所在的视图，但是这个视图并没有或者无法正常处理此次触摸事件，这个时候，系统便会通过响应者链寻找下一个响应者，以对此次触摸事件进行响应。</p>
<p><img src="https://github.com/apple272487813/codeLei.github.io/blob/master/images/iOS_Responder_Chain.jpg?raw=true" alt="https://github.com/apple272487813/codeLei.github.io/blob/master/images/iOS_Responder_Chain.jpg?raw=true"></p>
<p>如果一个 View 有一个视图控制器，它的下一个响应者就是这个视图控制器，然后才是它的父视图，如果一直到根视图都没能处理这个事件，事件会传递到 <code>UIWindow</code> ，若在 <code>UIWindow</code> 中也没有处理，则会传递给 <code>UIApplication</code> ，它是一个响应者链的终点，它的下一个响应者指向 <code>nil</code> ，以劫数整个循环。</p>
<br>

<h3 id="改变响应者链-Altering-the-Responder-Chain"><a href="#改变响应者链-Altering-the-Responder-Chain" class="headerlink" title="改变响应者链 (Altering the Responder Chain)"></a>改变响应者链 (Altering the Responder Chain)</h3><p>你可以通过覆盖你的响应者对象中的 <code>nextResponder</code> 属性来改变响应者链。当你这样做时，下一个响应者就是你返回的对象。</p>
<p>很多 <code>UIKit</code> 类已经覆盖了这个属性 : </p>
<ul>
<li><code>UIView</code> 对象。如果视图是视图控制器的根视图，那它的 <code>nextResponder</code> 是视图控制器，否则是视图的父视图。</li>
<li><code>UIViewController</code> 对象。<ul>
<li>如果视图控制器的视图是一个窗口的根视图，<code>nextResponder</code> 是窗口对象。</li>
<li>如果一个视图是被其它视图控制器推出的，<code>nextResponder</code> 是推出它的视图控制器。</li>
</ul>
</li>
<li><code>UIWindow</code> 对象。窗口的 <code>nextResponder</code> 是 <code>UIApplication</code> 对象。</li>
<li><code>UIApplication</code> 对象。只有在应用代理是 <code>UIResponder</code> 的实例而不是视图、视图控制器或者应用对象自身时，<code>UIApplication</code> 的 <code>nextResponder</code> 是应用程序代理。</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2016-01-09T16:00:00.000Z" title="2016/1/10 上午12:00:00">2016-01-10</time>发表</span><span class="level-item"><a class="link-muted" href="/categories/iOS/">iOS</a></span><span class="level-item">2 小时读完 (大约15078个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2016/01/10/iOS-Runtime/">Objective-C Runtime</a></h1><div class="content"><h1 id="Objective-C-Runtime"><a href="#Objective-C-Runtime" class="headerlink" title="Objective-C Runtime"></a>Objective-C Runtime</h1><p>动态语言，是指程序在运行时可以改变其结构：新的函数可以被引进，已有的函数可以被删除等在结构上的变化，类型的检查是在运行时做的，优点为方便阅读，清晰明了，缺点为不方便调试。</p>
<p>这里有三个名词容易被混淆：</p>
<p>Dynamic Programming Language，即动态语言或动态编程语言</p>
<p>Dynamically Typed  Language，即动态类型语言</p>
<p>Statically Typed Language，即静态类型语言</p>
<p>所谓的动态类型语言，指的是类型的检查是在运行时做的；与此相对，静态类型语言的类型判断是在运行前判断(如编译阶段)，C#、Java 等就是静态类型语言，静态类型的语言为了达到多态会采取一些类型鉴别手段，如接口、继承，而动态类型的语言却不需要，所以一般动态语言都会采用 dynamic typing，常出现于脚本语言中。</p>
<p><strong><code>Objective-C</code> 就是一门动态语言，它有一个运行时系统来执行编译的代码。这个运行时系统就是 <code>Objc Runtime</code>，它是一个由 C 和汇编语言编写的库。</strong></p>
<p><code>Runtime</code> 库的主要工作是封装和找出最终执行的代码。</p>
<ul>
<li>封装 ：在 <code>Objc Runtime</code> 库中，对象可以用 C 中的结构体表示，而方法可以用 C 中的函数来实现，另外再加上一些额外的特性。这些结构体和函数被 <code>Runtime</code> 函数封装后，我们就可以在程序运行时创建，检查，修改类、对象和它们的方法了。</li>
<li>找出方法的最终执行代码：当程序执行 <code>[object doSomething]</code>时，会向消息接收者发送一条消息，<code>Runtime</code> 会根据消息接收者是否能响应该消息而做出不同的反应。</li>
</ul>
<p>Objective-C Runtime 目前有两个版本：<code>Modern Runtime</code>和 <code>Legacy Runtime</code>。<code>Moder Runtime</code>覆盖了64位的 <code>Mac  OS X Apps</code>和 <code>iOS Apps</code>，<code>Legacy Runtime</code>是早期用来给32位的 <code>Mac OS X Apps</code>用的。</p>
<h2 id="Objective-C-Runtime-中的类与对象"><a href="#Objective-C-Runtime-中的类与对象" class="headerlink" title="Objective-C Runtime 中的类与对象"></a>Objective-C Runtime 中的类与对象</h2><h3 id="类与对象的基本数据结构"><a href="#类与对象的基本数据结构" class="headerlink" title="类与对象的基本数据结构"></a>类与对象的基本数据结构</h3><h4 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h4><p><code>Objective-C</code> 中的类是由 <code>Class</code> 类型来表示的，实际上是一个指向 <code>objc_class</code> 结构体的指针</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_class	*Class;	</span><br></pre></td></tr></table></figure>

<p>它的结构体定义如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">struct	objc_class &#123;</span><br><span class="line">  Class isa OBJC_ISA_AVAILABILITY;</span><br><span class="line">  </span><br><span class="line"> #if !__OBJC2__</span><br><span class="line"> 	Class	super_class						OBJC2_UNAVAILABLE;</span><br><span class="line">	const 	char *name						OBJC2_UNAVAILABLE;</span><br><span class="line">	long	version							OBJC2_UNAVAILABLE;</span><br><span class="line">	long	info 							OBJC2_UNAVAILABLE;</span><br><span class="line">	long 	instance_size					OBJC2_UNAVAILABLE;</span><br><span class="line">	struct	objc_ivar_list	*ivars			OBJC2_UNAVAILABLE;</span><br><span class="line">	struct	objc_method_list **methodLists  OBJC2_UNAVAILABLE;</span><br><span class="line">	struct	objc_cache	*cache				OBJC2_UNAVAILABLE;</span><br><span class="line">	struct	objc_protocol_list	*protocols	OBJC2_UNAVAILABLE;</span><br><span class="line"> #endif</span><br><span class="line">&#125; OBJC2_UNAVAILABLE;</span><br></pre></td></tr></table></figure>

<p>这些字段的意义如下：</p>
<ul>
<li><code>isa</code>：<code>Objective-C</code> 中所有类自身也是对象，这个对象的 <code>Class</code> 里也有一个 <code>isa</code> 指针，它指向 <code>metaClass</code> 元类。</li>
<li><code>super_class</code> ：指向该类的父类，如果该类已经是最顶层的根类，则为 <code>NULL</code>。</li>
<li><code>name</code> ：类名。</li>
<li><code>version</code> ：类的版本信息，默认为0。我们可以使用这个字段来提供类的版本信息，这对于对象的序列化非常有用，它可以让我们识别出不同类定义版本中实例变量布局的改变。</li>
<li><code>info</code> ：类信息，供运行期使用的一些位标识。</li>
<li><code>instance_size</code> ：类的实例变量的大小。</li>
<li><code>ivars</code> ：类的成员变量链表。</li>
<li><code>methodLists</code> ：方法定义的链表。</li>
<li><code>cache</code> ：用于缓存最近使用的方法。当一个接收者对象接收到一个消息时，它会根据 <code>isa</code> 指针去查找能够响应这消息的对象。在实际情况里，这个对象只有一部分方法是常用的，很多方法其实很少用或根本用不上。这种情况下，如果每次消息来时，都是在 <code>methodLists</code> 链表中遍历一遍，性能势必很差。更好的做法是，在我们每次调用过一个方法后，就将这个方法缓存到 <code>cache</code> 列表中，下次调用就会优先去 <code>cache</code> 中查找。</li>
<li><code>protocols</code> ：协议链表。</li>
</ul>
<p>当我们向一个 <code>Objective-C</code> 对象发送消息时，<code>Runtime</code> 会根据实例对象的 <code>isa</code> 指针找到这个实例对象所属的类，然后 <code>Runtime</code> 会在类的方法列表及其父类的方法列表中寻找与消息对应的 <code>selector</code> 指向的方法，找到后即运行这个方法。</p>
<p>当创建一个特定类的实例对象时，分配的内存会包含一个 <code>objc_object</code> 数据结构，然后是类的实例变量的数据。<code>NSObject</code> 类的 <code>alloc</code> 和 <code>allocWithZone:</code> 方法使用函数 <code>class_createInstance</code> 来创建 <code>objc_object</code> 数据结构。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct objc_object &#123;</span><br><span class="line">  Class isa	OBJC_ISA_AVAILABILITY;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">typedef	struct objc_object	*id;</span><br></pre></td></tr></table></figure>

<p>常见的 <code>id</code> 是一个 <code>objc_object</code> 结构类型的指针。</p>
<h4 id="objc-cache"><a href="#objc-cache" class="headerlink" title="objc_cache"></a>objc_cache</h4><p><code>objc_class</code> 中的 <code>cache</code> 字段用于缓存调用过的方法，它是一个指向 <code>objc_cache</code> 结构体的指针。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct	objc_cache &#123;</span><br><span class="line">  unsigned int mask 				OBJC2_UNAVAILABLE;	</span><br><span class="line">  unsigned int occupied				OBJC2_UNAVAILABLE;</span><br><span class="line">  Method buchets[1]					OBJC2_UNAVAILABLE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该结构体的字段描述如下：</p>
<ul>
<li><code>mask</code> ：一个整数，指定分配的缓存 <code>bucket</code> 的总数。在方法查找过程中，<code>Runtime</code> 使用这个字段来确定开始线性查找数组的索引位置。指向方法的 <code>selector</code> 指针与该字段做一个 <code>AND</code> 位操作。</li>
<li><code>occupied</code> ：一个整数，指定实际占用的缓存 <code>bucket</code> 的总数。</li>
<li><code>buckets</code> ： 指向 <code>Method</code> 数据结构指针的数组。这个数组可能包含不超过 <code>mask+1</code> 个元素。如果指针为 <code>NULL</code>，表明这个缓存 <code>bucket</code> 没有被占用，另外被占用的 <code>bucket</code> 可能是不连续的。</li>
</ul>
<h4 id="元类-Meta-Class"><a href="#元类-Meta-Class" class="headerlink" title="元类(Meta Class)"></a>元类(Meta Class)</h4><p>所有的类自身也是一个对象，我们也可以向这个对象发送消息。</p>
<p>当我们向一个对象发送消息时，<code>Runtime</code> 会在这个对象所属的类的方法列表中查找方法；而向一个类发送消息时，会在这个类的 <code>meta-class</code> 的方法列表中查找。</p>
<p><code>meta-class</code> 存储着一个类的所有类方法。每个类都会有个一个单独的 <code>meta-class</code> ，因为每个类的类方法基本不可能完全相同。</p>
<p><code>meta-class</code> 的 <code>isa</code> 指针指向基类的 <code>meta-class</code> ，以此作为它的所属类。可以理解为，任何 <code>NSObject</code> 继承体系下的 <code>meta-class</code> 都使用 <code>NSObject</code> 的 <code>meta-class</code> 作为自己的所属类，而基类的 <code>meta-class</code> 的 <code>isa</code> 指针则指向它自己。</p>
<p>对于 <code>NSObject</code> 继承体系来说，其实例方法对体系中的所有实例、类和 <code>meta-class</code> 都是有效的；而类方法对于体系内的所有类和 <code>meta-class</code> 都是有效的。</p>
<h3 id="类与对象操作函数"><a href="#类与对象操作函数" class="headerlink" title="类与对象操作函数"></a>类与对象操作函数</h3><p><code>Runtime</code> 提供了大量函数来操作类与对象。类的操作方法大部分以 <code>class_</code> 为前缀，对象的操作方法大部分是以 <code>objc_</code> 或 <code>object_</code> 为前缀。</p>
<h4 id="类名"><a href="#类名" class="headerlink" title="类名"></a>类名</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 获取类的类名</span><br><span class="line">const char * class_getName	(Class cls);</span><br></pre></td></tr></table></figure>

<p>对于 <code>class_getName</code> 函数来说，如果传入的 <code>cls</code> 为 <code>nil</code>，则返回一个字字符串。</p>
<h4 id="父类-super-class-和元类-meta-class"><a href="#父类-super-class-和元类-meta-class" class="headerlink" title="父类(super_class)和元类(meta-class)"></a>父类(super_class)和元类(meta-class)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 获取类的父类</span><br><span class="line">Class	class_getSuperClass	(Class cls);</span><br><span class="line">// 判断给定的类是否是元类</span><br><span class="line">BOOL class_isMetaClass	(Class cls);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>class_getSuperClass</code> 函数，当<code>cls</code> 为 <code>nil</code> 或 <code>cls</code> 为根类时，返回 <code>nil</code>。</li>
<li><code>class_isMetaClass</code> 函数，如果 <code>cls</code> 是元类，返回 <code>YES</code>。如果传入的 <code>cls</code> 为 <code>nil</code>，则返回 <code>NO</code>。</li>
</ul>
<h4 id="实例变量大小-instance-size"><a href="#实例变量大小-instance-size" class="headerlink" title="实例变量大小(instance_size)"></a>实例变量大小(instance_size)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 获取实例大小</span><br><span class="line">size_t	class_getInstanceSize	(Class cls);</span><br></pre></td></tr></table></figure>



<h4 id="成员变量-ivar-及属性"><a href="#成员变量-ivar-及属性" class="headerlink" title="成员变量(ivar)及属性"></a>成员变量(ivar)及属性</h4><p><code>objc_class</code> 中，所有的成员变量、属性的信息都是放在链表 <code>ivars</code> 中。<code>ivars</code> 是一个数组，数组中的每个元素是指向 <code>ivar</code> 的指针。</p>
<ul>
<li><p>成员变量操作函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 获取类中指定名称实例成员变量的信息</span><br><span class="line">Ivar	class_getInstanceVariable	(Class cls, const char *name);	</span><br><span class="line">// 获取类成员变量的信息</span><br><span class="line">Ivar	class_getClassVariable	(Class cls, const char *name);</span><br><span class="line">// 添加成员变量</span><br><span class="line">BOOL	class_addIvar	(Class cls, const char *name, size_t size, uint8_t alignment, const char *types);</span><br><span class="line">// 获取整个成员变量列表</span><br><span class="line">Ivar	* class_copyIvarList	(Class cls, unsigned int *outCount);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>class_getInstanceVariable</code> 函数，它返回一个指向包含 <code>name</code> 指定的成员变量信息的 <code>objc_ivar</code> 结构体的指针 <code>Ivar</code>。</li>
<li><code>class_getClassVariable</code> 函数，目前没有找到关于 <code>Objective-C</code> 中类变量的信息，一般认为 <code>Objective-C</code> 不支持类变量。</li>
<li><code>Objective-C</code> 不支持向已经存在的类中添加实例变量，但如果通过 <code>Runtime</code> 来创建一个类的话，就可以使用 <code>class_addIvar</code> 函数了。需要注意的是，这个函数只能在 <code>objc_allocateClassPair</code> 与 <code>objc_registerClassPair</code> 之间调用。另外这个类也不能是元类。</li>
<li><code>class_copyIvarList</code> ，返回一个包含成员变量信息的数组，数组中的每个元素是指向该成员变量信息的 <code>objc_ivar</code> 结构体的指针。这个数组不包含在父类中声明的变量。<code>outCount</code> 指针返回数组的大小。需要注意的是，我们必须使用 <code>free()</code> 来释放这个数组。</li>
</ul>
</li>
<li><p>属性操作函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 获取指定的属性</span><br><span class="line">objc_property_t	class_getProperty	(Class cls, const char *name);</span><br><span class="line">// 获取属性列表</span><br><span class="line">objc_property_t * class_copyPropertyList	(Class cls, unsigned int *outCount);</span><br><span class="line">// 为类添加属性</span><br><span class="line">BOOL class_addProperty	(Class cls, const char *name, const objc_property_attribute_t *attributes, unsigned int attributeCount);</span><br><span class="line">// 替换类的属性</span><br><span class="line">void class_replaceProperty	(Class cls, const char *name, const objc_property_attribute_t *attributes, unsigned int attributeCount);	</span><br></pre></td></tr></table></figure>
</li>
<li><p>在 <code>Mac OS X</code> 系统中，<code>Runtime</code> 提供了几个函数来确定一个对象的内存区域是否可以被垃圾回收器扫描，以处理 <code>strong/weak</code> 引用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const	uint8_t * class_getIvarLayout	(Class cls);</span><br><span class="line">void	class_setIvarLayout	(Class cls, const uint8_t *layout);</span><br><span class="line">const	uint_8	* class_getWeakIvarLayout	(Class cls);</span><br><span class="line">void	class_setWeakIvarLayout	(Class cls, const uint8_t *layout);</span><br></pre></td></tr></table></figure>

<p>通常情况下，我们不需要去主动调用这些方法，在调用 <code>objc_registerClassPair</code> 时，会生成合理的布局。</p>
</li>
</ul>
<h4 id="方法-methodLists"><a href="#方法-methodLists" class="headerlink" title="方法(methodLists)"></a>方法(methodLists)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 添加方法</span><br><span class="line">BOOL class_addMethod	(Class cls, SEL name, IMP imp, const char *types);</span><br><span class="line">// 获取实例方法</span><br><span class="line">Method	class_getInstanceMethod	(Class cls, SEL name);</span><br><span class="line">// 获取类方法</span><br><span class="line">Method	class_getClassMethod	(Class cls, SEL name);</span><br><span class="line">// 获取所有方法的数组</span><br><span class="line">Method	* class_copyMethodList	(Class cls, unsigned int *outCount);</span><br><span class="line">// 替代方法的实现</span><br><span class="line">IMP	class_replaceMethod	(Class cls, SEL name, IMP imp, const char *types);</span><br><span class="line">// 返回方法的具体实现</span><br><span class="line">IMP	class_getMethodImplementation	(Class cls, SEL name);</span><br><span class="line">IMP class_getMethodImplementation_stret	(Class cls, SEL name);</span><br><span class="line">// 类实例是否响应指定的 selector</span><br><span class="line">BOOL class_respondsToSelector	(Class cls, SEL sel);</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>class_addMethod</code> 的实现会覆盖父类的方法实现，但不会取代本类中已经存在的实现，如果本类中包含一个同名的实现，则函数会返回 <code>NO</code>。如果要修改已经存在的实现，可以使用 <code>method_setImplementation</code>。一个 <code>Objectice-C</code> 方法是一个简单的 C 函数，它至少包含两个参数 <code>self</code> 和 <code>_cmd</code>，所以我们实现函数至少需要两个参数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void myMethodIMP (id self, SEL _cmd) &#123;</span><br><span class="line">  // implementation</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与成员变量不同的是，我们可以动态的为类添加方法，不管这个类是否已经存在。</p>
<p>参数 <code>types</code> 是一个描述传递给方法的参数类型的字符数组。</p>
</li>
<li><p><code>class_getInstanceMethod</code> 、<code>class_getClassMethod</code> 函数，与 <code>class_copyMethodList</code> 不同的是，这两个函数都会去搜索父类的实现。</p>
</li>
<li><p><code>class_copyMethodList</code> 函数，返回包含所有实例方法的数组，如果需要获取类方法，则可使用 <code>class_copyMethodList(object_getClass(Class cls), &amp;count)</code> (一个类的实例方法是定义在元类中的)。该列表不包含父类实现的方法。<code>outCount</code> 参数返回方法的个数。在获取到列表后，我们需要使用 <code>free()</code> 来释放它。</p>
</li>
<li><p><code>class_replaceMethod</code> 函数，该函数的行为可以分为两种 ：如果类中不存在参数 <code>name</code> 指定的方法，则类似于 <code>class_addMethod</code> 函数一样会添加方法；如果类中已经存在 <code>name</code> 指定的方法，则类似于 <code>method_setImplementation</code> 一样替代原方法的实现。</p>
</li>
<li><p><code>class_getMethodImplementation</code> 函数，该函数在向类实例发送消息时会被调用，并返回一个指向方法实现函数的指针。这个函数会比 <code>method_getImplementation(Class cls, const char * name)</code> 更快。返回的函数指针可能是一个指向 <code>Runtime</code> 内部的函数，而不一定是方法的实际实现。</p>
</li>
<li><p><code>class_respondsToSelector</code> 函数，我们经常使用 <code>NSObject</code> 类的 <code>respondsToSelector:</code> 或 <code>instanceRespondToSelector:</code> 方法来达到同样的目的。</p>
</li>
</ul>
<h4 id="协议-objc-protocol-list"><a href="#协议-objc-protocol-list" class="headerlink" title="协议 (objc_protocol_list)"></a>协议 (objc_protocol_list)</h4><p>协议相关的操作包含以下函数：：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 添加协议</span><br><span class="line">BOOL class_addProtocol	(Class cls, Protocol *protocol);</span><br><span class="line">// 返回类是否实现指定的协议</span><br><span class="line">BOOL class_conformsToProtocol	(Class cls, Protocol *protocol);</span><br><span class="line">// 返回类实现的协议列表</span><br><span class="line">Protocol	*class_copyProtocolList	(Class cls, unsigned int *outCout);</span><br></pre></td></tr></table></figure>



<h4 id="版本-version"><a href="#版本-version" class="headerlink" title="版本(version)"></a>版本(version)</h4><p>版本相关的操作函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 获取版本号</span><br><span class="line">int class_getVersion	(Class cls);</span><br><span class="line">// 设置版本号</span><br><span class="line">void class_setVersion	(Class cls, int version)</span><br></pre></td></tr></table></figure>



<h3 id="动态创建类和对象"><a href="#动态创建类和对象" class="headerlink" title="动态创建类和对象"></a>动态创建类和对象</h3><p><code>Runtime</code> 经常被用到的功能就是在运行时创建类和对象。</p>
<h4 id="动态创建类"><a href="#动态创建类" class="headerlink" title="动态创建类"></a>动态创建类</h4><p>动态创建类涉及到一下几个函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个新类和元类</span><br><span class="line">Class	objc_allocateClassPair	(Class superclass, const char *name, size_t extraBytes);</span><br><span class="line">// 销毁一个类及其相关的类</span><br><span class="line">void objc_disposeClassPair	(Class cls);</span><br><span class="line">// 在应用中注册由 objc_allocateClassPair 创建的类</span><br><span class="line">void objc_registerClassPair	(Class cls);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>objc_allocateClassPair</code> 函数 ：如果我们要创建一个根类，则指定 <code>superClass</code> 为 <code>Nil</code>。<code>extraBytes</code> 通常指定为 0 ，该参数是分配给类和元类对象尾部的索引 <code>ivars</code> 的字节数。</li>
</ul>
<p>为了创建一个新类，我们需要调用 <code>objc_allocateClassPair</code> ，然后使用诸如 <code>class_addMethod</code> , <code>class_addIvar</code> 等函数来为新创建的类添加方法、实例变量和属性等。完成这些后，我们需要调用 <code>objc_registerClassPair</code> 函数来注册类，之后这个类就可以在程序中使用了。</p>
<p>实例方法和实例变量应该添加到类自身上，而类方法应该添加到类的元类上。</p>
<ul>
<li><code>objc_disposeClassPair</code> 函数用于销毁一个类，值得注意的是，如果程序运行中还存在类或其子类的实例，则不能对针对类调用该方法。</li>
</ul>
<h4 id="动态创建对象"><a href="#动态创建对象" class="headerlink" title="动态创建对象"></a>动态创建对象</h4><p>动态创建对象的函数如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 创建类实例</span><br><span class="line">id class_createInstance	(Class cls, size_t extraBytes);</span><br><span class="line">// 在指定位置创建类实例</span><br><span class="line">id objc_constructInstance	(Class cls, void *bytes);</span><br><span class="line">// 销毁类实例</span><br><span class="line">void * objc_destructInstance (id obj);</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>class_createInstance</code> 函数 ：创建实例时，会在默认的内存区域为类分配内存。<code>extraBytes</code> 表示分配的额外字节数。这些额外的字节数可用于存储在类定义中所定义的实例变量之外的实例变量。该函数在ARC环境下无法使用。</p>
<p>调用 <code>class_createInstance</code> 的效果和 <code>+alloc</code> 方法类似。</p>
</li>
<li><p><code>objc_constructInstance</code> 函数 ：在指定的位置(bytes)创建类实例。</p>
</li>
<li><p><code>objc_destructInstance</code> 函数 ：销毁一个类的实例，但不会释放并移除任何与其先关的引用。</p>
</li>
</ul>
<h3 id="实例操作函数"><a href="#实例操作函数" class="headerlink" title="实例操作函数"></a>实例操作函数</h3><p>实例操作函数主要是针对创建的实例对象的一系列操作函数。</p>
<h4 id="针对整个对象进行操作的函数"><a href="#针对整个对象进行操作的函数" class="headerlink" title="针对整个对象进行操作的函数"></a>针对整个对象进行操作的函数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 返回指定对象的一份拷贝</span><br><span class="line">id object_copy (id obj, size_t size);</span><br><span class="line">// 释放指定对象占用的内存</span><br><span class="line">id object_dispose	(id obj);</span><br></pre></td></tr></table></figure>



<h4 id="针对对象实例变量进行操作的函数"><a href="#针对对象实例变量进行操作的函数" class="headerlink" title="针对对象实例变量进行操作的函数"></a>针对对象实例变量进行操作的函数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 修改类实例的实例变量的值</span><br><span class="line">Ivar	object_setInstanceVariable	(id obj, const char *name, void *value);</span><br><span class="line">// 获取对象实例变量的值</span><br><span class="line">Ivar	object_getInstanceVariable	(id obj, const char *name, void **outValue);</span><br><span class="line">// 返回指向给定对象分配的任何额外字节的指针</span><br><span class="line">void * object_getIndexedIvars (id obj);</span><br><span class="line">// 返回对象中实例变量的值</span><br><span class="line">id object_getIvar	(id obj, Ivar ivar);</span><br><span class="line">// 设置对象中实例变量的值</span><br><span class="line">void object_setIvar	(id obj, Ivar ivar, id value);</span><br></pre></td></tr></table></figure>

<p>如果实例变量的 <code>Ivar</code> 已经知道，那么调用 <code>objc_getIvar</code> 会比 <code>objc_getInstanceVariable</code> 函数快。相同情况下，<code>object_setIvar</code> 也比 <code>object_setInstanceVariable</code> 快。</p>
<h4 id="针对对象的类进行操作的函数"><a href="#针对对象的类进行操作的函数" class="headerlink" title="针对对象的类进行操作的函数"></a>针对对象的类进行操作的函数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 返回给定对象的类名</span><br><span class="line">const char * object_getClassName	(id obj);</span><br><span class="line">// 返回对象的类</span><br><span class="line">Class object_getClass (id obj);</span><br><span class="line">// 设置对象的类</span><br><span class="line">Class object_setClass	(id obj, Class cls);</span><br></pre></td></tr></table></figure>



<h3 id="获取类定义"><a href="#获取类定义" class="headerlink" title="获取类定义"></a>获取类定义</h3><p><code>Objective-C Runtime</code> 会自动注册我们代码中定义的所有的类。我们也可以在运行时创建类定义并使用 <code>objc_addClass</code> 来注册它们。</p>
<p>获取类定义的相关函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 获取以注册的类定义的列表</span><br><span class="line">int objc_getClassList	(Class *buffer, int bufferCount);</span><br><span class="line">// 创建并返回一个指向所有已注册类的指针列表</span><br><span class="line">Class	*	objc_copyClassList	(unsigned int *outCount);</span><br><span class="line">// 返回指定类的类定义</span><br><span class="line">Class	objc_lookUpClass	(const char *name);</span><br><span class="line">Class	objc_getClass	(const char *name);</span><br><span class="line">Class	objc_getRequiredClass	(const char *name);</span><br><span class="line">// 返回指定类的元类</span><br><span class="line">Class	objc_getMetaClass	(const char *name);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>objc_getClassList</code> 函数 ：获取已注册的类定义的列表。我们不能假设从该函数中获取的类对象是继承自 <code>NSObject</code> 体系的，所以在这些类上调用方法时，都应该先检测一下这个方法是否在这个类中实现。</li>
<li>获取类定义的方法有三个 ：<code>objc_lookUpClass</code> , <code>objc_getClass</code> 和 <code>objc_getRequiredClass</code>。如果类在运行时未注册，则 <code>objc_lookUpClass</code> 会返回 <code>nil</code>，而 <code>objc_getClass</code> 会调用类处理回调，并在此确认类是否注册，如果确认未注册，再返回 <code>nil</code>。而 <code>objc_getRequiredClass</code> 函数的操作与 <code>objc_getClass</code> 相同，只不过没有找到类，就会杀死进程。</li>
<li><code>objc_getMetaClass</code> 函数 ：如果指定的类没有注册，则该函数会调用类处理回调，并在此确认类是否注册，如果确认未注册，再返回 <code>nil</code>。不过，每个类定义都必须有一个有效的元类定义，所以这个函数总是会返回一个元类定义。不管它是否有效。</li>
</ul>
<h2 id="Objective-C-Runtime-中的成员变量与属性"><a href="#Objective-C-Runtime-中的成员变量与属性" class="headerlink" title="Objective-C Runtime 中的成员变量与属性"></a>Objective-C Runtime 中的成员变量与属性</h2><h3 id="类型编码-Type-Encoding"><a href="#类型编码-Type-Encoding" class="headerlink" title="类型编码(Type Encoding)"></a>类型编码(Type Encoding)</h3><p>作为对 <code>Runtime</code> 的补充，编译器将每个方法的返回值和参数类型编码为一个字符串，并将其与方法的 <code>selector</code> 关联在一起。这种编码方案在其它情况下也是非常有用的，因此我们可以使用  <code>@encod</code> 编译器指令来获取它。当给定一个类型时，<code>@encode</code> 会返回这个类型的字符串编码。   </p>
<h3 id="成员变量、属性"><a href="#成员变量、属性" class="headerlink" title="成员变量、属性"></a>成员变量、属性</h3><p><code>Runtime</code> 中关于成员变量和属性的相关数据结构并不多，只有三个。</p>
<h4 id="基础数据类型"><a href="#基础数据类型" class="headerlink" title="基础数据类型"></a>基础数据类型</h4><h5 id="Ivar"><a href="#Ivar" class="headerlink" title="Ivar"></a>Ivar</h5><p><code>Ivar</code> 是表示实例变量的类型，其实际上是一个指向 <code>objc_ivar</code> 结构体的指针 ：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">typedef struct	objc_ivar	*Ivar;</span><br><span class="line"></span><br><span class="line">struct objc_ivar	&#123;</span><br><span class="line">  char *ivar_name		OBJC2_UNAVAILABLE;	// 变量名</span><br><span class="line">  char *ivar_type		OBJC2_UNAVAILABLE;	// 变量类型</span><br><span class="line">  int ivar_offset		OBJC2_UNAVAILABLE;	// 基地址偏移字节</span><br><span class="line">  </span><br><span class="line">#ifdef __LP64__</span><br><span class="line">  int space				OBJC2_UNAVAILABLE;</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="objc-property-t"><a href="#objc-property-t" class="headerlink" title="objc_property_t"></a>objc_property_t</h5><p><code>objc_property_t</code> 是声明属性的类型，是一个指向 <code>objc_property</code> 结构体的指针 ：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef	struct	objc_property	*objc_property_t;</span><br></pre></td></tr></table></figure>

<h5 id="objc-property-attribute-t"><a href="#objc-property-attribute-t" class="headerlink" title="objc_property_attribute_t"></a>objc_property_attribute_t</h5><p><code>objc_property_attribute_t</code> 定义了属性的特性，它是一个结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span>	<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *name;		<span class="comment">//	特姓名</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *value;	<span class="comment">//	特性值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="关联对象-Associated-Object"><a href="#关联对象-Associated-Object" class="headerlink" title="关联对象(Associated Object)"></a>关联对象(Associated Object)</h4><p>关联对象是<code>Runtime</code> 中一个非常实用的特性。关联对象类似于成员变量，不过是在运行时添加的。我们通常会把变量(<code>Ivar</code>)放在类声明的头文件中，或者放在类实现的 <code>@implementation</code> 后面。但这有一个缺点，我们不能在分类中添加成员变量。<code>Objective-C</code> 针对这一问题，提出了一个解决方案：即关联对象(Associated Object)。</p>
<p>我们可以把关联对象想象成一个<code>Objective-C</code> 对象(如字典)，这个对象通过给定的key连接到类的一个实例上。不过由于使用的是C接口，所以key是一个<code>void</code> 指针。我们还需要指定一个内存管理策略，告诉<code>Runtime</code> 如何管理这个对象的内存，这个内存管理策略可以由一下指定：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">OBJC_ASSOCIATION_ASSIGN</span><br><span class="line">OBJC_ASSOCIATION_RETAIN_NONATOMIC</span><br><span class="line">OBJC_ASSOCIATION_COPY_NONATOMIC</span><br><span class="line">OBJC_ASSOCIATION_RETAIN</span><br><span class="line">OBJC_ASSOCIATION_COPY</span><br></pre></td></tr></table></figure>

<p>当宿主对象被释放时，会根据指定的内存管理策略来处理关联对象。如果指定的是 <code>OBJC_ASSOCIATION_ASSIGN</code></p>
<p>，则宿主释放时，关联对象不会被释放；而如果指定的是 <code>retain</code> 或者是 <code>copy</code> ，则宿主释放时，关联对象会被释放。</p>
<p>将一个对象连接到其它对象所需的就是下面两行代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">static char aKey;</span><br><span class="line">objc_setAssociatedObject(self, &amp;aKey, anObject, OBJC_ASSOCIATION_RETAIN);</span><br></pre></td></tr></table></figure>

<p>在这种情况下，<code>self</code> 对象将获取一个新的关联对象 <code>anObject</code> ，且内存管理策略是自动 <code>retian</code> 管理对象，当<code>self</code> 对象释放时，会自动 <code>release</code> 关联对象。另外，如果我们使用同一个key来关联另外一个对象时，也会自动释放之前关联的对象，在这种情况下，先前的关联对象会被妥善的处理掉，并且新的对象会使用它的内存。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 获取指定key的关联对象</span><br><span class="line">id anObject	=	objc_getAssociatedObject(self, &amp;aKey);</span><br></pre></td></tr></table></figure>

<p>使用 <code>objc_removeAssociatedObjects</code> 函数来移除一个关联对象，或者使用 <code>objc_setAssociatedObject</code> 函数将key指定的关联对象设置为<code>nil</code> 。</p>
<h4 id="成员变量、属性的操作方法"><a href="#成员变量、属性的操作方法" class="headerlink" title="成员变量、属性的操作方法"></a>成员变量、属性的操作方法</h4><h5 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h5><p>成员变量的操作函数包括 ： </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 获取成员变量名</span><br><span class="line">const char * ivar_getName (Ivar v);</span><br><span class="line">// 获取成员变量类型编码</span><br><span class="line">const char * ivar_getTypeEncoding (Ivar v);</span><br><span class="line">// 获取成员变量的偏移量</span><br><span class="line">ptrdiff_t ivar_getOffset (Ivar v);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>ivar_getOffset</code> 函数，对于 <code>id</code>  或其它对象类型的实例变量，可以调用 <code>object_getIvar</code> 和 <code>object_setIvar</code> 来直接访问成员变量，而不使用偏移量。</li>
</ul>
<h5 id="关联对象"><a href="#关联对象" class="headerlink" title="关联对象"></a>关联对象</h5><p>关联对象的操作函数包括 ： </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 设置关联对象</span><br><span class="line">void objc_setAssociatedObject (id object, const void *key, id value, objc_AssociationPolicy policy);</span><br><span class="line">// 获取关联对象</span><br><span class="line">id objc_getAssociatedObject (id object, const void *key);</span><br><span class="line">// 移除关联对象</span><br><span class="line">void objc_removeAssociatedObjects (id object);</span><br></pre></td></tr></table></figure>

<h5 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h5><p>属性操作相关函数包括 ：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 获取属性名</span><br><span class="line">const char * property_getName (objc_property_t property);</span><br><span class="line">// 获取属性特性描述字符串</span><br><span class="line">const char * property_getAttributes (objc_property_t property);</span><br><span class="line">// 获取属性中指定的特性</span><br><span class="line">char * property_copyAttributeValue (objc_property_t property, const char *attributeName);</span><br><span class="line">// 获取属性的特性列表</span><br><span class="line">objc_property_attribute_t * property_copyAttributeList (objc_property_t property, unsigned int *outCount);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>property_copyAttributeValue</code> 函数，返回的 <code>char*</code> 在使用完后需要调用 <code>free()</code> 释放。</li>
<li><code>property_copuAttributeList</code> 函数，返回值在使用完后需要调用 <code>free()</code> 释放。</li>
</ul>
<h2 id="Objective-C-Runtime-中的方法与消息"><a href="#Objective-C-Runtime-中的方法与消息" class="headerlink" title="Objective-C Runtime 中的方法与消息"></a>Objective-C Runtime 中的方法与消息</h2><h3 id="基础数据类型-1"><a href="#基础数据类型-1" class="headerlink" title="基础数据类型"></a>基础数据类型</h3><h4 id="SEL"><a href="#SEL" class="headerlink" title="SEL"></a>SEL</h4><p>SEL 又叫做选择器，是表示一个方法的 <code>selector</code> 的指针，定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_selector *SEL;</span><br></pre></td></tr></table></figure>

<p>方法的 <code>selector</code> 用于表示运行时方法的名字。<code>Objective-C</code> 在编译时，会根据每一个方法的名字、参数序列，生成一个唯一的整型标识(<code>Int</code> 类型的地址)，这个标识就是 <code>SEL</code>。</p>
<p>两个类之间，不管它们是不是父类与子类的关系，还是之间没有这种关系，只要方法名相同，那么方法的 <code>SEL</code> 就是一样的。每一个方法都对应着一个 <code>SEL</code>。所以在 <code>Objective-C</code> 的同一个类(及类的继承体系)中，不能存在两个同名的方法，即使参数类型不同也不行。因为相同的方法只能对应一个 <code>SEL</code>，这导致 <code>Objectice-C</code> 在处理相同方法名且参数个数相同但类型不同的方法方面能力很差。</p>
<p>当然不同的类可以拥有相同的 <code>selector</code> ，这个没有问题。不同类的实例对象执行相同的 <code>selector</code> 时，会在各自的方法列表中根据 <code>selector</code> 去寻找自己对应的 <code>IMP</code>。</p>
<p>工程中的所有的 <code>SEL</code> 组成了一个 <code>Set</code> 集合，Set 特点就是唯一，因此 SEL 也是唯一的。因此，如果我们想到这个方法集合中查找某个方法时，只需要去找到这个方法对应的 SEL 就行了，SEL 实际上就是根据方法名 <code>hash</code> 化了的一个字符串，而对于字符串的比较仅仅需要比较它们的地址就可以了。</p>
<p>本质上，<code>SEL</code> 只是一个指向方法的指针(准确地说，只是一个根据方法名 <code>hash</code> 化了的 <code>KEY</code> 值，能唯一代表一个方法)，它的存在只是为了加快方法的查询速度。</p>
<p>我们可以在运行时添加新的 <code>selector</code> ，也可以在运行时获取已经存在的 <code>selector</code> ，我们可以通过下面三种方式来获取 <code>SEL</code> :</p>
<ul>
<li><code>sel_registerName</code> 函数</li>
<li><code>Objective-C</code> 编译器提供的 <code>@selector()</code></li>
<li><code>NSSelectorFromString()</code> 方法</li>
</ul>
<h4 id="IMP"><a href="#IMP" class="headerlink" title="IMP"></a>IMP</h4><p><code>IMP</code> 实际上是一个函数指针，指向函数实现的首地址。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id (*IMP)(id, SEL, ...)</span><br></pre></td></tr></table></figure>

<p>这个函数使用当前 <code>CPU</code> 架构实现的标准 C 调用约定。第一个参数是指向 <code>self</code> (如果是实例方法，则是类实例的内存地址；如果是类方法，则是指向元类的指针)的指针，第二个参数是 <code>selector</code> ，接下来是方法的实际参数列表。</p>
<p>通过取得 <code>IMP</code> ，我们可以跳过 <code>Runtime</code> 的消息传递机制，直接执行 <code>IMP</code> 指向的函数实现，这样就省去了 <code>Runtime</code> 消息传递过程中所做的一系列查找操作。</p>
<h4 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h4><p><code>Method</code> 用于表示类定义中的方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_method *Method;</span><br><span class="line"></span><br><span class="line">struct objc_method &#123;</span><br><span class="line">  SEL	method_name			OBJC2_UNAVAILABLE;	//	方法名</span><br><span class="line">  char  *method_types		OBJC2_UNAVAILABLE;	//</span><br><span class="line">  IMP	method_imp			OBJC2_UNAVAILABLE;	//	方法实现	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="方法操作相关函数"><a href="#方法操作相关函数" class="headerlink" title="方法操作相关函数"></a>方法操作相关函数</h3><p><code>Runtime</code> 提供了一系列的方法来处理与方法相关的操作，包括方法本身及 <code>SEL</code> 。</p>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>方法的相关操作函数如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 调用指定方法的实现</span><br><span class="line">id method_invoke ( id receiver, Method m, ... );</span><br><span class="line">// 调用返回一个数据结构的方法的实现</span><br><span class="line">void method_invoke_stret ( id receiver, Method m, ... );</span><br><span class="line">// 获取方法名</span><br><span class="line">SEL method_getName ( Method m );</span><br><span class="line">// 返回方法的实现</span><br><span class="line">IMP method_getImplementation ( Method m );</span><br><span class="line">// 获取描述方法参数和返回值类型的字符串</span><br><span class="line">const char * method_getTypeEncoding ( Method m );</span><br><span class="line">// 获取方法的返回值类型的字符串</span><br><span class="line">char * method_copyReturnType ( Method m );</span><br><span class="line">// 获取方法的指定位置参数的类型字符串</span><br><span class="line">char * method_copyArgumentType ( Method m, unsigned int index );</span><br><span class="line">// 通过引用返回方法的返回值类型字符串</span><br><span class="line">void method_getReturnType ( Method m, char *dst, size_t dst_len );</span><br><span class="line">// 返回方法的参数的个数</span><br><span class="line">unsigned int method_getNumberOfArguments ( Method m );</span><br><span class="line">// 通过引用返回方法指定位置参数的类型字符串</span><br><span class="line">void method_getArgumentType ( Method m, unsigned int index, char *dst, size_t dst_len );</span><br><span class="line">// 返回指定方法的方法描述结构体</span><br><span class="line">struct objc_method_description * method_getDescription ( Method m );</span><br><span class="line">// 设置方法的实现</span><br><span class="line">IMP method_setImplementation ( Method m, IMP imp );</span><br><span class="line">// 交换两个方法的实现</span><br><span class="line">void method_exchangeImplementations ( Method m1, Method m2 );</span><br></pre></td></tr></table></figure>

<ul>
<li><code>method_invoke</code>函数，返回的是实际实现的返回值。参数<code>receiver</code>不能为空。这个方法的效率会比<code>method_getImplementation</code>和<code>method_getName</code>更快。</li>
<li><code>method_getName</code>函数，返回的是一个<code>SEL</code>。如果想获取方法名的C字符串，可以使用<code>sel_getName(method_getName(method))</code>。</li>
<li><code>method_getReturnType</code>函数，类型字符串会被拷贝到<code>dst</code>中。</li>
<li><code>method_setImplementation</code>函数，注意该函数返回值是方法之前的实现。</li>
</ul>
<h4 id="方法选择器"><a href="#方法选择器" class="headerlink" title="方法选择器"></a>方法选择器</h4><p>选择器的相关操作函数包括 ：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 返回给定选择器指定的方法的名称</span><br><span class="line">const char * sel_getName ( SEL sel );</span><br><span class="line">// 在Objective-C Runtime系统中注册一个方法，将方法名映射到一个选择器，并返回这个选择器</span><br><span class="line">SEL sel_registerName ( const char *str );</span><br><span class="line">// 在Objective-C Runtime系统中注册一个方法</span><br><span class="line">SEL sel_getUid ( const char *str );</span><br><span class="line">// 比较两个选择器</span><br><span class="line">BOOL sel_isEqual ( SEL lhs, SEL rhs );</span><br></pre></td></tr></table></figure>

<ul>
<li><code>sel_registerName</code>函数：在我们将一个方法添加到类定义时，我们必须在<code>Objective-C Runtime</code>系统中注册一个方法名以获取方法的选择器。</li>
</ul>
<h3 id="方法调用流程"><a href="#方法调用流程" class="headerlink" title="方法调用流程"></a>方法调用流程</h3><p>在 <code>Objective-C</code> 中，消息直到运行时才绑定到方法实现上。编译器会将消息表达式 <code>[receiver message]</code> 转化为一个消息调用的函数，即 <code>objc_msgSend</code> 。这个函数将消息接收者和方法名作为其基础参数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objc_msgSend(receiver, selector)</span><br></pre></td></tr></table></figure>

<p>如果消息中还有其它参数，则该方法的形式如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objc_msgSend(receiver, selector, arg1, arg2, ...)</span><br></pre></td></tr></table></figure>

<p>这个函数完成了动态绑定的所有事情：</p>
<ul>
<li>首先它找到 <code>selector</code> 对应的方法实现。因为同一个方法在不同的类中有不同的实现，所以我们需要依赖于接收者的类来找到确切的实现。</li>
<li>它调用方法实现，并将接收者对象及方法的所有参数传递给它。</li>
<li>最后，它将实现返回的值作为它自己的返回值。</li>
</ul>
<p>消息的关键在于结构体 <code>objc_class</code> ，这个结构体中有两个字段是我们在分发消息时关注的：</p>
<ul>
<li>指向父类的指针</li>
<li>一个类的方法分发表，即 <code>methodLists</code>。</li>
</ul>
<p>当我们创建一个新对象时，先为其分配内存，并初始化其成员变量。其中 <code>isa</code> 指针也会被初始化，让对象可以访问类及类的继承体系。</p>
<p>当消息发送给一个对象时，<code>objc_msgSend</code> 通过对象的 <code>isa</code> 指针获取到类的结构体，然后在方法列表里查找方法的 <code>selector</code> 。如果没有找到 <code>selector</code> ，则通过 <code>objc_class</code> 结构体中指向父类的指针找到其父类，并在父类的方法列表里寻找方法的 <code>selector</code> 。依此，会一直沿着类的的继承体系到达 <code>NSObject</code> 类。一旦定位到 <code>selector</code> ，函数就会获取到实现的入口点，并传入相应的参数来执行方法的具体实现。如果没有定位到 <code>selector</code> ，则会走消息转发流程。</p>
<p>为了加速消息的处理，运行时系统缓存使用过的 <code>selector</code> 及对应的方法的地址。</p>
<h4 id="隐藏参数"><a href="#隐藏参数" class="headerlink" title="隐藏参数"></a>隐藏参数</h4><p><code>objc_msgSend</code> 有两个隐藏参数 ：</p>
<ul>
<li>消息接受对象</li>
<li>方法的 <code>selector</code></li>
</ul>
<p>这两个参数为方法的实现提供了调用者的信息，之所以说是隐藏的，是因为它们在定义方法的源代码中没有声明，而是在编译期被插入实现代码的。</p>
<p>虽然这些参数没有声明，但是我们仍然能在代码中引用它们。我们可以用 <code>self</code> 来引用接收者对象，使用 <code>_cmd</code> 来引用选择器。</p>
<h4 id="获取方法地址"><a href="#获取方法地址" class="headerlink" title="获取方法地址"></a>获取方法地址</h4><p><code>Runtime</code> 中方法的动态绑定让我们写代码时更具灵活性，如我们可以把消息转发给我们想要的对象，或者随意交换一个方法的实现等。不过灵活性的提升也带来了性能上的一些损耗。毕竟我们需要去查找方法的实现，而不像函数调用来得那么直接。当然，方法的缓存一定程度上解决了这一问题。</p>
<p>我们上面提到过，如果想要避开这种动态绑定方式，我们可以获取方法实现的地址，然后像调用函数一样来直接调用它。特别是当我们需要在一个循环内频繁地调用一个特定的方法时，通过这种方式可以提高程序的性能。</p>
<p><code>NSObject</code> 类提供了<code>methodForSelector:</code>方法，让我们可以获取到方法的指针，然后通过这个指针来调用实现代码。我们需要将<code>methodForSelector:</code>返回的指针转换为合适的函数类型，函数参数和返回值都需要匹配上。</p>
<p>我们通过以下代码来看看<code>methodForSelector:</code>的使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void (*setter)(id, SEL, BOOL);</span><br><span class="line">int i;</span><br><span class="line">setter = (void (*)(id, SEL, BOOL))[target methodForSelector:@selector(setFilled:)];</span><br><span class="line">for (i = 0 ; i &lt; 1000 ; i++)</span><br><span class="line">    setter(targetList[i], @selector(setFilled:), YES);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里需要注意的就是函数指针的前两个参数必须是<code>id</code>和<code>SEL</code>。</p>
<p>当然这种方式只适合于在类似于<code>for</code>循环这种情况下频繁调用同一方法，以提高性能的情况。另外，<code>methodForSelector:</code>是由Cocoa运行时提供的；它不是Objective-C语言的特性。</p>
<h3 id="消息转发"><a href="#消息转发" class="headerlink" title="消息转发"></a>消息转发</h3><p>当一个对象能接收一个消息时，就会走正常的方法调用流程。但如果一个对象无法接收指定消息时，又会发生什么事呢？默认情况下，如果是以<code>[object message]</code>的方式调用方法，如果<code>object</code>无法响应<code>message</code>消息时，编译器会报错。但如果是以<code>perform...</code>的形式来调用，则需要等到运行时才能确定object是否能接收<code>message</code>消息。如果不能，则程序崩溃。</p>
<p>通常，当我们不能确定一个对象是否能接收某个消息时，会先调用<code>respondsToSelector:</code>来判断一下。如下代码所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if ([self respondsToSelector:@selector(method)]) &#123;</span><br><span class="line">    [self performSelector:@selector(method)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不过，我们这边想讨论下不使用<code>respondsToSelector:</code>判断的情况。这才是我们这一节的重点。</p>
<p>当一个对象无法接收某一消息时，就会启动所谓”<strong>消息转发(message forwarding)</strong>“机制，通过这一机制，我们可以告诉对象如何处理未知的消息。默认情况下，对象接收到未知的消息，会导致程序崩溃，并由 <code>NSObject</code> 的 <code>doesNotRecognizeSelector</code> 方法抛出 ‘unrecognized selector sent to instance’ 错误信息。不过，我们可以采取一些措施，让我们的程序执行特定的逻辑，而避免程序的崩溃。</p>
<p>消息转发机制基本上分为三个步骤：</p>
<ol>
<li>动态方法解析</li>
<li>备用接收者</li>
<li>完整转发</li>
</ol>
<p>下面我们详细讨论一下这三个步骤。</p>
<h4 id="动态方法解析"><a href="#动态方法解析" class="headerlink" title="动态方法解析"></a>动态方法解析</h4><p>对象在接收到未知的消息时，首先会调用所属类的类方法<code>+resolveInstanceMethod:</code>(实例方法)或者<code>+resolveClassMethod:</code>(类方法)。在这个方法中，我们有机会为该未知消息新增一个”处理方法””。不过使用该方法的前提是我们已经实现了该”处理方法”，只需要在运行时通过<code>class_addMethod</code>函数动态添加到类里面就可以了。如下代码所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void functionForMethod1(id self, SEL _cmd) &#123;</span><br><span class="line">   NSLog(@&quot;%@, %p&quot;, self, _cmd);</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line">+ (BOOL)resolveInstanceMethod:(SEL)sel &#123;</span><br><span class="line">    NSString *selectorString = NSStringFromSelector(sel);</span><br><span class="line">    if ([selectorString isEqualToString:@&quot;method1&quot;]) &#123;</span><br><span class="line">        class_addMethod(self.class, @selector(method1), (IMP)functionForMethod1, &quot;@:&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return [super resolveInstanceMethod:sel];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不过这种方案更多的是为了实现<code>@dynamic</code>属性。</p>
<h4 id="备用接收者"><a href="#备用接收者" class="headerlink" title="备用接收者"></a>备用接收者</h4><p>如果在上一步无法处理消息，则 <code>Runtime</code>会继续调以下方法 :</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (id)forwardingTargetForSelector:(SEL)aSelector</span><br></pre></td></tr></table></figure>

<p>如果一个对象实现了这个方法，并返回一个非nil的结果，则这个对象会作为消息的新接收者，且消息会被分发到这个对象。当然这个对象不能是<code>self</code>自身，否则就是出现无限循环。当然，如果我们没有指定相应的对象来处理<code>aSelector</code>，则应该调用父类的实现来返回结果。</p>
<p>使用这个方法通常是在对象内部，可能还有一系列其它对象能处理该消息，我们便可借这些对象来处理消息并返回，这样在对象外部看来，还是由该对象亲自处理了这一消息。</p>
<p>这一步合适于我们只想将消息转发到另一个能处理该消息的对象上。但这一步无法对消息进行处理，如操作消息的参数和返回值。</p>
<h4 id="完整消息转发"><a href="#完整消息转发" class="headerlink" title="完整消息转发"></a>完整消息转发</h4><p>如果在上一步还不能处理未知消息，则唯一能做的就是启用完整的消息转发机制了。此时会调用以下方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)forwardInvocation:(NSInvocation *)anInvocation</span><br></pre></td></tr></table></figure>

<p>运行时系统会在这一步给消息接收者最后一次机会将消息转发给其它对象。对象会创建一个表示消息的<code>NSInvocation</code>对象，把与尚未处理的消息有关的全部细节都封装在<code>anInvocation</code>中，包括<code>selector</code>，目标(<code>target</code>)和参数。我们可以在<code>forwardInvocation</code>方法中选择将消息转发给其它对象。</p>
<p><code>forwardInvocation:</code>方法的实现有两个任务：</p>
<ol>
<li>定位可以响应封装在<code>anInvocation</code>中的消息的对象。这个对象不需要能处理所有未知消息。</li>
<li>使用<code>anInvocation</code>作为参数，将消息发送到选中的对象。<code>anInvocation</code>将会保留调用结果，运行时系统会提取这一结果并将其发送到消息的原始发送者。</li>
</ol>
<p>不过，在这个方法中我们可以实现一些更复杂的功能，我们可以对消息的内容进行修改，比如追回一个参数等，然后再去触发消息。另外，若发现某个消息不应由本类处理，则应调用父类的同名方法，以便继承体系中的每个类都有机会处理此调用请求。</p>
<p>还有一个很重要的问题，我们必须重写以下方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</span><br></pre></td></tr></table></figure>

<p>消息转发机制使用从这个方法中获取的信息来创建<code>NSInvocation</code>对象。因此我们必须重写这个方法，为给定的<code>selector</code>提供一个合适的方法签名。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector &#123;</span><br><span class="line">    NSMethodSignature *signature = [super methodSignatureForSelector:aSelector];</span><br><span class="line">    if (!signature) &#123;</span><br><span class="line">        if ([SUTRuntimeMethodHelper instancesRespondToSelector:aSelector]) &#123;</span><br><span class="line">            signature = [SUTRuntimeMethodHelper instanceMethodSignatureForSelector:aSelector];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return signature;</span><br><span class="line">&#125;</span><br><span class="line">- (void)forwardInvocation:(NSInvocation *)anInvocation &#123;</span><br><span class="line">    if ([SUTRuntimeMethodHelper instancesRespondToSelector:anInvocation.selector]) &#123;</span><br><span class="line">        [anInvocation invokeWithTarget:_helper];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>NSObject</code>的<code>forwardInvocation:</code>方法实现只是简单调用了<code>doesNotRecognizeSelector:</code>方法，它不会转发任何消息。这样，如果不在以上所述的三个步骤中处理未知消息，则会引发一个异常。</p>
<p>从某种意义上来讲，<code>forwardInvocation:</code>就像一个未知消息的分发中心，将这些未知的消息转发给其它对象。或者也可以像一个运输站一样将所有未知消息都发送给同一个接收对象。这取决于具体的实现。</p>
<h4 id="消息转发与多重继承"><a href="#消息转发与多重继承" class="headerlink" title="消息转发与多重继承"></a>消息转发与多重继承</h4><p>回过头来看第二和第三步，通过这两个方法我们可以允许一个对象与其它对象建立关系，以处理某些未知消息，而表面上看仍然是该对象在处理消息。通过这种关系，我们可以模拟“多重继承”的某些特性，让对象可以“继承”其它对象的特性来处理一些事情。不过，这两者间有一个重要的区别：多重继承将不同的功能集成到一个对象中，它会让对象变得过大，涉及的东西过多；而消息转发将功能分解到独立的小的对象中，并通过某种方式将这些对象连接起来，并做相应的消息转发。</p>
<p>不过消息转发虽然类似于继承，但<code>NSObject</code>的一些方法还是能区分两者。如<code>respondsToSelector:</code>和<code>isKindOfClass:</code>只能用于继承体系，而不能用于转发链。如果我们想让这种消息转发看起来像是继承，则可以重写这些方法，如以下代码所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)respondsToSelector:(SEL)aSelector</span><br><span class="line">&#123;</span><br><span class="line">	if ( [super respondsToSelector:aSelector])</span><br><span class="line">		return YES;</span><br><span class="line">	else &#123;</span><br><span class="line">		/* Here, test whether the aSelector message can     *</span><br><span class="line">		 * be forwarded to another object and whether that  *</span><br><span class="line">		 * object can respond to it. Return YES if it can.  */</span><br><span class="line">	&#125;</span><br><span class="line">	return NO; 	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Objective-C-Runtime-Method-Swizzling"><a href="#Objective-C-Runtime-Method-Swizzling" class="headerlink" title="Objective-C Runtime Method Swizzling"></a>Objective-C Runtime Method Swizzling</h2><p><code>Method Swizzling</code>是改变一个<code>selector</code>的实际实现的技术。通过这一技术，我们可以在运行时通过修改类的分发表中<code>selector</code>对应的函数，来修改方法的实现。</p>
<p>例如，我们想跟踪在程序中每一个view controller展示给用户的次数：当然，我们可以在每个view controller的viewDidAppear中添加跟踪代码；但是这太过麻烦，需要在每个view controller中写重复的代码。创建一个子类可能是一种实现方式，但需要同时创建UIViewController, UITableViewController, UINavigationController及其它UIKit中view controller的子类，这同样会产生许多重复的代码。</p>
<p>这种情况下，我们就可以使用<code>Method Swizzling</code>，如在代码所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;objc/runtime.h&gt;</span><br><span class="line"></span><br><span class="line">@implementation UIViewController (Tracking)</span><br><span class="line">  </span><br><span class="line">+ (void)load &#123;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        Class class = [self class];         </span><br><span class="line">        // When swizzling a class method, use the following:</span><br><span class="line">        // Class class = object_getClass((id)self);</span><br><span class="line">        SEL originalSelector = @selector(viewWillAppear:);</span><br><span class="line">        SEL swizzledSelector = @selector(xxx_viewWillAppear:);</span><br><span class="line">        Method originalMethod = class_getInstanceMethod(class, originalSelector);</span><br><span class="line">        Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector);</span><br><span class="line">        BOOL didAddMethod = class_addMethod(class,</span><br><span class="line">                originalSelector,</span><br><span class="line">                method_getImplementation(swizzledMethod),</span><br><span class="line">                method_getTypeEncoding(swizzledMethod));</span><br><span class="line">        if (didAddMethod) &#123;</span><br><span class="line">            class_replaceMethod(class,</span><br><span class="line">                swizzledSelector,</span><br><span class="line">                method_getImplementation(originalMethod),</span><br><span class="line">                method_getTypeEncoding(originalMethod));</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            method_exchangeImplementations(originalMethod, swizzledMethod);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark - Method Swizzling</span><br><span class="line">- (void)xxx_viewWillAppear:(BOOL)animated &#123;</span><br><span class="line">    [self xxx_viewWillAppear:animated];</span><br><span class="line">    NSLog(@&quot;viewWillAppear: %@&quot;, self);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>在这里，我们通过<code>method swizzling</code>修改了UIViewController的<code>@selector(viewWillAppear:)</code>对应的函数指针，使其实现指向了我们自定义的<code>xxx_viewWillAppear</code>的实现。这样，当UIViewController及其子类的对象调用<code>viewWillAppear</code>时，都会打印一条日志信息。</p>
<p>上面的例子很好地展示了使用<code>method swizzling</code>来向一个类中注入一些我们新的操作。当然，还有许多场景可以使用<code>method swizzling</code>，在此不多举例。在此我们说说使用<code>method swizzling</code>需要注意的一些问题：</p>
<h3 id="Swizzling应该总是在-load中执行"><a href="#Swizzling应该总是在-load中执行" class="headerlink" title="Swizzling应该总是在+load中执行"></a>Swizzling应该总是在+load中执行</h3><p>在<code>Objective-C</code>中，运行时会自动调用每个类的两个方法。<code>+load</code>会在类初始加载时调用，<code>+initialize</code>会在第一次调用类的类方法或实例方法之前被调用。这两个方法是可选的，且只有在实现了它们时才会被调用。由于<code>method swizzling</code>会影响到类的全局状态，因此要尽量避免在并发处理中出现竞争的情况。<code>+load</code>能保证在类的初始化过程中被加载，并保证这种改变应用级别的行为的一致性。相比之下，<code>+initialize</code>在其执行时不提供这种保证–事实上，如果在应用中没有给这个类发送消息，则它可能永远不会被调用。</p>
<h3 id="Swizzling应该总是在dispatch-once中执行"><a href="#Swizzling应该总是在dispatch-once中执行" class="headerlink" title="Swizzling应该总是在dispatch_once中执行"></a>Swizzling应该总是在dispatch_once中执行</h3><p>与上面相同，因为<code>swizzling</code>会改变全局状态，所以我们需要在运行时采取一些预防措施。原子性就是这样一种措施，它确保代码只被执行一次，不管有多少个线程。GCD的<code>dispatch_once</code>可以确保这种行为，我们应该将其作为<code>method swizzling</code>的最佳实践。</p>
<h3 id="选择器、方法与实现"><a href="#选择器、方法与实现" class="headerlink" title="选择器、方法与实现"></a>选择器、方法与实现</h3><p>在<code>Objective-C</code>中，选择器(<code>selector</code>)、方法(<code>method</code>)和实现(<code>implementation</code>)是运行时中一个特殊点，虽然在一般情况下，这些术语更多的是用在消息发送的过程描述中。</p>
<p>以下是<code>Objective-C Runtime Reference</code>中的对这几个术语一些描述：</p>
<ol>
<li><code>Selector(typedef struct objc_selector *SEL)</code>：用于在运行时中表示一个方法的名称。一个方法选择器是一个C字符串，它是在<code>Objective-C</code>运行时被注册的。选择器由编译器生成，并且在类被加载时由运行时自动做映射操作。</li>
<li><code>Method(typedef struct objc_method *Method)</code>：在类定义中表示方法的类型</li>
<li><code>Implementation(typedef id (*IMP)(id, SEL, ...))</code>：这是一个指针类型，指向方法实现函数的开始位置。这个函数使用为当前CPU架构实现的标准C调用规范。第一个参数是指向对象自身的指针(self)，第二个参数是方法选择器。然后是方法的实际参数。</li>
</ol>
<p>理解这几个术语之间的关系最好的方式是：一个类维护一个运行时可接收的消息分发表；分发表中的每个入口是一个方法(Method)，其中key是一个特定名称，即选择器(SEL)，其对应一个实现(IMP)，即指向底层C函数的指针。</p>
<p>为了swizzle一个方法，我们可以在分发表中将一个方法的现有的选择器映射到不同的实现，而将该选择器对应的原始实现关联到一个新的选择器中。</p>
<h3 id="调用-cmd"><a href="#调用-cmd" class="headerlink" title="调用 _cmd"></a>调用 _cmd</h3><p>我们回过头来看看前面新的方法的实现代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)xxx_viewWillAppear:(BOOL)animated &#123;</span><br><span class="line">    [self xxx_viewWillAppear:animated];</span><br><span class="line">    NSLog(@&quot;viewWillAppear: %@&quot;, NSStringFromClass([self class]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>乍看上去是会导致无限循环的。但令人惊奇的是，并没有出现这种情况。在swizzling的过程中，方法中的<code>[self xxx_viewWillAppear:animated]</code>已经被重新指定到UIViewController类的-viewWillAppear:中。在这种情况下，不会产生无限循环。不过如果我们调用的是<code>[self viewWillAppear:animated]</code>，则会产生无限循环，因为这个方法的实现在运行时已经被重新指定为<code>xxx_viewWillAppear:</code>了。</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>Swizzling通常被称作是一种黑魔法，容易产生不可预知的行为和无法预见的后果。虽然它不是最安全的，但如果遵从以下几点预防措施的话，还是比较安全的：</p>
<ol>
<li>总是调用方法的原始实现(除非有更好的理由不这么做)：API提供了一个输入与输出约定，但其内部实现是一个黑盒。Swizzle一个方法而不调用原始实现可能会打破私有状态底层操作，从而影响到程序的其它部分。</li>
<li>避免冲突：给自定义的分类方法加前缀，从而使其与所依赖的代码库不会存在命名冲突。</li>
<li>明白是怎么回事：简单地拷贝粘贴swizzle代码而不理解它是如何工作的，不仅危险，而且会浪费学习Objective-C运行时的机会。阅读<code>Objective-C Runtime Reference</code>和查看<code>&lt;objc/runtime.h&gt;</code>头文件以了解事件是如何发生的。</li>
<li>小心操作：无论我们对Foundation, UIKit或其它内建框架执行Swizzle操作抱有多大信心，需要知道在下一版本中许多事可能会不一样。</li>
</ol>
<h2 id="Objective-C-Runtime-中的协议与分类"><a href="#Objective-C-Runtime-中的协议与分类" class="headerlink" title="Objective-C Runtime 中的协议与分类"></a>Objective-C Runtime 中的协议与分类</h2><p><code>Objective-C</code> 中的分类允许我们通过给一个类添加方法来扩充它（但是通过<code>category</code>不能添加新的实例变量），并且我们不需要访问类中的代码就可以做到。</p>
<p><code>Objective-C</code> 中的协议是普遍存在的接口定义方式，即在一个类中通过<code>@protocol</code>定义接口，在另外类中实现接口，这种接口定义方式也称为“<code>delegation</code>”模式，<code>@protocol</code>声明了可以被其他任何方法类实现的方法，协议仅仅是定义一个接口，而由其他的类去负责实现。</p>
<h3 id="基础数据类型-2"><a href="#基础数据类型-2" class="headerlink" title="基础数据类型"></a>基础数据类型</h3><h4 id="Category"><a href="#Category" class="headerlink" title="Category"></a>Category</h4><p>Category 是表示一个指向分类的结构体的指针。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_category *Category;</span><br><span class="line"></span><br><span class="line">struct objc_category &#123;</span><br><span class="line">  	char *category_name                          OBJC2_UNAVAILABLE;	// 分类名</span><br><span class="line">    char *class_name                             OBJC2_UNAVAILABLE;	// 分类所属的类名</span><br><span class="line">    struct objc_method_list *instance_methods    OBJC2_UNAVAILABLE;	// 实例方法列表</span><br><span class="line">    struct objc_method_list *class_methods       OBJC2_UNAVAILABLE;	// 类方法列表</span><br><span class="line">    struct objc_protocol_list *protocols  		 OBJC2_UNAVAILABLE;	// 分类所实现的协议列表    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个结构体主要包含了分类定义的实例方法与类方法，其中<code>instance_methods</code>列表是<code>objc_class</code>中方法列表的一个子集，而<code>class_methods</code>列表是元类方法列表的一个子集。</p>
<h4 id="Protocol"><a href="#Protocol" class="headerlink" title="Protocol"></a>Protocol</h4><p>Protocol 的定义如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_object Protocol;</span><br></pre></td></tr></table></figure>

<p>可以看到，<code>Protocol</code> 其实就是一个对象结构体。</p>
<h3 id="操作函数"><a href="#操作函数" class="headerlink" title="操作函数"></a>操作函数</h3><p><code>Runtime</code>并没有在<code>&lt;objc/runtime.h&gt;</code>头文件中提供针对分类的操作函数。因为这些分类中的信息都包含在<code>objc_class</code>中，我们可以通过针对<code>objc_class</code>的操作函数来获取分类的信息。</p>
<p>而对于Protocol，runtime提供了一系列函数来对其进行操作，这些函数包括：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// 返回指定的协议</span><br><span class="line">Protocol * objc_getProtocol ( const char *name );</span><br><span class="line">// 获取运行时所知道的所有协议的数组</span><br><span class="line">Protocol ** objc_copyProtocolList ( unsigned int *outCount );</span><br><span class="line">// 创建新的协议实例</span><br><span class="line">Protocol * objc_allocateProtocol ( const char *name );</span><br><span class="line">// 在运行时中注册新创建的协议</span><br><span class="line">void objc_registerProtocol ( Protocol *proto );</span><br><span class="line">// 为协议添加方法</span><br><span class="line">void protocol_addMethodDescription ( Protocol *proto, SEL name, const char *types, BOOL isRequiredMethod, BOOL isInstanceMethod );</span><br><span class="line">// 添加一个已注册的协议到协议中</span><br><span class="line">void protocol_addProtocol ( Protocol *proto, Protocol *addition );</span><br><span class="line">// 为协议添加属性</span><br><span class="line">void protocol_addProperty ( Protocol *proto, const char *name, const objc_property_attribute_t *attributes, unsigned int attributeCount, BOOL isRequiredProperty, BOOL isInstanceProperty );</span><br><span class="line">// 返回协议名</span><br><span class="line">const char * protocol_getName ( Protocol *p );</span><br><span class="line">// 测试两个协议是否相等</span><br><span class="line">BOOL protocol_isEqual ( Protocol *proto, Protocol *other );</span><br><span class="line">// 获取协议中指定条件的方法的方法描述数组</span><br><span class="line">struct objc_method_description * protocol_copyMethodDescriptionList ( Protocol *p, BOOL isRequiredMethod, BOOL isInstanceMethod, unsigned int *outCount );</span><br><span class="line">// 获取协议中指定方法的方法描述</span><br><span class="line">struct objc_method_description protocol_getMethodDescription ( Protocol *p, SEL aSel, BOOL isRequiredMethod, BOOL isInstanceMethod );</span><br><span class="line">// 获取协议中的属性列表</span><br><span class="line">objc_property_t * protocol_copyPropertyList ( Protocol *proto, unsigned int *outCount );</span><br><span class="line">// 获取协议的指定属性</span><br><span class="line">objc_property_t protocol_getProperty ( Protocol *proto, const char *name, BOOL isRequiredProperty, BOOL isInstanceProperty );</span><br><span class="line">// 获取协议采用的协议</span><br><span class="line">Protocol ** protocol_copyProtocolList ( Protocol *proto, unsigned int *outCount );</span><br><span class="line">// 查看协议是否采用了另一个协议</span><br><span class="line">BOOL protocol_conformsToProtocol ( Protocol *proto, Protocol *other );</span><br></pre></td></tr></table></figure>

<ul>
<li><code>objc_getProtocol</code>函数，需要注意的是如果仅仅是声明了一个协议，而未在任何类中实现这个协议，则该函数返回的是<code>nil</code>。</li>
<li><code>objc_copyProtocolList</code>函数，获取到的数组需要使用<code>free()</code>来释放</li>
<li><code>objc_allocateProtocol</code>函数，如果同名的协议已经存在，则返回<code>nil</code></li>
<li><code>objc_registerProtocol</code>函数，创建一个新的协议后，必须调用该函数以在运行时中注册新的协议。协议注册后便可以使用，但不能再做修改，即注册完后不能再向协议添加方法或协议</li>
</ul>
<p>需要强调的是，协议一旦注册后就不可再修改，即无法再通过调用<code>protocol_addMethodDescription</code>、<code>protocol_addProtocol</code>和<code>protocol_addProperty</code>往协议中添加方法等。</p>
<h2 id="Objective-C-Runtime-补充知识"><a href="#Objective-C-Runtime-补充知识" class="headerlink" title="Objective-C Runtime 补充知识"></a>Objective-C Runtime 补充知识</h2><h3 id="super"><a href="#super" class="headerlink" title="super"></a>super</h3><p>在<code>Objective-C</code>中，如果我们需要在类的方法中调用父类的方法时，通常都会用到<code>super</code>。</p>
<p>如何使用<code>super</code>我们都知道。现在的问题是，它是如何工作的呢？</p>
<p>首先我们需要知道的是<code>super</code>与<code>self</code>不同。<code>self</code>是类的一个隐藏参数，每个方法的实现的第一个参数即为<code>self</code>。而<code>super</code>并不是隐藏参数，它实际上只是一个<strong>”编译器标示符”</strong>，它负责告诉编译器，当调用viewDidLoad方法时，去调用父类的方法，而不是本类中的方法。而它实际上与<code>self</code>指向的是相同的消息接收者。为了理解这一点，我们先来看看<code>super</code>的定义：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">struct objc_super &#123; id receiver; Class superClass; &#125;;</span><br></pre></td></tr></table></figure>

<p>这个结构体有两个成员：</p>
<ol>
<li>receiver：即消息的实际接收者</li>
<li>superClass：指针当前类的父类</li>
</ol>
<p>当我们使用<code>super</code>来接收消息时，编译器会生成一个<code>objc_super</code>结构体。就上面的例子而言，这个结构体的<code>receiver</code>就是当前对象，与<code>self</code>相同；<code>superClass</code>指向当前类的父类。</p>
<p>接下来，发送消息时，不是调用<code>objc_msgSend</code>函数，而是调用<code>objc_msgSendSuper</code>函数，其声明如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id objc_msgSendSuper ( struct objc_super *super, SEL op, ... );</span><br></pre></td></tr></table></figure>

<p>该函数第一个参数即为前面生成的<code>objc_super</code>结构体，第二个参数是方法的<code>selector</code>。该函数实际的操作是：从<code>objc_super</code>结构体指向的<code>superClass</code>的方法列表开始查找<code>viewDidLoad</code> 的<code>selector</code>，找到后以<code>objc-&gt;receiver</code>去调用这个<code>selector</code>，而此时的操作流程就是如下方式了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objc_msgSend(objc_super-&gt;receiver, @selector(viewDidLoad))</span><br></pre></td></tr></table></figure>

<p>由于<code>objc_super-&gt;receiver</code>就是<code>self</code>本身，所以该方法实际与下面这个调用是相同的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objc_msgSend(self, @selector(viewDidLoad))</span><br></pre></td></tr></table></figure>



<h3 id="库相关操作"><a href="#库相关操作" class="headerlink" title="库相关操作"></a>库相关操作</h3><p>库相关的操作主要是用于获取由系统提供的库相关的信息，主要包含以下函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 获取所有加载的Objective-C框架和动态库的名称</span><br><span class="line">const char ** objc_copyImageNames ( unsigned int *outCount );</span><br><span class="line">// 获取指定类所在动态库</span><br><span class="line">const char * class_getImageName ( Class cls );</span><br><span class="line">// 获取指定库或框架中所有类的类名</span><br><span class="line">const char ** objc_copyClassNamesForImage ( const char *image, unsigned int *outCount )</span><br></pre></td></tr></table></figure>

<p>通过这几个函数，我们可以了解到某个类所有的库，以及某个库中包含哪些类。</p>
<h3 id="块操作"><a href="#块操作" class="headerlink" title="块操作"></a>块操作</h3><p>我们都知道block给我们带到极大的方便，苹果也不断提供一些使用block的新的API。同时，苹果在runtime中也提供了一些函数来支持针对block的操作，这些函数包括：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个指针函数的指针，该函数调用时会调用特定的block</span><br><span class="line">IMP imp_implementationWithBlock ( id block );</span><br><span class="line">// 返回与IMP(使用imp_implementationWithBlock创建的)相关的block</span><br><span class="line">id imp_getBlock ( IMP anImp );</span><br><span class="line">// 解除block与IMP(使用imp_implementationWithBlock创建的)的关联关系，并释放block的拷贝</span><br><span class="line">BOOL imp_removeBlock ( IMP anImp );</span><br></pre></td></tr></table></figure>

<ul>
<li><code>imp_implementationWithBlock</code>函数：参数block的签名必须是<code>method_return_type ^(id self, method_args …)</code>形式的。该方法能让我们使用block作为<code>IMP</code>。</li>
</ul>
<h3 id="弱引用操作"><a href="#弱引用操作" class="headerlink" title="弱引用操作"></a>弱引用操作</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 加载弱引用指针引用的对象并返回</span><br><span class="line">id objc_loadWeak ( id *location );</span><br><span class="line">// 存储__weak变量的新值</span><br><span class="line">id objc_storeWeak ( id *location, id obj );</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>objc_loadWeak</code>函数：该函数加载一个弱指针引用的对象，并在对其做<code>retain</code>和<code>autoreleasing</code>操作后返回它。这样，对象就可以在调用者使用它时保持足够长的生命周期。该函数典型的用法是在任何有使用<code>__weak</code>变量的表达式中使用。</p>
<p>●  <code>objc_storeWeak</code>函数：该函数的典型用法是用于<code>__weak</code>变量做为赋值对象时。</p>
</li>
</ul>
<h3 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h3><p>在<code>Runtime</code> 中，还定义了一些宏定义供我们使用，有些值我们会经常用到，如表示BOOL值的YES/NO；而有些值不常用，如<code>OBJC_ROOT_CLASS</code>。在此我们做一个简单的介绍。</p>
<h4 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define YES  (BOOL)1</span><br><span class="line">#define NO   (BOOL)0</span><br></pre></td></tr></table></figure>

<p>这两个宏定义定义了表示布尔值的常量，需要注意的是<code>YES</code>的值是1，而不是非0值。</p>
<h4 id="空值"><a href="#空值" class="headerlink" title="空值"></a>空值</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define nil  __DARWIN_NULL</span><br><span class="line">#define Nil  __DARWIN_NULL</span><br></pre></td></tr></table></figure>

<p>其中<code>nil</code>用于空的实例对象，而<code>Nil</code>用于空类对象。</p>
<h4 id="分发函数原型"><a href="#分发函数原型" class="headerlink" title="分发函数原型"></a>分发函数原型</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define OBJC_OLD_DISPATCH_PROTOTYPES  1</span><br></pre></td></tr></table></figure>

<p>该宏指明分发函数是否必须转换为合适的函数指针类型。当值为0时，必须进行转换</p>
<h4 id="Objective-C根类"><a href="#Objective-C根类" class="headerlink" title="Objective-C根类"></a>Objective-C根类</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define OBJC_ROOT_CLASS</span><br></pre></td></tr></table></figure>

<p>如果我们定义了一个<code>Objective-C</code>根类，则编译器会报错，指明我们定义的类没有指定一个基类。这种情况下，我们就可以使用这个宏定义来避过这个编译错误。该宏在iOS 7.0后可用。</p>
<p>其实在NSObject的声明中，我们就可以看到这个宏的身影，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">__OSX_AVAILABLE_STARTING(__MAC_10_0, __IPHONE_2_0)</span><br><span class="line"></span><br><span class="line">OBJC_ROOT_CLASS</span><br><span class="line">OBJC_EXPORT</span><br><span class="line"></span><br><span class="line">@interface NSObject &lt;NSObject&gt; &#123;</span><br><span class="line">    Class isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以参考这种方式来定义我们自己的根类。</p>
<h4 id="局部变量存储时长"><a href="#局部变量存储时长" class="headerlink" title="局部变量存储时长"></a>局部变量存储时长</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define NS_VALID_UNTIL_END_OF_SCOPE</span><br></pre></td></tr></table></figure>

<p>该宏表明存储在某些局部变量中的值在优化时不应该被编译器强制释放。</p>
<p>我们将局部变量标记为<code>id</code>类型或者是指向<code>ObjC</code>对象类型的指针，以便存储在这些局部变量中的值在优化时不会被编译器强制释放。相反，这些值会在变量再次被赋值之前或者局部变量的作用域结束之前都会被保存。</p>
<h4 id="关联对象行为"><a href="#关联对象行为" class="headerlink" title="关联对象行为"></a>关联对象行为</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">enum &#123;</span><br><span class="line">   OBJC_ASSOCIATION_ASSIGN  = 0,</span><br><span class="line">   OBJC_ASSOCIATION_RETAIN_NONATOMIC  = 1,</span><br><span class="line">   OBJC_ASSOCIATION_COPY_NONATOMIC  = 3,</span><br><span class="line">   OBJC_ASSOCIATION_RETAIN  = 01401,</span><br><span class="line">   OBJC_ASSOCIATION_COPY  = 01403</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="Objective-C-Runtime-实际应用"><a href="#Objective-C-Runtime-实际应用" class="headerlink" title="Objective-C Runtime 实际应用"></a>Objective-C Runtime 实际应用</h2><h3 id="动态交换两个方法的实现"><a href="#动态交换两个方法的实现" class="headerlink" title="动态交换两个方法的实现"></a>动态交换两个方法的实现</h3><p>当第三方框架或系统原生方法功能不能满足我们的需求的时候，可以通过交换方法实现在保持原有方法功能的基础上，添加额外的功能。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+ (void)load &#123;</span><br><span class="line">  Method originalMethod	= class_getClassMethod(self, @selector(originalMethodName));</span><br><span class="line">  Method targetMethod	= class_getClassMethod(self, @selector(targetMethodName));</span><br><span class="line">  method_exchangeImplementations(originalMethod, targetMethod);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="动态添加属性"><a href="#动态添加属性" class="headerlink" title="动态添加属性"></a>动态添加属性</h3><p>属性赋值的本质就是让属性与一个对象产生关联。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@interface NSObject (AssociatedProperty)</span><br><span class="line">  </span><br><span class="line">@property NSString *propertyName;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line">  </span><br><span class="line">@implementation NSObject (AssociatedProperty)</span><br><span class="line">  </span><br><span class="line">- (void)setPropertyName:(NSString *)stringValue &#123;</span><br><span class="line">	objc_setAssociatedObject(self, @&quot;propertyName&quot;, stringValue, OBJC_ASSOCIATION_RETAIN_NONATOMIC);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSString *)propertyName &#123;</span><br><span class="line">	return objc_getAssociatedObject(self, @&quot;propertyName&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>



<h3 id="实现字典转模型的动态转换"><a href="#实现字典转模型的动态转换" class="headerlink" title="实现字典转模型的动态转换"></a>实现字典转模型的动态转换</h3><p>利用 <code>Runtime</code> 遍历模型中所有属性，根据模型的属性名，去字典中查找 key，去除对应的值，给模型的属性赋值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 最简单实现，不考虑字典中含有数组或对象的情况</span><br><span class="line">+ (instancetype)modelWithDict:(NSDictionary *)dict &#123;</span><br><span class="line">  id objc				=	[[self alloc] init];</span><br><span class="line">  unsigned int count	=	0;</span><br><span class="line">  Ivar *ivarList		=	class_copyIvarList(self, &amp;count);</span><br><span class="line">  for (int index = 0; index &lt; count; index++) &#123;</span><br><span class="line">    Ivar ivar	= ivarList[index];</span><br><span class="line">    NSString *ivarName	=	[NSString stringWithUTF8String:ivar_getName(ivar)];</span><br><span class="line">    NSString *key		=	[ivarName substringFromIndex:1];</span><br><span class="line">    id value			=	dict[key];</span><br><span class="line">    if (value) &#123;</span><br><span class="line">      [objc setValue:value forKey:key];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return objc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="动态添加方法"><a href="#动态添加方法" class="headerlink" title="动态添加方法"></a>动态添加方法</h3><p>如果一个类的方法很多，加载类到内存的时候比较耗费资源，使用动态给类添加方法的方式可以解决。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void methodAddWhenRun(id self, SEL _cmd, id argument ···) &#123;&#125;</span><br><span class="line"></span><br><span class="line">+ (BOOL)resolveInstanceMethod:(SEL)self &#123;</span><br><span class="line">  if (sel ==  NSSelectorFromString(@&quot;methodAddWhenRun&quot;)) &#123;</span><br><span class="line">    class_addMethod(self, sel, (IMP)methodAddWhenRun, &quot;v@:@&quot;);</span><br><span class="line">    return YES;</span><br><span class="line">  &#125;</span><br><span class="line">  return [super resolveInstanceMethod:sel];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="动态变量控制"><a href="#动态变量控制" class="headerlink" title="动态变量控制"></a>动态变量控制</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 假设要修改 `_propertyName`</span><br><span class="line">unsigned int count = 0;</span><br><span class="line">Ivar *ivarList	=	class_copyIvarList([self class], &amp;count);</span><br><span class="line">for (int index = 0; index &lt; count; index++) &#123;</span><br><span class="line">  Ivar ivar		=	ivarList[index];</span><br><span class="line">  const char *varName	=	ivar_getName(ivar);</span><br><span class="line">  NSString *name		=	[NSString stringWithUTF8String:varName];</span><br><span class="line">  if ([name isEqualToString:@&quot;_propertyName&quot;]) &#123;</span><br><span class="line">    object_setIvar([self class], var, (id)newValue);</span><br><span class="line">    break;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="实现-NSCoding-的自动归解档"><a href="#实现-NSCoding-的自动归解档" class="headerlink" title="实现 NSCoding 的自动归解档"></a>实现 NSCoding 的自动归解档</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">- (void)encodeWithCoder:(NSCoder *)encoder &#123;</span><br><span class="line">  unsigned int count = 0;</span><br><span class="line">  Ivar *ivarList	 = class_copyIvarList([TargetClass class], &amp;count);</span><br><span class="line">  for (int index = 0; index &lt; count; index++) &#123;</span><br><span class="line">    Ivar ivar	=	ivarList[index];</span><br><span class="line">    const char *name	=	ivar_getName(ivar);</span><br><span class="line">    NSString *key		=	[NSString stringWithUTF8String:name];</span><br><span class="line">    id value			=	[self valueForKey:key];</span><br><span class="line">    [encoder encodObject:value forKey:key];</span><br><span class="line">  &#125;</span><br><span class="line">  free(ivarList);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (id)initWithCoder:(NSCoder *)decoder &#123;</span><br><span class="line">  if (self = [super init]) &#123;</span><br><span class="line">    unsigned int count = 0;</span><br><span class="line">    Ivar *ivarList	   = class_copyIvaarList([TargetClass class], &amp;count);</span><br><span class="line">    for (int index = 0; index &lt; count; index++) &#123;</span><br><span class="line">      Ivar ivar = ivarList[index];</span><br><span class="line">      const char *name	=	ivar_getName:(ivar);</span><br><span class="line">      NSString *key		=	[NSString stringWithUTF8String:name];</span><br><span class="line">      id value			=	[decoder decodeObjectForKey:key];</span><br><span class="line">      [self setValue:value forKey:key];</span><br><span class="line">    &#125;</span><br><span class="line">    free(ivarList);</span><br><span class="line">  &#125;</span><br><span class="line">  return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p><strong>转载整理自 <a target="_blank" rel="noopener" href="http://southpeak.github.io/categories/objectivec/">南风子的技术博客</a></strong></p>
</blockquote>
<blockquote>
<p>参考 <a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%8A%A8%E6%80%81%E8%AF%AD%E8%A8%80/797407?fr=aladdin">百度百科 动态语言</a></p>
</blockquote>
<blockquote>
<p>参考 <a target="_blank" rel="noopener" href="http://www.jianshu.com/p/19f280afcb24">白水ln的简书</a></p>
</blockquote>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2015-11-30T16:00:00.000Z" title="2015/12/1 上午12:00:00">2015-12-01</time>发表</span><span class="level-item"><a class="link-muted" href="/categories/iOS/">iOS</a></span><span class="level-item">13 分钟读完 (大约1954个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2015/12/01/iOS-Memory-Management/">内存管理理解与分析</a></h1><div class="content"><h1 id="iOS-内存管理"><a href="#iOS-内存管理" class="headerlink" title="iOS 内存管理"></a>iOS 内存管理</h1><h3 id="iOS-中的程序内存结构"><a href="#iOS-中的程序内存结构" class="headerlink" title="iOS 中的程序内存结构"></a>iOS 中的程序内存结构</h3><hr>
<p>在 iOS 程序中，内存可以粗略的分为五个区域：</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Descroption</th>
</tr>
</thead>
<tbody><tr>
<td>栈</td>
<td>由操作系统自动分配和释放，常用来存放函数的参数值、局部变量的值等。优点是快速高效，缺点是有限制，数据</td>
</tr>
<tr>
<td>堆</td>
<td>一般由程序员分配和释放，常用来存储对象</td>
</tr>
<tr>
<td>全局区</td>
<td>用来存储已经初始化的全局变量和静态变量，程序结束时才会被释放回收</td>
</tr>
<tr>
<td>常量区</td>
<td>用来存储常量的区域，程序结束时才会被释放回收</td>
</tr>
<tr>
<td>代码段</td>
<td>用来存放程序的执行代码，直到程序结束才会释放回首</td>
</tr>
</tbody></table>
<p>在 iOS程序中，只有堆区中存放的数据是需要手动释放回收的，其它区域存储的数据的释放和回收都由系统进行管理。当一个 iOS 程序启动后，它的全局区、常量区和代码区就已经确定了。</p>
<ul>
<li><p>栈区 (stack) 是由编译器自动分配和释放，用来存放函数的参数值、局部变量等。栈是系统数据结构，对应进程/线程是唯一的。优点是快速高效，缺点是有限制，数据不灵活。</p>
</li>
<li><p>堆区 (heap) 由程序员分配和释放，如果程序员不释放，程序结束时，可能由操作系统回收。优点是灵活方便，数据适应面广泛，但是效率有一定降低。</p>
</li>
<li><p>全局区/静态区 (static) 存放全局变量和静态变量，初始话的全局变量和静态变量存放在一块区域，未初始化的全局变量和静态变量在另一块区域，程序结束后由系统自动释放。</p>
</li>
<li><p>文字常量区，用来存储常量字符串，程序结束后由系统释放。</p>
</li>
<li><p>代码区，存放函数的二进制代码</p>
<p>​</p>
</li>
</ul>
<h3 id="iOS-中的内存管理"><a href="#iOS-中的内存管理" class="headerlink" title="iOS 中的内存管理"></a>iOS 中的内存管理</h3><hr>
<p>因为 iOS 程序的内存分配中，只有堆区是有程序员进行管理的，所以 iOS 的内存管理大致上就是可以认为是堆区内存的管理。</p>
<p>在 Objective-C 中，使用引用计数来确定一个对象所占有的内存空间是否应该被回收。它的工作原理可以描述为：</p>
<blockquote>
<p><strong>Objective-C 中的每一个对象都有一个类型为 unsigned long 的 retainCount 的属性，这个属性由拥有它的对象进行维护。当我们新创建出这个对象的一个实例时，这个对象实例的 retainCount 值为1，每当一个新的引用指向对象，对象的 retainCount 值就会增加1，每当这个对象实例的引用减少一个，retainCount 的值就减少1。当着对象实例的 retainCount 的值为0时，代表这个对象实例没有被引用，系统会自动将这个对象实例的内存空间回收并同时调用这个实例对象的 dealloc 方法。</strong></p>
</blockquote>
<p>需要注意的几个问题：</p>
<ul>
<li>常量是没有引用计数的</li>
<li>使用对象实例的属性值进行赋值，不会引用这个对象</li>
<li>释放对象实例时会调用 dealloc 方法，如果没有调用则会造成内存泄漏</li>
<li>对引用计数为1的对象实例发送 release 消息时，系统不会再对其进行 retainCount - 1 的操作。</li>
</ul>
<h4 id="MRC-和-ARC"><a href="#MRC-和-ARC" class="headerlink" title="MRC 和 ARC"></a>MRC 和 ARC</h4><p>使用对象实例的引用计数来进行 iOS的内存管理，分为两种方式：</p>
<ul>
<li>MRC ：手动引用计数，由程序员手动的管理对象实例的引用计数</li>
<li>ARC ：自动引用计数，是基于 MRC 的，系统自动的管理对象实例的引用计数</li>
</ul>
<p>实际上在 iOS 5 之后，Apple 就开始推荐使用 ARC 来进行 iOS 程序的内存管理工作，目前 MRC 已经非常少见。</p>
<p>ARC 中，编译器会在编译时在代码中插入合适的 retain 和 release 语句。</p>
<h5 id="ARC-中的修饰符"><a href="#ARC-中的修饰符" class="headerlink" title="ARC 中的修饰符"></a>ARC 中的修饰符</h5><p>ARC 中有四种修饰符</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>__strong</td>
<td>强引用，默认值，持有所指向对象的所有权</td>
</tr>
<tr>
<td>__weak</td>
<td>弱引用，不持有所指向对象的所有权，所指向的对象销毁后，引用会自动置为 nil</td>
</tr>
<tr>
<td>__autoreleasing</td>
<td>自动释放对象的引用，一般用来传递参数</td>
</tr>
<tr>
<td>__unsafe_unretained</td>
<td>为兼容 MRC 出现的修饰符，可看成 MRC 下的 weak</td>
</tr>
</tbody></table>
<h5 id="属性的内存管理"><a href="#属性的内存管理" class="headerlink" title="属性的内存管理"></a>属性的内存管理</h5><p>常见的属性修饰符</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>assign</td>
<td>直接赋值，一般用来修饰基本数据类型。修饰 Objc 对会造成野指针</td>
</tr>
<tr>
<td>retain</td>
<td>保留新值，再释放旧值，再设置新值</td>
</tr>
<tr>
<td>copy</td>
<td>拷贝新值，再释放旧值，再设置新值</td>
</tr>
<tr>
<td>weak</td>
<td>ARC 新引入，可代替 assign，自动置 nil</td>
</tr>
<tr>
<td>strong</td>
<td>ARC 新引入，可代替 retain</td>
</tr>
</tbody></table>
<h5 id="block-的内存管理"><a href="#block-的内存管理" class="headerlink" title="block 的内存管理"></a>block 的内存管理</h5><p>使用@property声明一个 block 时，使用 copy 来修饰。</p>
<p>block 会对内部使用的对象进行强应用，在使用时可能会造成循环引用，可通过添加弱引用标记来解决：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__weak typeof(self) weakSelf	=	self;</span><br></pre></td></tr></table></figure>

<h4 id="Autorelease-amp-AutoreleasePool"><a href="#Autorelease-amp-AutoreleasePool" class="headerlink" title="Autorelease &amp; AutoreleasePool"></a>Autorelease &amp; AutoreleasePool</h4><p>在实际的情境中，经常会遇到不知道一个对象实例再什么时候不再使用，因而造成不知道应该何时才能将其释放的情况。Objective-C 中提供了 autorelease 方法来解决这个问题。</p>
<p>当给一个对象实例发送 autorelease 消息时，它会被添加到合适的自动释放池中，当自动释放池销毁时，会给自动释放池中的所有对象实例发送 release 消息。</p>
<p><strong>autorelease 不会改变对象的引用计数。</strong></p>
<p>创建自动释放池的两种方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 1</span><br><span class="line">NSAutoreleasePool	*pool	=	[[NSAutoreleasePool alloc] init];</span><br><span class="line">[pool release];</span><br><span class="line">// 2</span><br><span class="line">@autoreleasepool &#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>值得注意的是自动释放池实质上只是在销毁时给其中的所有对象发送了 release 消息，并不保证对象一定会被销毁。</p>
<h3 id="内存管理问题和解决方案"><a href="#内存管理问题和解决方案" class="headerlink" title="内存管理问题和解决方案"></a>内存管理问题和解决方案</h3><h4 id="僵尸对象和野指针"><a href="#僵尸对象和野指针" class="headerlink" title="僵尸对象和野指针"></a>僵尸对象和野指针</h4><p>僵尸对象是指内存已经被回收的对象，而野指针是指向僵尸对象的指针。</p>
<p>向野指针发送消息会导致程序崩溃，就是经典的 : EXC_BAD_ACCESS 错误。</p>
<p>所以为了避免产生僵尸对象和野指针，在对象释放后，应将其指针置为 nil。</p>
<h4 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h4><p>当对象之间相互拥有彼此的强引用，形成闭环引用时，就称为循环引用。</p>
<p>循环引用会造成程序内存消耗过高、程序闪退等问题。</p>
<p>以下几种情况可能会造成循环引用：</p>
<ul>
<li><p>由于父类指针可以指向子类对象，当父类对象和子类对象相互引用时，就造成了循环引用</p>
</li>
<li><p>作为对象属性的 block 中强引用了对象，造成循环引用，解决方法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__weak typeof(self) weakSelf = self;</span><br><span class="line"> self.testObject.testCircleBlock = ^&#123;</span><br><span class="line">      __strong typeof (weakSelf) strongSelf = weakSelf;</span><br><span class="line">      [strongSelf doSomething];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 strong 修饰符修饰代理属性，造成循环引用</p>
</li>
<li><p>作为属性的 NSTimer，造成循环引用</p>
</li>
</ul>
<h4 id="循环中对象占用内存大"><a href="#循环中对象占用内存大" class="headerlink" title="循环中对象占用内存大"></a>循环中对象占用内存大</h4><p>常见于循环次数较大，循环体生成的对象占用内存较大的情景。</p>
<p>可通过在循环中创建自己的 autoreleasePool 或及时释放占用内存大的 临时变量来解决。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2015-11-19T16:00:00.000Z" title="2015/11/20 上午12:00:00">2015-11-20</time>发表</span><span class="level-item"><a class="link-muted" href="/categories/iOS/">iOS</a></span><span class="level-item">34 分钟读完 (大约5120个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2015/11/20/iOS-RunLoop/">RunLoop 探索与分析</a></h1><div class="content"><h2 id="RunLoop-基础"><a href="#RunLoop-基础" class="headerlink" title="RunLoop 基础"></a>RunLoop 基础</h2><h3 id="什么是RunLoop？"><a href="#什么是RunLoop？" class="headerlink" title="什么是RunLoop？"></a>什么是RunLoop？</h3><p>RunLoop 是一种让线程能随时处理事件但并不退出的机制，是一个用来调度工作的和协调接受的事件的循环。</p>
<p>iOS系统中，提供了 NSRunLoop 和 CFRunLoopRef 两个对象来实现 RunLoop。RunLoop 对象管理其需要处理的事件和消息，并提供了一个入口函数来执行事件循环的逻辑。线程执行了这个函数之后，就会一直处于这个函数内部的循环中，直到这个循环结束，函数返回。</p>
<p>CFRunLoopRef 是在 CoreFoundation 框架内的，提供了纯C函数的API，所有这些API都是线程安全的。</p>
<p>NSRunLoop 是基于 CFRunLoopRef 的封装，提供了面向对象的API，但这些API不是线程安全的。</p>
<h3 id="RunLoop与线程的关系"><a href="#RunLoop与线程的关系" class="headerlink" title="RunLoop与线程的关系"></a>RunLoop与线程的关系</h3><p>线程和 RunLoop 之间是一一对应的，其关系保存在一个全局的 Dictionary 中。线程刚创建是并没有 RunLoop，如果你不主动获取，那它一直不会有。RunLoop 的创建是在第一次获取时发生的，RunLoop 的销毁是在线程结束时发生的。</p>
<p>你只能在一个线程内部获取它的 RunLoop(主线程除外)。</p>
<h3 id="RunLoop的对外接口"><a href="#RunLoop的对外接口" class="headerlink" title="RunLoop的对外接口"></a>RunLoop的对外接口</h3><p>在 CoreFoundation 中关于 RunLoop 的类有以下几个：</p>
<ul>
<li>CFRunLoopRef</li>
<li>CFRunLoopModeRef</li>
<li>CFRunLoopSourceRef</li>
<li>CFRunLoopTImerRef</li>
<li>CFRunLoopObserverRef</li>
</ul>
<p>一个 RunLoop 包含若干个 Mode ，每个 Mode 又包含若干个 Source/Timer/Observer。每次调用 RunLoop 的主函数时，只能指定其中一个 Mode。如果需要切换 Mode ，只能退出 RunLoop，再重新指定一个 Mode 进入。这样做的目的是为了分隔开不同组的 Source/Timer/Observer，使其不能互相影响。</p>
<p>CFRunLoopSourceRef 是事件产生的地方，有两个版本 Source0 和 Source1：</p>
<ul>
<li>Source0 只包含了一个回调(函数指针)，它并不能主动触发事件。使用时，你需要先调用 CFRunLoopSourceSignal(source)，将这个 Source 标记为待处理，然后手动调用 CFRunLoopWakeUp(runLoop) 来唤醒 RunLoop ，让其处理这个事件。</li>
<li>Source1 包含了一个 mach_port 和一个回调(函数指针)，被用于通过内核和其它线程相互发送消息，它能主动唤醒 RunLoop 的线程。</li>
</ul>
<p>CFRunLoopTimerRef 是基于时间的触发器，他和 NSTimer 是 toll-free bridge 的，可以混用。包含一个时间长度和一个回调(函数指针)。当其加入到 RunLoop 中时，RunLoop 会注册对应的时间点，当时间点到时，RunLoop 会被唤醒执行那个回调。</p>
<p>CFRunLoopObserverRef 是观察者，每个 Observer 都包含了一个回调(函数指针)，当 RunLoop的状态发生变化时，观察者就能通过回调接收到这个变化。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActiviry) &#123;</span><br><span class="line">	kCFRunLoopEntry			=	(1UL &lt;&lt; 0),	// 即将进入 RunLoop</span><br><span class="line">  	kCFRunLoopBeforeTimers	=	(1UL &lt;&lt; 1), // 即将处理 Timer</span><br><span class="line">    kCFRunLoopBeforeSources	=	(1UL &lt;&lt; 2), // 即将处理 Source</span><br><span class="line">  	kCFRunLoopBeforeWaiting	=	(1UL &lt;&lt; 5), // 即将进入休眠</span><br><span class="line">    kCFRunLoopAfterWaiting	=	(1UL &lt;&lt; 6), // 刚从休眠中唤醒</span><br><span class="line">    kCFRunLoopExit			=	(1UL &lt;&lt; 7), // 即将退出 RunLoop</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Source/Timer/Observer 被统称为 Mode Item，一个 item 可以被同时加入多个 Mode。但是一个item被重复加入一个 Mode 不会产生效果。如果一个 Mode 中没有一个 item，则 RunLoop会直接退出，不进入循环。</p>
<h3 id="RunLoop-的Mode"><a href="#RunLoop-的Mode" class="headerlink" title="RunLoop 的Mode"></a>RunLoop 的Mode</h3><p>CFRunLoopMode 和 CFRunLoop 的结构大致如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">CFRunLoopMode</span> &#123;</span></span><br><span class="line">	CFStringRef			_name;</span><br><span class="line">  	CFMutableSetRef		_source0;</span><br><span class="line">  	CFMutableSetRef		_source1;</span><br><span class="line">  	CFMutableArrayRef	_observers;</span><br><span class="line">  	CFMutableArrayRef	_timers;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struce __CFRunLoop &#123;</span><br><span class="line">	CFMutableSetRef		_commonModes;</span><br><span class="line">  	CFMutableSetRef		_commonModeItems;</span><br><span class="line">  	CFRunLoopModeRef	_currentMode;</span><br><span class="line">  	CFMutableSetRef		_modes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个 Mode 可以将自己标记为 “Common” 属性(通过将其 ModeName 添加到 RunLoop 的 “CommonModes”中)。每当 RunLoop 的内容发生变化时，RunLoop 都会自动将 _commonModeItmes 里的 Source/Observer/Timer 同步到具有 “Common” 标记的所有 Mode 里。</p>
<p>CFRunLoop对外暴露的管理 Mode 的接口只有两个：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CFRunLoopAddCommonMode(CFRunLoopRef runloop, CFStringRef modeName);</span><br><span class="line">CFRunLoopRunInMode(CFStringRef modeName);</span><br></pre></td></tr></table></figure>

<p>CFRunLoopModeRef 暴露的管理 Mode Item 接口有：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CFRunLoopAddSource(CFRunLoopRef runloop, CFRunLoopSourceRef source, CFStringRef modeName);</span><br><span class="line">CFRunLoopAddObserver(CFRunLoopRef runloop, CFRunLoopObserverRef observer, CFStringRef modeName);</span><br><span class="line">CFRunLoopAddTimer(CFRunLoopRef runloop, CFRunLoopTimerRef timer, CFStringRef modeName);</span><br><span class="line">CFRunLoopRemoveSource(CFRunLoopRef runloop, CFRunLoopSourceRef source, CFStringRef modeName);</span><br><span class="line">CFRunLoopRemoveObserver(CFRunLoopRef runloop, CFRunLoopObserverRef observer, CFStringRef modeName);</span><br><span class="line">CFRunLoopRemoveTimer(CFRunLoopRef runloop, CFRunLoopTimerRef timer, CFStringRef modeName);</span><br></pre></td></tr></table></figure>

<p>你只能通过 mode name 来操作内部的 mode，当你传入一个新的 mode name 时但 RunLoop内部没有对应的 mode 时，RunLoop 会自动的帮你创建对应的 CFRunLoopModeRef。对于一个 RunLoop ，其内部的 mode 只能添加不能删除。</p>
<p>Apple公开提供的 Mode 只有两个：kCFRunLoopDefaultMode(NSDefaultRunLoopMode) 和 UITrackingRunLoopMode，你可以用这两个 Mode Name 来操作其对应的 Mode。</p>
<p>同时 Apple 还提供了一个操作 Common 标记的字符串 : kCFRunLoopModes(NSDefaultRunLoopCommonModes)，你可以用这个字符串来操作 Common Items，或标记一个 Mode 为 “Common”。使用时要注意区分这个字符串和其它 Mode Name。</p>
<h3 id="RunLoop-的内部逻辑"><a href="#RunLoop-的内部逻辑" class="headerlink" title="RunLoop 的内部逻辑"></a>RunLoop 的内部逻辑</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">// DefaultMode 启动</span><br><span class="line">void CFRunLoopRun(void) &#123;</span><br><span class="line">  CFRunLoopRunSpecific(CFRunLoopGetCurrent(),kCFRunLoopDefaultMode, 1.0e10, false);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 用指定的 Mode 启动，允许设置 RunLoop 超时时间</span><br><span class="line">int CFRunLoopRunInMode(CFStringRef ModeName, CFTimeInterval seconds, Boolean stopAfterHandle) &#123;</span><br><span class="line">  return CFRunLoopSpecific(CFRunLoopGetCurrent(), modeName , seconds ,returnAfterSourceHandle)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// RunLoop 的实现</span><br><span class="line">int CFRunLoopRunSpecific(runloop, modeName ,seconds , stopeAfterHandle) &#123;</span><br><span class="line">  // 根据 ModeName 找到对应 Mode</span><br><span class="line">  CFRunLoopModeRef currentMode = __CFRunLoopFinMode(runloop, modeName, false);</span><br><span class="line">  // 如果 Mode 里没有 source/timer/observer，直接返回</span><br><span class="line">  if (__CFRunLoopModeIsEmpty(currentMode)) &#123;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  // 通知 Observer , RunLoop 即将进入 loop</span><br><span class="line">  __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopEntry);</span><br><span class="line">  // 进入 loop</span><br><span class="line">  __CFRunLoopRun(runloop, currentMode, seconds, returnAfterSourceHandle) &#123;</span><br><span class="line">    Boolean sourceHandledThisLoop	=	NO;</span><br><span class="line">    int retVal	=	0;</span><br><span class="line">    do &#123;</span><br><span class="line">      // 通知 Observers : RunLoop 即将触发 Timer 回调</span><br><span class="line">      __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeTimers);</span><br><span class="line">      // 通知 Observers : RunLoop 即将触发 Source0 (非port) 回调</span><br><span class="line">      __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeSources);</span><br><span class="line">      // 执行被加入的 block</span><br><span class="line">      __CFRunLoopDoBlocks(runloop, currentMode);</span><br><span class="line">      // RunLoop 触发 Source0(非port) 回调</span><br><span class="line">      sourceHandledThisLoop	=	__CFRunLoopDoSource0(runloop, currentMode, stopAfterHandele);</span><br><span class="line">      // 执行被加入的 block</span><br><span class="line">      __CFRunLoopDoBlocks(runloop, currentMode);</span><br><span class="line">      </span><br><span class="line">      // 如果有 Source1 处于 ready 状态，直接处理这个 Source1 然后跳转去处理消息</span><br><span class="line">      if (__Source0DidDispatchPortLastTime) &#123;</span><br><span class="line">        Boolean hasMsg	=	__CFRunLoopServiceMachPort(dispatchPort, &amp;msg);</span><br><span class="line">        if (hasMsg)</span><br><span class="line">        &#123;</span><br><span class="line">          goto handle_msg;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      // 通知 Observers : RunLoop 的线程即将结束进入休眠(Sleep)</span><br><span class="line">      if (!sourceHandleThisLoop) &#123;</span><br><span class="line">        __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeWaiting);</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      // 调用 mach_msg 等待接受 mach_port 的消息。线程进入休眠，直到被下面一个事件唤醒</span><br><span class="line">      // 1.一个基于 port 的 Source 的事件</span><br><span class="line">      // 2.一个 Timer 时间到了</span><br><span class="line">      // 3.RunLoop 自身的超时时间到了</span><br><span class="line">      // 4.被其它调用者手动唤醒了</span><br><span class="line">      __CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort) &#123;</span><br><span class="line">        mach_msg(msg, MACH_RCV_MSG, port);</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      // 通知 Observers : RunLoop 的线程刚刚被唤醒了</span><br><span class="line">      __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopAfterWaiting);</span><br><span class="line">      </span><br><span class="line">      // 收到消息，处理消息</span><br><span class="line">      handle_msg;</span><br><span class="line">      </span><br><span class="line">      // 如果一个 Timer 的时间到了，触发这个 Timer 的回调</span><br><span class="line">      if (msg_is_timer) &#123;</span><br><span class="line">        __CFRunLoopDoTimers(runloop, currentMode, mach_absolute_time());</span><br><span class="line">      &#125; else if (msg_is_dispatch) &#123;</span><br><span class="line">      // 如果有 dispatch 到  main_queue 的 block ，执行 block  </span><br><span class="line">        __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE_(msg);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">      // 如果有一个 Source1 发出事件了， 处理这个事件</span><br><span class="line">        CFRunLoopSourceRef	source1	=	__CFRunLoopModeFindSourceForMachPort(runloop, currentMode, livePort);</span><br><span class="line">        sourceHandleThisLoop	=	__CFRunLoopDoSource1(runloop, currentMode, source1,  msg);</span><br><span class="line">        if (sourceHandleThisLoop) &#123;</span><br><span class="line">          mach_msg(reply, MACH_SEND_MSG, reply);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      // 执行加入到 Loop 的 block</span><br><span class="line">      __CFRunLoopDoBlocks(runloop, currentMode);</span><br><span class="line">      </span><br><span class="line">      if (sourceHandleThisLoop &amp;&amp; stopAfterHandle) &#123;</span><br><span class="line">        // 进入 loop 时参数说处理完事件就返回</span><br><span class="line">        retVal	=	kCFRunLoopRunHandledSource;</span><br><span class="line">      &#125; else if (timeOut) &#123;</span><br><span class="line">        // 超出传入参数标记的超时时间了</span><br><span class="line">        retVal	=	kCFRunLoopRunTimeOut;</span><br><span class="line">      &#125; else if (__CFRunLoopIsStoped(runloop)) &#123;</span><br><span class="line">        // 被外部调用者强行停止了</span><br><span class="line">        retVal	=	kCFRunLoopRunStoped;</span><br><span class="line">      &#125; else if (__CFRunLoopModeIsEmpty(runloop, currentMode)) &#123;</span><br><span class="line">        // Source/Timer/Observer 一个都没有了</span><br><span class="line">        retVal	=	kCFRunLoopRunFinished;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      // 如果没超时，mode 里没空， loop 也没有被停止，那就继续 loop</span><br><span class="line">    &#125; while (retVal == 0)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="RunLoop有什么用？"><a href="#RunLoop有什么用？" class="headerlink" title="RunLoop有什么用？"></a>RunLoop有什么用？</h2><p>App 启动后 RunLoop 的状态 ：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">CFRunLoop &#123;</span><br><span class="line">    current mode = kCFRunLoopDefaultMode</span><br><span class="line">    common modes = &#123;</span><br><span class="line">        UITrackingRunLoopMode</span><br><span class="line">        kCFRunLoopDefaultMode</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    common mode items = &#123;</span><br><span class="line">  </span><br><span class="line">        // source0 (manual)</span><br><span class="line">        CFRunLoopSource &#123;order =-1, &#123;</span><br><span class="line">            callout = _UIApplicationHandleEventQueue&#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;order =-1, &#123;</span><br><span class="line">            callout = PurpleEventSignalCallback &#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;order = 0, &#123;</span><br><span class="line">            callout = FBSSerialQueueRunLoopSourceHandler&#125;&#125;</span><br><span class="line">  </span><br><span class="line">        // source1 (mach port)</span><br><span class="line">        CFRunLoopSource &#123;order = 0,  &#123;port = 17923&#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;order = 0,  &#123;port = 12039&#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;order = 0,  &#123;port = 16647&#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;order =-1, &#123;</span><br><span class="line">            callout = PurpleEventCallback&#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;order = 0, &#123;port = 2407,</span><br><span class="line">            callout = _ZL20notify_port_callbackP12__CFMachPortPvlS1_&#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;order = 0, &#123;port = 1c03,</span><br><span class="line">            callout = __IOHIDEventSystemClientAvailabilityCallback&#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;order = 0, &#123;port = 1b03,</span><br><span class="line">            callout = __IOHIDEventSystemClientQueueCallback&#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;order = 1, &#123;port = 1903,</span><br><span class="line">            callout = __IOMIGMachPortPortCallback&#125;&#125;</span><br><span class="line">  </span><br><span class="line">        // Ovserver</span><br><span class="line">        CFRunLoopObserver &#123;order = -2147483647, activities = 0x1, // Entry</span><br><span class="line">            callout = _wrapRunLoopWithAutoreleasePoolHandler&#125;</span><br><span class="line">        CFRunLoopObserver &#123;order = 0, activities = 0x20,          // BeforeWaiting</span><br><span class="line">            callout = _UIGestureRecognizerUpdateObserver&#125;</span><br><span class="line">        CFRunLoopObserver &#123;order = 1999000, activities = 0xa0,    // BeforeWaiting | Exit</span><br><span class="line">            callout = _afterCACommitHandler&#125;</span><br><span class="line">        CFRunLoopObserver &#123;order = 2000000, activities = 0xa0,    // BeforeWaiting | Exit</span><br><span class="line">            callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv&#125;</span><br><span class="line">        CFRunLoopObserver &#123;order = 2147483647, activities = 0xa0, // BeforeWaiting | Exit</span><br><span class="line">            callout = _wrapRunLoopWithAutoreleasePoolHandler&#125;</span><br><span class="line">  </span><br><span class="line">        // Timer</span><br><span class="line">        CFRunLoopTimer &#123;firing = No, interval = 3.1536e+09, tolerance = 0,</span><br><span class="line">            next fire date = 453098071 (-4421.76019 @ 96223387169499),</span><br><span class="line">            callout = _ZN2CAL14timer_callbackEP16__CFRunLoopTimerPv (QuartzCore.framework)&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  </span><br><span class="line">    modes ＝ &#123;</span><br><span class="line">        CFRunLoopMode  &#123;</span><br><span class="line">            sources0 =  &#123; /* same as &#x27;common mode items&#x27; */ &#125;,</span><br><span class="line">            sources1 =  &#123; /* same as &#x27;common mode items&#x27; */ &#125;,</span><br><span class="line">            observers = &#123; /* same as &#x27;common mode items&#x27; */ &#125;,</span><br><span class="line">            timers =    &#123; /* same as &#x27;common mode items&#x27; */ &#125;,</span><br><span class="line">          	</span><br><span class="line">        CFRunLoopMode  &#123;</span><br><span class="line">            sources0 =  &#123; /* same as &#x27;common mode items&#x27; */ &#125;,</span><br><span class="line">            sources1 =  &#123; /* same as &#x27;common mode items&#x27; */ &#125;,</span><br><span class="line">            observers = &#123; /* same as &#x27;common mode items&#x27; */ &#125;,</span><br><span class="line">            timers =    &#123; /* same as &#x27;common mode items&#x27; */ &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">  </span><br><span class="line">        CFRunLoopMode  &#123;</span><br><span class="line">            sources0 = &#123;</span><br><span class="line">                CFRunLoopSource &#123;order = 0, &#123;</span><br><span class="line">                    callout = FBSSerialQueueRunLoopSourceHandler&#125;&#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            sources1 = (null),</span><br><span class="line">            observers = &#123;</span><br><span class="line">                CFRunLoopObserver &gt;&#123;activities = 0xa0, order = 2000000,</span><br><span class="line">                    callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv&#125;</span><br><span class="line">            )&#125;,</span><br><span class="line">            timers = (null),</span><br><span class="line">        &#125;,</span><br><span class="line">  </span><br><span class="line">        CFRunLoopMode  &#123;</span><br><span class="line">            sources0 = &#123;</span><br><span class="line">                CFRunLoopSource &#123;order = -1, &#123;</span><br><span class="line">                    callout = PurpleEventSignalCallback&#125;&#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            sources1 = &#123;</span><br><span class="line">                CFRunLoopSource &#123;order = -1, &#123;</span><br><span class="line">                    callout = PurpleEventCallback&#125;&#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            observers = (null),</span><br><span class="line">            timers = (null),</span><br><span class="line">        &#125;,</span><br><span class="line">         </span><br><span class="line">        CFRunLoopMode  &#123;</span><br><span class="line">            sources0 = (null),</span><br><span class="line">            sources1 = (null),</span><br><span class="line">            observers = (null),</span><br><span class="line">            timers = (null),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>系统注册了五个默认的 Mode：</p>
<p>1.kCFRunLoopDefaultMode ：App 的默认 Mode，通常主线程就是在这个 Mode 下运行的。</p>
<p>2.UITrackingRunLoopMode : 界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其它 Mode 影响。</p>
<p>3.UIInitializationRunLoopMode ：在刚启动 App 时进入的第一个 Mode，启动完成后就不再使用。</p>
<p>4.GSEventReceiveRunLoopMode ：接受系统事件的内部 Mode，通常用不到。</p>
<p>5.kCFRunLoopCommonModes ：这是一个占位的 Mode，没有实际作用。</p>
<p>当 RunLoop 进行回调时，一般都是通过一个很长的函数调用出去(call out)，当你在你的代码中下断点时，通常能在调用栈中看到这些函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    /// 1. 通知Observers，即将进入RunLoop</span><br><span class="line">    /// 此处有Observer会创建AutoreleasePool: _objc_autoreleasePoolPush();</span><br><span class="line">    __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopEntry);</span><br><span class="line">    do &#123;</span><br><span class="line">  </span><br><span class="line">        /// 2. 通知 Observers: 即将触发 Timer 回调。</span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeTimers);</span><br><span class="line">        /// 3. 通知 Observers: 即将触发 Source (非基于port的,Source0) 回调。</span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeSources);</span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__(block);</span><br><span class="line">  </span><br><span class="line">        /// 4. 触发 Source0 (非基于port的) 回调。</span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__(source0);</span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__(block);</span><br><span class="line">  </span><br><span class="line">        /// 6. 通知Observers，即将进入休眠</span><br><span class="line">        /// 此处有Observer释放并新建AutoreleasePool: _objc_autoreleasePoolPop(); _objc_autoreleasePoolPush();</span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeWaiting);</span><br><span class="line">  </span><br><span class="line">        /// 7. sleep to wait msg.</span><br><span class="line">        mach_msg() -&gt; mach_msg_trap();</span><br><span class="line">         </span><br><span class="line">  </span><br><span class="line">        /// 8. 通知Observers，线程被唤醒</span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopAfterWaiting);</span><br><span class="line">  </span><br><span class="line">        /// 9. 如果是被Timer唤醒的，回调Timer</span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__(timer);</span><br><span class="line">  </span><br><span class="line">        /// 9. 如果是被dispatch唤醒的，执行所有调用 dispatch_async 等方法放入main queue 的 block</span><br><span class="line">        __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(dispatched_block);</span><br><span class="line">  </span><br><span class="line">        /// 9. 如果如果Runloop是被 Source1 (基于port的) 的事件唤醒了，处理这个事件</span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__(source1);</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    &#125; while (...);</span><br><span class="line">  </span><br><span class="line">    /// 10. 通知Observers，即将退出RunLoop</span><br><span class="line">    /// 此处有Observer释放AutoreleasePool: _objc_autoreleasePoolPop();</span><br><span class="line">    __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopExit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AutoreleasePool"><a href="#AutoreleasePool" class="headerlink" title="AutoreleasePool"></a>AutoreleasePool</h3><p>App 启动后，Apple 在主线程的 RunLoop 里注册了两个 Observer，其回调都是 _wrapRunLoopWithAutoreleasePoolHandler()。</p>
<p>第一个 Observer 监视的事件是 Entry(即将进入 Loop)，其回调内会调用 _objc_autoreleasePoolPush() 创建自动释放池，优先级最高，保证创建释放池发生在其它所有回调之前。</p>
<p>第二个 Observer 监视了两个事件：BeforeWaiting(准备进入休眠)时调用 _objc_autoreleasePoolPop() 和 _objc_auroreleasePoolPush() 释放旧的池并创建新池。Exit(即将退出Loop)时调用 _objc_autoreleasePoolPop() 来释放自动释放池，优先级最低，保证其释放发生在其它所有回调之后。</p>
<p>在主线程执行的代码，通常是写在诸如事件回调、Timer 回调内的。这些回调会被 RunLoop 创建好的 AutoreleasePool 环绕着，所以不会出现内存泄漏。</p>
<h3 id="事件响应"><a href="#事件响应" class="headerlink" title="事件响应"></a>事件响应</h3><p>Apple 注册了一个 Source1 (基于 mach port) 用来接收系统事件，其回调函数为 __IOHIDEventSystemClientQueueCallBack()。</p>
<p>当一个硬件事件发生后，首先由 IOKit.framework 生成一个 IOHIDEvent 事件并由 SpringBoard 接收。SpingBoard 只接收按键、触摸、加速、接近传感器等几种 Event，随后用 mach port 转发给需要的 App 进程。随后 Apple 注册的那个 Source1 就会触发回调，并调用 _UIApplicationHandleEventQueue() 进行应用内的分发。</p>
<p>_UIApplicationHandleEventQueue() 会把 IOHIDEvent 处理并包装成 UIEvent 进行处理或分发，其中包括识别 UIGesture、处理屏幕旋转、发送给 UIWindow等。通常事件比如 UIButton 点击、touchesBegin/Move/End/Cancle 事件都是在这个回调中完成的。</p>
<h3 id="手势识别"><a href="#手势识别" class="headerlink" title="手势识别"></a>手势识别</h3><p>当 _UIApplicationHandleEventQueue() 识别了一个手势时，其首先会调用 Cancel 将当前的 touchesBegin/Move/End 系列回调打断。随后系统将对应的 UIGestureRecognizer 标记为待处理。</p>
<p>Apple 注册了一个 Observer 检测 BeforeWaiting 事件，这个 Observer 的回调函数是 _UIGestureRecognizerUpdateObsever(), 其内部会获取所有刚被标记为待处理的 GestureRecognizer，并执行 GestureRecognizer 的回调。</p>
<p>当有 UIGestureRecognizer 的变化(创建/销毁/状态改变)时，这个回调都会进行相应处理。</p>
<h3 id="界面更新"><a href="#界面更新" class="headerlink" title="界面更新"></a>界面更新</h3><p>当在操作 UI 时，比如改变了 Frame、更新了 UIView/CALayer 的层次时，或者手动调用了 UIView/CALayer 的 setNeedsLayout/setNeedsDisplay方法后，这个 UIView/CALayer 就被标记为待处理，并被提交到一个全局的容器去。</p>
<p>苹果注册了一个 Observer 监听 BeforeWaiting(即将进入休眠) 和 Exit (即将退出Loop) 事件，回调去执行一个很长的函数：</p>
<p>_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()。这个函数里会遍历所有待处理的 UIView/CAlayer 以执行实际的绘制和调整，并更新 UI 界面。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()</span><br><span class="line">    QuartzCore:CA::Transaction::observer_callback:</span><br><span class="line">        CA::Transaction::commit();</span><br><span class="line">            CA::Context::commit_transaction();</span><br><span class="line">                CA::Layer::layout_and_display_if_needed();</span><br><span class="line">                    CA::Layer::layout_if_needed();</span><br><span class="line">                        [CALayer layoutSublayers];</span><br><span class="line">                            [UIView layoutSubviews];</span><br><span class="line">                    CA::Layer::display_if_needed();</span><br><span class="line">                        [CALayer display];</span><br><span class="line">                            [UIView drawRect];</span><br></pre></td></tr></table></figure>

<h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><p>NSTimer 其实就是 CFRunLoopTimerRef，他们之间是 toll-free bridged 的。一个 NSTimer 注册到 RunLoop 后，RunLoop 会为其重复的时间点注册好事件。例如 10:00, 10:10, 10:20 这几个时间点。RunLoop为了节省资源，并不会在非常准确的时间点回调这个Timer。Timer 有个属性叫做 Tolerance (宽容度)，标示了当时间点到后，容许有多少最大误差。</p>
<p>如果某个时间点被错过了，例如执行了一个很长的任务，则那个时间点的回调也会跳过去，不会延后执行。就比如等公交，如果 10:10 时我忙着玩手机错过了那个点的公交，那我只能等 10:20 这一趟了。</p>
<p>CADisplayLink 是一个和屏幕刷新率一致的定时器（但实际实现原理更复杂，和 NSTimer 并不一样，其内部实际是操作了一个 Source）。如果在两次屏幕刷新之间执行了一个长任务，那其中就会有一帧被跳过去（和 NSTimer 相似），造成界面卡顿的感觉。在快速滑动TableView时，即使一帧的卡顿也会让用户有所察觉。Facebook 开源的 AsyncDisplayLink 就是为了解决界面卡顿的问题，其内部也用到了 RunLoop。</p>
<h3 id="PerformSelector"><a href="#PerformSelector" class="headerlink" title="PerformSelector"></a>PerformSelector</h3><p>当调用 NSObject 的 performSelecter:afterDelay: 后，实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 中。所以如果当前线程没有 RunLoop，则这个方法会失效。</p>
<p>当调用 performSelector:onThread: 时，实际上其会创建一个 Timer 加到对应的线程去，同样的，如果对应线程没有 RunLoop 该方法也会失效。</p>
<h3 id="关于GCD"><a href="#关于GCD" class="headerlink" title="关于GCD"></a>关于GCD</h3><p>实际上 RunLoop 底层也会用到 GCD 的东西，比如 RunLoop 是用 dispatch_source_t 实现的 Timer。但同时 GCD 提供的某些接口也用到了 RunLoop， 例如 dispatch_async()。</p>
<p>当调用 dispatch_async(dispatch_get_main_queue(), block) 时，libDispatch 会向主线程的 RunLoop 发送消息，RunLoop会被唤醒，并从消息中取得这个 block，并在回调 <strong>CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE</strong>() 里执行这个 block。但这个逻辑仅限于 dispatch 到主线程，dispatch 到其他线程仍然是由 libDispatch 处理的。</p>
<h3 id="关于网络请求"><a href="#关于网络请求" class="headerlink" title="关于网络请求"></a>关于网络请求</h3><p>iOS 中，关于网络请求的接口自下至上有如下几层:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CFSocket</span><br><span class="line">CFNetwork       -&gt;ASIHttpRequest</span><br><span class="line">NSURLConnection -&gt;AFNetworking</span><br><span class="line">NSURLSession    -&gt;AFNetworking2, Alamofire</span><br></pre></td></tr></table></figure>

<ul>
<li>CFSocket 是最底层的接口，只负责 socket 通信。</li>
<li>CFNetwork 是基于 CFSocket 等接口的上层封装，ASIHttpRequest 工作于这一层。</li>
<li>NSURLConnection 是基于 CFNetwork 的更高层的封装，提供面向对象的接口，AFNetworking 工作于这一层。</li>
<li>NSURLSession 是 iOS7 中新增的接口，表面上是和 NSURLConnection 并列的，但底层仍然用到了 NSURLConnection 的部分功能 (比如 com.apple.NSURLConnectionLoader 线程)，AFNetworking2 和 Alamofire 工作于这一层。</li>
</ul>
<p>通常使用 NSURLConnection 时，你会传入一个 Delegate，当调用了 [connection start] 后，这个 Delegate 就会不停收到事件回调。实际上，start 这个函数的内部会会获取 CurrentRunLoop，然后在其中的 DefaultMode 添加了4个 Source0 (即需要手动触发的Source)。CFMultiplexerSource 是负责各种 Delegate 回调的，CFHTTPCookieStorage 是处理各种 Cookie 的。</p>
<p>当开始网络传输时，我们可以看到 NSURLConnection 创建了两个新线程：com.apple.NSURLConnectionLoader 和 com.apple.CFSocket.private。其中 CFSocket 线程是处理底层 socket 连接的。NSURLConnectionLoader 这个线程内部会使用 RunLoop 来接收底层 socket 的事件，并通过之前添加的 Source0 通知到上层的 Delegate。</p>
<p>NSURLConnectionLoader 中的 RunLoop 通过一些基于 mach port 的 Source 接收来自底层 CFSocket 的通知。当收到通知后，其会在合适的时机向 CFMultiplexerSource 等 Source0 发送通知，同时唤醒 Delegate 线程的 RunLoop 来让其处理这些通知。CFMultiplexerSource 会在 Delegate 线程的 RunLoop 对 Delegate 执行实际的回调。</p>
<h2 id="RunLoop-怎么用？"><a href="#RunLoop-怎么用？" class="headerlink" title="RunLoop 怎么用？"></a>RunLoop 怎么用？</h2><h3 id="AFNetWorking"><a href="#AFNetWorking" class="headerlink" title="AFNetWorking"></a>AFNetWorking</h3><p><a target="_blank" rel="noopener" href="https://github.com/AFNetworking/AFNetworking/blob/master/AFNetworking%2FAFURLConnectionOperation.m">AFURLConnectionOperation</a> 这个类是基于 NSURLConnection 构建的，其希望能在后台线程接收 Delegate 回调。为此 AFNetworking 单独创建了一个线程，并在这个线程中启动了一个 RunLoop：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">+ (void)networkRequestThreadEntryPoint:(id)__unused object &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        [[NSThread currentThread] setName:@&quot;AFNetworking&quot;];</span><br><span class="line">        NSRunLoop *runLoop = [NSRunLoop currentRunLoop];</span><br><span class="line">        [runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode];</span><br><span class="line">        [runLoop run];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">+ (NSThread *)networkRequestThread &#123;</span><br><span class="line">    static NSThread *_networkRequestThread = nil;</span><br><span class="line">    static dispatch_once_t oncePredicate;</span><br><span class="line">    dispatch_once(&amp;oncePredicate, ^&#123;</span><br><span class="line">        _networkRequestThread = [[NSThread alloc] initWithTarget:self selector:@selector(networkRequestThreadEntryPoint:) object:nil];</span><br><span class="line">        [_networkRequestThread start];</span><br><span class="line">    &#125;);</span><br><span class="line">    return _networkRequestThread;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>RunLoop 启动前内部必须要有至少一个 Timer/Observer/Source，所以 AFNetworking 在 [runLoop run] 之前先创建了一个新的 NSMachPort 添加进去了。通常情况下，调用者需要持有这个 NSMachPort (mach_port) 并在外部线程通过这个 port 发送消息到 loop 内；但此处添加 port 只是为了让 RunLoop 不至于退出，并没有用于实际的发送消息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (void)start &#123;</span><br><span class="line">    [self.lock lock];</span><br><span class="line">    if ([self isCancelled]) &#123;</span><br><span class="line">        [self performSelector:@selector(cancelConnection) onThread:[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]];</span><br><span class="line">    &#125; else if ([self isReady]) &#123;</span><br><span class="line">        self.state = AFOperationExecutingState;</span><br><span class="line">        [self performSelector:@selector(operationDidStart) onThread:[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]];</span><br><span class="line">    &#125;</span><br><span class="line">    [self.lock unlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当需要这个后台线程执行任务时，AFNetworking 通过调用 [NSObject performSelector:onThread:..] 将这个任务扔到了后台线程的 RunLoop 中。</p>
<h3 id="AsyncDisplayKit"><a href="#AsyncDisplayKit" class="headerlink" title="AsyncDisplayKit"></a>AsyncDisplayKit</h3><p><a target="_blank" rel="noopener" href="https://github.com/facebook/AsyncDisplayKit">AsyncDisplayKit</a> 是 Facebook 推出的用于保持界面流畅性的框架，其原理大致如下：</p>
<p>UI 线程中一旦出现繁重的任务就会导致界面卡顿，这类任务通常分为3类：排版，绘制，UI对象操作。</p>
<p>排版通常包括计算视图大小、计算文本高度、重新计算子式图的排版等操作。</p>
<p>绘制一般有文本绘制 (例如 CoreText)、图片绘制 (例如预先解压)、元素绘制 (Quartz)等操作。</p>
<p>UI对象操作通常包括 UIView/CALayer 等 UI 对象的创建、设置属性和销毁。</p>
<p>其中前两类操作可以通过各种方法扔到后台线程执行，而最后一类操作只能在主线程完成，并且有时后面的操作需要依赖前面操作的结果 （例如TextView创建时可能需要提前计算出文本的大小）。ASDK 所做的，就是尽量将能放入后台的任务放入后台，不能的则尽量推迟 (例如视图的创建、属性的调整)。</p>
<p>为此，ASDK 创建了一个名为 ASDisplayNode 的对象，并在内部封装了 UIView/CALayer，它具有和 UIView/CALayer 相似的属性，例如 frame、backgroundColor等。所有这些属性都可以在后台线程更改，开发者可以只通过 Node 来操作其内部的 UIView/CALayer，这样就可以将排版和绘制放入了后台线程。但是无论怎么操作，这些属性总需要在某个时刻同步到主线程的 UIView/CALayer 去。</p>
<p>ASDK 仿照 QuartzCore/UIKit 框架的模式，实现了一套类似的界面更新的机制：即在主线程的 RunLoop 中添加一个 Observer，监听了 kCFRunLoopBeforeWaiting 和 kCFRunLoopExit 事件，在收到回调时，遍历所有之前放入队列的待处理的任务，然后一一执行。</p>
<blockquote>
<p>转载整理自 ： <a target="_blank" rel="noopener" href="https://blog.ibireme.com/author/ibireme/">ibireme</a> 的博客 <a target="_blank" rel="noopener" href="https://blog.ibireme.com/2015/05/18/runloop/">深入理解RunLoop</a></p>
</blockquote>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2015-10-31T16:00:00.000Z" title="2015/11/1 上午12:00:00">2015-11-01</time>发表</span><span class="level-item"><a class="link-muted" href="/categories/iOS/">iOS</a></span><span class="level-item">26 分钟读完 (大约3865个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2015/11/01/iOS-Multi-Thread/">多线程编程基础</a></h1><div class="content"><h1 id="iOS-多线程"><a href="#iOS-多线程" class="headerlink" title="iOS 多线程"></a>iOS 多线程</h1><h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>进程(Process)是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础，是正在运行的程序的实例(An instance of a computer program that is being executed)。</p>
<p>进程的概念主要有两点：</p>
<ul>
<li>进程是一个实体。每一个进程都有它自己的地址空间，一般情况下，包括文本区域(Text Region)、数据区域(Data Region)和堆栈(Stack Region)。文本区域存储处理器执行的代码；数据区域存储变量和进程执行期间使用的动态分配的内存；堆栈区存储着活动过程调用的指令和本地变量。</li>
<li>进程是一个执行中的程序。</li>
</ul>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>线程是程序执行流的最小单元。一个标准的线程由线程ID、当前指令指针、寄存器集合和堆栈组成。另外，线程是进程中的一个实体，是被系统独立调度和分配的基本单位，线程自己不拥有系统资源，只拥有一点在运行中必不可少的资源，但它可以与同属一个进程的其它线程共享进程所拥有的全部资源。</p>
<h3 id="进程与线程的关系与区别"><a href="#进程与线程的关系与区别" class="headerlink" title="进程与线程的关系与区别"></a>进程与线程的关系与区别</h3><p>进程是资源分配的基本单位。所有与该进程有关的资源，都被记录在进程控制块PCB中，以表示该进程拥有这些资源或正在使用它们。另外，进程也是抢占处理机的基本单位，它拥有一个完整的虚拟地址空间。当进程发生调度时，不同的进程拥有不同的虚拟地址空间，而同一进程内的不同线程共享同一地址空间。</p>
<p>与进程相对应，线程与资源分配无关，它属于某一个进程，并与进程内的其它线程一起共享进程的资源。线程只由相关堆栈、寄存器和线程控制表TCB组成。寄存器可被用来存储线程内的局部变量，但不能存储其它线程的相关变量。</p>
<p>通常在一个进程中可以包含多个线程，它们可以利用进程所拥有的资源。在引入线程的操作系统中，通常都是把进程作为分配资源的基本单位，而把线程作为独立运行和独立调度的基本单位。由于线程比进程更小，基本上不拥有系统资源，故对它的调度所付出的开销就会小得多，能更叫高效的提高系统内多个程序之间并发执行的程度。</p>
<p>线程和进程区别：</p>
<ul>
<li>地址空间和其它资源：进程之间相互独立，同一进程的各线程间共享。某进程内的线程在其它进程不可见。</li>
<li>通信：进程间通信主要方式有管道、系统IPC(消息队列、信号、共享存储)、套接字(Socket)。而线程间可以直接读写进程数据段来进行通信(需要进程同步和互斥手段的辅助，以保证数据的异质性)</li>
<li>调度和切换：线程上下文切换比进程快的多。</li>
<li>在多线程OS中，进程不是一个可执行的实体</li>
</ul>
<h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><p>线程安全就是多线程访问时，采用了加锁机制，当一个线程访问该类的某个数据时，进行保护，其它线程不能进行访问直到该线程读取完，其它线程才可以使用。</p>
<h2 id="iOS中的多线程"><a href="#iOS中的多线程" class="headerlink" title="iOS中的多线程"></a>iOS中的多线程</h2><p>目前在iOS中有四种多线程解决方案：</p>
<ul>
<li>Pthreads</li>
<li>NSThread</li>
<li>GCD</li>
<li>NSOperation &amp; NSOperationQueue</li>
</ul>
<h3 id="Pthreads"><a href="#Pthreads" class="headerlink" title="Pthreads"></a>Pthreads</h3><p>POSIX线程，简称Pthreads，是线程的POSIX标准。该标准定义了创建和操作线程的一整套API。在类Unix操作系统中，都使用Pthreads作为操作系统的线程。</p>
<h3 id="NSThread"><a href="#NSThread" class="headerlink" title="NSThread"></a>NSThread</h3><p>NSThread是经常Apple封装的完全面向对象的。你可以直观方便的操控线程对象，但是生命周期需要手动管理。</p>
<h3 id="GCD"><a href="#GCD" class="headerlink" title="GCD"></a>GCD</h3><p>GCD是Apple为多核的并行运算提出的的解决方案，能够自动合理地利用更多的CPU内核，并自动管理线程的声明周期。GCD使用C进行编写，并使用了Block。</p>
<p>####任务</p>
<p>即代码所要完成的操作。</p>
<p>任务的执行方式有两种：同步执行和异步执行。</p>
<p>同步执行操作，它会阻塞当前线程并等待任务执行完毕，然后当前线程才会继续往下运行。</p>
<p>异步执行操作，则不会阻塞当前线程，当前线程会直接往下执行。</p>
<h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><p>用于存放要执行的任务。</p>
<p>串行队列中的任务，GCD会遵循FIFO原则来执行，串行队列的同步执行任务，会在当前线程一个一个执行，而异步执行任务，则会在它线程中一个一个执行。</p>
<p>并行队列中的任务执行顺序则要复杂一点，任务会根据同步或异步有不同的执行方式。并行队列中的同步执行任务会在当前线程中一个一个执行，而异步执行则会开很多线程一起执行。</p>
<h5 id="如何创建队列？"><a href="#如何创建队列？" class="headerlink" title="如何创建队列？"></a><strong>如何创建队列？</strong></h5><ul>
<li>主队列：特殊的串行队列，主要用于刷新UI，任何需要刷新UI的工作都必须在主队列中执行。</li>
</ul>
<p><code>dispatch_queue_t mainQueue = ispatch_get_main_queue();</code></p>
<ul>
<li><p>自己创建的队列：</p>
<p>创建串行队列</p>
</li>
</ul>
<p><code>dispatch_queue_t serialQueue = dispatch_queue_create(&quot;CustomSerialQueue&quot;,DISPATCH_QUEUE_SERIAL);</code></p>
<p>​    创建并行队列</p>
<p><code>dispatch_queue_t concurrentQueue = dispatch_queue_create(&quot;CustomConcurrentQueue&quot;,DISPATCH_QUEUE_CONCURRENT);</code></p>
<ul>
<li>全局队列：这是一个并行队列，并行任务一般都加入到这个队列。</li>
</ul>
<p><code>dispatch_queue_t globalQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,0)</code></p>
<p><strong>如何创建任务？</strong></p>
<ul>
<li><p>创建同步任务</p>
<p><code>dispatch_sync(,^&#123;// execute code));</code></p>
</li>
<li><p>创建异步任务</p>
<p><code>dispatch_async(,^&#123;// execute code&#125;);</code></p>
</li>
</ul>
<h5 id="队列组"><a href="#队列组" class="headerlink" title="队列组"></a>队列组</h5><p>队列组可以将很多队列添加到一个组里，当组中的所有任务都执行完了，队列组将会通知给用户。</p>
<p><code>dispatch_group_enter</code> 和 <code>dispatch_group_leave</code> 分别表示一个任务追加到队列组和一个任务执行完毕离开了队列组。</p>
<p>只有当group中未执行完毕的任务数量为0时，才会使 <code>dispatch_group_wait</code> 解除阻塞，以及执行追加到 <code>dispatch_group_notify</code> 的任务。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">dispatch_group_t group = dispatch_group_create();</span><br><span class="line">dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIOITY_DEFAULT,0);</span><br><span class="line">dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">  // execute code</span><br><span class="line">&#125;);</span><br><span class="line">// 向group中添加在主队列中执行的任务</span><br><span class="line">dispatch_group_async(group, dispatch_get_main_queue(),^&#123;</span><br><span class="line">  // execute code</span><br><span class="line">&#125;);</span><br><span class="line">// 向group中追加任务</span><br><span class="line">dispatch_group_enter(group);</span><br><span class="line">dispatch_async(queue，^&#123;</span><br><span class="line">    // execute code</span><br><span class="line">    dispatch_group_leave(group);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 直到前面加入到group中的所有任务都执行完毕后，才会执行</span><br><span class="line">dispatch_group_notify(group,dispatch_get_main_queue(),^&#123;</span><br><span class="line">  // execute code</span><br><span class="line">&#125;);</span><br><span class="line">OR</span><br><span class="line">// 直到前面加入到group中的所有任务都执行完成后，才会继续往下执行</span><br><span class="line">dispatch_group_wait(group, DISPATCH_TIME_FOREVER);</span><br></pre></td></tr></table></figure>



<h4 id="GCD的信号量机制"><a href="#GCD的信号量机制" class="headerlink" title="GCD的信号量机制"></a>GCD的信号量机制</h4><p>并发队列可以分配多个线程，同时处理不同的任务，虽然提升了效率，但是多线程的并发是通过时间片轮转的方法实现的，线程的创建、销毁、上下文切换等会消耗资源。适当的并发可以提高效率，但是无节制的并发，则会抢占CPU资源，造成性能下降。此外，提交给并发队列的任务中，有些任务内部会有全局的锁，会导致线程休眠、阻塞，一旦这类任务过多，并发队列还需要创建新的线程来执行其它任务，会造成线程数量的增加。</p>
<p>因此控制并发队列中的线程数量就成了不能忽视的问题。</p>
<h5 id="GCD并发线程数量控制"><a href="#GCD并发线程数量控制" class="headerlink" title="GCD并发线程数量控制"></a>GCD并发线程数量控制</h5><p>GCD中的信号量（dispatch_semaphore）是一个整形值，有初始计数值，可以接收通知信号和等待信号。当信号量收到通知信号时，计数+1；当信号量收到等待信号时，计数-1。如果信号量为0，线程会被阻塞，直到信号量大于0，才会继续执行。</p>
<p>使用信号量机制可以实现线程的同步，也可以控制最大并发数。</p>
<h5 id="使用GCD信号量机制实现并发线程数量控制"><a href="#使用GCD信号量机制实现并发线程数量控制" class="headerlink" title="使用GCD信号量机制实现并发线程数量控制"></a>使用GCD信号量机制实现并发线程数量控制</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t	workConcurrentQueue	=	dispatch_queue_create(@&quot;WORK_CONCURRENT_QUEUE&quot;,DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">dispatch_queue_t	workSerialQueue	=	dispatch_queue_create(@&quot;WORK_SERIAL_QUEUE&quot;,DISPATCH_QUEUE_SERIAL);</span><br><span class="line">int	maxConcurrent	=	10;</span><br><span class="line">dispatch_semaphore_t	semaphore	=	dispatch_semaphore_create(maxConcurrent);</span><br><span class="line">for (NSInteger i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">  dispatch_async(workSerialQueue, ^&#123;</span><br><span class="line">      // 使信号量-1，当信号量为0时就一直等待，即阻塞所在线程</span><br><span class="line">      // 这里使信号量 maxConcurrent-1，表示最大并发数量已被占用一个位置</span><br><span class="line">      dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">      dispatch_async(workConcurrentQueue, ^&#123;</span><br><span class="line">          // 发送一个信号，让信号量+1</span><br><span class="line">          // 这里使信号量 maxConcurrent+1，表示任务被执行，释放了最大并发数量中的一个位置</span><br><span class="line">          dispatch_semaphore_signal(semaphore);</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="使用GCD信号量机制实现线程同步"><a href="#使用GCD信号量机制实现线程同步" class="headerlink" title="使用GCD信号量机制实现线程同步"></a>使用GCD信号量机制实现线程同步</h5><p>有时候我们会遇到需要异步执行一些耗时任务，并在这些任务完成后进行一些额外的操作，相当于将异步执行任务转化为同步执行任务。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);</span><br><span class="line">     </span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">    	// 执行耗时任务</span><br><span class="line">    	···</span><br><span class="line">        // 任务完成后使信号量+1，被阻塞的线程继续执行</span><br><span class="line">        dispatch_semaphore_signal(semaphore);</span><br><span class="line">    &#125;);</span><br><span class="line">// 如果信号量为0，则会阻塞当前线程，直到信号量</span><br><span class="line">dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br></pre></td></tr></table></figure>

<h5 id="使用GCD信号量机制实现线程安全"><a href="#使用GCD信号量机制实现线程安全" class="headerlink" title="使用GCD信号量机制实现线程安全"></a>使用GCD信号量机制实现线程安全</h5><p>如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其它变量的值也和预期的是一样的，就是线程安全的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dispatch_semaphore_t semaphoreLock	=	dispatch_semaphore_create(1);</span><br><span class="line">// 相当于加锁</span><br><span class="line">dispatch_semaphore_wait(semaphoreLock, DISPATCH_TIME_FOREVER);</span><br><span class="line">&#123;</span><br><span class="line">    // 需要保证安全的执行代码</span><br><span class="line">&#125;</span><br><span class="line">// 相当于解锁</span><br><span class="line">dispatch_semaphore_singal(semaphoreLock);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="GCD的一些使用场景"><a href="#GCD的一些使用场景" class="headerlink" title="GCD的一些使用场景"></a>GCD的一些使用场景</h4><h5 id="使用GCD实现延迟执行"><a href="#使用GCD实现延迟执行" class="headerlink" title="使用GCD实现延迟执行"></a>使用GCD实现延迟执行</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t queue	=	dispatch_ger_gloabl_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">double delay			=	3;</span><br><span class="line">dispatch_after(dispatch_time(DISPATCH_TIME_NOW), (int64_t)(delay*NSEC_PER_SEC)), queue, ^&#123;</span><br><span class="line">  // execute code</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h5 id="使用GCD实现单例模式"><a href="#使用GCD实现单例模式" class="headerlink" title="使用GCD实现单例模式"></a>使用GCD实现单例模式</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">static id _instance;</span><br><span class="line">+ (instancetype)sharedInstance &#123;</span><br><span class="line">  static dispatch_once_t onceToken;</span><br><span class="line">  dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">    // initial code</span><br><span class="line">  &#125;);</span><br><span class="line">  retur _instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="任务同步"><a href="#任务同步" class="headerlink" title="任务同步"></a>任务同步</h5><p>我们有时需要异步执行两组操作，而且第一组操作执行完之后，才能开始执行第二组操作。这样我们就需要一个相当于 栅栏 一样的一个方法将两组异步执行的操作组给分割起来，当然这里的操作组里可以包含一个或多个任务。这就需要用到dispatch_barrier_async方法在两个操作组间形成栅栏。</p>
<p><code>dispatch_barrier_async</code> 函数会等待前边追加到并发队列中的任务全部执行完毕之后，再将指定的任务追加到该异步队列中。然后在 <code>dispatch_barrier_async</code> 函数追加的任务执行完毕之后，异步队列才恢复为一般动作，接着追加任务到该异步队列并开始执行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t queue = dispatch_queue_create(&quot;com.codelei.queue&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">     </span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">  		// Task 1</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        // Task 2</span><br><span class="line">    &#125;);</span><br><span class="line">     </span><br><span class="line">    dispatch_barrier_async(queue, ^&#123;</span><br><span class="line">        // 追加的任务 Task 3</span><br><span class="line">    &#125;);</span><br><span class="line">     </span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        // 追加的任务 Task 4</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        // 追加的任务 Task 5</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<p>直到 Task 1 和 Task 2 执行完成后，才会执行使用 <code>dispatch_barrier_asynce</code> 追加的任务 Task 3，然后在 Task 3 执行完成后，并行队列会正常执行。</p>
<h3 id="NSOperation-amp-NSOperationQueue"><a href="#NSOperation-amp-NSOperationQueue" class="headerlink" title="NSOperation &amp; NSOperationQueue"></a>NSOperation &amp; NSOperationQueue</h3><p>NSOperation是Apple对GCD的封装，完全面向对象。NSOperation和NSOperationQueue分别对应GCD的任务和队列。</p>
<h4 id="添加任务"><a href="#添加任务" class="headerlink" title="添加任务"></a>添加任务</h4><p>NSOperation只是一个抽象类，并不能直接封装任务。它有两个子类NSInvocationOperation和NSBlockOperation用来完成封装任务的操作。创建一个Operation后，需要调用<code>start</code>方法来启动任务，它默认在当前队列同步执行。如果需要在执行途中取消执行一个任务，调用<code>cancel</code>方法即可。</p>
<ul>
<li><p>NSInvocationOperation</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSInvocationOperation *invocationOperation = [[NSInvocation alloc] initWithTarget:self selector:@selector(executeMethod)];</span><br><span class="line">invocationOperation start];</span><br></pre></td></tr></table></figure>
</li>
<li><p>NSBlockOperation</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NSBlockOperation *blockOperation = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">  // execute code</span><br><span class="line">&#125;];</span><br><span class="line">[blockOperation start];</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上面提到，NSInvocationOperation和NSBlockOperation创建的任务默认在当前线程执行，但是NSBlockOperation可以通过<code>addExecutionBlock:</code>方法向Operation中添加多个可执行的Block。这样的Operation中的任务会并发执行，它会在主线程和其它多个线程执行这些任务。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NSBlockOperation *blockOperation = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">  // execute code</span><br><span class="line">&#125;];</span><br><span class="line">[blockOpertation addExecutionBlock:^&#123;</span><br><span class="line">  // execute code</span><br><span class="line">&#125;];</span><br><span class="line">[blockOperation start];</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>NOTE</strong>:<code>addExecutionBlock:</code>方法必须在<code>start</code>方法之前执行，否则会报错。</p>
</blockquote>
</li>
<li><p>自定义的Operation</p>
<p>自定义Operation类需要继承Operation类，并实现其<code>main()</code>方法，因为在调用<code>start()</code>方法的时候，内部会调用<code>main()</code>方法完成相关逻辑。</p>
</li>
</ul>
<h4 id="创建队列"><a href="#创建队列" class="headerlink" title="创建队列"></a>创建队列</h4><p>通过调用一个NSOperation类的<code>start()</code>方法来启动的任务，默认在当前线程同步执行。如果要避免占用当前线程，就需要使用到队列NSOperationQueue。只要将Operation添加到队列，就会自动调用任务的<code>start()</code>方法。</p>
<ul>
<li><p>主队列</p>
<p>添加到主队列中的任务时串行执行的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSOperationQueue *mainQueue = [NSOperationQueue mainQueue];</span><br></pre></td></tr></table></figure>
</li>
<li><p>其它队列</p>
<p>其它队列中的任务会在其它线程并行执行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NSOperationQueue *queue = [NSOperatin alloc] init];</span><br><span class="line">NSBlockOperatin	 *blockOperation = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">  // execute code</span><br><span class="line">&#125;]</span><br><span class="line">[queue addOperation:blockOperation];</span><br></pre></td></tr></table></figure>

<p>如果需要任务在队列中串行执行，可以通过设置NSOperationQueue的<code>maxConcurrentOperationCount</code>来实现。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSOperationQueue *queue = [NSOperatin alloc] init];</span><br><span class="line">[queue setMaxConcurrentOperationCount:1];</span><br></pre></td></tr></table></figure>

<p>你还可以通过<code>addOperationWithBlock:</code>方法来向队列中添加新任务。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NSOperationQueue *queue = [NSOperatin alloc] init];</span><br><span class="line">[queue addOperationWithBlock:^&#123;</span><br><span class="line">  // cxecute code</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="添加任务依赖"><a href="#添加任务依赖" class="headerlink" title="添加任务依赖"></a>添加任务依赖</h4>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">NSBlockOperation	*blockOperationFirst  = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">	// execute code</span><br><span class="line">&#125;];</span><br><span class="line">NSBlockOperation	*blockOperationSecond = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">	// execute code</span><br><span class="line">&#125;];</span><br><span class="line">NSBlockOperation	*blockOperationThird  = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">	// execute code</span><br><span class="line">&#125;];</span><br><span class="line">[blockOperationSecond addDependency:blockOperationFirst];</span><br><span class="line">[blockOperationThird addDependency:blockOperationSecond];</span><br><span class="line">NSOperationQueue *queue = [NSOperatin alloc] init];</span><br><span class="line">[queue addOperations:@[blockOperationFirst,blockOperationSecond,blockOperationThird]];</span><br></pre></td></tr></table></figure>


<blockquote>
<p><strong>NOTE</strong>:</p>
<ul>
<li>添加相互依赖会造成死锁。</li>
<li>使用<code>removeDependency</code>方法来移除依赖关系</li>
</ul>
</blockquote>
<h4 id="其它方法"><a href="#其它方法" class="headerlink" title="其它方法"></a>其它方法</h4><ul>
<li><p>NSOperation类的一些其它方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 判断任务是否正在执行</span><br><span class="line">BOOL exccuting;</span><br><span class="line">// 判断任务是否完成</span><br><span class="line">BOOL finished；</span><br><span class="line">// 设置任务完成后的后续操作</span><br><span class="line">void (^completionBlock) (void);</span><br><span class="line">// 取消任务</span><br><span class="line">- (void)cancle;</span><br><span class="line">// 阻塞当前线程直到此任务执行完毕</span><br><span class="line">- (void)waitUntilFinished;</span><br></pre></td></tr></table></figure>
</li>
<li><p>NSOperationQueue</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 获取队列的任务数量</span><br><span class="line">NSUInteger operationCount;</span><br><span class="line">// 取消队列中的所有任务</span><br><span class="line">- (void)cancelAllOperations;</span><br><span class="line">// 阻塞当前线程直到此队列中的所有任务执行完毕</span><br><span class="line">- (void)waitUntilAllOperationsAreFinished;</span><br><span class="line">// 暂停或继续队列</span><br><span class="line">BOOL suspended;</span><br></pre></td></tr></table></figure>

<p>​</p>
</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2015-10-20T16:00:00.000Z" title="2015/10/21 上午12:00:00">2015-10-21</time>发表</span><span class="level-item"><a class="link-muted" href="/categories/iOS/">iOS</a></span><span class="level-item">1 小时读完 (大约9115个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2015/10/21/ios-background-execution/">后台运行探索与解析</a></h1><div class="content"><h1 id="iOS-后台运行"><a href="#iOS-后台运行" class="headerlink" title="iOS 后台运行"></a>iOS 后台运行</h1><hr>
<p>当用户没有主动的使用你的应用程序时，系统会将它转换为后台运行状态。对于大多说应用程序来说，后台运行状态只是应用程序在被系统挂起前的一个阶段。挂起应用程序是一个改善电池寿命并让系统为前台应用程序释放重要资源的方式。</p>
<p>大多数应用程序都能很容易的挂起，但是拥有合理的理由在后台继续运行的应用程序也是有的。一个远足应用程序想要随着时间来定位用户的位置，让它能够在地图上显示用户的运动进程。一个音频应用程序可能需要在屏幕锁定时继续播放音乐。其它的应用程序可能想要在后台下载内容以便能够减少将内容呈献给用户的延迟。当你发现你的应用程序需要保持在后台继续运行的时候，iOS系统能够帮助你有效率的且尽可能少地占用系统资源的完成这个目的。</p>
<p>iOS提供的技术分为三类：</p>
<ul>
<li>在前台开始短任务的应用程序可以在进入后台状态时向系统请求完成这个任务的额外时间。</li>
<li>在前台启动下载的应用程序可以将这些下载的管理移交给系统，从而允许在下载过程中暂停或终止该应用。</li>
<li>需要在后台运行以支持特定类型任务的应用程序可以声明对一个或多个后台执行模式的支持。</li>
</ul>
<p>尽可能避免在后台执行任何任务除非这样做能全面的提升用户的体验。应用程序可能会因为启动了另一个应用程序，锁定了屏幕或现在不使用它而被转入后台。在这些情况下，用户都表明你的应用程序现在不需要做任何有意义的工作。在这种情况下继续运行只会浪费设备的电量并可能导致用户强制的完全退出你的应用程序。所以你应该审慎的考虑在后台运行应用程序。</p>
<h2 id="执行有限长度的任务"><a href="#执行有限长度的任务" class="headerlink" title="执行有限长度的任务"></a>执行有限长度的任务</h2><p>被转入后台的应用程序期待尽可能快的进入非活动状态以便它们能够被系统挂起。如果你的应用程序正在执行某个任务而且完成这个任务还需要一些时间的话，你可用调用 <code>UIApplication</code> 的<code>beginBackgroundTaskWithName:expirationHandler:</code> 或<code>beginBackgroundTaskWithExpirationHandler:</code>方法来请求一些额外的执行时间。调用这两个方法的任一个都会暂时的推迟你的应用程序被挂起，从而为完成你正在进行的任务赢得一些额外的时间。一旦你的应用程序完成了任务，你必须调用<code>endBackgroundTask:</code>方法让系统知道你的应用程序已经完成了任务，可以被挂起了。</p>
<p>每个调用<code>beginBackgroundTaskWithName:expirationHandler:</code> 或 <code>beginBackgroundTaskWithExpirationHandler:</code> 方法的应用程序都会生成一个与相应的任务相关的标记。当你的应用程序完成任务时，它必须以这个标记来调用 <code>endBackgroundTask:</code>方法告知系统任务已经完成。调用 <code>endBackgroundTask:</code>方法失败会导致你的应用程序被终止。如果你在启动任务的时候提供了一个完成处理模块，系统会调用这个模块并给你最后一次结束任务避免程序被终止的机会。</p>
<p>你不需要一直到等到应用程序进入后台才指定后台任务。一个更有用的设计是在开始任务之前调用<code>beginBackgroundTaskWithName：expirationHandler：</code>或<code>beginBackgroundTaskWithExpirationHandler：</code>方法，一旦完成就调用<code>endBackgroundTask：</code>方法.</p>
<p>下面的的代码展示了当你的应用程序进入后台时如何开始一个长时运行的任务。在这个例子中，开始后台任务的请求包含了一个完成处理模块以防这个任务耗时太长。这个任务稍后会被提交到一个异步执行的队列中以便<code>applicationDidEnterBackground:</code>方法能够正常返回。blocks的使用简化了维护一些重要变量引用所需要的代码。<code>bgTask</code>变量是指向存储当前任务标识符的指针的类的成员变量，它在调用这个方法之前被初始化。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (void)applicationDidEnterBackground:(UIApplication *)application &#123;</span><br><span class="line">    bgTask = [application beginBackgroundTaskWithName:@&quot;MyTask&quot; expirationHandler:^&#123;</span><br><span class="line">        // Clean up any unfinished task business by marking where you</span><br><span class="line">        // stopped or ending the task outright.</span><br><span class="line">        [application endBackgroundTask:bgTask];</span><br><span class="line">        bgTask = UIBackgroundTaskInvalid;</span><br><span class="line">    &#125;];</span><br><span class="line"> </span><br><span class="line">    // Start the long-running task and return immediately.</span><br><span class="line">    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line"> </span><br><span class="line">        // Do the work associated with the task, preferably in chunks.</span><br><span class="line"> </span><br><span class="line">        [application endBackgroundTask:bgTask];</span><br><span class="line">        bgTask = UIBackgroundTaskInvalid;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意:</strong> 你总是要在开始一个任务的时候提供完成处理模块，但是如果你想知道你的应用程序还能运行多长时间，你可以通过<code>UIApplication</code>对象的<code>backgroundTimeRemaining</code>属性来获得。</p>
</blockquote>
<p>在你的完成处理模块中，你可以加入一些必须的代码来关闭你的任务。但是，完成处理模块中的任何代码都不应该耗费太长的时间去执行，因为你的完成处理模块一旦被调用，就说明你的应用程序已经快要被关闭了。因此，只执行最少的清理状态信息并结束任务。</p>
<h2 id="在后台执行下载任务"><a href="#在后台执行下载任务" class="headerlink" title="在后台执行下载任务"></a>在后台执行下载任务</h2><p>当下载文件时，应用程序应该使用<code>NSURLSession</code>对象来开始下载，这样系统就能控制下载的进程即使应用程序被挂起或终止。当你配置<code>NSURLSession</code>对象进行后台传输时，系统用一个单独的队列管理这些任务并以常规方式将传输的状态报告给你的应用程序。如果你的应用程序在传输正在进行时被终止，系统会在后台继续传输，并在传输完成或一个甚至多个任务需要你的应用程序时启动你的应用程序(若果使用)。</p>
<p>为了支持后台传输，你必须合适地配置你的<code>NSURLSession</code>对象。为了配置<code>NSURLSession</code>有必须先创建一个<code>NSURLSessionConfiguration</code>对象并给它的一些属性赋予合适的值。然后将这个<code>NSURLSessionConfiguration</code>对象在初始化<code>NSURLSession</code>对象时传递过去。</p>
<p>创建支持后台下载的<code>NSURLSessionConfiguration</code>对象的过程如下：</p>
<p>   1.使用<code>NSURLSessionConfiguration</code>的<code>backgroundSessionConfigurationWithIdentifier：</code>方法创建配置对象。</p>
<p>   2.将配置对象的<code>sessionSendLaunchEvents</code>属性的值设置为<code>YES</code>。</p>
<p>   3.如果你的应用程序在前台进行转移，建议你将<code>sessionSendsLaunchEvents</code>属性设置为<code>YES</code>。</p>
<p>   4.根据需要配置配置对象的任何其他属性。</p>
<p>   5.使用配置对象创建您的<code>NSURLSession</code>对象。</p>
<p>一旦配置完成，你的<code>NSURLSession</code>对象会在合适的时间将上传和下载任务移交给系统。如果任务在你的应用程序仍在运行时完成(无论是在前台或是后台)，<code>NSURLSession</code>对象都会以常规方式通知它的代理。如果任务还未完成时你的应用程序就被终止，系统会自动地在后台管理任务。如果用户终止了你的应用程序，系统会停止任何待处理的任务。</p>
<p>当所有与后台会话管理的任务完成时，系统会重启被终止的应用程序(假定<code>sessionSendsLaunchEvents</code>属性被设置为<code>YES</code>而且这个应用程序不是被用户强制终止的)并调用应用代理的<code>application:handleEventsForBackgroundURLSession:completionHandler:</code>方法。(系统还可以重新启动应用程序来处理身份验证或其他需要你的应用程序注意的任务的相关事件)在执行该委托方法时，请使用提供的标识符创建一个新的与之前相同的<code>NSURLSessionConfiguration</code>和<code>NSURLSession</code>对象。 系统将你的新会话对象重新连接到先前的任务，并将其状态报告给会话对象的委托。</p>
<h2 id="执行长时间运行的任务"><a href="#执行长时间运行的任务" class="headerlink" title="执行长时间运行的任务"></a>执行长时间运行的任务</h2><p>对于需要更多后台执行时间的任务，你必须请求特定的权限才能在后台运行它们而不被挂起。iOS中，只有特定类型的应用程序被允许在后台运行：</p>
<ul>
<li>在后台播放音频内容给用户，比如音乐播放器</li>
<li>在后台录制音频文件</li>
<li>使用户随时了解其位置的应用程序，比如导航应用程序</li>
<li>支持VoIP的应用程序</li>
<li>需要经常性的下载和处理新内容的应用程序</li>
<li>周期性的从外部配件接收更新的应用程序</li>
</ul>
<p>使用这些服务的应用程序必须声明其支持的服务，并使用系统框架来实现这些服务的相关方面。</p>
<h3 id="声明你的应用程序支持的后台模式"><a href="#声明你的应用程序支持的后台模式" class="headerlink" title="声明你的应用程序支持的后台模式"></a>声明你的应用程序支持的后台模式</h3><p>你必须在应用程序使用后台任务之前声明你要支持的后台任务类型。在Xcode 5和之后，你需要在你工程的Capabilities选项卡中声明你要支持哪些后台模式。启用后台模式选项将<code>UIBackgroundModes</code>键添加到应用程序的<code>Info.plist</code>文件中。</p>
<p>下表列出了你可以指定的后台模式的值：</p>
<table>
<thead>
<tr>
<th>Xcode后台模式</th>
<th>UIBackgroundModes 值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>音频和AirPlay</td>
<td><code>audio</code></td>
<td>应用程序在后台播放或录制音频内容。用户必须在第一次使用前就授权使用麦克风。</td>
</tr>
<tr>
<td>位置更新</td>
<td><code>location</code></td>
<td>使用户随时知道他们的位置，即使应用在后台运行。</td>
</tr>
<tr>
<td>网络电话</td>
<td><code>voip</code></td>
<td>应用程序提供给用户通过网络连接进行通话的能力。</td>
</tr>
<tr>
<td>Newsstand下载</td>
<td><code>newsstand-content</code></td>
<td>Newsstand类型的应用程序在后台下载并处理报纸或杂志内容。</td>
</tr>
<tr>
<td>外部附件通信</td>
<td><code>external-accessory</code></td>
<td>应用程序与需要通过外部附件框架定期提供更新的硬件配件配合使用。</td>
</tr>
<tr>
<td>使用蓝牙设备</td>
<td><code>bluetooth-central</code></td>
<td>应用程序使用需要通过Core Bluetooth框架定期发送更新的蓝牙设备。</td>
</tr>
<tr>
<td>作为蓝牙LE附件</td>
<td><code>bluetooth-peripheral</code></td>
<td>应用程序通过Core Bluetooth框架支持外设模式下的蓝牙通信。使用此模式需要用户授权</td>
</tr>
<tr>
<td>后台抓取</td>
<td><code>fetch</code></td>
<td>应用程序定期的从网路下载并处理少量数据。</td>
</tr>
<tr>
<td>远程推送</td>
<td><code>remote-notification</code></td>
<td>应用程序想要在接收到一个远程推送时开始下载内容。</td>
</tr>
</tbody></table>
<p>以上每种模式都让系统知道应该在合适的时间唤醒或启动应用程序来响应相关的事件。</p>
<h4 id="追踪用户位置"><a href="#追踪用户位置" class="headerlink" title="追踪用户位置"></a>追踪用户位置</h4><p>在后台追踪用户的位置的方式有好几种，大多数方式实际上并不需要你的应用程序在后台不断的运行。</p>
<ul>
<li>重大位置变更</li>
<li>仅在前台定位服务</li>
<li>后台定位服务</li>
</ul>
<p>对于不需要高精度位置数据的应用程序来说，推荐使用重大位置变更定位服务。这个服务只有在用户的位置发生非常重大的变化时才会产生位置更新；它对社交类应用程序或者给用户提供不是很重要的位置相关信息的应用程序来说是非常理想的定位方式。如果当一个位置更新发生时应用程序被终止，系统会在后台唤醒它来处理这个更新。如果应用程序开始使用了这个服务然后被终止，当新的位置更新产生时，系统会自动重启它。</p>
<p>仅前台定位服务和后台定位服务都使用标准的Core Location服务获取位置数据。唯一的区别是，如果应用程序被挂起，则仅前台定位服务停止发送更新。 前台定位服务适用于只在前台需要位置数据的应用程序。</p>
<p>你可以在Xcode工程中的<code>Capabilities</code>选项卡中启用支持定位服务(你也可以通过在<code>Info.plist</code>文件中设置<code>UIBackgroundModes</code>的值为<code>location</code>来启用这个服务)。启用这个服务并不会阻止系统挂起你的应用程序，但是它会告知系统无论何时新的位置更新被发送过来都应该唤醒应用程序来处理。</p>
<blockquote>
<p><strong>重要提示:</strong>鼓励你谨慎使用标准的定位服务或改用重要的位置更改服务。 定位服务需要经常使用iOS设备的板载无线电硬件。 连续运行这个硬件会消耗大量的电量。 如果你的应用程序不需要向用户提供精确且连续的位置信息，则最好尽量减少使用位置服务。</p>
</blockquote>
<h4 id="在后台播放或录制音频"><a href="#在后台播放或录制音频" class="headerlink" title="在后台播放或录制音频"></a>在后台播放或录制音频</h4><p>一个需要连续播放或录制音频的应用程序(即使应用处在后台)可以注册后台服务，实现即使在后台也能执行这些任务。你可以在Xcode工程中的<code>Capabilities</code>选项卡中启用服务(你也可以通过在<code>Info.plist</code>文件中设置<code>UIBackgroundModes</code>的值为<code>audio</code>来启用这个服务)。在后台播放音频内容的应用程序必须播放听得见的内容而不能是无声的。</p>
<p>后台音频应用程序的典型例子包括：</p>
<ul>
<li>音乐播放程序</li>
<li>音频录制程序</li>
<li>支持通过AirPlay播放音频或视频的程序</li>
<li>VoIP程序</li>
</ul>
<p>当<code>UIBackgroundModes</code>键包含<code>audio</code>值时，系统的媒体框架会自动阻止相关的应用程序被挂起。只要应用程序还在播放视屏或音频内容，录制音频，它就还能在后台运行。然而，一旦录制或播放停止，就会被系统挂起。</p>
<p>你可以使用任何系统音频框架来处理后台音频播放，并且使用这些框架的过程和在前台使用相同(对于通过AriPlay播放视频内容来说，你可以使用Media Player或AVFoundation框架来实现)。因为应用程序在播放媒体文件时不会被挂起，所以即使应用程序在后台也能正常的进行回调操作。在你的回调中，你应该只做为播放提供数据的工作，不应该在回调中执行任何与播放无关的任务。</p>
<p>在任何给定的时刻，因为可能有不止一个应用程序支持音频服务，所以由系统来决定哪个应用程序能够播放或录制音频。前台应用程序总是有优先的音频操作权利。可能有不止一个应用程序被允许在后台播放音频，这个时候决定哪个应用程序能够播放音频就取决于每个应用程序的音频会话的配置。</p>
<h4 id="实现一个VoIP应用程序"><a href="#实现一个VoIP应用程序" class="headerlink" title="实现一个VoIP应用程序"></a>实现一个VoIP应用程序</h4><p>一个Voice over Internet Protocol应用程序允许用户通过互联网而不是设备的蜂窝网络设备进行语音通话。这样的一个应用程序需要为它的服务维持一个持续的网络连接，以便它能接收到打进来的电话和其它相关数据。系统允许VoIP应用程序被挂起并给它提供了监测它们的sockets的便利，而不是让它一直处于唤醒状态。当检测到传入流量时，系统唤醒VoIP程序并将socket的控制权交还给它。</p>
<p>为了配置VoIP应用程序，你必须：</p>
<ul>
<li>在Xcode工程中的<code>Capabilities</code>选项卡中启用服务(你也可以通过在<code>Info.plist</code>文件中设置<code>UIBackgroundModes</code>的值为<code>voip</code>来启用这个服务)。</li>
<li>为VoIP应用程序配置一个socket。</li>
<li>在移动到后台之前，调用<code>setKeepAliveTimeout:handler:</code>方法来安装一个定期执行的程序。你的应用程序可以使用这个处理程序来保持服务连接。</li>
<li>配置你的音频会话来操作进入或退出活跃的使用状态的转换。</li>
</ul>
<p>设置<code>UIBackgroundModes</code>的值为<code>voip</code>让系统知道，当VoIP应用程序需要管理它的网络会话时，系统应该允许它在后台运行。为了让VoIP应用程序总是可用，系统会在启动后立刻重新启动拥有这个键值的应用程序。</p>
<p>大多数的VoIP应用程序也需要配置后台音频模式，因为它也需要在后台发送音频内容。因此，你应该将<code>UIBackgroundModes</code>的值设置为<code>audio</code>和<code>voip</code>。如果你不这样做的话，你的应用程序将不能在后台播放或录制音频内容。</p>
<h4 id="适时的获取少量内容"><a href="#适时的获取少量内容" class="headerlink" title="适时的获取少量内容"></a>适时的获取少量内容</h4><p>需要定期的检查新内容的应用程序可以请求系统唤醒它们，以便它们可以初始化一个获取内容的拉取操作。为了支持这种模式，你需要在Xcode工程中的<code>Capabilities</code>选项卡中启用服务(你也可以通过在<code>Info.plist</code>文件中设置<code>UIBackgroundModes</code>的值为<code>fetch</code>来启用这个服务)。启用这个服务并不能保证系统会给你的应用程序任何时间来执行后台拉取操作。系统必须在你的应用程序拉取内容的请求和其它应用程序以及系统自身之间做出平衡。在评估所有信息后，如果有很好的机会的话，系统会给请求拉取内容的应用程序一些执行时间。</p>
<p>当有好机会产生时，系统会唤醒或启动你的应用程序到后台并调用应用程序代理对象的<code>application:performFetchWithCompletionHandler:</code>方法。使用这个方法来检查新内容，如果新内容可用则开始下载操作。一旦新内容下载完成，你必须将新内容是否可用的结果传递给提供好的完成处理块。执行这个块告诉系统它可以将你的应用程序转换到挂起状态并评估其使用功率。可以快速下载少量内容并在它们有可用的下载内容时准确反应的应用程序，比起花费更长的下载时间或声称有可用的下载内容但没有下载任何东西的应用程序，更可能在未来获得执行时间。</p>
<p>在下载任何内容时，推荐你使用<code>NSURLSession</code>类来开始和管理你的下载。</p>
<h4 id="使用推送通知来开始下载"><a href="#使用推送通知来开始下载" class="headerlink" title="使用推送通知来开始下载"></a>使用推送通知来开始下载</h4><p>如果你的服务器在有新的应用程序可用内容时向用户的设备发送了一个推送通知，你可以请求系统在后台运行你的应用程序并立即开始下载新的可用内容。这种后台模式意图在于尽可能减少从你的用户看见推送通知到你的应用程序可以展示相关内容之间的时间。应用程序通常会在用户看见推送通知的差不多相同的时间被唤醒，但是仍会给你更多的准备时间。</p>
<p>为了支持这种模式，你需要在Xcode工程中的<code>Capabilities</code>选项卡中启这项用服务(你也可以通过在<code>Info.plist</code>文件中设置<code>UIBackgroundModes</code>的值为<code>remote-notification</code>来启用这个服务)。</p>
<p>对于一个使用推送通知来触发下载操作的应用程序来说，通知的有效内容必须包含值为<code>1</code>的<code>content-available</code>的键。当这个键值对被检测到时，系统会启动或唤醒你的应用程序到后台同时调用应用程序的代理对象的<code>application:didReceiveRemoteNotification:fetchCompletionHandler:</code>方法。你应该在这个方法里实现对相关内容的下载并将下载好的内容在加入到你的应用程序中。</p>
<p>在下载任何内容时，推荐你使用<code>NSURLSession</code>类来开始和管理你的下载。</p>
<h4 id="在后台下载新闻站内容"><a href="#在后台下载新闻站内容" class="headerlink" title="在后台下载新闻站内容"></a>在后台下载新闻站内容</h4><p>下载新闻和新的杂志文章的新闻站应用程序可以注册在后台进行这些下载。你需要在Xcode工程中的<code>Capabilities</code>选项卡中启这项用服务(你也可以通过在<code>Info.plist</code>文件中设置<code>UIBackgroundModes</code>的值为<code>newsstand-content</code>来启用这个服务)。当你提供这个关键字时，如果你的应用程序没有在运行，系统会启动你的应用程序以便它能开始下载新的文章。</p>
<p>当你使用Newsstand Kit框架来开始一个下载时，由系统为你的应用程序操作下载的进程。即使你的应用程序被挂起或终止，系统仍会继续下载文件。当下载操作完成后，系统将下载好的文件传输到你的应用程序的沙盒并向你的应用程序发送一个通知。如果应用程序没有在运行，这个通知会唤醒它并给它一个处理新的下载文件的机会。如果在下载过程中发生了错误，你的应用程序也会这样被唤醒来处理这个错误。</p>
<h4 id="与外部附件通信"><a href="#与外部附件通信" class="headerlink" title="与外部附件通信"></a>与外部附件通信</h4><p>使用外部附件的应用程序可以请求在附件发送了一个更新时被唤醒，即使它处在挂起状态。这种支持对于某些定期发送数据的附件来说是非常重要的，比如心率监视器。你需要在Xcode工程中的<code>Capabilities</code>选项卡中启这项用服务(你也可以通过在<code>Info.plist</code>文件中设置<code>UIBackgroundModes</code>的值为<code>external-accessory</code>来启用这个服务)。当你启用这个模式时，外部附件框架不会关闭活跃的外部附件会话。当外部附件发送来新的内容时，这个框架唤醒你的应用程序以便它能处理这些数据内容。在外部附件建立连接或失去连接时，系统也会唤醒应用程序来进行处理。</p>
<p>任何支持附件更新后台处理的应用程序都必须遵循以下基本准则：</p>
<ul>
<li><p>应用程序必须提供一个界面，让用户来开始或者停止附件更新事件的发送。</p>
</li>
<li><p>一旦被唤醒，应用程序大约有10S时间来处理数据。理想情况下，它应该尽可能快速地处理数据然后转换到挂起状态。但是，如果需要更多的时间，应用程序可以使用<code>beginBackgroundTaskWithExpirationHandler:</code>方法来申请额外的执行时间。</p>
</li>
</ul>
<h4 id="与蓝牙附件通信"><a href="#与蓝牙附件通信" class="headerlink" title="与蓝牙附件通信"></a>与蓝牙附件通信</h4><p>使用蓝牙外设的应用程序可以请求在外设发送了一个更新时被唤醒，即使它处在挂起状态。这种支持对于需要定期发送数据的Bluetooth-LE外设来说是非常重要的。你需要在Xcode工程中的<code>Capabilities</code>选项卡中启这项用服务(你也可以通过在<code>Info.plist</code>文件中设置<code>UIBackgroundModes</code>的值为<code>bluetooth-central</code>来启用这个服务)。当你启用这个模式时，Core Bluetooth框架会保持相应外设的任何活跃会话连接。此外，当有新的数据从外设传来，系统会唤醒应用程序让他能够处理数据。在外设建立连接或失去连接时，系统也会唤醒应用程序来进行处理。</p>
<p>iOS 6中，一个使用蓝牙外设的应用程序也可以在外设模式下运行。要充当蓝牙外设，你需要在Xcode工程中的<code>Capabilities</code>选项卡中启这项用服务(您也可以通过在应用程序<code>Info.plis</code>t文件中包含<code>UIBackgroundModes</code>键和<code>bluetooth-peripheral</code>值来启用此支持)。启用此模式可让Core Bluetooth框架在后台简单地唤醒应用程序，以便它可以处理外设的相关请求。</p>
<p>支持蓝牙数据后台处理的任何应用程序都必须基于会话，并遵循以下基本准则：</p>
<ul>
<li><p>应用程序必须提供一个界面，允许用户启动和停止蓝牙事件的传递。</p>
</li>
<li><p>被唤醒后，应用程序大概需要10秒钟才能处理数据。理想情况下，它应该尽可能快地处理数据，并允许自己再次暂停。但是，如果需要更多的时间，应用程序可以使用<code>beginBackgroundTaskWithExpirationHandler</code>：方法来请求更多的时间，它应该只有在绝对必要的时候才这样做。</p>
<p>​</p>
</li>
</ul>
<h2 id="在后台获得用户的注意"><a href="#在后台获得用户的注意" class="headerlink" title="在后台获得用户的注意"></a>在后台获得用户的注意</h2><p>通知是处在挂起，在后台运行或没有运行的应用程序获得用户的注意的一种方式。应用程序可以使用本地通知来显示提醒框，播放声音，标记应用程序的图标或者全部一起使用。比如，一个闹钟应用程序可能会使用本地通知来播放闹铃声并显示一个提醒框来使闹钟不可用。当一个通知被发送给用户，用户必须决定是否授权让应用程序来到前台。如果应用程序已经在前台，本地通知将会被静默的发送给你的应用程序而不是发送给用户。</p>
<p>为了安排本地通知的发送，需要创建一个配置了通知的各个参数的<code>UILocalNotification</code>类的实例并调用<code>UIApplication</code>类的方法。本地通知对象包含了发送通知的类型和在什么时间发送它的信息。<code>UIApplication</code>类的方法提供了是立即发送还是按时间表发送通知的选项。</p>
<p>下面的代码片段展示了如何安排一个由用户设置的使用了日期和时间的闹钟的例子。这个例子在一个时间只配置了一个闹钟并在安排它之前终止了前一个闹钟(你的应用程序在任何给定的时刻都不能拥有超过128个处在活跃状态的本地通知，它们每一个都能设置成以固定的时间间隔重复)。如果闹钟被触发时，应用程序没有运行或者处在后台，闹钟会弹出提醒框并在后台播放音频。如果应用程序是活动且处在前台，则会调用应用程序的代理对象的<code>application:didReceiveLocalNotification:</code>方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (void)scheduleAlarmForDate:(NSDate*)theDate &#123;</span><br><span class="line">    UIApplication* app = [UIApplication sharedApplication];</span><br><span class="line">    NSArray*    oldNotifications = [app scheduledLocalNotifications];</span><br><span class="line"> </span><br><span class="line">    // Clear out the old notification before scheduling a new one.</span><br><span class="line">    if ([oldNotifications count] &gt; 0)</span><br><span class="line">        [app cancelAllLocalNotifications];</span><br><span class="line"> </span><br><span class="line">    // Create a new notification.</span><br><span class="line">    UILocalNotification* alarm = [[UILocalNotification alloc] init];</span><br><span class="line">    if (alarm)</span><br><span class="line">    &#123;</span><br><span class="line">        alarm.fireDate = theDate;</span><br><span class="line">        alarm.timeZone = [NSTimeZone defaultTimeZone];</span><br><span class="line">        alarm.repeatInterval = 0;</span><br><span class="line">        alarm.soundName = @&quot;alarmsound.caf&quot;;</span><br><span class="line">        alarm.alertBody = @&quot;Time to wake up!&quot;;</span><br><span class="line"> </span><br><span class="line">        [app scheduleLocalNotification:alarm];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本地通知使用的音频文件和推送通知使用的要求相同。自定义的音频文件必须位于你应用程序主要包中且必须是以下几种格式：Linear PCM，MA4，μ-Law或者a-Law。你也可以指定<code>UILocalNotificationDefaultSoundName</code>常量来使设备播放默认的提醒声音。当通知被发送且音频被播放时，系统也会触发设备震动来配合。</p>
<h2 id="何时启动应用程序进入后台"><a href="#何时启动应用程序进入后台" class="headerlink" title="何时启动应用程序进入后台"></a>何时启动应用程序进入后台</h2><p>支持后台执行的应用程序可能会被系统重启来处理发生的事件。如果应用程序不是被用户强制退出，系统会启动应用程序在下列事件发生时：</p>
<ul>
<li>对于定位应用程序<ul>
<li>系统收到一个满足发送给应用程序标准的位置更新。</li>
<li>设备进入或退出一个已注册的区域。</li>
</ul>
</li>
<li>对于音频应用程序，音频框架需要应用程序来处理某些数据。</li>
<li>对于蓝牙应用程序<ul>
<li>应用程序作为从连接的外设接收数据的核心角色。</li>
<li>应用程序作为从连接核心接收命令的外设。</li>
</ul>
</li>
<li>对于后台下载应用程序<ul>
<li>应用程序收到一个包含 <code>content-available</code> 键并且值为 <code>1</code>的远程通知。</li>
<li>系统在随机时间唤醒应用程序来开始新内容的下载。</li>
<li>使用<code>NSURLSession</code>对象在后台下载内容的应用程序，当这个会话相关的任务全部成功完成或发生了一个错误。</li>
<li>Newsstand应用程序内容下载完成。</li>
</ul>
</li>
</ul>
<p>在大多数情况下，系统并不会重启被用户强制退出的应用程序。定位应用程序是个例外，在iOS8和之后。如果不是的话，用户必须显式的启动应用程序或者重启设备，系统才能自动的启动程序进入后台。当启用密码保护时，在用户第一次解锁设备之前，系统不会启动任何应用程序进入后台。</p>
<h2 id="成为一个负责的后台运行应用程序"><a href="#成为一个负责的后台运行应用程序" class="headerlink" title="成为一个负责的后台运行应用程序"></a>成为一个负责的后台运行应用程序</h2><p>在使用系统资源和硬件时，前台应用程序始终比后台应用程序的优先级高。后台应用程序需要为这个差异做准备并调整它们的行为：</p>
<ul>
<li><strong>不要在你的代码中进行任何OpenGL ES调用</strong>。在后台运行时，你绝不能创建<code>EAGLContext</code>对象或发出任何OpenGL ES绘图命令。使用这些会使你的应用程序被立即终止。应用程序必须保证任何先前提交的命令在移入后台之前完成。</li>
</ul>
<ul>
<li><strong>在挂起之前停止任何Bonjour-related服务</strong>。在你的应用程序移入后台但未被挂起之前，它应该从Bonjour注销并关闭任何与网络服务相关的监听sockets。一个挂起的应用程序无论如何不能响应任何传入的服务请求。如果你没有关闭Bonjour服务，在应用程序挂起时，系统会自动的关闭它们。</li>
<li><strong>准备好处理基于网络的sockets的连接失败</strong>。系统可能会销毁socket连接，当你的应用程序因为某些原因被挂起时。只要你的基于网络的socket代码准备好了如何处理其他类型的网络失败，比如使用失败信号或网络转化，socket被销毁就不会导致出现任何不寻常的问题。当你的应用程序重新开始运行时，如果使用socket遭遇故障，只需重新建立一个。</li>
<li><strong>在转入后台之前保存你的应用程序的状态</strong>。处于低内存的情况下，后台应用程序可能会被从内存中移除以释放空间。挂起的应用程序首先被移除，并且不会在移除之前通知应用程序。因此，应用程序应该利用iOS 6及之后提供的状态保存机制将应用程序状态信息保存到磁盘。</li>
<li><strong>在转入后台时移除对任何不需要的对象的强引用</strong>。</li>
<li><strong>在挂起之前停止使用共享系统资源</strong>。与共享系统资源进行交互的应用程序应该在被挂起之前停止使用这些资源。前台应用程序总是拥有这些资源的优先使用权。当你的应用程序挂起时，如果被发现它在使用这些共享资源，则会被系统杀死进程。</li>
<li><strong>避免更新窗口和视图</strong>。因为你的应用程序的窗口和视图在后台是不可见的，你应该避免更新它们。如果你的应用程序需要在系统拍摄快照前更新窗口的内容的话则是一种例外情况。</li>
<li><strong>响应外部附件的连接和断开通知</strong>。对于和外部附件通信的应用程序来说，当应用程序转入后台时系统会自动的发送一个断开通知。应用程序必须注册这个通知并用它来关闭当前附件的会话。当应用程序转入前台时，一个匹配连接的通知被发送，给应用程序重新连接的机会。</li>
<li><strong>在转入后台时清理活动的提醒框的资源</strong>。为了在各个应用程序之间进行切换时保存上下文，在你的应用程序进入后台时，系统不会自动地释放上拉菜单或提醒视图。在应用程序转入后台之前，你需要提供合适的清理行为。</li>
<li><strong>在转入后台之前从视图中移除敏感信息</strong>。当应用程序转入后台时，系统会对应用程序的主窗口拍摄快照，当应用程序转入到前台时，这个快照会短暂的显示。在从<code>applicationDidEnterBackground:</code>方法返回之前，你应该隐藏或混淆可能被作为快照一部分拍摄的密码和其它敏感的个人信息</li>
<li><strong>在后台运行时尽可能的少做工作</strong>。给与后台应用程序的执行时间相比于前台应用程序来说有更多的限制。应用程序不应该在后台执行太长时间，这可能导致应用程序被终止。</li>
</ul>
<h2 id="选择退出后台执行"><a href="#选择退出后台执行" class="headerlink" title="选择退出后台执行"></a>选择退出后台执行</h2><p>如果你不希望你的应用程序在后台运行，你可以通过将值为<code>YES</code>的<code>UIApplicationExitsOnSuspend</code>键加入<code>Info.plist</code>来显式的退出后台模式。当一个应用程序选择退出后台，它的生命周期将在未运行，非活动和活动状态之间转换，永远不会进入后台或被挂起状态。当用户按下Home按钮来退出应用程序时，应用程序代理对象的<code>applicationWillTerminate:</code>方法将会被调用，应用程序将有大约5秒时间在它被终止或移入未运行状态之前来执行清理任务并退出。</p>
<p>强烈不鼓励退出后台执行，但在某些情况下可能是首选。 具体来说，如果后台执行的编码对你的应用程序来说增加了很大的复杂性，那么终止应用程序可能会更简单。 此外，如果你的应用程序消耗大量内存，并且无法轻松释放任何内存，系统可能会迅速杀死你的应用程序，为其他应用程序腾出空间。 因此，选择终止，而不是切换到后台，可能会产生相同的结果，并节省你的开发时间和精力。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2015-10-17T16:00:00.000Z" title="2015/10/18 上午12:00:00">2015-10-18</time>发表</span><span class="level-item"><a class="link-muted" href="/categories/iOS/">iOS</a></span><span class="level-item">1 小时读完 (大约8088个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2015/10/18/ios-application-life-cycle/">应用程序生命周期和状态转换操作策略</a></h1><div class="content"><h1 id="iOS-应用程序生命周期"><a href="#iOS-应用程序生命周期" class="headerlink" title="iOS 应用程序生命周期"></a>iOS 应用程序生命周期</h1><hr>
<h2 id="基本概念介绍"><a href="#基本概念介绍" class="headerlink" title="基本概念介绍"></a>基本概念介绍</h2><h3 id="The-Main-Function-程序的入口"><a href="#The-Main-Function-程序的入口" class="headerlink" title="The Main Function - 程序的入口"></a>The Main Function - 程序的入口</h3><p><code>main</code>函数是每个基于C的应用程序的入口，iOS也是这样。在Xcode中开发iOS程序的话，Xcode会自动为你创建这个函数作为你工程的一部分。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>main</code>函数控制UIKit framework的工作。<code>UIApplicationMain</code>函数通过创建应用程序的核心对象，从可用的<code>storyboard</code>文件加载应用程序的用户界面，调用自定义代码，以便让你可以在程序启动时进行一些初始设置，并将应用程序的运行循环启动。 </p>
<h3 id="The-Structure-of-an-App-程序的结构"><a href="#The-Structure-of-an-App-程序的结构" class="headerlink" title="The Structure of  an App - 程序的结构"></a>The Structure of  an App - 程序的结构</h3><p>在启动过程中，<code>UIApplicationMain</code>函数设置了几个关键对象，启动应用程序并开始运行它。 每个iOS应用程序的核心都是<code>UIApplication</code>对象，其工作是为了方便系统与应用程序中的其他对象之间的交互。 </p>
<p>一个iOS应用程序中包含的关键对象：</p>
<img src="https://raw.githubusercontent.com/apple272487813/apple272487813.github.io/master/images/application_life_cycle/application_core_objects.png"  style="zoom:50%"/>



<p>一个iOS应用程序中各个对象的所起到的作用：</p>
<table>
<thead>
<tr>
<th align="left">Object</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>UIAppplication</code></td>
<td><code>UIApplication</code>对象管理着App的事件循环和一些高级App行为，并向它的委托对象报告App的状态转换和一些特殊事件。</td>
</tr>
<tr>
<td align="left"><code>Appdelegate</code></td>
<td><code>Appdelegate</code>是你编写的程序代码的核心 ，它与<code>UIApplication</code>对象一起工作，处理应用程序初始化，状态转换和许多高级App行为。 这个对象也是唯一一个保证在每个应用程序中都出现的对象，因此通常用于设置应用程序的初始数据结构。</td>
</tr>
<tr>
<td align="left"><code>ViewController</code></td>
<td><code>View Controller</code>对象管理着你的App内容在屏幕上是如何呈现的。一个<code>View Controller</code>对象管理着一个视图和这个视图的子视图。</td>
</tr>
<tr>
<td align="left"><code>UIWindow</code></td>
<td><code>UIWindow</code>对象协调屏幕上一个或多个视图的呈现。 大多数应用程序只有一个窗口，它在主屏幕上显示内容，但应用程序可能会在外部显示器上显示内容的附加窗口。要更改应用程序的内容，可以使用视图控制器更改相应窗口中显示的视图。 你永远不会更换窗口本身。除了托管视图之外，<code>Windows</code>还可以使用<code>UIApplication</code>对象将事件传递给的视图和控制器。</td>
</tr>
<tr>
<td align="left"><code>View,Control and Layer</code></td>
<td>View和Control提供了应用内容的可视化表示。 除了包含View和Control之外，应用程序还可以将Core Animation图层纳入其视图和控制层次结构中。 层对象实际上才是表示可视内容的数据对象。</td>
</tr>
</tbody></table>
<h3 id="The-Main-Run-Loop-主运行循环"><a href="#The-Main-Run-Loop-主运行循环" class="headerlink" title="The Main Run Loop - 主运行循环"></a>The Main Run Loop - 主运行循环</h3><p>应用程序的主运行循环处理所有与用户相关的事件。 <code>UIApplication</code>对象在启动时设置主运行循环，并使用它来处理事件并处理基于视图的接口的更新。</p>
<p> 顾名思义，主运行循环在应用程序的主线程上执行，这确保了与用户相关的事件按照接收的顺序连续处理。</p>
<p>当用户与设备进行交互时，与这些交互相关的事件由系统生成，并通过由UIKit设置的特殊端口传送到应用。 事件在应用程序内部进入队列，并逐个分派到主运行循环执行。<code>UIApplication</code>对象是接收事件的第一个对象，并且决定需要做什么来处理这个事件。 触摸事件通常被分派到主窗口对象，主窗口对象又将其发送到触摸发生的视图。 </p>
<img src="https://raw.githubusercontent.com/apple272487813/apple272487813.github.io/master/images/application_life_cycle/application_event_draw_cycle.png" style="zoom:50%"/>

<p>可以在iOS应用程式中分发许多类型的事件。 最常见的如下表所示。 这些事件大多是使用应用程序的主运行循环分发的，但也有些不是。 一些事件被分发到一个委托对象或被分发给你提供的一个block。</p>
<table>
<thead>
<tr>
<th>事件类型</th>
<th>分发对象</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>触摸事件</td>
<td>事件发生的视图</td>
<td>视图是响应者对象。任何没有被当前视图处理的触摸事件都会被沿着响应链继续向下分发进行处理。</td>
</tr>
<tr>
<td>遥控器事件和摇动运动事件</td>
<td>首要响应对象</td>
<td>遥控器事件用于控制媒体播放，并由耳机和其他附件产生。</td>
</tr>
<tr>
<td>加速度计、磁力仪和陀螺仪</td>
<td>你指定的对象</td>
<td>与加速度计，磁力计和陀螺仪硬件相关的事件传递给你指定的对象。</td>
</tr>
<tr>
<td>定位</td>
<td>你指定的对象</td>
<td>你注册定位服务以接收使用Core Location框架位置的事件。</td>
</tr>
<tr>
<td>重绘</td>
<td>需要更新的视图</td>
<td>重绘事件不涉及事件对象，而是简单地调用视图来绘制自身。</td>
</tr>
</tbody></table>
<p>一些事件，如触摸和遥控事件，由你的应用程序的响应者对象处理。响应者对象在你的应用程序中无处不在。 大多数事件都针对特定的响应者对象，但如果需要处理事件，则可以将其传递给其他响应方（通过响应者链）。 例如，不处理事件的视图可以将事件传递到其父视图或父视图控制器。</p>
<p>触摸控件（如按钮）中发生的事件的处理方式与在许多其他类型的视图中发生的触摸事件的处理方式不同。 通常只有有限数量的交互可能与控件相关联，因此这些交互被重新封装到动作消息中并传递到适当的目标对象。 这种目标动作(Target-Action)设计模式可以轻松地使用控件来触发你应用中自定义代码的执行。</p>
<h3 id="Execution-States-for-Apps-应用程序的执行状态"><a href="#Execution-States-for-Apps-应用程序的执行状态" class="headerlink" title="Execution States for Apps - 应用程序的执行状态"></a>Execution States for Apps - 应用程序的执行状态</h3><p>在任何给定的时刻，你的应用程序都处在下表所列的状态之一。 系统会改变应用程序的状态以响应整个系统中发生的操作。</p>
<table>
<thead>
<tr>
<th>状态</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Not running</td>
<td>应用程序没有运行或被系统终止运行。</td>
</tr>
<tr>
<td>Inactive</td>
<td>应用程序正在前台运行，但当前没有收到事件 (它可能正在执行其他代码)。应用程序通常在转换到不同的状态时暂时保持在此状态。</td>
</tr>
<tr>
<td>Active</td>
<td>应用程序正在前台运行，并且正在接收事件(这是前台应用程序的正常模式)。</td>
</tr>
<tr>
<td>Background</td>
<td>应用程序在后台执行代码。 大多数应用程序短暂地进入此状态。 但是，请求额外执行时间的应用程序可能会保持此状态一段时间。</td>
</tr>
<tr>
<td>Suspended</td>
<td>应用程序是在后台，但不执行代码。 系统将应用程序自动转换到这个状态，在这样做之前并不会通知应用程序。 挂起时，应用程序保留在内存中，但不执行任何代码。当出现低内存条件时，系统可能会清除已挂起的应用程序，以为前台应用程序腾出更多空间。</td>
</tr>
</tbody></table>
<p>下图展示了应用程序在各种状态之间的转换：</p>
<img src="https://raw.githubusercontent.com/apple272487813/apple272487813.github.io/master/images/application_life_cycle/application_high_level_flow.png" style="zoom:50%"/>

<p>大多数状态转换伴随着对应用程序委托对象的方法的相应调用 ，这些方法是你以适当方式响应状态变更的地方。 </p>
<ul>
<li><p><code>application:willFinishLaunchingWithOptions:</code></p>
<p>告诉代理对象启动过程已经开始，但还没有发生状态恢复。</p>
</li>
<li><p><code>application:didFinishLaunchingWithOptions:</code></p>
<p>告诉代理对象启动过程快要完成，应用程序快要准备好运行。</p>
</li>
<li><p><code>applicationDidBecomeActive:</code></p>
<p>告诉代理对象应用程序已经处于Active状态。</p>
</li>
<li><p><code>applicationWillResignActive:</code></p>
<p>告诉代理对象应用程序即将进入Inactive状态。</p>
</li>
<li><p><code>applicationDidEnterBackground:</code></p>
<p>告诉代理对象应用程序已经进入后台。</p>
</li>
<li><p><code>applicationWillEnterForeground:</code></p>
<p>告诉代理对象应用程序即将进入前台。</p>
</li>
<li><p><code>applicationWillTerminate:</code></p>
<p>告诉代理对象应用程序即将被终止。</p>
<p>​</p>
</li>
</ul>
<h3 id="App-Termination-应用程序的终止"><a href="#App-Termination-应用程序的终止" class="headerlink" title="App Termination - 应用程序的终止"></a>App Termination - 应用程序的终止</h3><p>应用程序必须随时准备终止运行，不应等待保存用户数据或执行其他关键任务。 System-initiated termination是应用程序生命周期的正常部分。该系统通常终止应用程序，以便它可以回收内存并为用户启动的其他应用程序腾出空间，但是系统也可能会终止行为不当或未及时响应事件的应用程序。</p>
<p>挂起的应用程序终止时不会收到通知，系统将杀死该进程并回收相应的内存。如果一个应用程序当前在后台运行并且没有挂起，系统会在终止之前调用应用程序委托的<code>applicationWillTerminate：</code>。当设备重新启动时，系统不会调用此方法。</p>
<p>除了系统终止你的应用程序，用户可以使用多任务UI显式地终止你的应用程序。System-initiated termination与终止挂起的应用程序具有相同的效果。该应用程序的进程被杀死，并且不会有通知发送到该应用程序。</p>
<h3 id="Threads-and-Concurrency-线程和并发"><a href="#Threads-and-Concurrency-线程和并发" class="headerlink" title="Threads and Concurrency - 线程和并发"></a>Threads and Concurrency - 线程和并发</h3><p>系统创建你的应用程序的主线程，你可以根据需要创建其他线程来执行其他任务。</p>
<p>对于iOS应用，首选技术是使用Grand Central Dispatch（GCD），操作对象和其它异步编程接口，而不是自己创建和管理线程。 GCD等技术可以让你定义想要执行的工作以及要执行的顺序，但让系统决定如何在可用的CPU上执行该工作。让系统处理线程管理简化了必须编写的代码，使得更容易确保代码的正确性，并提供更好的整体性能。</p>
<p>在考虑线程和并发时，请考虑以下几点：</p>
<ul>
<li><p>涉及视图，核心动画和许多其他UIKit类的工作通常必须发生在应用程序的主线程上。</p>
</li>
<li><p>长时间的任务（或潜在的长度任务）应始终在后台线程上执行。任何涉及网络访问，文件访问或大量数据处理的任务都应使用GCD或操作对象异步执行。</p>
</li>
<li><p>在启动时，尽可能将任务从主线程移出。在启动时，您的应用程序应尽可能快地设置用户界面。只有有助于设置用户界面的任务才能在主线程上执行。</p>
<p>所有其他任务应该是异步执行的。</p>
</li>
</ul>
<hr>
<h2 id="操作应用程序的状态转换"><a href="#操作应用程序的状态转换" class="headerlink" title="操作应用程序的状态转换"></a>操作应用程序的状态转换</h2><hr>
<p>对于应用程序的任何一个可能的运行状态，系统都对你的应用程序有不同的期望。当应用程序的状态发生转换时，系统会通知应用对象，应用对象又通知其代理。你可以使用<code>UIApplicationDelegate</code>协议的状态转换方法来检测这些状态变化并进行适当的响应。</p>
<h2 id="应用程序启动时应该做什么"><a href="#应用程序启动时应该做什么" class="headerlink" title="应用程序启动时应该做什么"></a>应用程序启动时应该做什么</h2><p>当应用程序启动(进入前台货后台)时，你应该使用应用程序委托对象的<code>application:willFinishLaunchingWithOptions:</code>和<code>application：didFinishLaunchingWithOptions：</code>方法执行一些操作：</p>
<ul>
<li><p>检查启动选项字典的内容(launch options dictionary)，了解应用程序启动的原因，并作出适当的响应。</p>
</li>
<li><p>初始化应用程序的关键数据结构。</p>
</li>
<li><p>准备应用程序的窗口和视图以进行内容显示。</p>
<ul>
<li><p>使用OpenGL ES进行绘图的应用程序不能使用这些方法来准备绘图环境，使用OpenGL ES绘图应该在<code>applicationDidBecomeActive:</code>方法中进行准备。</p>
</li>
<li><p>Show your app window from your <code>application:willFinishLaunchingWithOptions:</code> method. UIKit delays making the window visible until after the <code>application:didFinishLaunchingWithOptions:</code> method returns.</p>
</li>
<li><p>在<code>application:willFinishLaunchingWithOptions:</code>方法中配置如何显示应用程序的Window。UIKit延迟Window的显示直到<code>application:didFinishLaunchingWithOptions:</code>方法进行了返回。</p>
</li>
</ul>
</li>
</ul>
<p>在启动时，系统会自动的加载应用程序的主要storyBoard文件，并加载初始视图控制器。对于支持状态恢复的应用程序，状态恢复机制会在调用<code>application:willFinishLaunchingWithOptions:</code>和 <code>application:didFinishLaunchingWithOptions:</code>方法之间将应用程序恢复到以前的状态。使用<code>application:willFinishLaunchingWithOptions:</code>方法显示应用程序窗口，并确定状态恢复是否应该发生。使用<code>application:didFinishLaunchingWithOptions:</code>方法对应用程序的用户界面进行任何最终调整。</p>
<p><code>application:willFinishLaunchingWithOptions:</code>和<code>application:didFinishLaunchingWithOptions:</code>方法应始终尽可能轻量级，以减少应用程序的启动时间。如果应用程序没有及时完成其启动周期，系统将使其无法响应。因此，任何可能减慢启动速度的任务（如访问网络）都应该在辅助线程上执行。</p>
<h3 id="The-Launch-Cycle-启动周期"><a href="#The-Launch-Cycle-启动周期" class="headerlink" title="The Launch Cycle - 启动周期"></a>The Launch Cycle - 启动周期</h3><p>当你的应用程序启动后，在短暂的停留在非活动状态(Inactive)后，将会从非运行状态(Not Running)转换到活动状态(Active)或后台状态(Background)。作为启动周期的一部分，系统会为你的应用程序创建一个进程和一个主线程，并在主线程中调用应用程序的<code>main</code>函数。</p>
<p>下图显示了应用程序启动到前台时发生的事件序列，包括调用的应用程序委派方法。</p>
<img src="https://raw.githubusercontent.com/apple272487813/apple272487813.github.io/master/images/application_life_cycle/app_launch_fg.png" style="zoom:50%" />



<p>当你的应用程序启动到后台时，通常要处理一些后台事件，启动周期会有些许改变。主要的不同在于，在后台的应用程序不是处于活动状态，只是进入后台来处理一些事件，之后可能会被挂起。当启动到后台时，系统仍然会加载用户界面文件，但不会显示应用程序的窗口。</p>
<img src="https://raw.githubusercontent.com/apple272487813/apple272487813.github.io/master/images/application_life_cycle/app_launch_bg.png" style="zoom:50%"/>

<p>你可以通过在代理方法 <code>application:willFinishLaunchingWithOptions:</code> 和<code>application:didFinishLaunchingWithOptions:</code>中检查<code>UIApplication</code>的<code>applicationState</code>属性来决定应用程序是启动到前台还是后台。当你的应用程序启动到前台时，这个属性的值是<code>UIApplicationStateInactive</code>，当你的应用程序启动到后台时，这个属性的值是<code>UIApplicationStateBackground</code>。</p>
<h3 id="Launching-in-Landscape-Mode-以横屏模式启动"><a href="#Launching-in-Landscape-Mode-以横屏模式启动" class="headerlink" title="Launching in Landscape Mode - 以横屏模式启动"></a>Launching in Landscape Mode - 以横屏模式启动</h3><p>对于界面只使用横屏的应用程序来说，必须明确地请求系统以横屏模式启动。通常来说，应用程序以纵屏模式启动，只有在需要适应设备的方向的时候才旋转屏幕的方向。 对于支持纵向和横向方向的应用程序，应始终为纵向模式配置视图，然后让视图控制器处理任何旋转。<br>但是，如果您的应用程序支持横向而不是纵向方向，请执行以下任务，让使其以横向模式启动：</p>
<ul>
<li>像你应用程序中的<code>Infl.plist</code>文件中添加<code>UIInterfaceOrientation</code>字段，并将其值设为<code>UIInterfaceOrientationLandscapeLeft</code>或<code>UIInterfaceOrientationLandscapeRight</code>。</li>
<li>在横屏模式下布局你的视图并确保视图的布局和自动调整大小选项设置正确。</li>
<li>重写试图控制器的<code>shouldAutorotateToInterfaceOrientation:</code>方法并在左向横屏或右向横屏时返回<code>YES</code>，在纵屏模式下返回<code>NO</code>。</li>
</ul>
<blockquote>
<p><strong>重要提示:</strong> 应用程序应该总是用视图控制器来管理基于窗口(Window)的内容。</p>
</blockquote>
<p>在<code>Info.plist</code>文件中的<code>UIInterfaceOrientation</code>字段告诉iOS系统该如何配置应用程序状态栏的方向(如果显示的话)以及任何视图控制器管理的视图在启动时的方向。视图控制器根据这个字段设置它的视图的初始方向。 使用此字段相当于在执行你的<code>applicationDidFinishLaunching:</code>方法的早期调用应用程序的<code>setStatusBarOrientation：animated:</code>方法。</p>
<h3 id="Installing-App-Specific-Data-Files-at-First-Launch-配置应用程序数据文件"><a href="#Installing-App-Specific-Data-Files-at-First-Launch-配置应用程序数据文件" class="headerlink" title="Installing App-Specific Data Files at First Launch - 配置应用程序数据文件"></a>Installing App-Specific Data Files at First Launch - 配置应用程序数据文件</h3><p>你可以使用应用程序的第一个启动周期来设置任何应用程序运行所需要的数据或配置文件。 应用程序特定的数据文件应在应用程序沙箱的<code>Library/Application Support/&lt;bundleID&gt;/</code>目录中创建，其中<bundleID>是应用程序的标识符。你可以根据需要细分目录来组织你的数据文件。</p>
<p>如果应用程序包中包含你打算进行修改的数据文件，你应该将要修改的数据文件从应用程序的数据包中复制出来进行修改。你不能在应用程序包中修改数据文件，因为iOS应用程序是代码签名的，在应用程序包中修改数据文件会使应用程序的签名失效，使得你的应用程序无法启动。将打算修改的数据文件复制到<code>Application Support</code>(或者其它可写的目录)目录下进行修改是唯一安全的方式。</p>
<h2 id="应用程序临时被打断时应该做什么"><a href="#应用程序临时被打断时应该做什么" class="headerlink" title="应用程序临时被打断时应该做什么"></a>应用程序临时被打断时应该做什么</h2><p>基于警报的打断会导致你的应用程序临时性的失去控制。这种情况下，你的应用程序仍然运行在前台，但是不接收任何来自系统的触摸事件(但是会继续接收推送通知等其他类型的时间，比如加速度计时间等)。你应该在<code>applicationWillResignActive:</code>方法中进行如下操作来处理这种情况：</p>
<ul>
<li>保存数据以及任何相关的状态信息。</li>
<li>停止计时器和其他周期性任务。</li>
<li>停止任何进行的数据请求任务。</li>
<li>不要创建任何新的任务。</li>
<li>停止视屏播放(除了通过AriPlay播放的视屏)</li>
<li>如果你的应用程序是游戏的话，是游戏进入暂停状态。</li>
<li>提高OpenGL ES 帧速率。</li>
<li>暂停执行非关键代码的任何调度队列或操作队列。 (可以在不活动的情况下继续处理网络请求和其他时间敏感的后台任务)</li>
</ul>
<p>当你的应用程序返回活动状态时，在<code>applicationDidBecomeActive:</code>方法中应该进行与<code>applicationWillResignActive:</code>相反的操作步骤。因此，一但重新活动，你的应用程序应重新启动计时器，恢复调度队列，并再次调低OpenGL ES帧速率。 但是，游戏不应该自动恢复，它们应该保持暂停，直到用户选择恢复它们为止。</p>
<p>当用户按下睡眠或唤醒按钮时，含有<code>NSFileProtectionComplete</code>保护选项的文件的应用程序必须关闭这些被保护文件的任何引用。对于设置了相应密码的设备，按下睡眠或唤醒按钮时应该锁定屏幕并强制系统丢弃对拥有完全保护文件的解密密钥。当屏幕锁定时，任何尝试访问相关文件的操作都会失败。所以你如果有这样的文件，你应该在<code>applicationWillResignActive:</code>方法中关闭对它们的任何引用，在<code>applicationDidBecomeActive:</code>中打开新的引用。</p>
<p><strong>重要提示:</strong> 你应该总是在适当的时候保存用户数据。虽然你可以使用应用程序状态转换来强制对象将为保存的变更写入磁盘，但是合适的做法是永远不要等到状态转换时才去保存数据。</p>
<h3 id="Responding-to-Temporary-Interruptions-响应临时打断"><a href="#Responding-to-Temporary-Interruptions-响应临时打断" class="headerlink" title="Responding to Temporary Interruptions - 响应临时打断"></a>Responding to Temporary Interruptions - 响应临时打断</h3><p>当基于警报的打断发生时(比如打进电话)，应用程序暂时进入非活动状态已便系统可以提示用户如和继续操作。应用程序保持在这个状态直到用户拒绝了这个警报，这时应用程序会返回前台进入活动状态或进入后台。</p>
<img src="https://raw.githubusercontent.com/apple272487813/apple272487813.github.io/master/images/application_life_cycle/app_interruptions.png" style="zoom:50%"/>

<p>以横幅形式显示的通知不会像基于警报的通知那样是你的应用程序进入非活动状态。尽管横幅放置在你应用程序窗口的顶部边缘，但是你的应用程序还是能够继续接收触摸事件。然而如果用户下拉横幅以便查看通知中心，你的应用程序就会像基于警报的打断发生时那样进入非活动状态。你的应用程序保持在非活动状态直到用户退出通知中心或启动另一个应用程序，这时，你的应用程序相应的会进入非活动转台或后台。</p>
<p>按下睡眠或唤醒按钮是另一种类型的可以导致你的应用程序暂时进入非活动状态的打断。当用户按下这个按钮，系统会使触摸事件变得不可用并让应用程序进入后台，同时将<code>applicationState</code>的值设置为<code>UIApplicationStateBackground</code>并锁定屏幕。</p>
<h2 id="应用程序在前台时做什么"><a href="#应用程序在前台时做什么" class="headerlink" title="应用程序在前台时做什么"></a>应用程序在前台时做什么</h2><p>当你的应用程序返回前台进入活动状态时，你可以重新启动在进入后台时停止的任务。移动到前台时出现的步骤如下图所示，<code>applicationWillEnterForeground：</code>方法应该撤消在<code>applicationDidEnterBackground：</code>方法中完成的任何内容，并且<code>applicationDidBecomeActive：</code>方法应该继续执行与启动时相同的激活任务。</p>
<img src="https://raw.githubusercontent.com/apple272487813/apple272487813.github.io/master/images/application_life_cycle/app_enter_foreground.png" style="zoom:50%"/>



<h3 id="Be-Prepared-to-Process-Queued-Notifications-准备处理通知队列"><a href="#Be-Prepared-to-Process-Queued-Notifications-准备处理通知队列" class="headerlink" title="Be Prepared to Process Queued Notifications - 准备处理通知队列"></a>Be Prepared to Process Queued Notifications - 准备处理通知队列</h3><p>一个处于挂起状态的应用程序必须做好在返回前台或进入后台执行状态时处理任何在队列中的通知。处于挂起状态的应用程序不执行任何代码，因此不能处理通知引发的屏幕方向改变，时间改变，偏好改变以及其它会影响应用程序的外观和状态的改变。为了确保这些改变不会丢失，系统将相关的通知放入队列并在应用程序开始执行代码(无论在前台还是后台)时分发通知给它。为了防止应用程序在恢复通知时变得超负荷，系统会将事件合并，并提供一个单一的通知（每种相关类型），反映自您的应用程序被挂起以来的净变化。</p>
<p>下表列出了分发给你的应用程序的可以合并的通知。这些通知的大多数都直接分发给已经注册的观察者。</p>
<table>
<thead>
<tr>
<th>Event</th>
<th>Notifications</th>
</tr>
</thead>
<tbody><tr>
<td>An accessory is connected or disconnected.</td>
<td><code>EAAccessoryDidConnectNotification</code> <code>EAAccessoryDidDisconnectNotification</code></td>
</tr>
<tr>
<td>设备方向改变</td>
<td><code>UIDeviceOrientationDidChangeNotification</code>除了这个通知，视图控制器自动的改变自己的方向。</td>
</tr>
<tr>
<td>重要的时间改变</td>
<td><code>UIApplicationSignificantTimeChangeNotification</code></td>
</tr>
<tr>
<td>电池状态改变</td>
<td><code>UIDeviceBatteryLevelDidChangeNotification</code> <code>UIDeviceBatteryStateDidChangeNotification</code></td>
</tr>
<tr>
<td>The proximity state changes.</td>
<td><code>UIDeviceProximityStateDidChangeNotification</code></td>
</tr>
<tr>
<td>被保护的文件的状态的改变</td>
<td><code>UIApplicationProtectedDataWillBecomeUnavailable</code> <code>UIApplicationProtectedDataDidBecomeAvailable</code></td>
</tr>
<tr>
<td>内建显示器连接或失去连接</td>
<td><code>UIScreenDidConnectNotification</code> <code>UIScreenDidDisconnectNotification</code></td>
</tr>
<tr>
<td>屏幕显示模式改变</td>
<td><code>UIScreenModeDidChangeNotification</code></td>
</tr>
<tr>
<td>通过设置应用程序改变了应用程序的设置</td>
<td><code>NSUserDefaultsDidChangeNotification</code></td>
</tr>
<tr>
<td>当前语言或本地化设置改变</td>
<td><code>NSCurrentLocaleDidChangeNotification</code></td>
</tr>
<tr>
<td>用户的iCloud账户状态改变</td>
<td><code>NSUbiquityIdentityDidChangeNotification</code></td>
</tr>
</tbody></table>
<p>通常在任何触摸事件或用户输入事件之前，在主线程中分发队列化的通知。大多数的应用程序应该足够快地处理这些事件，避免在重启是导致可观察到的延迟。</p>
<p>应用程序返回前台时也会接收到要更新自从上次更新以来被标记为dirty的视图的通知。一个运行在后台的应用程序仍然能调用<code>setNeedsDisplay</code> 和 <code>setNeedsDisplayInRect:</code>方法来请求更新视图。然而，因为这些请求更新的视图不可见，系统合并了这些请求并在应用程序进入前台后才更新它们。</p>
<h3 id="Handle-iCloud-Changes-处理iCloud改变"><a href="#Handle-iCloud-Changes-处理iCloud改变" class="headerlink" title="Handle iCloud Changes - 处理iCloud改变"></a>Handle iCloud Changes - 处理iCloud改变</h3><p>当iCloud的状态发生改变时，系统会发送一个<code>NSUbiquityIdentityDidChangeNotification</code>通知给你的应用程序。用户登入或登出iCloud账号，关闭了文档和数据的同步，都会引起iCloud状态的改变。这个通知表示应用程序应该更新缓存和与iCloud有关的用户界面元素。</p>
<p>如果你的应用程序已经提示了用户是否要在iCloud存储文件的话，不要在iCloud状态发生改变时再次提醒。在第一次提醒了用户后，将用户的选择保存在本地的偏好设置中。</p>
<h3 id="Handle-Locale-Changes-处理本地化改变"><a href="#Handle-Locale-Changes-处理本地化改变" class="headerlink" title="Handle Locale Changes - 处理本地化改变"></a>Handle Locale Changes - 处理本地化改变</h3><p>如果用户在你的应用程序挂起时改变了当前的本地化方案，当你的应用程序返回前台时，你可以使用<code>NSCurrentLocaleDidChangeNotification</code>通知来强制更新包含了对本地化方案敏感的信息，比如日期，时间和数字。当然，最好的避免发生本地化相关的问题的方法是用能简单更新视图的方法来编写代码：</p>
<ul>
<li>使用<code>autoupdatingCurrentLocale</code>类方法当你检索到<code>NSLocal</code>对象。这个方法返回一个可以自动更新自己来响应本地化方案改变的本地化对象，所以你永远不需要重新创建它。然而，当本地化方案发生改变时，你仍然需要更新包含来自于当前本地化方案的信息的视图。</li>
<li>重新创建任何缓存的日期和数字格式，无论当前本地化方案何时发生变化。</li>
</ul>
<h3 id="Handle-Changes-to-Your-App’s-Settings-处理偏好设置的改变"><a href="#Handle-Changes-to-Your-App’s-Settings-处理偏好设置的改变" class="headerlink" title="Handle Changes to Your App’s Settings - 处理偏好设置的改变"></a>Handle Changes to Your App’s Settings - 处理偏好设置的改变</h3><p>如果你的应用程序含有被设置应用程序管理的设置选项，你应该监测<code>NSUserDefaultsDidChangeNotification</code>通知，因为用户可以改变这些设置当你的应用程序被挂起或在后台。你可以使用这个通知来响应并处理在这些设置上的重要改变。</p>
<p>一旦收到<code>NSUserDefaultsDidChangeNotification</code>通知，你的应用程序应该重新加载任何相关的设置，如果需要，恰当地重置用户界面。</p>
<h2 id="应用程序在后台时做什么"><a href="#应用程序在后台时做什么" class="headerlink" title="应用程序在后台时做什么"></a>应用程序在后台时做什么</h2><p>当应用程序从前台转为后台执行时，使用你的代理对象的<code>applicationDidEnterBackground:</code>方法来做：</p>
<ul>
<li>准备应用程序的照片。当你的<code>applicationDidEnterBackground:</code>返回时，系统会对你的应用程序的用户界面拍照并用这个照片来做过度动画。如果你的应用程序里的视图包含敏感信息，你应该在<code>applicationDidEnterBackground:</code>返回之前隐藏或更改这些视图。</li>
<li>保存任何应用程序状态的相关信息。在进入后台之前，你的应用程序应该已经保存好了所有重要的用户数据。使用转换到后台来保存应用程序状态的最后一分钟更改。</li>
</ul>
<p>你的应用程序代理对象的<code>applicationDidEnterBackground:</code>方法大约有5分钟的时间来结束任何任务并返回。实际上，这个方法应该可能快的返回。如果这个方法没有在时间耗尽前返回，你的应用程序将会被终止并被移出内存。如果你仍然需要更多的时间来执行任务，调用<code>beginBackgroundTaskWithExpirationHandler:</code>方法来请求后台执行时间，然后在一个次要线程里开始任何长时任务。不管你有没有开始一个后台任务，<code>applicationDidEnterBackground:</code>方法都会在5分钟内退出。</p>
<p><strong>提示:</strong> 除了调用<code>applicationDidEnterBackground:</code>方法外，系统还会发送<code>UIApplicationDidEnterBackgroundNotification</code>通知。你可以使用这个通知将清理任务分发给应用程序里的其它对象。</p>
<h3 id="The-Background-Transition-Cycle-后台转换周期"><a href="#The-Background-Transition-Cycle-后台转换周期" class="headerlink" title="The Background Transition Cycle - 后台转换周期"></a>The Background Transition Cycle - 后台转换周期</h3><p>When the user presses the Home button, presses the Sleep/Wake button, or the system launches another app, the foreground app transitions to the inactive state and then to the background state. These transitions result in calls to the app delegate’s <code>applicationWillResignActive:</code> and <code>applicationDidEnterBackground:</code> methods, as shown in Figure 4-5. After returning from the <code>applicationDidEnterBackground:</code> method, most apps move to the suspended state shortly afterward. Apps that request specific background tasks (such as playing music) or that request a little extra execution time from the system may continue to run for a while longer.</p>
<p>当用户按下Home键，按下睡眠或唤醒按钮，或者系统启动了另一个应用程序，运行在前台的应用程序会转换为非活动状态然后进入后台。这些状态转换会导致调用<code>applicationWillResignActive:</code> 和 <code>applicationDidEnterBackground:</code>方法，如下图所示。从<code>applicationDidEnterBackground：</code>方法返回后，大多数应用程序不久之后就会转换到挂起状态。 请求特定后台任务（如播放音乐）或从系统请求一点额外执行时间的应用程序可能会持续运行一段时间。</p>
<img src="https://raw.githubusercontent.com/apple272487813/apple272487813.github.io/master/images/application_life_cycle/app_bg_life_cycle.png" style="zoom:50%"/>



<h3 id="Prepare-for-the-App-Snapshot-准备应用程序快照"><a href="#Prepare-for-the-App-Snapshot-准备应用程序快照" class="headerlink" title="Prepare for the App Snapshot - 准备应用程序快照"></a>Prepare for the App Snapshot - 准备应用程序快照</h3><p>系统在应用程序代理对象<code>applicationDidEnterBackground:</code>方法返回的不久之前，对应用程序的窗口进行快照。相似的，当应用程序被唤醒执行后台任务时，系统会对应用程序进行一次新的反应改变的快照。</p>
<p>如果在进入后台更改视图时，可以调用主视图的<code>snapshotViewAfterScreenUpdates：</code>方法来强制执行这些更改。在一个视图上调用<code>setNeedsDisplay</code>方法对快照是无效的，因为快照发生在下一个绘制周期之前。调用值为“YES”的<code>snapshotViewAfterScreenUpdates：</code>方法将立即使用机器的底层缓冲区更新快照。</p>
<h3 id="Reduce-Your-Memory-Footprint"><a href="#Reduce-Your-Memory-Footprint" class="headerlink" title="Reduce Your Memory Footprint"></a>Reduce Your Memory Footprint</h3><p>每个应用程序应该在进入后台时释放尽可能多的内存。 系统尝试尽可能多地在内存中保留应用程序，但是当内存不足时，会终止挂起的应用程序以回收该内存。 在后台消耗大量内存的应用程序是第一个要终止的应用程序。</p>
<p>实际上，你的应用程序应该在不再需要的时候删除对对象的强引用。 删除强引用使编译器能够立即释放对象，以便可以回收对应的内存。 但是，如果要缓存某些对象以提高性能，则可以等到应用程序转换到后台再删除对它们的引用。</p>
<p>应该尽快删除强引用的对象的一些示例包括：</p>
<ul>
<li>你创建的图像对象。</li>
<li>可以从磁盘重新加载的大型媒体或数据文件</li>
<li>您的应用程序不需要的任何稍后可以重新创建其他对象。</li>
</ul>
<p>为了帮助你减少应用程序的内存占用空间，系统会自动清除在应用程序移动到后台时代表应用程序分配的数据。</p>
<ul>
<li>系统清除所有Core Animation层的后备存储。 此功能不会从应用程序的图层对象中删除内存，也不会更改当前图层属性。 它只是防止这些图层的内容出现在屏幕上，这表明应用程序在后台应该不会发生。</li>
<li>它删除任何系统对缓存图像的引用。</li>
<li>它删除了对其他系统管理的数据高速缓存的强引用。</li>
</ul>
<hr>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2015-09-01T16:00:00.000Z" title="2015/9/2 上午12:00:00">2015-09-02</time>发表</span><span class="level-item"><a class="link-muted" href="/categories/iOS/">iOS</a></span><span class="level-item">10 分钟读完 (大约1507个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2015/09/02/ios-property/">属性修饰符分析</a></h1><div class="content"><h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h3><hr>
<h5 id="atomic-amp-nonatomic"><a href="#atomic-amp-nonatomic" class="headerlink" title="atomic &amp; nonatomic"></a>atomic &amp; nonatomic</h5><p>决定编译器生成的setter/getter是否为原子操作 。<br>atomic是Objc使用的一种线程保护技术，防止在某个操作未完成时被另外一个线程操作，造成数据错误。然而这种多线程安全机制对资源的占用很大，在iPhone等小型设备中，除非需要使用多线程之间通讯编程，采用这种技术需要慎重考量。<br>一般情况下，使用nonatomic来修饰成员变量，存取器直接返回一个值，而不需要管当不同的线程同时访问时会发生什么。</p>
<h5 id="readwrite-amp-readonly"><a href="#readwrite-amp-readonly" class="headerlink" title="readwrite &amp; readonly"></a>readwrite &amp; readonly</h5><p>  任何属性都可以声明为readwrite或readonly，且默认设置为readwrite 。<br>  将一个属性声明为readwrite时，编译器将会为这个属性生成setter和getter。<br>  将一个属性生命为readonly时，编译器将只会生成getter。</p>
<h5 id="assign"><a href="#assign" class="headerlink" title="assign"></a>assign</h5><p>   直接赋值，不更改引用计数，一般用于基础数据类型和C语言类型数据。</p>
<h5 id="retain"><a href="#retain" class="headerlink" title="retain"></a>retain</h5><p>   释放旧对象，并使传入的新对象引用计数+1。<br>   此属性只能用于NSObject及其子类，而不能用于Core Foundation（因为其没有使用引用计数，需要另外使用CFRetain和CFRelease来进行CF的内存管理）。</p>
<h5 id="strong"><a href="#strong" class="headerlink" title="strong"></a>strong</h5><p>   释放旧对象，并使传入的新对象引用计数+1。<br>   在ARC下，strong为对象类型属性声明时的默认值。</p>
<h5 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h5><p>   创建一个引用计数为1的新对象，这个新对象是传入对象的拷贝。<br>   会拷贝传入的对象（即创建一个引用计数为1的新对象，但是内容与传入对象相同），并把新对象赋值给实例变量。</p>
<h5 id="weak"><a href="#weak" class="headerlink" title="weak"></a>weak</h5><p>  弱引用，要求不保留传入的属性（既不会使传入的对象引用计数+1）。<br>  类似于assign，但与assign不同的是，当它们指向的对象被释放后，weak会被自动置为nil，而assign则不会。</p>
<hr>
<h3 id="进阶问题"><a href="#进阶问题" class="headerlink" title="进阶问题"></a>进阶问题</h3><hr>
<h5 id="strong-amp-weak"><a href="#strong-amp-weak" class="headerlink" title="strong &amp; weak"></a>strong &amp; weak</h5><p>这里采用 stack overflow 上的一个对强/弱引用的解释</p>
<blockquote>
<p>如果将对象想象成一只想要逃跑(be deallocated)的狗的话。</p>
<p>强引用就像是拴住狗的绳子。只要你还还牵着拴住狗的绳子，狗就逃跑不了。如果有五个人都将绳子拴住了狗，那么除非五个人都解开了绳子，否则狗就不可能逃跑。</p>
<p>而弱引用，就像一个小孩子指着狗说：看，那里有一直狗。只要狗仍被狗绳拴着，小孩就还能看见狗，他们仍会指着它。然而一但狗绳被解开，狗就会逃跑而不管多少小孩子指着它。</p>
</blockquote>
<h5 id="copy-amp-retain"><a href="#copy-amp-retain" class="headerlink" title="copy &amp; retain"></a>copy &amp; retain</h5><p>copy实际上是建立了一个新的相同的对象，而retain是将传入对象的引用计数+1 。</p>
<h5 id="深拷贝-amp-浅拷贝"><a href="#深拷贝-amp-浅拷贝" class="headerlink" title="深拷贝 &amp; 浅拷贝"></a>深拷贝 &amp; 浅拷贝</h5><p>浅拷贝就是对内存地址的复制，让目标对象指针和源对象指向同一片内存空间 。浅拷贝只是对对象的简单拷贝，让几个对象共用一片内存，当内存销毁的时候，指向这片内存的几个指针需要重新定义才可以使用，要不然会成为野指针。<br>在iOS中，使用retain修饰的属性变量，就是一种浅拷贝。它既让几个指针共用同一片内存空间，又可以在release时由于计数的存在，不会轻易的销毁内存，达到更加简单使用的目的。<br>深拷贝是指拷贝对象的具体内容，而内存地址是自主分配的，拷贝结束之后，两个对象虽然存的值是相同的，但是内存地址不一样，两个对象也互不影响，互不干涉。<br>值得注意的是，对可变对象如NSMutableArray等无论是copy还是mutableCopy都是进行了深拷贝。</p>
<h5 id="property-amp-synthesize"><a href="#property-amp-synthesize" class="headerlink" title="@property &amp; @synthesize"></a>@property &amp; @synthesize</h5><p>如果我们希望使用默认的实例变量命名方式，那么我们在.m文件中就不需要使用@synthesize声明，系统会帮我们自动完成。如果我们希望自己命名实例变量命，那么我们就使用@synthesize显式声明我们希望的实例变量名 。</p>
<h5 id="block作为实例变量为何要用copy修饰？"><a href="#block作为实例变量为何要用copy修饰？" class="headerlink" title="block作为实例变量为何要用copy修饰？"></a>block作为实例变量为何要用copy修饰？</h5><p>因为block如果在栈上的话，其所属的变量作用域结束，该block就被释放掉，block中的__block变量也同时被释放掉。为了解决栈块在其变量作用域结束之后被释放掉的问题，我们就需要把block复制到堆中。</p>
<h5 id="为什么NSString、NSDictionary、NSArray要使用copy修饰？"><a href="#为什么NSString、NSDictionary、NSArray要使用copy修饰？" class="headerlink" title="为什么NSString、NSDictionary、NSArray要使用copy修饰？"></a>为什么NSString、NSDictionary、NSArray要使用copy修饰？</h5><p>对于NSString、NSDictionary、NSArray等经常使用copy关键字，是因为它们有对应的可变类型：NSMutableString、NSMutableDictionary、NSMutableArray，它们之间可能进行赋值操作，为确保对象中的字符串值不会无意间变动，应该在设置新属性时拷贝一份。</p>
<h5 id="weak、copy、strong、assgin分别用在什么地方？"><a href="#weak、copy、strong、assgin分别用在什么地方？" class="headerlink" title="weak、copy、strong、assgin分别用在什么地方？"></a>weak、copy、strong、assgin分别用在什么地方？</h5><p>什么情况下会使用weak关键字？</p>
<ul>
<li>在ARC中，出现循环引用的时候，会使用weak关键字。</li>
<li>自身已经对它进行了一次强引用，没有必要再强调引用一次。</li>
</ul>
<p>assgin适用于基本的数据类型，比如NSInteger、BOOL等。</p>
<p>NSString、NSArray、NSDictionary等经常使用copy关键字，是因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary；</p>
<p>除了上面的三种情况，剩下的就使用strong来进行修饰。</p>
<hr>
</div></article></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="LeiTech"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">LeiTech</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>China</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">55</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">10</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">3</p></a></div></div></nav><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="/"><i class="fab fa-github"></i></a></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/CS/"><span class="level-start"><span class="level-item">CS</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/Git/"><span class="level-start"><span class="level-item">Git</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/JavaScript/"><span class="level-start"><span class="level-item">JavaScript</span></span><span class="level-end"><span class="level-item tag">19</span></span></a></li><li><a class="level is-mobile" href="/categories/Mac/"><span class="level-start"><span class="level-item">Mac</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/"><span class="level-start"><span class="level-item">Python</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/TypeScript/"><span class="level-start"><span class="level-item">TypeScript</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Vue/"><span class="level-start"><span class="level-item">Vue</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Web/"><span class="level-start"><span class="level-item">Web</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/iOS/"><span class="level-start"><span class="level-item">iOS</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"><span class="level-start"><span class="level-item">大前端</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li></ul></div></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2021/08/"><span class="level-start"><span class="level-item">八月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/04/"><span class="level-start"><span class="level-item">四月 2021</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/03/"><span class="level-start"><span class="level-item">三月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/01/"><span class="level-start"><span class="level-item">一月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/12/"><span class="level-start"><span class="level-item">十二月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/06/"><span class="level-start"><span class="level-item">六月 2020</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/09/"><span class="level-start"><span class="level-item">九月 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/06/"><span class="level-start"><span class="level-item">六月 2019</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/04/"><span class="level-start"><span class="level-item">四月 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/03/"><span class="level-start"><span class="level-item">三月 2019</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/02/"><span class="level-start"><span class="level-item">二月 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/12/"><span class="level-start"><span class="level-item">十二月 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/09/"><span class="level-start"><span class="level-item">九月 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/07/"><span class="level-start"><span class="level-item">七月 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/06/"><span class="level-start"><span class="level-item">六月 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/05/"><span class="level-start"><span class="level-item">五月 2018</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/04/"><span class="level-start"><span class="level-item">四月 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/03/"><span class="level-start"><span class="level-item">三月 2018</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/02/"><span class="level-start"><span class="level-item">二月 2018</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/01/"><span class="level-start"><span class="level-item">一月 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/05/"><span class="level-start"><span class="level-item">五月 2017</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/04/"><span class="level-start"><span class="level-item">四月 2017</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2016/06/"><span class="level-start"><span class="level-item">六月 2016</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2016/04/"><span class="level-start"><span class="level-item">四月 2016</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2016/03/"><span class="level-start"><span class="level-item">三月 2016</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2016/02/"><span class="level-start"><span class="level-item">二月 2016</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2016/01/"><span class="level-start"><span class="level-item">一月 2016</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/archives/2015/12/"><span class="level-start"><span class="level-item">十二月 2015</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2015/11/"><span class="level-start"><span class="level-item">十一月 2015</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2015/10/"><span class="level-start"><span class="level-item">十月 2015</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2015/09/"><span class="level-start"><span class="level-item">九月 2015</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Git/"><span class="tag">Git</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/JavaScript/"><span class="tag">JavaScript</span><span class="tag">12</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Web/"><span class="tag">Web</span><span class="tag">3</span></a></div></div></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><!--!--></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="关于代码的碎碎念" height="28"></a><p class="is-size-7"><span>&copy; 2021 Y2hlbmdsZWk=</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>