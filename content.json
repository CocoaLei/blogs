{"pages":[{"title":"分类","text":"","link":"/categories/index.html"},{"title":"标签","text":"","link":"/tags/index.html"}],"posts":[{"title":"GraphQL 概览","text":"GraphQLGraphQL 是一个用于 API 的查询语言，使用基于类型系统来执行查询的服务端运行时，并且它不和任何特定数据库或存储引擎绑定，依靠你现有的代码和数据支撑。 一个 GraphQL 服务通过定义类型和类型上的字段创建，并为每个类型上的字段提供解析函数。 为什么使用 GraphQL传统的 REST 标准在使用中有一些问题： 获取比较复杂的对象需要向服务器进行多次请求 REST 通常在服务端就决定了数据的结构，这导致你获得的数据很多是你不要的，即冗余数据颇多 服务器返回的数据不可预测，你需要付出额外的工作来准确的理解你从服务器获得数据 而通过 GraphQL 你可以从服务器获取你期望的数据，并且清楚的知道你获得的数据是什么样子的。 查询和变更字段 Fields字段可以是标量或对象，当子段位对象类型时，你可以对其进行次级选择。GraphQL 查询能够遍历相关对象及其字段，是的客户端可以一次请求查询大量相关数据。 参数 Arguments在 GraphQL 中，每一个字段和嵌套对象都能有自己的一组参数，从而使得 GraphQL 可以完美替代多次 API 请求。 参数可以是多种不同的类型。GraphQL 自带一套默认类型，但是你可以声明一套自己的定制类型，你要能序列化成的你需要的格式即可。 123456{ queryFunction(arg: arg) { field, ... }} 别名 Aliases为字段设置别名，可以使你能够通过不同参数来查询相同的字段。 片段 Fragments片段是 GraphQL 中的可复用单元，它能够组织一组字段，在需要的地方被引入。 片段也可以访问查询或变更中声明的变量。 操作名称 Operation name1query/mutation/subscription operation_name {} 操作类型可以是 query/mutation/subscription，描述你打算做什么类型的操作。操作类型是必须的，除非使用查询简写语法 - 这种情况下，你无法为操作提供名称或变量定义。 操作名称是你的操作的有意义和明确的名称，它仅在有多个操作的文档中是必须的。但是操作名称在调试和服务端日志记录中非常有用，可以帮助快速定位到问题发生的位置。 变量 Variables12345query query_function($variable_name: variable_type) { obj(variable: $variable_name) { ... }} 所有声明的变量都必须是标量、枚举类型或输入对象类型。所以如果想要传递一个复杂对象到一个字段上，你必须知道服务器上其匹配的类型。 变量定义可以是可选的或者必要的。但是如果你传递变量的字段要求非空参数，那变量一定是必要的。 可以通过在查询中对类型定义后面附带默认值的方式，将默认值赋给变量。 12345query query_function($variable_name: variable_type = &quot;default_value&quot;) { obj(variable: $variable_name) { ... }} 指令 Directives指令可以动态的改变我们的查询结构。指令可以附着在字段或者字段包含的字段上，然后以任何服务端期待的方式来改变查询的执行。 @include(if: Boolean) 仅在参数为 true 时，包含此字段 @skip(if: Boolean) 如果参数为 true ，跳过此字段 变更 Mutations技术上而言，任何查询都能够被实现为导致数据写入的操作，然而，一个规范任何导致写入的操作都应该显式通过变更来发送也是必要的。 一个变更可能包含多个字段，查询是并行执行，变更是线性执行。 内联片段 Inline Fragments如果你查询的字段返回的是接口或者联合类型，那么你可能需要使用内联片段来取出下层具体类型的数据。 12345678910111213query numberOFAnimals($sp：Species!) { animals(species: $sp) { number, // 仅在 animals 返回为 Mammal 时执行 ... on Mammal { isRare } // 仅在 animals 返回为 Human 时执行 ... on Human { sex } }} 具名片段也可以用于同样的情况，因为具名片段总是附带了一个类型。 原字段12// 获得那个位置的对象类型名称__typename Schema 和类型类型系统GraphQL 查询语言基本上就是关于选择对象上的字段。因此一个 GraphQL 查询的结构和结果非常相似，这使我们能预测服务器会返回什么样的结果。 每一个 GraphQL 服务都会定义一套类型，用来描述你能从服务器能够查询到的数据。每当查询到来，服务器就会根据 schema 验证并执行查询。 类型语言GraphQL 可以用任何语言编写，因为它并不依赖于任何特定语言的句法来与 GrapahQL schema 沟通，它定义了称之为 GraphQL schema language 的简单语言。 对象类型和字段 Object Types and FieldsGraphQL schema 中最基本的组件是对象类型，它就表示你可以从服务上获取到什么类型的对象，以及这个对象有什么字段。 1234type Object_Name { field, ...} 参数 ArgumentsGraphQL 对象类型上的每个字段都可能有零个或多个参数，并且所有参数都必须是具名的。参数可能是必选的或可选的，如果参数可选的，可以给它定义默认值。 查询和变更类型 The Query and Mutation Types每一个 GraphQL 服务中都有一个 query 类型，可能有一个 mutation 类型，它们定义了每一个 GraphQL 查询的入口。 1234schema { query: Query, mutation: Mutation} 标量类型 Scalar Types一个对象类型有自己的名字和字段，而某些时候，这些字段必然会解析到具体数据，这就是标量，表示对应 GraphQL 查询的叶子节点。 它们包括 ： Int : 有符号 32 位证书 Float ：有符号双精度浮点值 String ： UTF-8 字符序列 Boolean ： true 或 false ID ： ID 标量类型表示一个唯一标识符，通常用以重新获取对象或者作为缓存中的键 你可以自定义标量类型，但需要保证其能够序列化、反序列化和验证。 枚举类型 Enumeration Types枚举类型是一种特殊的标量，它限制在一个特殊的可选值集合内。 列表和非空 List and Non-Null类型修饰符 ! 可将字段标注为非空，即表示这个字段总是会返回一个非空值。亦可用于修饰定义字段上的参数。 123type Object_Name { field_1: Type!} 使用 [] 标记一个类型为 List ，表示这个字段会返回这个类型的数组。 123query query_name { field_list: [String],} 接口 InterfaceGraphQL 支持接口，接口是一个抽象类型，它包含某些字段，而想要实现这个接口的对象必须包含这些子段。 1234567891011interface Human { name: String! age: Int!}type Man implements Human { name: String! age: Int! height: Float! } 联合类型 Union Type联合类型和接口非常相似，但是不指定类型之间的任何共同字段。 1union union_type = type_1 | type_2 | ... 联合类型的成员需要是具体对象类型。 输入类型 Input Types使用输入类型可以将复杂的对象传递给字段，这在变更中特别有用。 1234input input_type { field, ....} 输入对象类型上的字段本身也可以只带输入对象类型，但是注意不能混淆输入和输出类型，输入对象类型上的字段不能拥有参数。 验证通过使用类型系统，可以预判一个查询是否有效。这使得服务器和客户端可以在无效查询创建时就有效的通知开发者，而不用依赖运行时检查。 以下是指的注意的基本原则 片段不能引用自身或创造回环 只能查询给定类型上的字段 如果查询返回的不是标量或枚举类型，就需要指明想要从字段中获取的数据 执行一个 GraphQL 查询在被验证之后，GraphQL 服务器将会将其执行，并返回与请求的结构相对应的结果，该结果通常会是 JSON 格式。 每个类型的每个字段都由一个 resolver 函数支持，该函数由 GraphQL 服务器开发人员提供 - 当一个字段被执行时，相应的 resolver 函数被调用以产生下一个值。如果字段产生标量值，则执行完成。如果一个字段产生一个对象，则该查询将继续执行该对象对应字段的解析器，直到生成标量值。GraphQL 查询始终以标量值结束。 根字段 &amp; 解析器每一个 GraphQL 服务端应用的顶层，必有一个代表着所有进入 GraphQL API 可能的入口点，称之为 Root 类型或 Query 类型。 1234567891011// `obj` 代表上一级对象，如果字段是根节点查询类型通常不会被使用// `args` 提供在 GraphQL 查询中传入的参数// `context` 会提供给所有解析器，持有重要的上下文信息// `info` 保存与当前查询相关的字段的特定信息以及 `schema` 详细信息的值Query { query_name(obj, args, context, info) { return context.db.query(...).then((return_data) =&gt; { return return_data; }); }} 当每个字段被解析后，结果被放到键值映射中，字段名称作为键值映射的键，解析器的值作为键值映射的值，这个过程从查询字段的底部叶子节点开始返回，直到根 Query 类型的起始节点。最后合并成为能够镜像到原始查询结果的结果，让后将其发送到请求的客户端。 异步解析器context 提供了一个数据库访问对象，用来通过查询中传递的参数查询数据，因为从数据库拉取数据是一个异步操作，它会返回一个 Promise 对象，当数据库查询返回结果，就能构造并返回查询结果。 只有解析器能够感知 Promise 的进度，GraphQL 查询只关注一个结果是否返回，在执行期间如果异步操作没有完成，则 GraphQL 会一直等待下去。 内省GraphQL 通过内省系统使得我们能够直到 GraphQL Schema 支持哪些查询。 我们可以通过 __schema 字段来向 GraphQL 询问哪些类型是可用的。一个查询的根类型总是有 __schema 这个字段。 12345{ __schema { ... }} 检验特定类型 123{ __type() {}}","link":"/2018/12/22/GraphQL/"},{"title":"JavaScript Map 和 Object","text":"Map Map 是一个保存’键值对’的对象，会记忆键的插入顺序，而且不管是对象还是原始值都能作为其键或值。 如果看过 Map 的实例方法，就会发现它在某些方面起到的作用极为相似，但也有很多的不同： Map Object 意外的键 默认情况下不包含任何键，只包含显式插入的键。 如果 Object 有原型，原型链上的键名则可能和你在对象上设置的键名冲突 键的类型 可以是任意值，包括函数、对象和原始值 只能是 String 或 Symbol 键的顺序 键是有序的，顺序为插入顺序 键是无序的 Size 通过 size 属性获取 手动计算 迭代 可以直接迭代 性能 在频繁增删键的情况下性能更好","link":"/2019/03/10/JavaScript%20Map%20%E5%92%8C%20Object/"},{"title":"Homebrew 命令","text":"Mac 上的软件包管理器 - Homebrew 查看信息 1234567891011# 查看帮助信息brew help# 查询可更新的包brew outdated# 查看包信息brew info &lt;packagename&gt;# 查看安装列表brew list 安装和更新 12345# 安装 homebrew/bin/bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)&quot;# 更新 homebrewbrew update 软件包管理 homebrew 会将软件安装到自己所在文件夹内 1234567891011121314151617181920212223242526272829# 安装软件brew install &lt;packagename&gt;# 更新软件brew upgrade &lt;packagename&gt;# 卸载/删除软件brew uninstall &lt;packagename&gt;# 安装图形化软件brew cast &lt;appname&gt;# 搜索可用的软件brew search &lt;name&gt;# 清理旧版本brew cleanup# 清理指定包的旧版本brew cleanup &lt;packagename&gt;# 查看可清理的旧版本包brew cleanup -n# 锁定某个包使其不能更新brew pin &lt;packagename&gt;# 解锁brew unpin &lt;packagename&gt;","link":"/2019/02/16/Homebrew/"},{"title":"HTTP 概览","text":"HTTP 协议开发中，我们经常需要向服务器端发送数据或从服务器端请求特定数据，为了完成数据在客户端和服务器端的传输，我们在传输数据时必须用到 HTTP 协议。 什么是 HTTP 协议？HTTP 协议，即 HyperText Transmission Protocol，超文本传输协议，定义了客户端与服务器端的数据传输规则，让客户端和服务器能够有效地进行数据沟通。 HTTP 的基本性质 HTTP 是简单的 HTTP 是可扩展的 - 通过 HTTP headers 可以轻松对协议进行扩展 HTTP 是无状态，有会话的 - 在同一个连接中，两个执行成功的请求之间是没有关系的 HTTP 请求与响应HTTP 请求HTTP 协议规定，一个完整的 HTTP 请求应包含如下内容 请求行 ：包含请求方法、请求统一资源标示符和 HTTP 版本号。 请求头 ：请求头包含客户端传送给服务器端的附加信息。 Name Description Host 目标服务器的网络地址 Accept 告知服务器端客户端能够接收的数据类型，如 ‘text/html’等 Content-Type 请求体中的数据类型，如 ‘Application/Json; charset=UTF-8’等 Accept-Language 客户端的语言环境，如 ‘zh-cn’ 等 Accept_Encoding 客户端支持的数据压缩格式，如 ‘gzip’ 等 User-Agent 客户端的软件环境 Connection : keep-alive 告知服务器这是一个持久连接 Content-Length 请求体的长度 Cookie 记录着用户保存在本地的用户数据 请求体 ：发送给服务器端的数据 在使用 POST-Multipart 上传请求中请求体就是上传文件的二进制数据。 在使用 GET 请求时，请求体为空。 在普通的 POST 请求中，请求体就是表单数据。 响应状态行 ： 服务器返回给客户端的状态信息，一般包含 HTTP 版本号、状态码和状态码对应的英文名称。 一个典型的状态行如下： 1HTTP/1.1 200 OK HTTP 响应基本与 HTTP 请求相同。 HTTP 的版本HTTP 的主要版本如下 Version Feature &lt; HTTP 1.1 不支持持久连接；无请求头和响应头；客户端的前后请求是同步的。 HTTP 1.1 增加请求头和响应头；支持持久连接；客户端的不同请求之间是异步的。 HTTP 2.0 向下兼容 HTTP 1.1，但只用于 https 网址。 HTTP 缓存缓存是一种保存资源副本并在下次请求时直接使用该副本的技术。当 web 缓存发现请求的资源已经被存储，它会拦截请求，返回该资源的拷贝，而不会去源服务器重新下载。这样带来的好处有：缓解服务器端压力，提升性能(获取资源的耗时更短了)。对于网站来说，缓存是达到高性能的重要组成部分。缓存需要合理配置，因为并不是所有资源都是永久不变的：重要的是对一个资源的缓存应截止到其下一次发生改变（即不能缓存过期的资源）。 缓存操作的目标虽然 HTTP 缓存不是必须的，但重用缓存的资源通常是必要的。然而常见的 HTTP 缓存智能存储 GET 响应。 缓存控制Cache-control 头HTTP/1.1 定义的 Cache-Control 头用来区分对缓存机制的支持情况，请求头和响应头都支持这个属性，你可以通过它提供的不同的值来定义缓存策略。 禁止进行缓存 12Canche-Control: no-store,Canche-Control: no-cache, no-store 强制确认缓存 每次有请求发出时，缓存会将次请求发送到服务器，服务器端会验证请求中所描述的缓存是否过期，若未过期，则缓存才使用本地缓存副本 1Cache-Control: must-revalidate 私有缓存和公共缓存 public 指令表示该响应可以被任何中间人缓存。若指定了 public ，则一些通常不被中间人缓存的页面，将被缓存。 private 则表示该响应是专用于某单个用户的，中间人不能缓存此响应。 缓存过期机制 max-age=&lt;seconds&gt; 指令表示资源能够被缓存的最大时间，这个时间是距离请求发起的时间的秒数。一般用来缓存应用中不会改变的文件，通过手动设置一定的时长以保证缓存有效。 1Cache-Control: max-age=10000 缓存验证确认 当使用了 must-revalidate 指令，那就意味着缓存在考虑使用一个资源时，必须先验证它的状态，已过期的缓存将不被使用 Pargma 头Pargma 是 HTTP/1.1 标准中定义的一个 header 属性，请求中包含 Pargma 的效果跟在头信息中定义 Cache-Control: no-cache 相同，但是 HTTP 的响应头不支持这个属性，所以它不能完全替代 Cache-Control 头。 新鲜度在过期时间之前，缓存资源是新鲜的，否则是陈旧的。一个陈旧的资源是不会被直接清除的，当客户端发起一个请求时，检索到已经有一个对应的缓存副本，则会在此次请求上附加一个 If-None-Match 头，然后再发送给服务器，以此来检查此资源是否依然是新鲜的，若返回 304 (Not Modified) ，则表示该副本是新鲜的，否则返回新的资源。 缓存验证用户点击刷新按钮时会开始缓存验证。如果缓存的响应头信息里含有 Cache-control: must-revalidate 的定义，在浏览的过程中也会触发缓存验证。另外，在浏览器偏好设置里设置 Advanced-&gt;Cache 为强制验证缓存也能达到相同的效果。 当缓存的文档过期后，需要进行缓存验证或者重新获取资源。只有在服务器返回强校验器或者弱校验器时才会进行验证。 ETag作为缓存的一种强校验器，ETag 响应头是一个对用户代理不透明的值。对于像浏览器这样的 HTTP UA，不知道 ETag 代表什么，不能预测它的值是多少。如果资源请求的响应头里含有 ETag， 客户端可以在后续的请求的头中带上 If-None-Match 头来验证缓存。 Last-Modified 响应头可以作为一种弱校验器。说它弱是因为它只能精确到一秒。如果响应头里含有这个信息，客户端可以在后续的请求中带上 If-Modified-Since 来验证缓存。 当向服务端发起缓存校验的请求时，服务端会返回 200 ok 表示返回正常的结果或者 304 Not Modified表示浏览器可以使用本地缓存文件。304 的响应头也可以同时更新缓存文档的过期时间。 需要注意的是 If-None-Match 的优先级高于 If-Modified-Since，两者同时存在的话，按照前者进行校验。 带 Vary 头的响应Vary HTTP 响应头决定了对于后续的请求头，如何判断是请求一个新的资源还会使用缓存的文件。 当缓存服务器收到一个请求，只有当前的请求和原始（缓存）的请求头跟缓存的响应头里的Vary都匹配，才能使用缓存的响应。 HTTP CookiesHTTP Cookie（也叫Web Cookie或浏览器Cookie）是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。Cookie 使基于无状态的 HTTP 协议记录稳定的状态信息成为了可能。 创建 Cookie服务器通过在响应头里面添加一个 Set-Cookie 选项，来使浏览器保存下 Cookie，之后对该服务器的每一次请求中都通过 Cookie 请求头部将 Cookie 信息发送给服务器。 Set-Cookie 响应头部和 Cookie 请求头部 服务器使用 Set-Cookie 响应头部向用户代理发送 Cookie 信息 1Set-Cookie: &lt;name&gt;=&lt;value&gt; 保存 Cookie 信息后，对该服务器发起的每一次新请求，浏览器都会将保存的 Cookie 信息通过 Cookeie 请求头再发送给服务器。 会话期 Cookie 会话期 Cookie 是最简单的 Cookie：浏览器关闭后它会被自动删除，即它仅在会话期内有效。 会话期 Cookie 不需要指定过期时间或者有效期 持久性 Cookie 持久性 Cookie 指定了特定的过期时间或有效期，不会随着浏览器的关闭而被删除。 12Set-Cookie: id=asfwa; Expires=Wed, 21 Oct 2015 07:28:00 GMT; 设定的过期时间只和客户端有关，而不是服务端。 Cookie 的 Secure 和 HttpOnly 标记 标记为 Secure 的 Cookie 只应通过被 HTTPS 协议加密过的请求发送给服务器，但由于 Cookie 固有的不安全性，敏感信息不应该通过 Cookie 传输。 为避免跨域脚本攻击，通过 JavaScript 的 Document.cookie API 无法访问带有 HttpOnly 标记的 Cookie，它们只应发送给服务器。 Cookie 的作用域 通过 Domain 和 Path 标识可以定义 Cookie 的作用域：即 Cookie 应该发送给哪些 URL。 Domain 指定哪些主机可以接受 Cookie，如果不指定，则默认为当前文档的主机，且不包含子域名。如果指定了，则会包含子域名。 Path 指定主机下的哪些路径可以接受 Cookie，以字符 %x2F (即 /) 作为路径分隔符，子路径也会被匹配。 SameSite Cookies SameSite Cookie 允许服务器要求某个 Cookie 在跨站请求时不会被发送，从而可以组织跨站请求伪造攻击。 JavaScript 通过 document.cookies 访问 Cookie 通过 Document.cookie 属性可创建新的 Cookie，也可以通过该属性访问非 HttpOnly 标记的 Cookie。 Cookie 安全当机器处于不安全环境时，切记不能通过 Cookie 存储传输敏感信息。 会话劫持和 XSS 在 Web 应用中， Cookie 常用来标记用户或授权会话。因此，如果 Web 应用的 Cookie 被窃取，可能导致授权用户的会话受到攻击。 HttpOnly 类型的 Cookie 由于阻止了 JavaScript 对其的访问性能而在一定程度上缓解了此类攻击。 跨站请求伪造 通过以下方式可以一定程度上阻止宽展请求伪造： 对用户输入进行过滤来阻止 XSS 任何敏感操作都需要确认 用于敏感信息的 Cookie 只能拥有较短的生命周期 追踪和隐私 第三方 Cookie 每个 Cookie 都会有与之关联的域（Domain），如果 Cookie 的域和页面的域相同，那么我们称这个 Cookie 为第一方 Cookie ，如果 Cookie 的域和页面的域不同，则称之为第三方Cookie。一个页面包含图片或存放在其他域上的资源（如图片广告）时，第一方的 Cookie 也只会发送给设置它们的服务器。通过第三方组件发送的第三方 Cookie 主要用于广告和网络追踪。 禁止追踪 Do-Not-Track 虽然并没有法律或者技术手段强制要求使用DNT，但是通过DNT可以告诉Web程序不要对用户行为进行追踪或者跨站追踪。 欧盟 Cookie 指令 僵尸 Cookie 和删不掉的 Cookie HTTP 访问控制跨域资源共享（CORS）是一种使用额外的 HTTP 头来使运行在一个 origin 上的 web 应用被准许访问来自不同源服务器上的指定的资源的机制，即当一个资源从与该资源本身所在的服务器不同的域、协议或端口请求一个资源时，就会发起一个跨域 HTTP请求。 跨域资源共享标准新增了一组 HTTP 首部字段，允许服务器声明哪些源站通过浏览器有权限访问哪些资源。对那些可能对服务器数据产生副作用的 HTTP 请求方法，浏览器必须首先使用 OPTIONS 方法发起一个预检请求（Preflight Request），从而获知服务端是否允许该跨域请求。服务端确认允许后，才发起实际的 HTTP 请求。 HTTP 消息HTTP 消息是客户端和服务器之间交换数据的方式。它们分为两种类型：由客户端发送的用来在服务器上触发动作的消息和从服务器得到的回应。 HTTP 消息由跨越多行的用 ASCII 编码的文本信息组成。在 HTTP/1.1 和更早期的版本的协议中，消息通过连接明文发送。在 HTTP/2 中，为了优化和性能提升，人类可读的消息被分割成 HTTP 帧。 HTTP Request1234567891011121314151617181920212223// 请求头的名称是大小写不敏感的// Start line// [HTTP Method] [Request Target] [HTTP Version]GET /img/me.png HTTP/1.1GET http://developer.mozilla.org/en-US/docs/Web/HTTP/Messages HTTP/1.1// Headers// Request Headers : 对请求的设置User-AgentAcceptAccept-LanguageAccept-Encoding// General Headers : 作用于消息整体Connection// Entity Headers : 作用与请求的 body 部分，如果 body 部分没有数据，则没有这部分头Content-TypeContent-Length// Body// 大体上分为两类 : 单一资源 body 和多资源 body HTTP Response12345678// Status line// [HTTP Version] [Status Code] [Status Text]HTTP/1.1 404 Not Found// Headers// 与 HTTP Request 结构相似// Body HTTP/2 帧HTTP/1.1 的消息在性能上有着一系列的缺点： Header 不像 body，它不会被压缩 两个报文之间的 header 通常非常相似，但它们仍然在连接中重复传输 无法复用。当在同一个服务器打开几个连接时：TCP 热连接比冷连接更加有效 所以在 HTTP/2 中，消息被分割成嵌入到流中的帧。Headers 和 Body 的帧是分开的，这使得 Headers 帧也可以被压缩。多个流可以被组合在一起，这是一种称为多路复用的技术，它使得 TCP 连接下的传输更有效率。 HTTP 会话在类似 HTTP 的客户端-服务器协议中，会话由三个部分组成： 客户端建立一个 TCP 连接 客户端发送请求，等待回应 服务器处理请求，做出回应 从 HTTP/1.1 起，连接在完成第三部后不再被关闭，客户端被允许发起新的请求，这意味着第二和第三部可以重复进行多次。 客户端-服务器协议中，在 HTTP 中打开一个连接，意味着在底层传输层初始化连接。使用 TCP 时，HTTP 服务器默认的端口号是 80。 HTTP 、Scoket 和 TCP 的区别HTTP 是应用层的协议，TCP 是传输层的协议，而 Socket 是从传输层抽象的一个抽象层，本质是接口。 TCP 连接与 HTTP 连接的区别 HTTP 是基于 TCP的，客户端向服务器端发送一个 HTTP 请求时，第一步就是要建立与服务端的 TCP 连接。 TCP 连接与 Socket 连接的区别 Socket 层只是在 TCP/UDP 传输层上做的一个抽象接口层。 基于 TCP 协议的 Socket 连接同样需要通过三次握手建立连接，是可靠的。 基于 UDP 协议的 Socket 连接不需要建立连接的过程，不管对方能不能收到都会发送过去，是不可靠的。 HTTP 连接与 Socket 连接的区别 HTTP 是短连接，基于 TCP 协议的 Socket 连接是长连接。尽管 HTTP 1.1 开始支持持久连接，但仍无法保证始终连接。 而基于 TCP 协议的 Socket 连接一旦建立成功，除非一方主动断开，否则连接状态一直保持。 HTTP 连接，服务器无法主动发送消息，而 Socket 连接，双发请求的发送没有先后限制。 HTTP 采用 ‘请求-响应’ 机制，在客户端没有发送请求给服务端时，服务端无法推送消息给客服端。 Socket 连接双方类似于 P2P 的关系，可以随时互相发送消息。","link":"/2016/01/02/HTTP%E6%A6%82%E8%A7%88/"},{"title":"JavaScript delete 操作符","text":"delete 操作符用于删除对象的某个属性，如果没有指向这个属性的引用，它最终将会被释放。 1delete obj['property']; 对于所有结果都返回 true，除非属性是一个不可配置属性，这种情况，在非严格模式下返回 false，在严格模式下则抛出 TypeError。 1234567891011121314151617const originO = { name: 'Mike', age: 29, speak() { console.log(`I am ${this.name}`); }}Object.defineProperty(originO, 'sex', { value: '女'， configurable: false});console.log(delete originO.sex); // false'use strict'console.log(delete originO.sex); // TypeError: Cannot delete property 'sex' of #&lt;Object&gt; 如果要删除的属性不存在，delete 不会有任何作用，但仍返回 true delete 只能删除对象本身上的属性，不会删除原型链上的同名属性（如果有的话） 1234567891011function originO() { this.name = 'originO';}originO.prototype.name = 'name in prototype';let obj = new originO();delete obj.name;console.log(obj.name); // name in prototype 任何使用 var 声明的属性不能从全局作用域或函数的作用域中删除 12345var globalVar = 'XYZ';const descriptor = Object.getOwnPropertyDescriptor(window, 'globalVar');console.log(descriptor); // { ..., configurable: false, ... } 可以看到 var 声明的属性不可配置 任何使用 let 或 const 声明的属性不能从它声明的作用域中被删除 delete 删除数组元素 1234567const arr = [ 1, 2, 3, 4 ];delete arr[3];console.log(arr); // [ 1, 2, 3, &lt;1 empty item&gt; ]console.log(arr.length); // 4console.log(arr[3]); // undefined","link":"/2019/06/16/JavaScript%20delete/"},{"title":"JavaScript 中的事件循环","text":"JavaScript 有一个基于事件循环的并发模型，它负责执行代码、收集和处理事件以及执行队列中子任务，它被称为事件循环(Event Loop)。了解事件循环的工作方式和原理对于进行优化非常重要。 运行时概念 栈函数调用形成了一个有若干帧组成的栈。 栈是一种仅限在表为进行添加和删除的线性数据结构。 堆对象被分配在堆中。堆是一个用来表示一块非结构化内存区域的计算机术语。 堆是一种利用完全二叉树维护的线性数据结构。 队列一个 JavaScript 运行时包含了一个待处理消息的消息队列。每一个消息都关联着一个用来处理这个消息的回调函数。 在事件循环的合适时刻，JavaScript 运行时会从最早进入消息队列的消息开始处理消息。被处理的消息会被移出消息队列，并以自身为参数调用与之关联的函数。 函数的处理会一直到执行栈再次为空为止，然后事件循环会处理下一个消息。 事件循环事件循环的概念非常简单，一个无限的循环：JavaScript 引擎等待任务、执行任务，然后进入休眠状态，等待更多任务。 123while (queue.waitForMessage()) { queue.processNextMessage();} queue.waitForMessage() 会同步地等待消息到达。 消息队列中的消息只有在当前消息完全的执行完成后，接下来的消息才会被执行。这个特性会带来一些优秀的特性，包括：当一个函数执行时，它不会被抢占，只有在它运行完毕之后才会去运行任何其他的代码，才能修改这个函数操作的数据。 这个模型的一个缺点在于当一个消息需要太长时间才能处理完毕时，Web应用程序就无法处理与用户的交互。一个良好的习惯是缩短单个消息处理时间，并在可能的情况下将一个消息裁剪成多个消息。 零延迟零延迟并不意味着回调会立即执行。以 0 为第二参数调用 setTimeout 并不表示在 0 毫秒后就立即调用回调函数，其等待的时间取决于队列里待处理的消息数量。延迟参数是运行时处理请求所需的最小等待时间，但并不保证是准确的等待时间。 运行时通信一个 web worker 或者一个跨域的 iframe 都有自己的栈、堆和消息队列。两个不同的运行时只能通过 postMessage 方法进行通信。如果另一个运行时侦听 message 事件，则此方法会向该运行时添加消息。 浏览器下的事件循环实现浏览器中所有任务都会被放到调用栈中等待主线程执行。 调用栈调用栈是解释器（比如浏览器中的 JavaScript 解释器）追踪函数执行流的一种机制。当执行环境中调用了多个函数时，通过这种机制，我们能够追踪到哪个函数正在执行，执行的函数体中又调用了哪个函数。 宏任务和微任务在每一个宏任务执行完成后，浏览器会立即执行所有来自微任务队列的微任务，这是比执行任何其它宏任务或者渲染更具有优先级的操作。 只有当微任务队列中的所有微任务都执行完之后，才会执行其它宏任务，这保证了在微任务执行时应用程序的环境不会改变。 如果想要在渲染或处理新的事件之前运行一个异步函数，可以通过 queueMicrotsk 方法来达成。 宏任务 - scripts/setTimeOut/setInterval/I/O/UI Rendering 微任务 - Promise.then catch finally/MutationObserver 同步任务和异步任务Javascript 单线程任务被分为同步任务和异步任务，同步任务会在调用栈中按照顺序等待主线程依次执行，异步任务会在异步任务有了结果后，将注册的回调函数放入任务队列中等待主线程空闲的时候（调用栈被清空），被读取到栈内等待主线程的执行。 任务执行逻辑 -&gt; 选择当前要执行的任务队列，选择任务队列中最先进入的任务，如果任务队列为空即null，则执行跳转到微任务（MicroTask）的执行步骤。 -&gt; 将事件循环中的任务设置为已选择任务。 -&gt; 执行任务。 -&gt; 将事件循环中当前运行任务设置为 null。 -&gt; 将已经运行完成的任务从任务队列中删除。 -&gt; microtasks 步骤：进入microtask检查点。 -&gt; 更新界面渲染。 -&gt; 返回第一步。 -&gt; 设置 microtask 检查点标志为 true。 -&gt; 当事件循环 microtask 执行不为空时：选择一个最先进入的 microtask 队列的 microtask，将事件循环的 microtask 设置为已选择的 microtask，运行 microtask，将已经执行完成的 microtask 为 null，移出 microtask 中的 microtask。 -&gt; 清理 IndexDB 事务 -&gt; 设置进入 microtask 检查点的标志为 false。 事件循环的一些应用分割占用 CPU 较多的任务假设我们有一个需要占用非常多 CPU 的任务，当浏览器在处理这个任务时，它就不能做其它 DOM 相关的操作，处理用户事件等，这将导致浏览器变的卡顿甚至崩溃，显然这是不可接受的。但我们可以通过将大任务分割成较小任务的方法来避免这个问题。 比如下面的代码，在执行时会导致浏览器挂起一段不短的时间，这期间用户事件都不会得到处理。 1234567891011121314let i = 0;let start = Date.now();function count() { // 大任务 for (let j = 0; j &lt; 1e9; j++) { j++; } console.log(&quot;Done in &quot; + (Date.now() - start) + &quot;ms&quot;);}count(); 如果用 setTimeout 将其分割成较小的任务，如果在小任务执行时有其它任务要执行，会被放入任务队列，当目前的分割小任务完成后立即执行这个任务。 1234567891011121314151617let i = 0;let start = Date.now();function count() { do { i++; } while(i % 1e6 !== 0) if (i === 1e9) { console.log(&quot;Done in &quot; + (Date.now() - start) + &quot;ms&quot;); } else { setTimeout(count); }}count(); 永不阻塞JavaScript 的事件循环模型与许多其他语言不同的一个非常有趣的特性是，它永不阻塞。 处理 I/O 通常通过事件和回调来执行，所以当一个应用正等待一个 IndexedDB 查询返回或者一个 XHR 请求返回时，它仍然可以处理其它事情，比如用户输入。 Node 中的事件循环、定时器和 process.nextTick()","link":"/2019/06/06/JavaScript%20%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/"},{"title":"JavaScript 变量作用域","text":"变量作用域变量能够被访问的范围被称为变量作用域。 变量声明ES6 之前所有的变量都使用 var 关键字进行声明，ES6 中新增了 let 和 const 两种变量声明的关键字。 使用 var 声明变量 使用 var 声明的变量会被自动添加到最靠近的上下文中，如果变量未经声明就初始化了，会被添加到全局上下文中。 var 声明的变量会被拿到函数或全局作用域的顶部，这种现象被称为变量提升。提升让同一作用域中的代码不必考虑变量是否已经声明就可以直接使用。可是在实践中，提 升也会导致合法却奇怪的现象，即在变量声明之前使用变量。 单需要注意的是：变量的声明会提升，但变量的赋值不会。 使用 let 的块级作用域声明 ES6 新增的 let 关键字跟 var 很相似，但它的作用域是块级的，这也是 JavaScript 中的新概念。块级作用域由最近的一对包含花括号 {} 界定。换句话说，if 块、while 块、function 块，甚至连单独 的块也是 let 声明变量的作用域。 let 与 var 的另一个不同之处是在同一作用域内不能声明两次。 重复的 var 声明会被忽略，而重 复的 let 声明会抛出 SyntaxError。 使用 const 的常量声明 ES6 同时还增加了 const 关键字。使用 const 声明的变量必须同时初始化为某个值。 一经声明，在其生命周期的任何时候都不能再重新赋予新值。 由于 const 声明暗示变量的值是单一类型且不可修改，JavaScript 运行时编译器可以将其所有实例都替换成实际的值，而不会通过查询表进行变量查找。谷歌的 V8 引擎就执行这种优化。","link":"/2019/06/19/JavaScript%20%E4%BD%9C%E7%94%A8%E5%9F%9F/"},{"title":"JavaScript 原型和继承","text":"很多面向对象语言都支持两种继承实现方式：接口继承和实现继承 - 接口继承继承方法签名，实现继承则继承方法的实现。但由于 JavaScript 中没有方法签名，因此只支持实现继承者一种方式，而原型链正是实现它的方式。 原型链JavaScript 中每个对象都有一个被称为原型的持有其它对象引用的私有属性，而原型对象也有其自己的原型，以此类推，这种链条持续到某个原型对象的原型为 null 。根据定义，null 是没有对象的，被作为原型链的最后一环。 当试图访问一个对象的属性时，不仅会搜索对象本身 - 如果对象本身未找到对应的属性，则会沿着对象的原型链层层向上搜索，直到找到匹配的属性或达到原型链的末尾。 每个构造函数都有一个原型对象 ，原型有一个属性指回构造函数，而实例有一个内部指针指向原型。 1234567891011function Point(x, y) { this.x = x; this.y = y;}console.log(Point.__proto__ === Function.prototype); // trueconsole.log(Point === Point.prototype.constructor); // trueconst somePoint = new Point(0, 0);console.log(somePoint.__proto__ === Point.prototype); // true 如果原型是另一个类型的实例呢？那就意味着这个原型本身有一个内部指针指向另一个原型，相应地另一个原型也有一个指针指向另一个构造函 数。这样就在实例和原型之间构造了一条原型链。这就是原型链的基本构想。 123456789101112131415161718function SuperType() { this.superName = 'Super Type';}SuperType.prototype.getSuperTypeName = function() { return this.superName; };function SubType() { this.subName = 'Sub Type';}SubType.prototype = new SuperType();SubType.prototype.getSubTypeName = function() { return this.subName; };const aType = new SubType();console.log(aType.__proto__ === SubType.prototype); // trueconsole.log(SubType.prototype.__proto__ === SuperType.prototype); // trueconsole.log(SuperType.prototype.constructor === SuperType); // true 下图展示了子类的实例与两个构造函数及其对应的原型之间的关系： 实际上，原型链中还有一环。默认情况下，所有引用类型都继承自 Object，这也是通过原型链实现的。 任何函数的默认原型都是一个 Object 的实例， 这意味着这个实例有一个内部指针指向 Object.prototype。这也是为什么自定义类型能够继承包括 toString()、valueOf() 在内的所有默认方法的原因。因此前面的例子还有额外一层继承关系： 继承原型链虽然是实现继承的强大工具，但它也有问题。主要问题出现在原型中包含引用值的时候。前面在谈到原型的问题时也提到过，原型中包含的引用值会在所有实例间共享，这也是为什么属性通常会在构造函数中定义而不会定义在原型上的原因。在使用原型实现继承时，原型实际上变成了另一个类型的实例。 1234567891011121314function SuperType() { this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];}function SubType() {}// 继承 SuperType SubType.prototype = new SuperType();let instance1 = new SubType(); instance1.colors.push(&quot;black&quot;); console.log(instance1.colors); // &quot;red,blue,green,black&quot;let instance2 = new SubType();console.log(instance2.colors); // &quot;red,blue,green,black&quot; 原型链的第二个问题是，子类型在实例化时不能给父类型的构造函数传参。事实上，我们无法在不影响所有对象实例的情况下把参数传进父类的构造函数。再加上之前提到的原型中包含引用值的问题，就导致原型链基本不会被单独使用。 在子类构造函数中调用父类构造函数，因为毕竟函数就是在特定上下文中执行代码的简单对象，所以可以使用 apply() 和 call() 方法以新创建的对象为上下文执行构造函数，这种实现继承的方法被称为盗用构造函数继承。 这种方法的问题是必须在构造函数中定义方法，因此函数不能重用，而且子类也不能访问父类原型上定义的方法，因此所有类型只能使用构造函数模式。 使用原型链继承原型上的属性和方法，通过盗用构造函数继承实例属性。这样既可以把方法定义在原型上以实现重用，又可以让每个实例都有自己的属性，这种实现继承的方法被称为组合继承。 123456789101112131415161718192021222324252627function SuperType(name) { this.name = name; this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];}SuperType.prototype.sayName = function() { console.log(this.name); };function SubType(name, age){ // 继承属性 SuperType.call(this, name); this.age = age;}// 继承方法 SubType.prototype = new SuperType();SubType.prototype.sayAge = function() { console.log(this.age); };let instance1 = new SubType(&quot;Nicholas&quot;, 29); instance1.colors.push(&quot;black&quot;); console.log(instance1.colors); // &quot;red,blue,green,black&quot; instance1.sayName(); // &quot;Nicholas&quot;; instance1.sayAge(); // 29let instance2 = new SubType(&quot;Greg&quot;, 27);console.log(instance2.colors); // &quot;red,blue,green&quot; instance2.sayName(); // &quot;Greg&quot;; instance2.sayAge(); // 27 组合继承弥补了原型链和盗用构造函数的不足，是 JavaScript 中使用最多的继承模式。而且组合继承也保留了 instanceof 操作符和 isPrototypeOf() 方法识别合成对象的能力。 其它补充函数的 prototype每个函数都有 prototype 属性，它默认包含了一个只有 constructor 属性的对象，这个 constructor 属性指向函数自身。 123function Foo() {}console.log(Foo.prototype.constructor === Foo); // true 在使用 new 操作符创建对象时，构造函数的 prototype 被赋值给被创建的对象实例的 [[prototype]] 属性。 12345678function Foo() {}const foo = new Foo();console.log(foo.constructor === Foo); // trueconsole.log(foo.__proto__ === Foo.prototype); // trueconst anotherFoo = new foo.constructor(); 我们可以使用 constructor 属性来创建一个新对象，该对象使用与现有对象相同的构造器。 1234567function Foo() {}const foo = new Foo();const anotherFoo = new foo.constructor();console.log(anotherFoo.constructor === Foo); // true","link":"/2019/06/13/JavaScript%20%E5%8E%9F%E5%9E%8B%E4%B8%8E%E7%BB%A7%E6%89%BF/"},{"title":"JavaScript 中的反射与 Proxy 与 Reflect","text":"JavaScript 中的反射与 Proxy 与 Reflect反射（Reflect）是指程序运行时访问、检测和修改本身状态和行为的能力。在 ES6 中引入 Reflect 之前，常用 for...in 实现反射，而在引入 Reflect 之后，反射机制在 JavaScript 中得到了更大的延伸与应用。 ReflectReflect 是一个全局对象，但与其它全局对象不同，它并不是一个构造函数，所以不能通过 new 来对其进行调用。 而且它所有的属性和方法都是静态的（类似的还有 Math）。 12345678910// ** 检测一个对象是否有特定的属性const obj = { A: '1', B: '2' };Reflect.has(obj, 'A'); // trueReflect.has(obj. 'C'); // false// ** 返回对象自身的键 has 与 in 运算符作用相同Reflect.ownKeys(obj); // ['A', 'B']// ** 为对象添加新的属性Reflect.set(obj, 'C', '3'); // true ProxyProxy 基于目标对象创建一个代理对象，可以通过代理对象实现对于基本操作的拦截和自定义。 123// target 要代理的对象，可以是任何对象，包括函数// handler 代理配置，带有扑捉器的对象const proxy = new Proxy(targe, handler); 对 proxy 对象进行操作，如果 handler 中包含了对应的捕捉器，则扑捉器会拦截这个操作，并对其进行处理。如果没有相应的捕捉器，则操作会被转发到被代理的对象。 对被代理对象的操作和相应的捕捉器名称如下： 被代理对象的操作 捕捉器 Object.getPrototypeOf() handler.getPrototypeOf() Object.setPrototypeOf() handler.setPrototypeOf() Object.isExtensible() handler.isExtensible() Object.preventExtensions() handler.preventExtensions() Object.getOwnPropertyDescriptor() handler.getOwnPropertyDescriptor() Object.defineProperty() handler.defineProperty() in handler.has() 属性读取 handler.get() 属性赋值 handler.set() delete handler.deleteProperty() Object.getOwnPropertyNames() 和 Object.getOwnPropertySymbols() handler.ownKeys() 函数调用 handler.apply() new handler.construct() 不变量为了确保语言功能和行为的一致性，代理对象的捕捉器的返回是有一定限制的，被称为不变量。 set() ，如果设置属性值成功，需要返回 true，否则返回 false deleteProperty()，如果属性删除成功，需要返回 true，否则返回 false getPrototypeOf() 必须返回被代理对象的原型 … 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&quot;use strict&quot;;let origin = { name: 'Mike', age: 29, _isMarried: false};origin = new Proxy(origin, { isExtensible: function(obj) { return Reflect.isExtensible(obj); }, has: function(obj, prop) { return Reflect.has(obj, prop); }, get: function get(obj, prop, receiver) { if (Reflect.has(obj, prop)) { if (prop.startsWith('_')) return 'Access denied'; return Reflect.get(obj, prop, receiver); } else { return &quot;No &quot;.concat(prop, &quot; find in target&quot;); } }, set: function set(obj, prop, value, receiver) { if (Reflect.has(obj, prop)) { if (prop.startsWith('_')) return 'Access denied'; Reflect.set(obj, prop, value, receiver); return true; } else { return false; } }});console.log(origin._isMarried); // Access deniedconsole.log(origin._isMarried = '1'); // Access deniedfunction constructPoint(numX, numY) { return [numX, numY];}const funcProxy = new Proxy(constructPoint, { apply: function(obj, thisArg, argumentsList) { return argumentsList.join('-'); }});console.log(funcProxy(1, 2)); // 1-2 对于每个可被 Proxy 捕获的内部方法，在 Reflect 中都有一个对应的方法，其名称和参数与 Proxy 捕捉器相同。 所以，我们可以使用 Reflect 来将操作转发给原始对象。 Proxy 的局限许多内建对象，例如 Map，Set，Date，Promise 等，都使用了所谓的“内部插槽”。 它们类似于属性，但仅限于内部使用，仅用于规范目的。例如，Map 将项目（item）存储在 [[MapData]] 中。内建方法可以直接访问它们，而不通过 [[Get]]/[[Set]] 内部方法。所以 Proxy 无法拦截它们。 1234567891011let map = new Map();let proxy = new Proxy(map, { get(target, prop, receiver) { let value = Reflect.get(...arguments); return typeof value == 'function' ? value.bind(target) : value; }});proxy.set('test', 1);alert(proxy.get('test')); // 1（工作了！） 类似的，类的私有属性也是通过内部插槽而不是 get 和 set 方法，采用上面的方法依旧有效 123456789101112131415161718class User { #name = &quot;Guest&quot;; getName() { return this.#name; }}let user = new User();user = new Proxy(user, { get(target, prop, receiver) { let value = Reflect.get(...arguments); return typeof value == 'function' ? value.bind(target) : value; }});alert(user.getName()); // Guest","link":"/2020/06/18/JavaScript%20%E5%8F%8D%E5%B0%84%E4%B8%8E%20Reflect/"},{"title":"JavaScript 调用栈和执行上下文","text":"执行上下文和执行栈执行上下文是评估和执行 JavaScript 代码的环境的抽象概念。每当 Javascript 代码在运行的时候，它都是在执行上下文中运行。变量或函数的执行上下文决定了它们能够访问哪些数据以及它们的行为。 执行上下文的类型 全局执行上下文 默认或者说基础的上下文，所有不在函数内部的代码都在全局上下文中执行。它会创建一个全局对象 window 并将 this 指向它(浏览器环境)。所有通过 var 定义的全局变量和方法都会成为 window 对象的属性和方法。使用 let 和 const 定义的顶级声明不会定义在全局上下文中，但在作用域链的解析效果上是一样的。 一个程序中只会有一个全局执行上下文。 函数执行上下文 每当一个函数被调用时，都会为该函数创建一个新的上下文。 每个函数都有它自己的执行上下文，不过是在函数被调用时创建的。 eval 函数上下文 执行在 eval 函数内部的代码也会有它属于自己的执行上下文。 执行上下文的内容ES 5 中执行上下文包含了： 词法环境 变量环境 this 词法环境JavaScript 中每个运行的函数，代码块以及整个脚本，都有一个被称为词法环境的隐藏的内部关联对象。而词法环境对象又由两部分组成： 环境记录 - 存储所有局部变量 一个对外部词法环境的引用 当代码要访问一个变量时，首先会搜索内部词法环境，然后搜索外部环境，然后搜索更外部的环境，以此类推，直到全局词法环境。 执行栈(调用栈)执行栈(或者调用栈)，也就是在其它编程语言中所说的调用栈，是一种拥有 LIFO（后进先出）数据结构的栈，被用来存储代码运行时创建的所有执行上下文。 当 JavaScript 引擎第一次遇到你的脚本时，它会创建一个全局的执行上下文并且压入当前执行栈。每当引擎遇到一个函数调用，它会为该函数创建一个新的执行上下文并压入栈的顶部。 引擎会执行那些执行上下文位于栈顶的函数。当该函数执行结束时，执行上下文从栈中弹出，控制流程到达当前栈中的下一个上下文。 执行上下文的创建创建执行上下文有两个阶段：创建阶段和执行阶段 创建阶段在 JavaScript 代码执行前，执行上下文将经历创建阶段 this 绑定 在全局执行上下文中，this 值是全局对象。 在函数执行上下文中，this 的值取决于函数是如何被调用的。如果被一个引用对象调用，this 的值会被设置为这个对象，否则会被设置为 undefined 或全局对象。 词法环境组件的创建 词法环境是一种持有 标识符 - 变量 映射的结构。词法环境的内部有两个组件 ：环境记录器和一个外部环境的引用。环境记录器是存储变量和函数声明的实际位置，外部环境引用意味着你可以用它访问其父级词法环境。 全局词法环境 全局词法环境是没有外部环境引用的词法环境(在全局执行上下文中)。 函数词法环境 函数内部用户定义的变量存储在环境记录器中。它的外部环境引用可能是全局环境或者任何包含此函数的外部函数。 环境记录器的两种类型 ： 声明式环境记录器存储变量、函数和参数 对象环境记录器用来定义出现在全局上下文中的变量和函数的关系 简而言之，在全局环境中，环境记录器就是对象环境记录器，在函数环境中，环境记录器就是声明式环境记录器。 变量环境组件的创建 变量环境实际上也是一个词法环境，其环境记录器持有变量声明语句在执行上下文中创建的绑定关系。 ES 6 中，词法环境和变量环境的一个不同就是前者被用来存储函数声明和变量绑定(let 和 const)，后者只用来存储 var 变量绑定。 执行阶段在执行阶段，完成对所有变量的分配，最后执行代码。 执行上下文的销毁执行上下文在其所有代码都执行完毕后会被销毁，包括定义在它上面的所有变量和函数（全局上下文在应用程序退出前才会被销毁，比如关闭网页或退出浏览器）。 闭包闭包是指内部函数总是可以访问其所在的外部函数中声明的变量和参数，即使在外部函数被返回之后；也可以理解为闭包就是一个绑定了执行环境的函数。 在 JavaScript 中，函数是天生闭包的。","link":"/2019/04/22/JavaScript%20%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E8%B0%83%E7%94%A8%E6%A0%88/"},{"title":"JavaScript 操作符","text":"位操作符ECMAScript 中的所有数值都以 IEEE 754 64 位格式存储，但位操作并不直接应用到 64 位表示，而是先把值转换为 32 位整数，再进行位操作，之后再把结果转换为 64 位。对开发者而言，就好像只有 32 位整数一样，因 为 64 位整数存储格式是不可见的。这让二进制操作变得与其他语言中类似。但这个转换也导致了一个奇特的副作用，即特殊值 NaN 和 Infinity 在位操作中都会被当成 0 处理。 有符号整数使用 32 位的前 31 位表示整数值。第 32 位表示数值的符号，如 0 表示正，1 表示负。这 一位称为符号位（sign bit），它的值决定了数值其余部分的格式。正值以真正的二进制格式存储，即 31 位中的每一位都代表 2 的幂。第一位（称为第 0 位）表示 20 ，第二位表示 21 ，依此类推。如果一个位是空的，则以 0填充，相当于忽略不计。 负值以一种称为二补数（或补码）的二进制编码存储。一个数值的二补数通过如下 3 个步骤计算 得到： 确定绝对值的二进制表示 找到数值的一补数（或反码），换句话说，就是每个 0 都变成 1，每个 1 都变成 0 给结果加 1 默认情况下，ECMAScript 中的所有整数都表示为有符号数。不过，确实存在无符号整数。对无符号整数来说，第 32 位不表示符号，因为只有正值。无符号整数比有符号整数的范围更大，因为符号位被用来表示数值了。 123456console.log(1 &lt;&lt; 10); // 1024console.log(-1 &lt;&lt; 10); // -1024console.log(1024 &gt;&gt; 10); // 1console.log(-1024 &gt;&gt; 10); // -1console.log(1024 &gt;&gt;&gt; 10); // 1console.log(-1024 &gt;&gt;&gt; 10); // 4194303 相等操作符全等和不全等操作符与相等和不相等操作符类似，只不过它们在比较相等时不转换操作数。全等操 作符由 3 个等于号（===）表示，只有两个操作数在不转换的前提下相等才返回 true。","link":"/2019/06/26/JavaScript%20%E6%93%8D%E4%BD%9C%E7%AC%A6/"},{"title":"JavaScript 文件操作","text":"在大部分浏览器上，你不能直接存储你创建的文件，因为这会导致大量的安全问题。不过你可以将你的文件通过下载链接的方式提供给用户。 在客户端生成文件静态方法 window.URL.createObjectURL(object) 会创建一个表示参数中给出的对象 object 的 URL 的 DOMString ，其生命周期和创建它的 document 生命周期绑定。 object 可以是 File 、Blob 和 MediaSource。 每次调用 createObjectURL() 都会为指定的对象创建一个新的 URL 对象，而不管是否已经用这个指定对象创建过 URL 对象。因此在创建的 URL 对象不再使用时，应该在安全的时机调用 revokeObjectURL() 方法来释放掉它。 1234567891011121314151617181920const objArrInJson = JSON.stringify([ { &quot;name&quot;: &quot;一般职业&quot;, &quot;value&quot;: &quot;0&quot; }, { &quot;name&quot;: &quot;农牧业&quot;, &quot;value&quot;: &quot;1&quot;, &quot;childs&quot;: [ { &quot;name&quot;: &quot;机关、团体、公司&quot;, &quot;value&quot;: &quot;1&quot; } ] },]);function generateF(raw) { const datasInBlob = new Blob([raw], { type: 'application/json' }); return window.URL.createObjectURL(datasInBlob);} 关于 FileReader在网页应用程序中，使用 FileReader 可以通过使用 Blob 或 File 指定要异步的读取的文件内容（或数据缓冲区内容）。 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=&quot;file&quot; multiple accept=&quot;*&quot; id=&quot;fileInput&quot;&gt; &lt;script&gt; const fileInput = document.getElementById('fileInput'); // change 事件当用户选择了文件时被触发 fileInput.addEventListener('change', (event) =&gt; { const fileI = event.target; console.log(fileI.files); }) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 文件加载完成后返回的 files 是一个 FileList，其中的 File 的就是选择的文件的相关信息。 File 对象包含提供文件有关的信息，使得网页中的代码能够访问文件内容。 12345678{ lastModified: 00000000000, // 只读属性，以毫秒表示的的文件上次修改时间 lastModifiedDate: '', // 只读属性，文件上次修改时间 name: 'file.text', // 只读属性， File 对象的关联的文件的名称 size: 1024, // 只读属性，以字节表示的文件大小 type: 'text/plain', // 只读属性，文件的 MIME 类型，类型不确定是返回 &quot;&quot; webkitRelativePath: '' // 文件相关的 `Path` 或 `URL`} 拖拽文件12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;dropbox&quot; id=&quot;dropbox&quot;&gt;&lt;/div&gt; &lt;script&gt; const dropbox = document.getElementById('dropbox'); dropbox.addEventListener('dragenter', (e) =&gt; { e.stopPropagation(); e.preventDefault(); }, false); dropbox.addEventListener('dragover', (e) =&gt; { e.stopPropagation(); e.preventDefault(); console.log(e); }, false); dropbox.addEventListener('drop', (e) =&gt; { e.stopPropagation(); e.preventDefault(); const dt = e.dataTransfer; console.log(dt); const files = dt.files; }, false); &lt;/script&gt; &lt;style&gt; .dropbox { width: 100vw; height: 100vh; background-color: aliceblue; } &lt;/style&gt;&lt;/body&gt;&lt;/html&gt;","link":"/2018/06/16/JavaScript%20%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"},{"title":"JavaScript 正则表达式","text":"JavaScript 正则表达式 什么是正则表达式？正则表达式是一些用来匹配和处理文本的字符串。 语法可以使用字面量、构造器和工厂标记来创建正则表达式 123/partern/flagsnew RegExp(pattern[, flags])RegExp(pattern[, flags]) 其中 flags g 全局匹配 i 不区分大小写 m 多行匹配 u Unicode 字符匹配 正则表达式中的特殊字符字符类 . 匹配除行终止符(\\n,\\r,\\u2028 or \\u2029)之外的任何单个字符，若在字符集中则仅仅只匹配. \\d 匹配任何一个数字字符，相当于 [0-9] \\D 匹配任何一个非数字字符，相当于 [^0-9] \\w 匹配任何一个字母数字字符，包括下划线，相当于 [A-Za-z0-9_] \\W 匹配任何一个非字母数字字符或非下划线字符，相当于 [^A-Za-z0-9_] \\s 匹配任何单个空格字符，相当于 [\\f\\n\\r\\t\\v\\u00a0\\u1680\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff] \\S 匹配除了空格外的单个字符，相当于 [^ \\f\\n\\r\\t\\v\\u00a0\\u1680\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff] \\t 匹配一个横向制表符 \\r 匹配一个回车 \\n 匹配一个换行符 \\v 匹配一个垂直制表符 \\f 匹配一个换页符 [\\b] 匹配一个删除符 \\0 匹配 NUL 字符 \\cX 匹配控制字符 字符集 [-a-z-] 匹配方括号中字符中的任何一个，可以使用连字符 - 来指定字符范围，但如果连字符是方括号中的第一个或最后一个字符，则作为普通字符包含在字符集中。也可以在字符集中包含字符类。 [^-A-Z-] 匹配除括号中包含的内容外的任何内容 可选字符 x|y 匹配 x 或 y 中的一个 边界 ^ 匹配开头，如果设置了多行匹配标记，则在换行符后立即匹配 $ 匹配结尾 \\b 匹配单词边界，实际上它匹配的是一个能够构成单词的字符(\\w)和一个不能构成单词的字符(\\W)之间的位置 \\B 匹配非单词边界 分组和反向引用 (x) 匹配 x 并记录匹配结果，称为捕获分组 \\n 引用之前的第 n 个 表达式 (?:x) 匹配 x 但不记录匹配结果，称为非捕获分组 量词 x* 匹配 x 0次或更多次 x+ 匹配 x 1次或更多次 x? 匹配 x 0次或1次 x{n} 匹配 x n次 x{n,} 匹配 x 至少n次 x{n,m} 匹配 x 至少n次至多m次 ? 非贪婪匹配，在量词后加上 ? 表示量词的非贪婪模式，匹配尽可能少的字符 回溯引用 x(?=y) 前向查找，仅当 x 后跟 y 时，才匹配 x (?&lt;=y)x 后向查找，仅当 x 前面有 y 时，才匹配 x 常用的方法 exec() 在指定的字符串上执行匹配搜索，返回结果数组或 null 12345678const str = &quot;My ip address is 255.198.99.101 and your ip address 199.123.44.88&quot;;const reg = /\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}/g;// Found 255.198.99.101, from index 17, last match from index 31// Found 199.123.44.88, from index 52, last match from index 65while((res = reg.exec(str)) !== null) { console.log(`Found ${res[0]}, from index ${res['index']}, last match from index ${reg.lastIndex}`);} test() 在指定的字符串和一个正则表达式之间执行匹配搜索，返回 true 或 false match() 对给定的字符串进行匹配并返回匹配结果 12345const str = &quot;My ip address is 255.198.99.101 and your ip address 199.123.44.88&quot;;const reg = /\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}/g;// [ '255.198.99.101', '199.123.44.88' ]console.log(str.match(reg)); replace() 使用给定的字符串替换匹配到的结果 search() 在给定的字符串中搜索匹配，并返回首次匹配结果的索引 split() 通过将字符串分隔为子字符串，将字符串拆分为数组。 常用正则表达式 匹配中文字符 1/^[\\u4e00-\\u9fa5]{0,}$/ 匹配双字节字符 1/[^\\x00-\\xff]/ 匹配千分位 1/\\B(?=(\\b{3})+(?!\\d))/ 匹配两位小数 1/^([1-9][0-9]*)(\\.[0-9]{2})?$/ 匹配中国固定电话号码 最开始的一位一定是 0，接着是 2，3，4位数字组成的区号，然后是7位或8位的电话号码，其中首位不为1 1/\\(?0[1-9]\\d{1,3}\\)?[ -]?[2-9]\\d{2,3}[ -]?\\d{4}/ 匹配统一社会信用代码 统一社会信用代码由18位数字或者大写字母组成，但是字母不包括 I、O、Z、S、V 一共由五部分组成： 第一部分：登记管理部门代码1位 (数字或大写英文字母) 第二部分：机构类别代码1位 (数字或大写英文字母) 第三部分：登记管理机关行政区划码6位 (数字) 第四部分：主体标识码（组织机构代码）9位 (数字或大写英文字母) 第五部分：校验码1位 (数字或大写英文字母) 1/[0-9A-HJ-NPQRTUWXY]{2}\\d{6}[0-9A-HJ-NPQRTUWXY]{10}/ 目前还有老的工商注册代码，也就是15位的社会信用代码，正则表达式如下：（弱校验） 1/[1-9]\\d{15}/ 同时支持18位和15位社会信用代码 1/^([0-9A-HJ-NPQRTUWXY]{2}\\d{6}[0-9A-HJ-NPQRTUWXY]{10}|[1-9]\\d{14})$/ 中国邮政编码 前两位代表省、市、自治区，第三位代表邮区，第四位代表县、市，最后两位代表投递邮局，其中第二位不为 8。 1/\\d[0-7|9][0-9]{4}/ 中国身份证号码 前六位是户口所在地编码，其中第一位是 1~8，此后是出生年月日，出生年份只能是 18、19、20，而且是可选的，最后一位校验位是数字或 x 1/[1-8]\\d{5}((18)|(19)|(20))?\\d{2}(0[1-9]|1[0-2])((0|1|2)[1-9]|3[0-1])\\d{3}[\\dx]?/ JavaScript 中的特殊字符 Unicode 转义序列 含义 类别 \\u0008 \\b Backspace \\u0009 \\t Tab 空白 \\u000A \\n 换行符 行终止符 \\u000B \\v 垂直制表符 空白 \\u000C \\f 换页 空白 \\u000D \\r 回车 行终止符 \\u0022 &quot; 双引号 \\u0027 ' 单引号 \\u005C \\ \\ 反斜杠 \\u00A0 不间断空格 空白 \\u0028 行分隔符 行终止符 \\u0029 段落分割符 行终止符 \\uFEFF 字节顺序标记 空白","link":"/2018/09/02/JavaScript%20%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"title":"JavaScript 中的深拷贝和浅拷贝","text":"关于深拷贝和浅拷贝的定义： 浅拷贝 - 创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址 ，所以如果其中一个对象改变了这个地址，就会影响到另一个对象。 深拷贝 - 将一个对象从内存中完整的拷贝一份出来,从堆内存中开辟一个新的区域存放新对象,且修改新对象不会影响原对象。 使用 JSON.parse(JSON.stringify()) 来实现深拷贝可以使用 JSON.parse(JSON.stringify(obj)) 来实现对目标对象的深拷贝，但是这种方法有很多缺陷： 如果 undefined、Symbol 和 函数是对象的属性值或以Symbo值为键的属性值，拷贝的对象会丢失这些属性 1234567891011const originObj = { name: 'Trump', age: 94, phone: undefined, idNo: Symbol('1900'), speak: () =&gt; console.log('I am Trump'), [Symbol.for('weight')]: 120,}const copyObj = JSON.parse(JSON.stringify(originObj));console.log(copyObj); // { name: 'Trump', age: 94 } 无法处理循环引用 123456789101112131415161718const team = { teamName: 'MAGA',}const originObj = { name: 'Trump', age: 94, phone: undefined, idNo: Symbol('1900'), speak: () =&gt; console.log('I am Trump'), [Symbol.for('weight')]: 120, team,}team.leader = originObj;const copyObj = JSON.parse(JSON.stringify(originObj));console.log(copyObj); // TypeError: Converting circular structure to JSON 一个比较全面的深拷贝实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177const TYPE_OBJECT = '[object Object]';const TYPE_MAP = '[object Map]';const TYPE_SET = '[object Set]';const TYPE_ARRAY = '[object Array]';const TYPE_ARGUMENTS = '[object Arguments]';const TYPE_BOOLEAN = '[object Boolean]';const TYPE_DATE = '[object Date]';const TYPE_NUMBER = '[object Number]';const TYPE_STRING = '[object String]';const TYPE_SYMBOL = '[object Symbol]';const TYPE_ERROR = '[object Error]';const TYPE_REGEXP = '[object RegExp]';const TYPE_FUNCTION = '[object Function]';const TYPE_UNDEFINED = '[object Undefined]';const forEach = (array, iterator) =&gt; { let index = -1; let length = array.length; while(++index &lt; length) { iterator(array[index], index); } return array;}const isObj = (value) =&gt; { const type = typeof value; return value !== null &amp;&amp; (type === 'object' || type === 'function');}const getType = (value) =&gt; { return Object.prototype.toString.call(value);}const canCopyTags = [TYPE_OBJECT, TYPE_ARRAY, TYPE_MAP, TYPE_SET, TYPE_ARGUMENTS];const getInit = (value) =&gt; { const ctor = value.constructor; return new ctor();}const copyReg = (value) =&gt; { const regFlags = /\\w*$/; const newReg = new value.constructor(value.source, regFlags.exec(value)); newReg.lastIndex = value.lastIndex; return newReg;}const copySymbol = (value) =&gt; { return Object(Symbol.prototype.valueOf.call(value));}const copyFunction = (value) =&gt; { const bodyReg = /(?&lt;={)(.|\\n)+(?=})/m; const paramReg = /(?&lt;=\\().+(?=\\)\\s+{)/; if (value.prototype) { const body = bodyReg.exec(value.toString()); const param = paramReg.exec(value.toString()); if (body) { if (param) { const paramArr = param[0].split(','); return new Function(...paramArr, body[0]); } else { return new Function(body[0]); } } else { return null; } } else { return eval(value.toString()); }}const copyOther = (value, type) =&gt; { const ctor = value.constructor; switch(type) { case TYPE_BOOLEAN: case TYPE_NUMBER: case TYPE_STRING: case TYPE_ERROR: case TYPE_DATE: return new ctor(value); break; case TYPE_REGEXP: return copyReg(value); break; case TYPE_SYMBOL: return copySymbol(value); break; case TYPE_FUNCTION: return copyFunction(value); break; default: return null; }}const copy = (origin, relationMap = new WeakMap()) =&gt; { if (!isObj(origin)) return origin; const type = getType(origin); let target; if (canCopyTags.includes(type)) { target = getInit(origin); } else { return copyOther(origin, type); } if (relationMap.get(origin)) return relationMap.get(origin); relationMap.set(origin, target); if (type === TYPE_SET) { origin.forEach((value) =&gt; { target.add(copy(value)); }); return target; } if (type === TYPE_MAP) { origin.forEach((value, key) =&gt; { target.set(key, copy(value)); }); return target; } const keys = type === TYPE_ARRAY ? undefined : Object.keys(origin); forEach(keys || origin, (value, key) =&gt; { if (keys) { key = value; } target[key] = copy(origin[key], relationMap); }); return target;}const originObj = { name: 'Trump', age: 94, phone: undefined, idNo: Symbol('1900'), speak: () =&gt; console.log('I am Trump'), [Symbol.for('weight')]: 120, team: { leader: 'Ywank', office: { address: 'white house' } }, employee: [ { name: 'pense', }, { name: 'fox', }, ],}originObj.president = originObj;console.log(copy(1)); // 1console.log(copy(undefined)); // undefinedconsole.log(copy(/\\d/)); // /\\d/console.log(copy(new Date())); // 2018-05-16T08:06:45.361Zconst someFun = function(num1, num2) { console.log(num1 + num2); return num1 + num2;}const copyFun = copy(someFun);console.log(copyFun(1, 3)); // 4const someSet = new Set();someSet.add(1);console.log(copy(someSet)); // Set(1) { 1 }const copyObj = copy(originObj);console.log(originObj);console.log(copyObj);copyObj.speak(); // I am Trump 为什么使用 while 实现遍历123456789101112131415161718192021222324252627282930313233343536const ARRAY_SIZE = 10000000;const LARGE_ARRY = new Array(ARRAY_SIZE).fill(1);// for...inlet forInCopy = 0;console.time('FOR_IN');for (let key in LARGE_ARRY) { forInCopy += LARGE_ARRY[key];}console.timeEnd('FOR_IN');// forlet forCopy = 0console.time('FOR');for (let index = 0; index &lt; LARGE_ARRY.length; index += 1) { forCopy += LARGE_ARRY[index];}console.timeEnd('FOR');// whilelet whileCopy = 0;let index = 0;console.time('WHILE');while(index &lt; ARRAY_SIZE) { whileCopy += LARGE_ARRY[index]; index += 1;}console.timeEnd('WHILE');// forEachlet forEachCopy = 0console.time('FOR_EACH');LARGE_ARRY.forEach((value) =&gt; { forEachCopy += value;});console.timeEnd('FOR_EACH'); 遍历方式 for...in for forEach while 100 0.103ms 0.012ms 0.027ms 0.007ms 10 0.088ms 0.005ms 0.022ms 0.003ms 1000 0.313ms 0.036ms 0.052ms 0.028ms 10000 1.332ms 0.299ms 0.316ms 0.252ms 100000 14.167ms 1.691ms 1.977ms 1.428ms 1000000 140.967ms 2.928ms 14.94ms 3.012ms 10000000 2.748s 13.197ms 141.273ms 15.944ms 20000000 7.824s 22.389ms 254.557ms 28.07ms 30000000 17.107s 33.414ms 375.766ms 44.301ms 综合来看，在百万量级的数据下，使用 while 进行遍历所耗费的时间最少。 判断引用类型1234const isObj = (value) =&gt; { const type = typeof value; return value !== null &amp;&amp; (type === 'object' || type === 'function');} 获取数据类型每一个引用类型都有toString方法，默认情况下，toString()方法被每个Object对象继承。如果此方法在自定义对象中未被覆盖，toString() 返回 &quot;[object type]&quot;，其中type是对象的类型。 123const getType = (value) =&gt; { return Object.prototype.toString.call(value);}","link":"/2018/05/19/JavaScript%20%E6%B7%B1%E6%8B%B7%E8%B4%9D/"},{"title":"JavaScript 迭代器和生成器","text":"ECMAScript 6 规范新增的两个高级特性：生成器和迭代器能够使我们高效、清晰、方便的实现迭代。 在 ECMAScript 较早的版本中，执行迭代必须使用循环或其他辅助结构。随着代码量增加，代码会变得越发混乱。很多语言都通过原生语言结构解决了这个问题，开发者无须事先知道如何迭代就能实现迭代操作。这个解决方案就是迭代器模式。Python、Java、C++，还有其他很多语言都对这个模式提供了完备的支持。 生成器和生成器对象生成器是 ECMAScript 6 新增的一个极为灵活的结构，拥有在一个函数块内暂停和恢复代码执行的能力。 需要注意的是：箭头函数不能用来定义生成器函数。(箭头函数的作用域根据当前环境决定) 通过生成器函数可以生成一个遵循可迭代协议(Iterable Protocol)和迭代器协议(Iterator Protocol)的生成器对象。 可迭代协议是指：支持迭代的自我识别能力和创建实现 Iterator 接口的对象的能力。在 ECMAScript 中，这意味着必须暴露一个属性作为 “默认迭代器”，而且这个属性必须使用特殊的 [Symbol.iterator] 作为键。这个默认迭代器属性必须引用一个迭代器工厂函数，调用这个工厂函数必须返回一个新迭代器。 迭代器协议是指：含有 next() 方法可以在可迭代对象中遍历数据，并返回 { done: Boolean, value: any } 形式的返回数据，done 用来标识迭代是否完成。 yield 关键字可以让生成器停止和开始执行，也是生成器最有用的地方。生成器函数在遇到 yield 关键字之前会正常执行。遇到这个关键字后，执行会停止，函数作用域的状态会被保留。停止执行的生成器函数只能通过在生成器对象上调用 next() 方法来恢复执行： 123456789101112function* generatorFun() { yield 1; yield 2; yield 3;}const generatorObj = generatorFun(); // {}console.log(generatorObj.next()); // { value: 1, done: false }console.log(generatorObj.next()); // { value: 2, done: false }console.log(generatorObj.next()); // { value: 3, done: false }console.log(generatorObj.next()); // { value: undefined, done: true } 生成器对象遵循可迭代协议和迭代器协议，因此它可以通过 for...of 进行迭代 123456789101112131415function* generatorFun() { yield 1; yield 2; yield 3;}const generatorObj = generatorFun();for (const iterator of generatorObj) { console.log(iterator);}// 1// 2// 3 也可以通过 spread 语法输出其值 123456789function* generatorFun() { yield 1; yield 2; yield 3;}const generatorObj = generatorFun();console.log(...generatorObj); // 1 2 3 通过 yield* 可以将执行委托给另一个迭代器，是将一个生成器的流插入到另一个生成的流的方式 12345678910111213141516function* generateSquence(start, end) { for (let i = start; i &lt;= end; i++) yield i;}function* generatePwdChars() { yield* generateSquence(48, 57); yield* generateSquence(65, 90); yield* generateSquence(97, 122);}let pwdChars = '';for (const char of generatePwdChars()) { pwdChars += String.fromCharCode(char);}console.log(pwdChars); // 0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz yield 不仅可以向外返回结果，还可以将外部的值传递到生成器内部(第一次调用 next() 方法传递的参数会被忽略) 123456789101112function* gen() { // 向外部代码传递一个问题并等待答案 let result = yield &quot;2 + 2 = ?&quot;; // (*) alert(result);}let generator = gen();let question = generator.next().value; // &lt;-- yield 返回的 valuegenerator.next(4); // --&gt; 将结果传递到 generator 中 可以通过 generator.throw() 向生成器内部传递一个错误 123456789101112131415function* gen() { try { let result = yield &quot;2 + 2 = ?&quot;; // (1) console.log(&quot;The execution does not reach here, because the exception is thrown above&quot;); } catch(e) { console.log(e); // Error: The answer is not found in my database }}let generator = gen();let question = generator.next().value;generator.throw(new Error(&quot;The answer is not found in my database&quot;)); // (2) 当迭代值是以异步的形式出现时，就需要使用异步迭代，通过为对象添加 [Symbol.asyncIterator] 方法返回异步迭代器对象，异步迭代器对象通过 for await...of 循环来访问迭代值 1234567891011121314151617let range = { from: 1, to: 5, [Symbol.asyncIterator]: async function* () { for (let start = this.from; start &lt;= this.to; start++) { value = awiat doSth(); yield value; } }};(async () =&gt; { for await (let value of range) { // (4) alert(value); // 1,2,3,4,5 }})() 迭代器JavaScript 中的可迭代对象是对数组的泛化，可以通过 for...of 对其进行迭代。 迭代器是一种一次性使用的对象，用于迭代和它关联的可迭代对象。 Symbol.iterator可以通过为对象添加一个返回迭代器的 [Symbol.iterator] 方法来使得对象成为可迭代的 – 迭代器是指一个拥有 next() 方法的对象。 通过 for...of 对可迭代对象进行迭代时，for...of 希望获得下一个迭代值时就会调用迭代器对象的 next() 方法，next() 方法返回的对象必须是{ value: any: done: Boolean } 形式的值，当 done 为 true 时表示迭代结束，否则表示还可以迭代下一个值。 一般来说，迭代器对象和要迭代的对象是不同的，这样可以避免迭代时造成要迭代对象的属性变化。 1234567891011121314151617181920212223242526const range = { from: 1, to: 3, [Symbol.iterator]: function () { return { current: this.from, last: this.to, next() { if (this.current &lt;= this.last) { return { value: this.current++, done: false }; } else { return { value: undefined, done: true }; } } }; }};// for...of 希望获得下一个迭代值时就会调用迭代器对象的 next() 方法// next() 方法返回的对象必须是 { value: any: done: boolean } 形式的值for (const iterator of range) { console.log(iterator);}// 1// 2// 3 使用 for...of 循环对对象进行迭代时，它会寻找 [Symbol.iterator] 方法，如果没有找到则会报错。 12345678const range = { from: 1, to: 3,};for (const iterator of range) { // TypeError: range is not iterable console.log(iterator);} 如果需要在迭代过程中做更多的事情，我们可以通过显示调用迭代器来获得比 for...of 跟多的控制权 1234567891011121314151617181920212223242526const range = { from: 1, to: 3, [Symbol.iterator]: function () { return { current: this.from, last: this.to, next() { if (this.current &lt;= this.last) { return { value: this.current++, done: false }; } else { return { value: undefined, done: true }; } } }; }};const generatorObj = range[Symbol.iterator]();while(true) { const res = generatorObj.next(); if (res.done) break; console.log(res.value);} JavaScript 中的内建可迭代对象JavaScript 中很多内建对象都遵循了可迭代协议： 字符串 数组 映射(Map/WeakMap) 集合(Set/WeakSet) arguments 对象 NodeList 等 DOM 集合类型 数组和字符串数组和字符串是使用最广泛的内建可迭代对象。 123456789const string = 'Best wishes for the beautiful world.'for (let iterator of string) { console.log(iterator);}const arr = [ 'Best', 'wishes', 'for', 'the', 'beautiful', 'world' ];for (const iterator of arr) { console.log(iterator);} 类数组对象和可迭代对象JavaScript 中的类数组对象是指拥有 length 属性和索引的对象，但它不一定是可迭代的。 1234567const arrLikeObj = { length: 2, 0: '1', 1: '2'}for (const iterator of arrLikeObj) {} // TypeError: arrLikeObj is not iterable JavaScript 中的可迭代对象是指实现了 [Symbol.iterator] 方法的对象。 我们可以通过全局方法 Array.from 将类数组对象转变成真正的数组再进行迭代 123456789const arrLikeObj = { length: 2, 0: '1', 1: '2'}for (const iterator of Array.from(arrLikeObj)) { console.log(iterator);} 使用生成器进行迭代根据上文对生成器的介绍，很容易想到可以使用生成器函数来返回可迭代对象实现对象的迭代。 1234567891011121314151617const range = { from: 1, to: 3, [Symbol.iterator]: function* () { for (let value = this.from; value &lt;= this.to; value++) { yield value; } }};for (const iterator of range) { console.log(iterator);}// 1// 2// 3 提前终止迭代器可选的 return() 方法用于指定在迭代器提前关闭时执行的逻辑。执行迭代的结构在想让迭代器知道它不想遍历到可迭代对象耗尽时，就可以 “关闭” 迭代器。可能的情况包括： for...of 循环通过 break、continue、return 或 throw 提前退出 解构操作并未消费所有值","link":"/2019/06/11/JavaScript%20%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E7%94%9F%E6%88%90%E5%99%A8/"},{"title":"JavaScript 装饰器和转发","text":"装饰器模式 装饰器是一个特殊的函数，它接受一个函数作为参数，并改变它的行为。 它非常重要和普遍的一种应用就是缓存函数返回结果，节省重复计算的时间。 123456789101112function cacheDecorator(fun) { const cache = new Map(); return function(x) { // 如果命中缓存，则直接返回缓存中的计算好的值 if (cache.has(x)) return cache.get(x); // 如果没有命中缓存，则使用传入的函数重新计算结果 const result = fun(x); // 将新的结果进行缓存 cache.set(x, result); return result; }} call 和 apply 都允许显式地设置调用函数执行时的上下文（即 this 值），在作用上它们几乎相同。 不同的是 call 以参数列表的形式接收参数，而 apply 以类数组的形式接收参数。","link":"/2019/03/09/JavaScript%20%E8%A3%85%E9%A5%B0%E5%99%A8%E5%92%8C%E8%BD%AC%E5%8F%91/"},{"title":"JavaScript 高级程序设计 - 引用类型","text":"应用类型的值是应用类型的一个实例。在 ECMAScript 中，引用类型是一种数据结构，用于将数据和功能组织在一起，它也常被称为类 ，但这种称呼并不妥当。尽管 ECMAScript 从技术上讲是一门面向对象的语言，但它不具备传统的面向对象语言所支持的类和接口等基本结构。引用类型有时候也被称为对象定义，因为它们描述的是一类对象所具有的属性和方法。 Object 类型Object 是 ECMAScript 中使用最多的一个类型。虽然 Object 的实例不具备多少功能，但对于在应用程序中存储和传输数据而言，它们确实是非常理想的选择。 创建 Object 实例的两种方式 ： 使用 new 操作符 12var person = new Object();person.name = &quot;CocoaLei&quot;; 使用对象字面量 123var person = { name = &quot;CocoaLei&quot;}; 对象字面量是对象定义的一种简写形式 ，目的在于简化创建包含大量属性的对象的过程。 对象字面量也是向函数传递大量可选参数的首选方式。 一般来说，访问对象属性时使用的都是点语法，这也是很多面向对象语言中通用的语法。不过，在 JavaScript 中也可以使用方括号表示法来访问对象的属性。 1234567var person = { name = &quot;CocoaLei&quot;};console.log(person.name); // CocoaLeiconsole.log(person[&quot;name&quot;]); // CocoaLeivar propertyName = &quot;name&quot;;console.log(person[propertyName]); // CocoaLei 通常，除非必须使用变量来访问属性，否则建议使用点语法。 Array 类型Array 类型是出了 Object 之外 ECMAScript 中最常用的类型了。而且，ECMAScript 中的数组与其它语言中的数组有着相当大的区别。虽然 ECMAScript 数组与其它语言中的数组都是数据的有序列表，但与其它语言不通的是， ECMAScript 中的数组的每一项可以保存任何类型的数据。并且，ECMAScript 数组的大小是可以动态调整的，即可以随着数据的添加自动增长以容纳新增数据。 创建数组的两种方式 ： Array 构造函数 1var colors = new Array(); 如果预先知道数组要保存的项目数量，也可以给构造函数传递该数量，而改数量会自动编程 length 的值。 1var colors = new Array(255); 使用数组字面量 1var colors = [&quot;red&quot;, &quot;yellow&quot;, &quot;blue&quot;]; 在读取和设置数组的值时，要使用方括号并提供相应值的基于 0 的数字索引。 数组最多可以包含 4294967295 个项，这几乎已经能够满足任何编程需求了。如果想添加的项数超过这个上限值，就会发生异常。而创建一个初始大小与这个上限值接近的数组，则可能会导致运行时间超长的脚本错误。 检测数组如果假定只有一个全局执行环境，使用 instanceof 操作符就能检测值是不是数组。但是，实际上存在的全局环境不止一个，那么 Array 构造函数也不止一个。 为了解决这个问题，ECMAScript 5 新增了 Array.isArray() 方法。这个方法的母的是最终确定某个值到底是不是数组，而不管它在哪个全局执行环境中创建的。 1Array.isArray(value); 转换方法所有对象都具有 toLocalString() 、toString() 、 valueOf() 方法。调用数组的 toString() 方法会返回数组中每个值得字符串形式拼接而成的一个以逗号分隔的字符串。调用 valueOf() 方法返回的还是数组。 数组继承的 toLocalString() 、toString() 、valueOf() 方法，在默认情况下都会以逗号分隔的字符串的形式返回数组项。而如果使用 join() 方法，则可以使用不同的分隔符来构建这个字符串。join() 方法只接受一个参数，即用作分隔符的字符串，然后返回包含所有数组项的字符串。 如果数组中的某一项的值是 null 或 undefined , 那么该值在 toLocalString() 、toString() 、valueOf() 方法返回的结果中以空字符串表示。 栈方法ECMAScript 数组也提供了一种让数组的行为类似于其它数组结构的方法。具体来说，数组可以表现的像栈一样。 ECMAScript 专门为数组提供了push() 和 pop() 方法，以便实现类似栈的行为。 push() 方法可以接收任意数量的参数，把它们逐个添加到数组末尾，并返回修改后数组的长度。而 pop() 方法则从数组末尾移除最后一项，减少数组的 length 值，然后返回移除的项。 123var sampleArr = new Array();var arrLength = sampleArr.push(&quot;A&quot;,&quot;B&quot;); // arrLength is 2 and sampleArr is [&quot;A&quot;, &quot;B&quot;]var removedItem = sampleArr.pop(); // removedItem is &quot;B&quot; 队列方法栈数据结构的访问规则是后进先出，而队列数据结构的访问规则是先进先出。队列在列表的末端添加项，从列表的前端移除项。由于 push() 是向数组末端添加项的方法，因此要模拟队列只需一个从数组前端取得项的方法。实现这一操作的数组方法就是 shift() ，它能够移除数组中的第一个项并返回该项，同时将数组长度减 1 。结合使用 shift() 、push() 方法，就可以像使用队列一样使用数组。 123var sampleArr = new Array();sampleArr.push(&quot;A&quot;, &quot;B&quot;);var firstItem = sampleArr.shift(); // firstItem is &quot;A&quot; ECMAScript 还未数组提供了一个 unshift() 方法，它能在数组前端添加任意个项并返回新数组的长度。 重排序方法数组中已经存在两个可以直接用来重排序的方法 ：reverse() 和 sort() 。 数组的 reverse() 方法会反转数组的顺序 ： 12var originalArr = [3, 7, 1, -1, 22];originalArr.reverse(); // 22, -1, 1, 7, 3 在默认情况下，sort() 方法按升序排列数组。为了实现排序，sort() 方法会调用数组中每项的 toString() 方法，然后比较得到的字符串，以确定如何排序。这种排序方式在很多情况下都不是最佳方案。不过，sort() 方法可以接收一个比较函数作为参数，以便我们指定哪个值位于哪个值的前面。 12345678910// 升序function compare (value_1, value_2) { if (value_1 &lt; value_2) { return -1; } else if (value_1 &gt; value_2) { return 1; } else { return 0; }} reverse() 和 sort() 方法的返回值是经过排序后的数组。 对于数值类型或者其 valueOf() 方法会返回数值类型的对象类型，可以使用一个更简单的比较函数。这个函数只要用第二个值减第一个值即可。 123function compare (value_1, value_2) { return value_2 - value_1;} 由于比较函数通过返回一个小于零、等于零或大于零的结果来影响排序，因此减法操作就可以适当地处理所有这些情况。 操作方法ECMAScript 为操作已经包含在数组中的项提供了很多方法。 contact()contact() 方法可以基于当前数组的所有项创建一个新数组。具体来说，这个方法会先创建当前数组的一个副本，然后将接收到的参数添加到这个副本的末尾，最后返回新构建的数组。在没有给 contact() 方法传递参数的情况下，它只是复制当前数组并返回副本。如果传递给 contact() 方法的是一或多个数组，则该方法会将这些数组中的每一项都添加到结果数组中。如果传递的不是数组，这些值就会被简单地添加到结果数组的末尾。 123var sampleArr = nes Array();sampleArr.push(&quot;A&quot;, &quot;B&quot;);var copyArr = sampleArr.contact(&quot;C&quot;); // now sampleArr is [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;] slice()slice() 方法能够基于当前数组中的一个或多个项创建一个新数组。slice() 方法可以接受一个或两个参数，即要返回项的起始和结束位置。在只有一个参数的情况下，slice() 方法返回从该参数指定位置开始到当前数组末尾的所有项。如果有两个参数，该方法返回起始和结束位置之间的项（不包括结束位置）。 123var sampleArr = [1, 2, 3, 4, 5, 6, 7];var resultArr = sampleArr.slice(3); // resultArr is [4, 5, 6, 7]resultArr = sampleArr.slice(3,5); // resultArr is [4, 5] 如果 slice() 方法中有一个负数，则用数组长度加上该数来确定相应的位置。如果结束位置小于起始位置，则返回空数组。 splice()splice() 方法主要用途是向数组的中部插入项，但使用这种方法的方式则有如下三种 ： 删除 ：可以删除任意数量的项，只需指定要删除的第一项的位置和要删除的项数两个参数 12var sampleArr = [1, 2, 3, 4, 5, 6, 7];sampleArr.splice(5, 1); // sampleArr is [1, 2, 3, 4, 5, 6] 插入 ：可以向指定位置插入任意数量的项，只需提供起始位置、要删除的项数 (设为0) 和要插入的项 12var sampleArr = [1, 2, 3];sampleArr.splice(1, 0, 2.1, 2.2); // sampleArr is [1, 2, 2.1, 2.2, 3] 替换 ：可以向指定位置插入任意数量的项，同时删除任意数量的项 12var sampleArr = [1, 2, 3];sampleArr.splice(2, 1, 4); // sampleArr is [1, 2, 4] splice() 方法始终都会返回一个数组，该数组包含从原始数组中删除的项 (如果没有删除任何项，则返回一个空数组) 。 位置方法ECMAScript 5 为数组实例添加了两个位置方法 ：indexOf() 和 lastIndexOf() 。这两个方法都接收两个参数 ：要查找的项和表示查找七点位置的索引。其中，indexOf() 从数组的开头开始向后查找，lastIndexOf() 则是从数组的末尾开始向前查找。 这两个方法都返回要查找的项在数组中的位置，或者在没有找到的情况下返回 -1 。在比较第一个参数与数组中的每一项时，会使用全等操作符。 123var sampleArr = [1, 2, 3, 4, 5, 6, 5, 4, 3, 2, 1];sampleArr.indexOf(4); // 3sampleArr.lastIndexOf(4); // 7 迭代方法ECMAScript 5 为数组定义了 5 个迭代方法，每个方法都接收两个参数 ：要在每一项上运行的函数和运行该函数的作用域对象。传入这些方法中的函数会接收三个参数 ：数组项的值，该项在数组中的位置和数组对象的本身。 every() : 对数组中的每一项运行给定函数，如果该函数对每一项都返回 true ，则返回 true filter() ：对数组中的每一项运行给定函数，返回该函数会返回 true 的项组成的数组 forEach() ：对数组中的每一项运行给定函数，这个方法没有返回值 map() ：对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组 some() ：对数组中的每一项运行给定函数，如果该函数对任一项返回 true ，则返回 true 以上这些方法都不会修改数组中包含的值。 归并方法ECMAScript 5 增加了两个归并数组的方法 ：reduce() 和 reduceRight() 。这两个方法都会迭代数组所有的项，然后构建一个最终返回的值。其中，reduce() 方法从数组的第一项开始，逐个遍历到最后。而 reduceRight() 则从数组的最后一项开始，向前遍历到第一项。 这两个方法都接收两个参数 ：一个在每一项上调用的函数和作为归并基础的初始值。传给 reduce() 和 reduceRight() 的函数接收 4 个参数 ：前一个值、当前值、项的索引和数组对象。这个函数返回的任何值都会作为第一个参数自动传给下一项。第一次迭代发生在数组的第二项上，因此第一个参数是数组的第一项，第二个参数是数组的第二项。 求数组中所有值之和 ： 1234var sampleArr = [1, 2, 3, 4, 5];var sum = sampleArr.reduce(function(prev, cur, index, array) { return prev + cur;}); // sum is 15 Date 类型ECMAScript 中的 Date 类型是在早期 Java 中的 java.util.Date 类基础上构建的。为此，Date 类型使用 UTC 1970 年 1 月 1 日午夜开始经过的毫秒数来保存日期。这使用这种数据存储格式的条件下，Date 类型保存的日期能够精确到 1970 年 1 月 1 日之前或之后的 285616 年。 在调用 Date 构造函数而不传递参数的情况下，新创建的对象自动获得当前的日期和时间。如果想根据特定的日期和时间创建日期对象，必须传入表示该日期的毫秒数。为了简化这一计算过程，ECMAScript 提供了两个方法 ： Date.parse() 和 Date.UTC() 。 其中，Date.parse() 方法接收一个表示日期的字符串参数，然后尝试根据这个字符串返回相应日期的毫秒数。ECMA 没有定义 Date.parse() 应该支持哪种日期格式，因此这个方法的行为因实现而异。 Date.UTC() 方法同样也返回表示日期的毫秒数，但它与 Date.parse() 在构建值时使用不同的信息。Date.UTC() 的参数分别是年份、基于 0 的月份、月中的哪一天、小时数、分钟、秒以及毫秒数。在这些参数中，只有前两个参数是必需的。 Date.now() 方法会返回表示调用这个方法时的日期和时间的毫秒数。 继承的方法与其它引用类型一样，Date 类型也重写了 toLocalString() 、toString() 和 valueOf() 方法 。Date 类型的 toLocalString() 方法会按照与浏览器设置的地区相适应的格式返回日期和时间。而 toString() 方法则通常返回带有时区信息的日期和时间。Date 类型的 valueOf() 方法，则根本不返回字符串，而是返回日期的毫秒表示，常用来比较日期值的大小。 12345var date_pre = new Date(2017, 0, 1);var date_next = new Date(2017, 1, 1);if (date_pre &lt; date_next) { consolo.log(&quot;&quot;);} 日期格式化方法Date 类型用于将日期格式化为字符串的方法 ： toDateString() ：以特定于实现的格式显示星期几、月、日和年 toTimeString() ：以特定于实现的格式显示时、分、秒和时区 toLocalDateString() ：以特定于地区的格式显示星期几、月、日和年 toLocalTimeString() ：以特定于实现的格式显示时、分、秒 toUTCString() ：以特定于实现的格式显示完整的 UTC 日期 RegExp 类型ECMAScript 通过 RegExp 类型来支持正则表达式 ： 1var expression = /pattern/flags; 其中的模式部分可以是任何简单或复杂的正则表达式，可以包含字符类、限定符、分组、向前查找以及反向引用。每个正则表达式都可以带有一或多个标志，用以表明正则表达式的行为。 正则表达式的匹配模式下支持下列 3 个标志 ： g ：全局模式，即模式将被应用于所有字符串，而非在发现第一个匹配项时立即停止 i ：不区分大小写模式，即在确定匹配项时忽略模式与字符串的大小写 m ：多行模式，即在到达一行文本末尾时还会继续查找下一行中是否在与模式匹配的项 模式中使用的所有元字符都必须转义。正则表达式中的元字符包括 ： 1( [ { \\ ^ $ | ) ? * + . ] } 这些元字符在正则表达式中都有一或多种特殊用途，因此如果想要匹配字符串中包含的这些字符，就必须对它们进行转义。 使用 RegExp 构造函数构造正则表达式时，需要注意 ：传递的两个参数都是字符串。由于 RegExp 的构造函数的模式参数是字符串，所以在某些情况下要对字符进行双重转义。所有元字符都必须双重转义，那些已经转义过的字符也是如此。 123字面量模式 等价的字符串/\\[bc\\]at/ “\\\\[bc\\\\]at”/\\w\\\\hello\\\\123/ &quot;\\\\w\\\\\\\\heollo\\\\\\\\123&quot; 使用正则表达式字面量和使用 RegExp 构造函数创建的正则表达式不一样。在 ECMAScript 3 中，正则表达式字面量始终会共享同一个 RegExp 实例，而使用构造函数创建的每一个新 RegExp 实例都是新实例。 ECMAScript 5 明确规定，使用正则表达式字面量必须像直接调用 RegExp 构造函数一样，每次赌创建新的 RegExp 实例。 RegExp 实例属性RegExp 的每个实例都具有下列属性 ： global ：布尔值，表示是否设置了 g 标志 ignoreCase ：布尔值，表示是否设置了 i 标志 lastIndex ：整数，表示开始搜索下一个匹配项的字符位置，从 0 算起 multiline ：布尔值，表示是否设置了 m 标志 source ：正则表达式的字符串表示，按照字面量模式而非传入构造函数中的字符串模式返回 RegExp 实例方法RegExp 对象的主要方法是 exec() ，该方法是专门为捕获组而设计的。 exec() 接受一个参数，即要应用模式的字符串，然后返回包含第一个匹配项信息的数组或者在没有匹配项的情况下返回 null 。返回的数组虽然是 Array 的实例，但包含两个额外的属性 ：index 和 input 。其中 index 表示匹配项在字符串的位置，而 input 表示应用正则表达式的字符串。在数组中，第一项是与整个模式匹配的字符串，其它项是与模式中单的捕获组匹配的字符串。 对于 exec() 方法而言，即使在模式中设置了全局标志，它每次也只会返回一个匹配项。在不设置全局标志的情况下，在同一个字符串上多次调用 exec() 将始终返回第一个匹配项的信息。而在设置全局标志的情况下，每次调用 exec() 则都会在字符串中继续查找新匹配项。 正则表达式的第二个方法是 test() ，它接受一个字符串参数。在模式与该参数匹配的情况下返回 true ；否则返回 false 。在只想知道目标字符串与某个模式是否匹配，但不需要知道其文本内容的情况下，使用这个方法","link":"/2017/05/24/JavaScript-%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1---%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/"},{"title":"JavaScript 数据类型","text":"ECMAScript 有 6 种简单数据类型（也称为原始类型）：Undefined、Null、Boolean、Number、 String 和 Symbol。还有一种复杂数据类型叫 Object（对 象）。Object 是一种无序名值对的集合。 Undefined 和 NullUndefined 类型只有一个值 undefined，当使用 let 或 var 声明变量单并没有初始化时，就相当于给变量赋予了 undefined 值。 一般来说不建议显式的给变量赋值 undefined，字面值 undefined 主要是用来比较。 12345let v1;var v2;console.log(v1); // undefinedconsole.log(v2); // undefinedconsole.log(v1 === v2); // true 增加这个特殊值的目的就是为了正式明确空对象指针 null 和未初始化变量的区别。 undefined 值是由 null 值派生而来的，因此 ECMA-262 将它们定义为表面上相等，如下所示： 12console.log(null === undefined); // falseconsole.log(null == undefined); // true Null 类型同样只有一个值，即特殊值 null。逻辑上讲，null 值表示一个空对象指针，这也是给 typeof 传一个 null 会返回 “object” 的原因。 12let v3 = null;console.log(typeof v3); // &quot;object&quot; 在定义将来要保存对象值的变量时，建议使用 null 来初始化，不要使用其他值。这样，只要检查这个变量的值是不是 null 就可以知道这个变量是否在后来被重新赋予了一个对象的引用。 undefined 和 null 都是假值，如果只是为了检测假值，可以方便的检测它们；如果是明确的想要检测 undefined 或 null，则需要显式的对其进行判断。 123456let v4;let o1 = null;console.log(!v4); // trueconsole.log(v4 === undefined); // trueconsole.log(!o1); // trueconsole.log(o1 === null); // true BooleanBoolean 类型是使用非常频繁的数据类型，它有两个值 true 和 false (布尔值字面量是区分大小写的)。 这两个布尔值并不等同于数值： 1234let t1 = true;let f1 = false;console.log(t1 === 1); // falseconsole.log(f1 === 0); // false 虽然布尔值只有两个，但所有其他 ECMAScript 类型的值都有相应布尔值的等价形式。要将一个其他类型的值转换为布尔值，可以调用特定的 Boolean() 转型函数。 1234567891011console.log(Boolean(true)); // trueconsole.log(Boolean(false)); // falseconsole.log(Boolean('true')); // trueconsole.log(Boolean('false')); // trueconsole.log(Boolean(0)); // falseconsole.log(Boolean(-0)); // falseconsole.log(Boolean(NaN)); // falseconsole.log(Boolean(1)); // trueconsole.log(Boolean(-1)); // trueconsole.log(Boolean('')); // falseconsole.log(Boolean(' ')); // true NumberNumber 类型使用 IEEE 754 格式表示整 数和浮点值（在某些语言中也叫双精度值）。不同的数值类型相应地也有不同的数值字面量格式。 整数可以用八进制、十进制和十六进制字面量表示，但是使用八进制和十六进制格式创建的数值在所有数学操作中都被视为十进制数值。 123456let octalNum = 077;let hexNum = 0xff;console.log(octalNum); // 63console.log(hexNum); // 255let sum = octalNum + hexNum;console.log(sum); // 318 浮点值要定义浮点值，数值中必须包含小数点，而且小数点后面必须至少有一个数字。虽然小数点前面不是必须有整数，但推荐加上。 12let float1 = 1.01;let float2 = .01; 因为存储浮点值使用的内存空间是存储整数值的两倍，所以 ECMAScript 总是想方设法把值转换为 整数。在小数点后面没有数字的情况下，数值就会变成整数。类似地，如果数值本身就是整数，只是小 数点后面跟着 0（如 1.0），那它也会被转换为整数。 对于非常大或非常小的数值，浮点值可以用科学记数法来表示。科学记数法用于表示一个应该乘以 10 的给定次幂的数值。ECMAScript 中科学记数法的格式要求是一个数值（整数或浮点数）后跟一个大 写或小写的字母 e，再加上一个要乘的 10 的多少次幂 1234let float3 = 2.23e9;console.log(float3); //2230000000let float4 = 1.01e-5;console.log(float4); // 0.0000101 浮点值的精确度最高可达 17 位小数，但在算术计算中远不如整数精确。例如，0.1 加 0.2 得到的不 是 0.3，而是 0.300 000 000 000 000 04。由于这种微小的舍入错误，导致很难测试特定的浮点值。 123let float5 = 0.1;let float6 = 0.2;console.log(float5 + float6); // 0.30000000000000004 之所以存在这种舍入错误，是因为使用了 IEEE 754 数值，这种错误并非 ECMAScript 所独有。其他使用相同格式的语言也有这个问题。 因此永远不要测试某个特定的浮点值。 使用最小精度值来比较浮点数： 1console.log( Math.abs(0.1 + 0.2 - 0.3) &lt;= Number.EPSILON); 值的范围ECMAScript 可以表示的最小 数值保存在 Number.MIN_VALUE 中，这个值在多数浏览器中是 5e-324；可以表示的最大数值保存在 Number.MAX_VALUE 中，这个值在多数浏览器中是 1.7976931348623157e+308。如果某个计算得到的数值结果超出了 JavaScript 可以表示的范围，那么这个数值会被自动转换为一个特殊的 Infinity（无 穷）值。任何无法表示的负数以 -Infinity（负无穷大）表示，任何无法表示的正数以 Infinity（正 无穷大）表示。 12console.log(Number.MIN_VALUE); // 5e-234console.log(Number.MAX_VALUE); // 1.7976931348623157e+308 如果计算返回正 Infinity 或负 Infinity ， 则该值将不能再进一步用于任何计算。 这是因为 Infinity 没有可用于计算的数值表示形式。要确定一个值是不是有限大（即介于 JavaScript 能表示的最小值和最大值之间），可以使用 isFinite() 函数。 1234let num1 = 6e-325;let num2 = 1.8e308;console.log(Number.isFinite(num1)); // falseconsole.log(Number.isFinite(num2)); // false Number.NEGATIVE_INFINITY 和 Number.POSITIVE_INFINITY 也可以获取正、负 Infinity。没错，这两个属性包含的值分别就是 -Infinity 和 Infinity。 NaN有一个特殊的数值叫 NaN，意思是 “不是数值”（Not a Number），用于表示本来要返回数值的操作 失败了（而不是抛出错误）。比如，用 0 除任意数值在其他语言中通常都会导致错误，从而中止代码执 行。但在 ECMAScript 中，0、+0 或-0 相除会返回 NaN。 1234console.log(Number.parseFloat('f1.f')); // NaNconsole.log(1/0); // Infinityconsole.log(0/1); // 0console.log(0/0); // NaN NaN 有几个独特的属性。首先，任何涉及 NaN 的操作始终返回 NaN（如 NaN/10），在连续多步计算 时这可能是个问题。其次，NaN 不等于包括 NaN 在内的任何值。 12console.log(0/0 === NaN); // falseconsole.log(NaN === NaN); // false 要判断一个值是不是 NaN， 可以使用 isNaN() 函数。 12console.log(Number.isNaN(0/0)); // trueconsole.log(Number.isNaN(true)); // false 数值转换JavaScript 中提供了 Number()，parseInt()，parseFloat() 三个方法用来将非数值转换为数值。 Number12345678console.log(Number(true)); // 1console.log(Number(false)); // 0console.log(Number(1000)); // 1000console.log(Number(null)); // 0console.log(Number(undefined)); // NaNconsole.log(Number('12')); // 12console.log(Number(' 12')); // 12console.log(Number('12-')); // NaN parseInt()parseInt() 函数更专注于字符串是否包含数值模式。字符串最前面的空格会被忽略，从第一个非空格字符开始转换。如果第一个字符不是数值字符、加号或减号，parseInt() 立即 返回 NaN。这意味着空字符串也会返回 NaN（这一点跟 Number() 不一样，它返回 0）。如果第一个字符 是数值字符、加号或减号，则继续依次检测每个字符，直到字符串末尾，或碰到非数值字符。 123456console.log(parseInt(100)); // 100console.log(parseInt('1000')); // 1000console.log(parseInt('1000lll')); // 1000console.log(parseInt(' 1000')); // 1000console.log(parseInt('001000')); // 1000console.log(parseInt('a 1000')); // NaN parseInt() 也接收第二个参数，用于指定底数（进制数）。 12console.log(parseInt('077', 8)); // 63console.log(parseInt('0xff', 16)); // 255 不传底数参数相当于让 parseInt() 自己决定如何解析，所以为避免解析出错，建议始终传给 它第二个参数。 parseFloat()parseFloat() 函数的工作方式跟 parseInt() 函数类似，都是从位置 0 开始检测每个字符。同样， 它也是解析到字符串末尾或者解析到一个无效的浮点数值字符为止。这意味着第一次出现的小数点是有效的，但第二次出现的小数点就无效了，此时字符串的剩余字符都会被忽略。 1234567console.log(parseFloat('-1.01')); // -1.01console.log(parseFloat('1.01')); // 1.01console.log(parseFloat('1.01.01')); // 1.01console.log(parseFloat(' 1.01')); // 1.01console.log(parseFloat('a1.01')); // NaNconsole.log(parseFloat('1.01a')); // 1.01console.log(parseFloat('00001.01a')); // 1.01 StringString（字符串）数据类型表示零或多个 16 位 Unicode 字符序列。 ECMAScript 中的字符串是不可变的（immutable），意思是一旦创建，它们的值就不能变了。要修改某个变量中的字符串值，必须先销毁原始的字符串，然后将包含新值的另一个字符串保存到该变量。 把值转换为字符串使用 toString() 方法null 和 undefined 没有 toString() 方法。 123456789101112let val1 = 12;let val2= '12';let val3 = [1,2];let val4 = new Date();let val5 = {};// 12 12 1,2 Fri Dec 25 2020 13:48:14 GMT+0800 (China Standard Time) [object Object]console.log(val1.toString(), val2.toString(), val3.toString(), val4.toString(), val5.toString());null.toString(); // Uncaught TypeError: Cannot read property 'toString' of undefinedundefined.toString(); // Uncaught TypeError: Cannot read property 'toString' of null 在对数字类型值调用 toString() 方法时，可传递一个参数指定以什么底数输出数值的字符串表示。 123456let numVal = 123;console.log(numVal.toString(2)); // 1111011console.log(numVal.toString(8)); // 173console.log(numVal.toString(10)); // 123console.log(numVal.toString(16)); // 7b 使用 String()在使用 String() 将值转换为字符串时，如果值有 toString() 方法，则直接调用 toString() 方法并返回结果。对于没有 toString() 方法的 null 和 undefined ，则会分别返回 “null” 和 “undefiend”。 12console.log(String(null));console.log(String(undefined)); SymbolSymbol（符号）是 ECMAScript 6 新增的数据类型。符号是原始值，且符号实例是唯一、不可变的。 符号的用途是确保对象属性使用唯一标识符，不会发生属性冲突的危险。 尽管听起来跟私有属性有点类似，但符号并不是为了提供私有属性的行为才增加的。相反，符号就是用来创建唯一记号，进而用作非字符串形式的对象属性。 1234let s1 = Symbol();let s2 = Symbol('s2');console.log(s1);console.log(s2); ObjectECMAScript 中的对象其实就是一组数据和功能的集合。对象通过 new 操作符后跟对象类型的名称 来创建。","link":"/2019/06/25/JavaScrtip%20%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"title":"Object Oriented Programming","text":"面向对象编程 (Object Oriented Programming)面向对象编程是一种基于 对象 概念的编程范例，对象可以以字段的形式包含数据(通常被称为属性)，以程序的形式包含代码(通常被称为方法)。 对象的一个特点就是它的方法可以访问和修改与之关联的对象的数据字段。在面向对象编程中，计算机程序被设计为由能够互相交互的对象们组成。面向对象编程语言是多种多样，最受欢迎的是基于类(Class)的那些。 面向对象编程的特征通常，面向对象编程被理解为一种将程序分解为封装数据及相关操作的模块的编程范例。它的特征如下： 类与对象 支持面向对象编程的语言通常使用继承类来达到代码重用或可扩展性。 类 ：定义了事物的抽象特点 对象 ：类的实例 动态配置( dynamic dispatch )与消息传递机制 对象的任务是通过选择执行合适的程序代码响应方法调用，通常这种选择是在运行时查找与对象关联的表中的方法来实现的。这被称之为动态分配，它将对象与抽象数据类型(或模块)区分开来，后者具有所有实例的操作静态实现。 方法调用也被称之为消息传递。它被概念化为传递给对象进行分配的消息(即方法的名称和输入的参数)。 封装 封装是面向对象编程的一个概念，它将数据和对数据的操作绑定在一起，并保护它们免受外部的干扰和误用(仅让允许的类和对象进行访问)。数据封装引入了重要的面向对象编程数据隐藏概念。 如果一个类不允许调用代码直接访问对象内部的数据，而只允许通过它提供的方法进行访问，这种强大的抽象或信息隐藏被称之为封装。 具备封装性的面向对象编程隐藏了某一方法对的具体执行过程，取而代之的是通过消息传递机制传递消息给它。 继承 几乎所有支持类的语言都支持继承。继承使得类能够以层级结构表示 is-a-type-of 的关系。父类的所有数据和方法都能被子类以同样的名字所继承，这使得相同的代码和数据复用变得更加简单，而且还是镜像真实世界关系的一种直观方式。 子类可以重写父类定义的方法。在一些语言中存在多重继承，这可能会造成重写冲突。 抽象类不能实例化为对象，它们的存在只是为了可以被继承到其它可以被实例化的具体类中。 继承的过程就是一个从一般到特殊的过程。 多态 多态是指有继承产生的相关但不同的类，对统一消息会做出不同的响应。它能极大减少类型之间的耦合。 抽象 JavaScript 与面向对象编程JavaScript 的核心是支持面向对象的，同时它也提供了强大灵活的 OOP 语言能力。 命名空间命名空间是一个容器，它允许开发人员在一个独特的、特定于应用程序的名称下捆绑所有功能。在 JavaScript 中，命名空间是一个包含方法、属性和对象的对象，它和普通对象在语言层面上并无差别。 使用命名空间可以最大程度上减少应用程序名称冲突的可能性。 自定义对象类JavaScript 是基于原型的语言，并没有声明类的语句。它使用函数做类，定义一个类和定义一个函数相同。 123function Person() {}// orlet Person = function() {} 对象对象是类的实例。 1234function Person() {}// 创建为初始化的实例let person1 = new Person();let person2 = Object.create(Person) 构造器构造器在实例化时被调用，它是对象中的一个方法，常用于给对象的属性赋值或者为调用函数做准备。在 JavaScript 中函数就可以作为构造器使用，因此不需要特别地定义一个构造器方法，每个声明的函数都可以在实例化后被调用执行。 属性属性就是类中包含的变量。每一个对象实例有若干个属性. 为了正确的继承，属性应该被定义在类的原型属性 (函数)中。 可以使用 this 关键字调用类的属性，它是对当前对象的引用。 12345function Person(name) { this.name = name;}let person = new Person('Li Lei'); 方法在JavaScript中方法通常是一个绑定到对象中的普通函数, 这意味着方法可以在其所在上下文之外被调用。 1234567function Person(name) { this.name = name;}Person.prototype.sayHello = function() { console.log('My name is ' + this.anme);} 在方法调用的过程中，this 的值取决于我们如何调用方法。可以通过 Function#call 或 Funcation#apply 显式的指定 this 的值。 继承在 Javascript 中，继承通过赋予子类一个父类的实例并专门化子类来实现。在现代浏览器中你可以使用 Object.create() 实现继承。 12345678function Person() {}function Student() { Person.call(this);}Student.prototype = Object.create(Person.prototype);Student.prototype.constructor = Student; 封装类的实例调用存在于类中的方法时，并不清楚它是如何实现并运行的，这就是封装。 抽象抽象是允许模拟工作问题中通用部分的一种机制。这可以通过继承（具体化）或组合来实现。JavaScript通过继承实现具体化，通过让类的实例是其他对象的属性值来实现组合。 多态就像所有定义在原型属性内部的方法和属性一样，不同的类可以定义具有相同名称的方法;方法是作用于所在的类中。并且这仅在两个类不是父子关系时成立（继承链中，一个类不是继承自其他类）。","link":"/2018/03/13/ObjectOrientedProgramming/"},{"title":"Reflow and Redraw","text":"回流和重绘以及性能的优化在解释回流和重绘的概念之前，我们首先需要知道两个概念：DOM 和 CSSOM。 DOM (Document Object Model) 文档对象模型 DOM 是 HTML 和 XML 文档的编程接口，它提供了对文档的结构化表述，并使得开发人员能够从程序中访问它，改变文档的结构、样式和内容。DOM 将文档解析为一个由节点和对象（包含属性和方法的对象）组成的结构集合。 CSSOM (CSS Object Model) CSS对象模型 CSSOM 是一组允许 JavaScript 操作 CSS 的 API，非常类似于 DOM，它允许用户动态的修改 CSS 样式。 DOM 和 CSSOM 构建浏览器渲染页面时会构建 DOM 和 CSSOM 树，这个过程可简化如下： 转换 - 浏览器从磁盘或网络读取 HTML 的原始字节，并按照其指定的编码方式将其解析为字符 符号化(令牌化) - 浏览器将字符串转换为 HTML 标准规定的各种具有特殊含义和规则的令牌 词法分析- 将令牌转换为定义了其规则和属性的对象 DOM构建 - HTML 标记定义了不同的标记之间的关系，根据标签创建的对象在结构树中根据由原始标记定义的父子关系相互连接。 整个过程最后形成一个文档对象结构模型，即 DOM。CSSOM 的构建与 DOM 的构建非常类似，不再重复。 渲染树的构建最后 CSSOM 和 DOM 会结合形成渲染树。渲染树用来计算每个可见元素的布局，并在绘制到屏幕的过程中作为输出，简化后的过程如下： 从 DOM 树的根节点开始，遍历每个可见的节点 有些节点是不可见的（比如 &lt;script&gt; 标签、&lt;meta&gt; 标签 等），这些节点会被忽略， 因为它们并不影响渲染的输出 一些节点通过 CSS 被隐藏了，它们也会被忽略 为每一个可见的节点找到匹配的 CSSOM 规则并在节点上应用这些规则 将节点连同内容和计算好的样式发送出去 渲染树构建完成后，即进入 “布局” 阶段。 布局在渲染树中我们已经计算好了哪个节点应该被显示和它们的计算样式，但是对于它们在设备的视口中的精确位置和大小还没有进行计算，对其进行计算就是 ”布局“，也被称为 回流。 为了计算页面中每个对象的精确位置和大小，浏览器从渲染树的根节点开始遍历。 布局过程的输出是一个“盒子模型”，它精确地捕获视口中每个元素的确切位置和大小：所有相对测量值都转换为屏幕上的绝对像素。 绘制布局完成后，我们已经知道了节点的可见性、计算样式和几何结构，浏览器将会把渲染树中的每个节点转换为屏幕上的实际像素。这个步骤通常被称为 ”绘制“ 或 ”栅格化“； 由于浏览器需要进行大量的工作进行绘制，这个阶段可能会花费一些时间。 回流当渲染树中部分或全部元素的尺寸、结构、或某些属性发生改变时，浏览器重新渲染部分或全部文档的过程称为回流。 可能会引起回流的操作如下 页面首次渲染 浏览器窗口大小发生改变 元素尺寸或位置发生改变 元素内容发生改变 元素字体大小发生变化 添加或删除可见的 DOM 元素 激活 CSS 伪类 查询某些属性或调用某些方法 常用且可能导致回流的属性和方法 clientWidth , clientHeight, clientTop, clientLeft offsetWidth, offsetHeight, offsetTop, offsetLeft scrollWidth, scrollHeight, scrollTop, scrollLeft scrollIntoView(), scrollIntoViewIfNeeded() getComputedStyle() getBoundingClientReact() scrollTo() 重绘当页面中元素样式的改变并不影响它在文档流中的位置时（例如：color、background-color、visibility等），浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘。 性能影响回流比重绘的代价要高的多。有时候仅仅回流一个单一的元素，它的父元素及任何与它相关的元素都会产生回流。 浏览器会对频繁的回流或重绘操作进行优化： 浏览器会维护一个队列，把所有引起回流和重绘的操作放入队列中，如果队列中的任务数量或者时间间隔达到一个阈值的时候，浏览器就会将队列清空，进行一次批处理，这样可以把多次回流和重绘变成一次。 当你访问下列属性是，浏览器会立刻清空队列： clientWidth , clientHeight, clientTop, clientLeft offsetWidth, offsetHeight, offsetTop, offsetLeft scrollWidth, scrollHeight, scrollTop, scrollLeft width, height getComputedStyle() getBoundingClientRect() 因为队列中可能会有影响到这些属性或方法返回值的操作，即使你希望获取的信息与队列中操作引发的改变无关，浏览器也会强行清空队列，确保你拿到的值是最精确的。 如何避免回流CSS 避免使用table布局。 尽可能在DOM树的最末端改变class。 避免设置多层内联样式。 将动画效果应用到position属性为absolute或fixed的元素上。 避免使用CSS表达式（例如：calc()）。 JavaScript 避免频繁操作样式，最好一次性重写style属性，或者将样式列表定义为class并一次性更改class属性。 避免频繁操作DOM，创建一个documentFragment，在它上面应用所有DOM操作，最后再把它添加到文档中。 也可以先为元素设置display: none，操作结束后再把它显示出来。因为在display属性为none的元素上进行的DOM操作不会引发回流和重绘。 避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。 对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。","link":"/2018/04/02/ReflowAndRedraw/"},{"title":"服务端渲染","text":"服务器端渲染什么是服务器端渲染？将组件或页面在服务器端渲染为 HTML 字符串，直接发送到浏览器，最后将这些静态标记激活为客户端上完全可交互的应用程序。 为什么使用服务器端渲染？SSR 的主要优势 更好的 SEO 搜索引擎爬虫工具可以直接查看完全渲染的页面 更快的内容达到时间 无需等待所有的 JavaScript 都完成下载并执行 需要权衡的地方 浏览器特定的代码，只能在某些生命周期钩子函数中使用 涉及构建设置和部署的更多要求 服务器渲染应用程序，需要处于 Node.js server 环境 更多的服务器端负载","link":"/2018/07/11/ServeSideRender/"},{"title":"TCP&#x2F;IP 协议族","text":"TCP/IP 协议族TCP/IP 协议不是 TCP 和 IP 这两个协议的合称，而是指因特网整个 TCP/IP 协议族。 参考模型TCP/IP 参考模型TCP/IP 参考模型是首先由 ARPANET 所使用的网络体系结构。这个体系结构在它的两个主要协议出现以后被称为 TCP/IP 参考模型。这一网络协议一般分为四层： 网络访问层/链路层，用来处理连接网络的硬件部分。 互联网层/网络层用来处理在网络上流动的数据包，是整个体系结构的关键部分，其功能是使主机可以把分组发往任何网络，并使分组独立地传向目标。这些分组可能经过不同的网络，到达的顺序和发送的顺序也可能不同。高层如果需要顺序收发，那就必须自行处理对分组的排序。互联网层使用因特网协议(IP)。 传输层为处于网络连接中的计算机之间的通信提供数据传输服务。在这一层定义了两个端到端的协议：传输控制协议(TCP)和用户数据报协议(UDP)。 TCP 是面向连接的协议，它提供可靠的报文传输和对上层应用的连接服务。为此，除了基本的数据传输外，它还有可靠性保证、流量控制、多路复用、优先权和安全性控制等功能。 UDP 是面向无连接的不可靠传输协议，主要用于不需要 TCP 的排序和流量控制等功能的应用程序。 应用层包含所有的高层协议，包括：虚拟终端协议(TELNET)、文件传输协议(FPT)、电子邮件传输协议(SMTP)、域名服务(DNS,)、网上新闻传输协议(NNTP)和超文本传输协议(HTTP)，这些协议为应用提供对应的通信服务。 TELNET 是远程登录服务的标准协议和主要方式，为用户提供了在本地计算机上完成远程主机工作的能力。 FTP 是用于在网络上进行文件传输的一套标准协议。 SMTP 是一个提供可靠且有效的电子邮件传输的协议，它建立在 FTP 服务之上，主要用于完成系统之间的邮件信息传递，并提供有关来信的通知。 DNS 主要用于域名和 IP 之间的相互转换，是一种分布式网络目录服务。 NNTP 用于新闻的发布、检索和获取。 HTTP 是一个基于 TCP 协议的用于客户端和服务端通信的 请求-响应 协议。 OSI 参考模型OSI 参考模型是国际标准化组织指定的一个用于计算机或通信系统之间互联的标准体系。 物理层 - 通过物理媒体传输原始字节流 链路层 - 定义网络上数据的格式 网络层 - 决定数据通过哪条物理路径进行传输 传输层 - 通过传输协议传输数据 会话层 - 维护链接并负责控制端口和会话 展示层 - 保证数据的格式时可用并加密的 应用层 - 计算机交互层，在这里应用可以访问网络服务 TCP/IP 特点 TCP/IP 协议不依赖于任何特定的计算机硬件或操作系统，提供开放的协议标准。 TCP/IP 并不依赖于特定的网络传输硬件，所以 TCP/IP 协议能够集成各种各样的网络。 统一的网络地址分配方案，使整个 TCP/IP 设备在网中都有唯一的地址。 标准化的高层协议，可以提供多种可靠的服务。 TCP/IP 通信传输流利用 TCP/IP 协议族进行网络通信时， 会通过分层顺序与对方进行通信。发送端从应用层往下走，接收端则往应用层往上走。 发送端在层与层之间传输数据时，每经过一层时必定会被打上一个 该层所属的首部信息。反之，接收端在层与层传输数据时，每经过一层 时会把对应的首部消去。 这种把数据信息包装起来的做法称为封装。 IP 协议IP 协议位于 TCP/IP 参考模型中的网络层，是整个 TCP/IP 协议族的核心，也是构成互联网的基础。它的主要内容包括： IP 编址方案 分组封装格式 分组转发规则 TCP 协议TCP 协议位于参考模型中的传输层，是一种面向连接的、可靠的、基于字节流的传输层通信协议。当应用层向传输层发送用于网间传输的、用8位字节表示的数据流，TCP 则把数据流分割成适当长度的报文段( segment )，最大传输段大小通常受该计算机连接的网络的数据链路层的最大传送单元( MTU )限制。之后TCP把数据包传给IP层，由它来通过网络将包传送给接收端实体的TCP层。 为了准确无误地将数据送达目标处，TCP 协议采用了三次握手策略来建立连接： 发送端首先向接收端发送一个带有 SYN 标志的数据包 接收端接收到带有 SYN 标志的数据包后，返回带有 ACK/SYN 标志的数据包 发送端在接收到接收端回传的带有 ACK/SYN 标志的数据包后，发送带有 ACK 标志的数据包表示握手结束 连接建立后，就可以开始传输数据了。 TCP 连接其实是接收端和客户端保存的一份关于对方的信息，如果 IP 地址、端口号等。 同样的，在断开连接时，TCP 会采用四次挥手策略来保证接数据发送安全和完整： 当发送端的数据都传输完成后，发送端会向接收端发送连接释放报文 FIN。需要注意的是发送端发送 FIN 报文后，只是不能发送数据了，但是能正常接收数据的。 接收端收到发送端的 FIN 报文后，回复包含 ACK 标志的确认报文，此时接收端处于等待关闭状态，而不是马上给发送端发送 FIN 报文，因为可能还有数据没有发送完成。 接收端的数据发送完成后，发送带有 ACK 和 FIN 标志的连接释放报文给发送端。 发送端收到接收端的 FIN 报文后，向接收端发送 ACK 报文。此时接收端并不是立刻释放 TCP 连接，而是等待 2MSL( 最大报文段寿命的两倍时长 )后才释放连接。但是接收端一旦收到发送端的 ACK 报文后就会立马释放连接。 TCP 和 UDPTCP 是面向连接的传输控制协议，而 UDP 提供了无连接的数据报服务； TCP 具有高可靠性，确保传输数据的正确性，不出现丢失或乱序；UDP 在传输数据前不建立连接，不对数据报进行检查与修改，无须等待对方的应答，所以会出现分组丢失、重复、乱序，应用程序需要负责传输可靠性方面的所有工作； UDP 具有较好的实时性，工作效率较 TCP 协议高； UDP 段结构比 TCP 的段结构简单，因此网络开销也小。 TCP 协议可以保证接收端毫无差错地接收到发送端发出的字节流，为应用程序提供可靠的通信服务。对可靠性要求高的通信系统往往使用 TCP 传输数据。比如 HTTP 运用 TCP 进行数据的传输。","link":"/2016/01/04/TCP&IP/"},{"title":"Vue 3 原理解析 - 数据侦测原理","text":"Vue 3 原理解析 - 数据侦测原理Vue 2.x 及之前的版本中实现数据的可响应，需要对 Object 和 Array 分别进行处理： Object 类型通过 Object.definePropery 把属性转换成 getter/setter ，这个过程需要递归侦测所有的对象 key 来实现深度侦测 Array 类型通过对改变数组自身的几个方法进行拦截来实现对数组的可响应 而在 Vue3 中则是通过 Proxy 实现数据读取和设置拦截，在捕捉器中实现数据依赖收集和触发视图更新的操作。 ProxyProxy 是 ES6 中新引入的特性。 Proxy 正如其含字面意义 - “代理” 所表明的那样，它是对象与对象之间的一层代理，程序可以通过 Proxy 来访问或操作目标对象，进而可以实现基本操作的拦截和自定义。 基本语法如下： 1const proxy = new Proxy(target, handler); 参数： target 要代理的原始对象，可以是任何类型的对象，包括原生数组、函数甚至另一个代理对象 handler 一个通常以函数作为属性的对象，各属性中的函数分别定义了在执行各种操作时代理的行为 举个栗子： 12345let const obj = {};const proxyHandler = {};const objProxy = new Proxy(obj, proxyHandler);// 赋值操作被转发到 obj 对象objProxy.a = 37; handler 中可以设置对原始对象各种操作的捕获器，在捕获器中可以自定义修改操作的行为。 1234567const obj = { a: 'A' };const proxy = new Proxy(obj, { get: (o, p) =&gt; { if (p === 'a') return 'This is A'; return o[p]; }}); 有时我们并不知道目标对象的具体类型，这种情况下使用 Reflect 返回 trap （捕捉器）相应的默认行为。 Reflect 是一个内置的不可构造的非函数对象，它提供了拦截 JavaScript 各种操作的方法。 12345678910let target = {};const proxyObj = new Proxy(target, { get: (obj, prop) =&gt; { return Reflect.get(obj, prop, receiver); }, set: (obj, prop, value) =&gt; { Reflect.set(obj, prop, value, receiver); return true; }}); 对于 set 操作，可能会引起代理对象的属性更改，导致 set 多次执行。比如当代理对象是数组时，执行 push 操作，会多次触发 set，同时也引发 get 操作。 123456789101112131415161718192021let array = [ 1, 3 ];const proxyHandler = { get: (target, prop, receiver) =&gt; { console.log('Get value : ', prop, Reflect.get(target, prop, receiver)); return Reflect.get(target, prop, receiver); }, set: (target, prop, value, receiver) =&gt; { console.log('Set value :', prop, value); return Reflect.set(target, prop, value, receiver); }};const objProxy = new Proxy(array, proxyHandler);objProxy.push(4);// Get value : push [Function: push]// Get value : length 2// Set value : 2 4// Set value : length 3 当要代理的对象是多层结构时，Proxy 的代理只能到第一层，即不能感知操作对象内部的 set 操作，但是 get 会被执行。 1234567891011121314151617181920let obj = { 'foo': 'foo', 'bar': { 'name': 1 } };const proxyHandler = { get: (target, prop, receiver) =&gt; { console.log('Get value : ', prop, Reflect.get(target, prop, receiver)); return Reflect.get(target, prop, receiver); }, set: (target, prop, value, receiver) =&gt; { console.log('Set value :', prop, value); Reflect.set(target, prop, value, receiver); return true; }};const objProxy = new Proxy(obj, proxyHandler);console.log(objProxy.bar.name);// Get value : bar { name: 1 }// 1 一句话总结：Proxy 是 ES6 引入的新特性，可以使用 Proxy 间接访问或操作其代理的对象。 Vue 3 中响应式数据实现Vue 3 中响应式系统的 API 主要有 reactive ref computed readonly watchEffect watch 其中 reactive 是最核心的 API reactiveVue 3 中是用全局的 WeakMap 来存储正在追踪的响应式对象，如 reactiveMap 、shallowReactiveMap 、readonlyMap、shallowReadonlyMap 。 1234export const reactiveMap = new WeakMap&lt;Target, any&gt;()export const shallowReactiveMap = new WeakMap&lt;Target, any&gt;()export const readonlyMap = new WeakMap&lt;Target, any&gt;()export const shallowReadonlyMap = new WeakMap&lt;Target, any&gt;() 此外还定义了代理对象的可响应操作： 1234567891011121314// 普通对象，如 Object 、Array 的拦截器// 包含了当对代理对象进行取值、复制、删除属性等操作时的捕获器export const mutableHandlers: ProxyHandler&lt;object&gt; = { get, set, deleteProperty, has, ownKeys};// 集合对象，如果 Map/WeakMap/Set/WeakSet 的拦截器export const mutableCollectionHandlers: ProxyHandler&lt;CollectionTypes&gt; = { get: /*#__PURE__*/ createInstrumentationGetter(false, false)} reactive 创建响应式对象的流程如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/*** 生成一个原始对象的响应式副本，这种转换是深层次的，会影响到所有嵌套属性*/function reactive(target: object) { // 如果目标对象是只读的，直接返回目标对象 if (target &amp;&amp; (target as Target).__v_isReadonly) { return target } // 否则就在目标对象的基础上创建响应式对象 return createReactiveObject( target, // 目标代理对象 false, // 是否只读 mutableHandlers, mutableCollectionHandlers, reactiveMap )}/*** 创建响应式对象*/ function createReactiveObject( target: Target, // 原始对象 isReadonly: boolean, // 是否只读 baseHandlers: ProxyHandler&lt;any&gt;, collectionHandlers: ProxyHandler&lt;any&gt;, proxyMap: WeakMap&lt;Target, any&gt; // 正在追踪的可响应对象的集合) { // 如果 target 不是对象类型，返回原值 if (!isObject(target)) { if (__DEV__) { console.warn(`value cannot be made reactive: ${String(target)}`) } return target } // 如果 taret 已经是一个响应式对象，返回原值 if ( target[ReactiveFlags.RAW] &amp;&amp; !(isReadonly &amp;&amp; target[ReactiveFlags.IS_REACTIVE]) ) { return target } // 如果 target 已经有一个代理对象，返回已经存在的代理对象 const existingProxy = proxyMap.get(target) if (existingProxy) { return existingProxy } // 只有特定类型的对象才可以被观测 // 包括 Array/Object/Map/Set/WeakMap/WeakSet，不是则返回 TargetType.INVALID const targetType = getTargetType(target) if (targetType === TargetType.INVALID) { return target } const proxy = new Proxy( target, // Map/Set/WeakMap/WeakSet 被认为是 COLLECTION 类型，handler 和其它类型不同 targetType === TargetType.COLLECTION ? collectionHandlers : baseHandlers ) proxyMap.set(target, proxy) return proxy} 上面提到了对于多层对象的代理，set 并不能感知到内层对象的变化，但是 get 会被触发，Vue 3 利用这个原理，再对内层数据进行一次代理。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364function createGetter(isReadonly = false, shallow = false) { return function get(target: Target, key: string | symbol, receiver: object) { if (key === ReactiveFlags.IS_REACTIVE) { // 如果 key 是可响应标志 IS_REACTIVE，返回 !isReadonly return !isReadonly } else if (key === ReactiveFlags.IS_READONLY) { // 如果 key 是只读标志 IS_READONLY，返回 isReadonly return isReadonly } else if ( key === ReactiveFlags.RAW &amp;&amp; receiver === (isReadonly ? shallow ? shallowReadonlyMap : readonlyMap : shallow ? shallowReactiveMap : reactiveMap ).get(target) ) { return target } const targetIsArray = isArray(target) // 如果目标是数组 if (!isReadonly &amp;&amp; targetIsArray &amp;&amp; hasOwn(arrayInstrumentations, key)) { return Reflect.get(arrayInstrumentations, key, receiver) } const res = Reflect.get(target, key, receiver) // 判断 key 是否是 Symbol if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) { return res } // 如果可读，追踪 if (!isReadonly) { track(target, TrackOpTypes.GET, key) } // 如果是浅层响应，直接返回得到的值 if (shallow) { return res } // 判断是否 Ref if (isRef(res)) { // ref unwrapping - does not apply for Array + integer key. const shouldUnwrap = !targetIsArray || !isIntegerKey(key) return shouldUnwrap ? res.value : res } if (isObject(res)) { // Convert returned value into a proxy as well. we do the isObject check // here to avoid invalid value warning. Also need to lazy access readonly // and reactive here to avoid circular dependency. return isReadonly ? readonly(res) : reactive(res) } return res }} 使用 reactive 创建了响应式对象后，改变响应式对象的属性操作，会被侦测，并即时地在目标对象上触发对应的响应。 拿 set 方法，即赋值来举例，就是： 12345678910111213141516171819202122232425262728293031323334353637383940414243const set = /*#__PURE__*/ createSetter()const shallowSet = /*#__PURE__*/ createSetter(true)function createSetter(shallow = false) { return function set( target: object, key: string | symbol, value: unknown, receiver: object ): boolean { // 取得旧的值 oldValue let oldValue = (target as any)[key] // 如果不是浅层响应模式，需要进行一系列的判断，才能赋值 if (!shallow) { value = toRaw(value) oldValue = toRaw(oldValue) // 如果 target 不是数组，旧值是 Ref if (!isArray(target) &amp;&amp; isRef(oldValue) &amp;&amp; !isRef(value)) { oldValue.value = value return true } } else { // in shallow mode, objects are set as-is regardless of reactive or not } const hadKey = isArray(target) &amp;&amp; isIntegerKey(key) ? Number(key) &lt; target.length : hasOwn(target, key) const result = Reflect.set(target, key, value, receiver) // don't trigger if target is something up in the prototype chain of original if (target === toRaw(receiver)) { // 在 target 上触发 ADD 或者 SET 响应 if (!hadKey) { trigger(target, TriggerOpTypes.ADD, key, value) } else if (hasChanged(value, oldValue)) { trigger(target, TriggerOpTypes.SET, key, value, oldValue) } } return result }} ref由于 Proxy 代理的目标需是对象形式，不能对简单类型进行代理，为此 Vue 3 中使用 ref 函数为简单类型的值生成了一个包装，这样就可以通过 recative 函数构建响应式数据了。 包装对象的实现如下: 1234567891011121314151617181920212223242526class RefImpl&lt;T&gt; { private _value: T private _rawValue: T public dep?: Dep = undefined public readonly __v_isRef = true constructor(value: T, public readonly _shallow = false) { this._rawValue = _shallow ? value : toRaw(value) this._value = _shallow ? value : convert(value) } get value() { trackRefValue(this) return this._value } set value(newVal) { newVal = this._shallow ? newVal : toRaw(newVal) if (hasChanged(newVal, this._rawValue)) { this._rawValue = newVal this._value = this._shallow ? newVal : convert(newVal) triggerRefValue(this, newVal) } }} 12345678910111213141516171819202122232425262728293031323334353637383940interface Ref&lt;T = any&gt; { [RefSymbol]: true value: T}function ref(value?: unknown) { return createRef(value)}function createRef(rawValue: unknown, shallow = false) { // 判断是否是 Ref，如果是 Ref 则直接返回 if (isRef(rawValue)) { return rawValue } // 判断是否是浅代理 // convert = (val) =&gt; isObject(val) ? reactive(val) : val let value = shallow ? rawValue : convert(rawValue) // const r = { __v_isRef: true, get value() { track(r, TrackOpTypes.GET, 'value') return value }, set value(newVal) { if (hasChanged(toRaw(newVal), rawValue)) { rawValue = newVal value = shallow ? newVal : convert(newVal) trigger( r, TriggerOpTypes.SET, 'value', __DEV__ ? { newValue: newVal } : void 0 ) } } } return r} computed1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859function computed&lt;T&gt;( getterOrOptions: ComputedGetter&lt;T&gt; | WritableComputedOptions&lt;T&gt;) { let getter: ComputedGetter&lt;T&gt; let setter: ComputedSetter&lt;T&gt; // 如果传入的 getterOrOptions 是函数，则将其设置为计算属性的 getter if (isFunction(getterOrOptions)) { getter = getterOrOptions // 如果只传入了 getter 函数，将计算属性是不可修改的 readonly setter = __DEV__ ? () =&gt; { console.warn('Write operation failed: computed value is readonly') } : NOOP } else { // 如果 getterOrOptions 是个对象，则计算属性是可修改的 getter = getterOrOptions.get setter = getterOrOptions.set } let dirty = true let value: T let computed: ComputedRef&lt;T&gt; const runner = effect(getter, { lazy: true, // 将 effect 标记为 computed，则其在执行时拥有更高的优先级 computed: true, scheduler: () =&gt; { if (!dirty) { dirty = true trigger(computed, TriggerOpTypes.SET, 'value') } } }) // 构建一个 computed 对象 computed = { __v_isRef: true, // 将 effect 暴露，使得计算属性能够 stop effect: runner, get value() { if (dirty) { value = runner() dirty = false } // 追踪 track(computed, TrackOpTypes.GET, 'value') // 返回最新值 return value }, set value(newValue: T) { setter(newValue) } } as any return computed} effect1234567891011121314151617181920212223242526272829303132333435363738394041424344454647function effect&lt;T = any&gt;( fn: () =&gt; T, options: ReactiveEffectOptions = EMPTY_OBJ): ReactiveEffect&lt;T&gt; { if (isEffect(fn)) { fn = fn.raw } const effect = createReactiveEffect(fn, options) if (!options.lazy) { effect() } return effect}function createReactiveEffect&lt;T = any&gt;( fn: (...args: any[]) =&gt; T, options: ReactiveEffectOptions): ReactiveEffect&lt;T&gt; { const effect = function reactiveEffect(...args: unknown[]): unknown { if (!effect.active) { return options.scheduler ? undefined : fn(...args) } // 如果 effectStack 不存在当前 effect if (!effectStack.includes(effect)) { cleanup(effect) try { enableTracking() // 将当前 effect 加入 effectStack effectStack.push(effect) // 将当前 effect 设置为 activeEffect activeEffect = effect return fn(...args) } finally { effectStack.pop() resetTracking() activeEffect = effectStack[effectStack.length - 1] } } } as ReactiveEffect effect.id = uid++ effect._isEffect = true effect.active = true effect.raw = fn effect.deps = [] effect.options = options return effect} 关于 trigger 和 tracktrigger 用来当观测值发生发生变化时通知观察者 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091function trigger( target: object, type: TriggerOpTypes, key?: unknown, newValue?: unknown, oldValue?: unknown, oldTarget?: Map&lt;unknown, unknown&gt; | Set&lt;unknown&gt;) { // targetMap 存储了所有被追踪的对象，如果当前对象没有被追踪，直接返回 const depsMap = targetMap.get(target) if (!depsMap) { // never been tracked return } const effects = new Set&lt;ReactiveEffect&gt;() const computedRunners = new Set&lt;ReactiveEffect&gt;() const add = (effectsToAdd: Set&lt;ReactiveEffect&gt; | undefined) =&gt; { if (effectsToAdd) { effectsToAdd.forEach(effect =&gt; { if (effect !== activeEffect || !shouldTrack) { if (effect.options.computed) { computedRunners.add(effect) } else { effects.add(effect) } } else { // the effect mutated its own dependency during its execution. // this can be caused by operations like foo.value++ // do not trigger or we end in an infinite loop } }) } } // 如果当前触发类型为 CLEAR if (type === TriggerOpTypes.CLEAR) { // collection being cleared // trigger all effects for target depsMap.forEach(add) } else if (key === 'length' &amp;&amp; isArray(target)) { depsMap.forEach((dep, key) =&gt; { if (key === 'length' || key &gt;= (newValue as number)) { add(dep) } }) } else { // schedule runs for SET | ADD | DELETE if (key !== void 0) { add(depsMap.get(key)) } // also run for iteration key on ADD | DELETE | Map.SET const isAddOrDelete = type === TriggerOpTypes.ADD || (type === TriggerOpTypes.DELETE &amp;&amp; !isArray(target)) if ( isAddOrDelete || (type === TriggerOpTypes.SET &amp;&amp; target instanceof Map) ) { add(depsMap.get(isArray(target) ? 'length' : ITERATE_KEY)) } if (isAddOrDelete &amp;&amp; target instanceof Map) { add(depsMap.get(MAP_KEY_ITERATE_KEY)) } } const run = (effect: ReactiveEffect) =&gt; { // 在开发环境下，调试触发器 if (__DEV__ &amp;&amp; effect.options.onTrigger) { effect.options.onTrigger({ effect, target, key, type, newValue, oldValue, oldTarget }) } if (effect.options.scheduler) { effect.options.scheduler(effect) } else { effect() } } // Important: computed effects must be run first so that computed getters // can be invalidated before any normal effects that depend on them are run. computedRunners.forEach(run) effects.forEach(run)} 12345678910111213141516171819202122232425function track(target: object, type: TrackOpTypes, key: unknown) { if (!shouldTrack || activeEffect === undefined) { return } let depsMap = targetMap.get(target) if (!depsMap) { targetMap.set(target, (depsMap = new Map())) } let dep = depsMap.get(key) if (!dep) { depsMap.set(key, (dep = new Set())) } if (!dep.has(activeEffect)) { dep.add(activeEffect) activeEffect.deps.push(dep) if (__DEV__ &amp;&amp; activeEffect.options.onTrack) { activeEffect.options.onTrack({ effect: activeEffect, target, type, key }) } }}","link":"/2020/06/16/Vue3%20%E6%95%B0%E6%8D%AE%E4%BE%A6%E6%B5%8B%E5%8E%9F%E7%90%86/"},{"title":"","text":"加密和解密数据加密的基本过程就是对原本为明文的数据或文件按照某种算法进行处理，使其成为不可读的密文。解密则是加密过程的逆过程，即将密文转换为原本数据的过程。 加密技术的分类目前加密技术主要被分为对称加密和非对称加密。 对称加密技术 对称加密技术是指加密和解密使用同一个密钥的加密技术 非对称加密技术 非对称加密是指加密和解密使用的不是同一个密钥的加密技术，通常有两个密钥，称为公钥和私钥，必须配对使用公钥和私钥才能解开加密的文件 常见加密算法对称算法DES即 Data Encryption Standard，数据加密标准，速度较快，适合于加密大量数据的场合 3DES即 Triple DES，是基于 DES 的加密算法，使用三个不同的密钥对一块数据进行三次加密，强度比 DES 更高 RC2和RC4用变长密钥对大量数据记性加密，比 DES 快 IDEA即 International Data Encryption Algorithm，国际数据加密算法，使用128位密钥提供非常强的安全性 AES即 Advanced Encryption Standard，高级加密标准，是下一代的加密算法标准，速度快，安全性高 BLOWFISH使用变长密钥，长度可达 448 位，运行速度很快 非对称算法RSA支持变长密钥的公共密钥算法，需要加密的文件块长度也是可变的，是一种非对称算法 其它PKCSThe Public-Key Cryptography Standards (PKCS)是由美国RSA数据安全公司及其合作伙伴制定的一组公钥密码学标准，其中包括证书申请、证书更新、证书作废表发布、扩展证书内容以及数字签名、数字信封的格式等方面的一系列相关协议。 MD5严格来说不算加密算法，是摘要算法 DSA即 Digital Signature Algorithm 数据签名算法，严格来说不是加密算法，而是数字签名标准 JavaScript 中的原生加密","link":"/2021/01/08/Web%20%E5%8A%A0%E5%AF%86%E5%92%8C%E8%A7%A3%E5%AF%86/"},{"title":"CSS 基础概览","text":"CSS 构造块CSS (层叠样式表)是一种文本文件，其中包含一个或多个(通过属性和值)决定网页某特定元素如何显示的规则。CSS 里有控制基本格式的属性(如 font-size 和 color)，有控制布局的属性(如 position 和 float)，还有决定访问者打印时在哪里换页的打印控制 元素。CSS 还有很多控制元素显示或消失的动态属性，可以用于创建下拉列表和其他交互性组件。 CSS2 是目前浏览器支持最为广泛的版本，CSS3 是以CSS2 为基础，提供了大量设计人员和开发人员长期期待的功能，但可惜的是目前还没有成为规范。 构造样式规则样式表中包含了定义网页外观的规则。 样式表中的每条规则都有两个主要部分 ：选择器和声明块。选择器决定哪些元素受到影响；声明块由一个或多个 属性 - 值 对组成，它们指定应该做什么。 123456789selector { property-name:property-value; ···}h1 { background-color: green; color: red;} 在样式规则中可以添加额外的空格、制表符或回车，从而提高样式表的可读性 。 ​ 为样式规则添加注释在 CSS 中添加注释是个好主意，这样就可以标注样式表的主要区域，或者只是针对某条规则或声明进行解释。注释不仅对开发 人员有用，对阅读代码的其他人也有好处。 注释可以包含回车，因此可以跨越多行。类似地，/* 和 */ 既可以单独成行，也可以跟文本同处一行。另外，注释还可以放到声明块内部，或者样式规则后面。 1234567891011/* This is a single line comment *//* ··· This is multi-ling comment ···*/h1 { color: green; font-size: .875em; /* This is a comment in declarations bloc */} 需要注意的是，不能将一个注释嵌套在另一个注释内部 ，这样的做法是错误的。 注释是很有用的组织工具。样式表很快就会变得很长，因此，组织好样式表对于保持 CSS 易于维护至关重要。通常，将相关的规则放在一起，形成分组，并在每组前面放置一段描述性的注释 123456/* Section-1 */ ···/* Section-2 */ ···/* Section-3 */ ··· 当然，你也可以注释掉属性值，来进行调试，就像你在其它语言中做的那样。 ​ CSS 中的继承当你为某个元素应用 CSS 属性时，这些属性不仅会影响该元素，还会影响其下的分支元素。也就是说，这些下层的元素继承了其祖先元素的属性。 任何一个直接包含在另一个元素中的元素，都是其父元素的分支。 此外，对大多数属性来说，还可以使用 inherit 值进行强行继承。 那么，哪些属性会被继承呢？ 文本 color(颜色，a 元素除外)  direction(方向) font(字体) font-family(字体系列)  font-size(字体大小) font-style(用于设置斜体) font-variant(用于设置小型大写字母)  font-weight(用于设置粗体) letter-spacing(字母间距) line-height(行高) text-align(用于设置对齐方式) text-indent(用于设置首行缩进) text-transform(用于修改大小写) visibility(可见性) white-space(用于指定如何处理空格)  word-spacing(字间距) 列表 list-style(列表样式) list-style-image(用于为列表指定定制的标记)  list-style-position(用于确定列表标记的位置)  list-style-type(用于设置列表的标记) 表格 border-collapse(用于控制表格相邻单元格的边框是否合并为单一边框)  border-spacing(用于指定表格边框之间的空隙大小) caption-side(用于设置表格标题的位置) empty-cells(用于设置是否显示表格中的空单元格) 页面设置 orphans(用于设置当元素内部发生分页时在页面底部需要保留的最少行数)  page-break-inside(用于设置元素内部的分页方式) widows(用于设置当元素内部发生分页时在页面顶部需要保留的最少行数) 其它 cursor(鼠标指针) quotes(用于指定引号样式) 层叠：当规则发生冲突时样式的来源很多，每个浏览器都有其默认的样式，你可以使用自己的样式覆盖它们或对它们进行补充。 有时候，多条规则会定义元素的同一个属性，这是应该怎么办呢？CSS 用层叠的原则来考虑样式声明，从而判断相互冲突的规则中哪个规则应该起作用。 首先，你编写的样式如果与浏览器的默认样式冲突，均以你编写的样式为准。在此基础上，CSS 用层叠的原则来考虑特殊性(specificity)、顺序(order)和重要性(importance)，从而判断相互冲突的规则中哪个规则应该起作用。 特殊性 特殊性规则指定选择器的具体程度。选择器越特殊，规则就越强。遇到冲突时，优先应用特殊性强的规则 。 一般来说，我们任务 id 选择器是最特殊的，而继承的样式是最一般的。 不过，建议在样式表中多使用类选择器，避免使用 id 选择器。 顺序 有时候，特殊性还不足以判断在相互冲突的规则中应该优先应用哪一个。在这种情况下，规则的顺序就可以起到决定作用:晚出现的优先级高。 重要性 如果这还不够，可以声明一条特殊的规则覆盖整个系统中的规则，这条规则的重要程度要比其他所有规则高。也可以在某条声 明的末尾加上 !important，比如 p{ color: orange !important; }(除非是在特殊情况 下，否则不推荐使用这种方法)。 你编写的样式会覆盖浏览器的默认样式。 当两个或两个以上的样式发生冲突时，会应用特殊性高的样式声明，不管它位于样式表中的哪个位置。如果两个或两个以上的规则拥有相同的特殊性，则使用后出现的规则， 除非其中某条规则标记了 !important。 如果某元素没有直接指定某条规则，则使用继承的值(如果有的话)。 ​ 属性的值每个 CSS 属性对于它可以接受哪些值都有不同的规定。有的属性只能接受预定义的值。有的属性接受数字、整数、相对值、百分数、 URL 或者颜色。有的属性可以接受多种类型的值。 inherit 对于任何属性，如果希望显式地指出该属性的值与对应元素的父元素对该属性设定的值相同，就可以使用 inherit 值。 预定义的值 大多数 CSS 属性都有一些可供使用的预定义值。例如，float 属性可被设为 left、right 或 none。与 HTML 不同，不需要(也不能)将预定义的值放在引号里。实际上， 大多数 CSS 值，无论是否为预定义的值，都不需要加引号。(也有一些例外，如超过一个单 词的 font-family 名称，以及要生成的内容。) 长度和百分数 很多 CSS 属性的值是长度。所有长度都必须包含数字和单位，并且它们之间没有空 格。例如 3em、10px。唯一的例 外是 0，它可以带单位也可以不带。效果是一样的，因此 0 一般不带单位。 有的长度是相对于其他值的。一个 em 的长度大约与对应元素的字号相等。一般来说，应该只在输出尺寸已知的情况下使用绝对长度 。 百分数(如 65%)的工作方式很像 em， 它们都是相对于其他值的值 ，百分数通常是相对于父元素的 。 纯数字 只有极少数的 CSS 属性接受不带单位的数字，典型的如 line-height、z-index 和 opacity。 URL 有的 CSS 属性允许开发人员指定另一个文件的 URL，background-image 就是这样一个属性。 1background: url(bg-patern.png); 注意，规范指出，相对 URL 应该相对于样式表的位置而不是相对于 HTML 文档的位置。 CSS 颜色 我们可以使用预定义颜色关键字或以十六进制(通常称为 hex)、RGB、HSL、 RGBA、HSLA 等格式表示的值中为 CSS 属性指定颜色。 实践中，定义 CSS 颜色更常规的方法是使用十六进制格式或 RGB 格式。如果要指定透明度的话，请使用 RGBA。 RGB 可以通过指定红、绿、蓝(这也是 RGB 这一名称的由来)的量来构建自己的颜色。 可以使用百分数、0 ~ 255 之间的数字来指定这三种颜色的值。 1color: rgb(0,0,0); 十六进制数 1color: #FFFFF; RGBA RGBA 在 RGB 的基础上加了一个代表 alpha 透明度(alpha transparency) 的 A。 alpha 透明度的一种常见使用场景是将其用在对元素设置 background-color 或 background 的情况(均用于设置背景)，因为 alpha 透明度允许元素下面的任何东西(如图像、其他颜色、文本等)透过来并与元素混合在一起。 也可以对其他基于颜色的属性使用 alpha 透明度，如 color、border、border-color、box- shadow、text-shadow 等。 123456/* 不透明，和 rgb(89, 0, 127); 效果相同 */ background-color: rgba(89,0,127,1);/* 完全透明 */background-color: rgba(89,0,127,0);/* 25%透明 */background-color: rgba(89,0,127,0.75); /* 60%透明 */background-color: rgba(89,0,127,0.4); 操作样式表将 CSS 应用到多个网页(包括整个网站)、单个页面或单独的 HTML 元素 ，有三种方式：外部样式表、嵌入样式表和内联样式表。外部样式表非常适合给网站上的大多数页面或者所有页面设置一致的外观。可以在一个外部样式表中定义全部样式，然后让网 站上的每个页面加载这个外部样式表，从而确保每个页面都有相同的设置 。 外部样式表是作为操作样式表的最佳实践。 链接到外部样式表将已经编写好的样式表加载到 HTML 页面中去，最好的方式是链接到样式表。对外部样式表进行修改时，所有引用它的页面也会自动更新 。 12345678910&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;CSS&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css/style.css&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; link 元素位于 HTML 文档的 head 部分。 页面可以包含一个以上的 link 元素，但使用它的次数最好尽可能地少，让页面得以更快地加载 。 外部样式表的另一个好处是，一旦浏览器在某个页面加载了它，在随后浏览引用它的页面时，通常无需再向 Web 服务器请求 该文件。浏览器会将它保存到缓存里，也就是保存到用户的计算机里，并使用这个版本的文件。这样做可以加快对页面的加载。如果随后对样式表作了修改，再将它传到 Web 服务器，浏览器就会下载更新后的文件，而不是使用缓存的文件(从技术上讲也有例外，但通常不会遇到这种情况)。 可以在页面中使用多个 link 元素， 从而加载多个样式表文件。如果在不同的文件中有显示声明产生冲突，则后面文件中的规则的优先级更高。 ​ 嵌入式样式表嵌入样式表是在页面中应用 CSS 的第二种方式。我们在 HTML 页面的 head 部分创建一个 style 元素，其中包含了我们的样式表。由于这些样式只在一个网页里存在，因此不会像外部样式表中的规则那样应用到其他的页面，同时，缓存的好处也不存在了。如上文所述，对于大多数情况， 我们推荐使用外部样式表，但理解其他的选择以备不时之需也是很重要的。 1234567891011121314&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;CSS&lt;/title&gt; &lt;style&gt; img { border: 4px solid red; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; 使用嵌入样式表时，style 元素及其包围的样式规则通常位于文档的 head 部分。 当且仅当 style 元素出现在 link 元素后面的时候，嵌入样式表中的样式才会覆盖外部样式表中的样式。 ​ 应用内联样式内联样式将内容和变现会在一起，严重违背了最佳规范。 12345678910&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;CSS&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;img src=&quot;imgs/market.png&quot; width=&quot;20&quot; height=&quot;20&quot; alt=&quot;&quot; style=&quot;border: 4px solid red&quot; /&gt;1 &lt;/body&gt; &lt;/html&gt; 更好的做法是通过类名来应用外部样式表中的规则。如果你希望其它元素也是用这种样式，只需为其添加 class=”class-name” 即可。 内联样式的优先级高于其它所有样式，除非其它地方与之冲突的样式标记了 !important。 ​ 样式的层叠和顺序将多个样式规则应用于同一元素的情况并不少见，大型网站更是如此，他们需要更多精力维护 CSS。有时候这些规则针对的是 同一条属性。在规则的特殊性相同的情况下，样式的顺序就成为关键。基本规则是:在其他条件相同的情况下， 越晚出现的样式优先级越高 。 以下解释了顺序如何决定样式规则的优先级： 嵌入样式表（位于 style 元素内）与任何链接的外部样式表之间的关系取决于它们在 HTML 中的相对位置。 内联样式(实际上直接应用于元素) 在外部样式表和嵌入样式表之后。由于顺序最靠后，其优先级是最高的。 一旦应用到任何地方，都会覆盖与之冲突的其他样式。 关于相互冲突的样式的顺序对优先级的影响，有一种例外情况，就是标记 !important 的样式总是具有最高的优先级，无论它出现在最前、最后，还是中间。不过，要尽量避免这种用法，极端情况除外。几乎在全部情况下，使用选择器都能达到同样的效果。此外，!important 让声明变得太强，如果要覆盖这样的样式，就不得不借助于更长的规则。 有一种使用 !important 的合理情形。 有时网页会包含一些你无法修改的 HTML， 例如来自第三方服务的新闻源。如果这些 HTML 中有一些内联样式与你的设计不符， 你就可以在自己的样式表中使用 !important 覆盖这些样式。 ​ 使用与媒体相关的样式表可以指定一个只用于特定输出的样式表， 如只用于打印，或只用于在浏览器中查看屏幕。 1234567891011&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;CSS&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css/style.css&quot; media=&quot;screen&quot; /&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css/print.css&quot; media=&quot;print&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; 通过对 link 元素添加 media 属性，可 以将样式表限于特定输出。 123456789101112131415161718192021222324/* 针对所有样式 */img { border: 4px solid red;}p { color: orange; font-style: italic;}/* 打印样式表 */@media print { body { /* 加大字号 */ font-size: 25pt; } p{ /* 黑色的十六进制值 */ color: #000; } img { /* 不显示图像 */ display: none; }} 联合使用 CSS3 引入的媒体查询和这里介绍的媒体输出类型可以形成强大的威力。 通过这些技术，可以根据输出设备的属性确 定需要应用到页面的样式。 ​ 定义选择器CSS 样式规则有两个主要部分。选择器决定将格式化应用到哪些元素，而声明则定义要应用的格式化。 构造选择器选择器可以定义五个不同的标准来选择要进行格式化的元素。 元素的类型和名称 123h1 { color: red;} 元素所在的上下文 1234/* em 为元素名称，这个选择器只应用于 h1 元素中的 em 元素*/h1 em { color: red;} 元素的类或 id 123456789/* 选择所有属于 error 类的元素 */.error { color: red;}/* 选择 id 为 gaudi 的元素 */#gaudi { color: red;} 通过在 class 或 id 选择器前面添加目标元素的名称，可以增强选择器的特殊性。 1234/* 选择属于 error 的 strong 元素 */strong.error { color: red;} 如果要定位的元素有多个类名，可以在选择器中将它们连在一起。 元素的伪类或伪元素 1234/* 选择属于 link 伪类的 a 元素 */a:link { color: red;} 元素是否有某些属性的值 123456789/* 选择所有 title 属性的 a 元素 */a[title] { color: red;}/* 选择指向维基百科的 a 元素 */a[href=&quot;https://www.wikipedia.ort&quot;] { color: red;} 编写 CSS 的一个重要目标就是让选择器尽可能的简单，仅保持必要的特殊性。应该充分利用样式的层叠特性，即元素的后代会继承祖先元素的样式。同时，应该将页面中的通用设计元素挑选出来，编写一个选择器(如类名)，从而可以在全站不同的元素上共享该样式。 ​ 按照名称选择元素选择要格式化的元素，最常用的就是按照元素的名称进行选择。比如 ： 123h1 { color: red;} 除非指定其它情况，指定类型的所有元素都将被格式化，无论它们出现在文档的什么位置。 通配符 * 匹配代码中的任何元素名称。但是因为匹配范围太广，一般不建议使用，因为这会使得浏览器加载页面变慢。 可以在一个选择器中使用一组元素名称，名称之间用逗号分隔。 123h1,h2,h3 { color: red;} ​ 按类或 ID 选择元素如果已经在元素中标识了 class 或 id ，就可以在选择器中使用这个标准，从而只对已标识的元素进行格式化。 可以单独用使用 class 和 id，也可以同其它选择器标准混在一起使用，比如 12345678// 会影响所有属于 news 类的元素.news { color: red;}// 只会影响属于 news 类的 h1 元素h1.news { color: red;} 除非必须特别针对目标元素，否则不要在 id 或 class 选择器中添加元素名称。 如果要定位的类名有多个，可以在选择器中将它们连在一起 123.class-news.class-video { color: blue;} 这里需要主要的是，任何 .class-news 和 .class-video 选择器的规则仍会应用于该元素，但是 .class-news.class-video 的规则的特殊性更高。 ​ 按上下文选择元素在 CSS 中，可以根据元素的祖先、父元素或同胞元素来定位它们。 1234567891011121314// 组合使用了类选择器和类型选择器// 这将作用于任何作为 class-news 类元素的后代的 p 元素.class-news p { color: red;}// 作用于所有以 article 元素为祖先的 p 元素article p { color: red;}// 作用于以属于 class-news 类的 article 元素为祖先的任何 p 元素// 这种类型的选择器的特殊性最高，通常会比实际需要的特殊性更高article.class-news p { color: red;} 祖先元素是包含目标元素的任何元素，不管它们之间相隔多少代，而父元素是直接包含另一个元素的元素，它们之间只隔一代。 通常将基于祖先元素的选择器成为后代选择器，不过 CSS 3 中将其称为后代结合符。 按照祖先元素选择要格式化的元素123element-ancestor element-target { ···} 按照父元素选择要格式化的元素123element-father &gt; element-target { ···} 按照相邻同胞元素选择要格式化的元素CSS 相邻同胞结合符可以选择直接跟在指定的同胞元素后面的同胞元素。 123.class-news p+p { ···} ​ 选择第一个或最后一个子元素有时候需要选择仅作为某元素第一个或最后一个子元素的元素，这时候就要用到 :first-child 和 :last-child 伪类。 123456789101112// 选择子元素中的第一个 li 元素li:first-child { color: red;}// 选择子元素中的最后一个 li 元素li:last-child { color: red;}// 选择任何作为另一个元素的第一个子元素:first-child { color: red;} 在伪类之前添加其它选择器可以使其特殊性更高 1234// 仅对 class-news 类的第一个 h1 子元素起作用.class-news h1:first-child { color: red;} ​ 选择元素的第一个字母或第一行使用 :first-letter 和 :first-line 伪元素只选择元素的第一个字母或第一行。 12345678910// 选择 p 元素的第一个字母p:first-letter { color: red; font-size: 1.4em; font-weight: bold;}// 选择 p 元素的第一行p:first-line { color: red;} 可以将 :first-letter 和 :first-line 伪元素与其它选择器结合使用 1234// 作用于 class-news 类中每个段落的第一个字母.class-news p:first-letter { color: red;} 需要注意的是，只有某些特定的 CSS 属性可以应用于 :first-letter 伪元素，包括 font、color、background、text-decoration、vertical-algin、text-transform、line-height、margin、padding、border、float 和 clear。 伪元素、伪类及 CSS 3 语法 在 CSS 3 中 12:first-line -&gt; ::first-line:first-letter -&gt; ::first-letter 这样是为了将伪类和伪元素进行区分。 ​ 按照状态选择链接元素CSS 允许根据链接的当前状态对其进行格式化。 链接的状态包括访问者是否将鼠标停留在链接上，链接是否被访问过等等。 123456789101112131415161718192021222324// 从未被激活或指向，当前也没有被激活或指向的链接a:link { color: red;}// 已激活过的链接a:visited { color: orange;}// 通过键盘选择并已准备好激活的a:focus { color: purple;}// 光标指向连接时a:hover { color: green;}// 激活的链接a:active { color: blue;} 也可以对其它类型的元素使用 :active 和 :hover 伪类 1234// 鼠标停留在任何段落上都会使其显示红色p:hover { color: red;} ​ 按照属性选择元素可以对具有给定属性或属性值的元素进行格式化。 CSS 提供了多种方式匹配属性和属性值，包括只检查属性名、检查全部或者部分属性值。如果在选择器中呼略了属性值，就可以为具有给定属性的元素应用样式。 12345678910111213element[attribute] // 匹配指定属性，无论属性值是什么 [attribute=&quot;value&quot;] // 完全匹配指定属性值 [attribute~=&quot;value&quot;] // 匹配属性值以空格分隔的多个单词，其中有一个完全匹配指定值 [attribute|=&quot;value&quot;] // 匹配以 value- 打头的属性值 [attribute^=&quot;value&quot;] // 匹配以 value 开头的属性值，value 为完整的单词或完整的单词的一部分 [attribute$=&quot;value&quot;] // 匹配属性值以 value 结尾，value 为完整的单词或完整的单词的一部分 [attribute*=&quot;value&quot;] // 属性值为指定值的子字符串// 选择所有具有 class 属性的段落p[class] { color: red;} ​ 指定元素组我们经常需要将相同的样式规则应用于多个元素。可以为每个元素重复地设置样式规则，也可以组合选择器，一次性地设置样式规则。 123456element-1,element-2, ···element-n { ···} 可以列出任意数量的单独的选择器，无论它们包含的是元素名称、类还是伪元素，只需用逗号将它们隔开。 通过元素组添加样式只是一种简写方式。 有时，为应用于多个选择器的共同样式创建一个样式规则，再为没有共同点的样式分别创建单独的样式规则是很有用的。要记住，在样式表中后指定的规则会覆盖先指定的规则。 ​ 为文本添加样式使用 CSS 可以修改文本的字体、大小、粗细、倾斜、行高、前景和背景颜色、间距和对齐方式、添加下划线和删除线等。 选择字体系列并非所有的系统都支持相同的默认字体，因此应该定义替代字体作为备选。 设置字体的方法1234567body { font-family: Geneva;}h1，h2 { font-family: &quot;Gill Sans&quot;;} 由于 font-family 是继承属性，当我们对 body 元素设置了字体以后，该样式也会应用到其它元素。但是有几个元素不会继承父元素的字体设置，其中有表单的 select、textarea 和 input 元素。不过，可以强制它们继承父元素的字体。 123input, select, textarea { font-family: inherit;} 指定替代字体为了使得文本以你想要呈现的字体来展示，你需要设置替代字体以防止在某些系统上没有安装你指定的字体的情况。 123456789// 浏览器会使用列表中的第一个已安装在访问者系统内的字体body { font-family: Geneva, Tahoma, sans-serif;}h1,h2 { font-family: &quot;Gill Sans&quot;,&quot;Gill Sans MT&quot;;} OS X 和 Windows 上默认的共有的字体 它们仅包括 Arial、Comic、Sans MS、Courier New、Georgia、Impact、Trebuchet MS、Times New Roman 和 Verdana。 系统通常都有下列表示类属的字体名称对应的字体：serif、sans-serif、cursive、fantasy 和 monospace。因此，标准的做法就是字体栈的末尾指定上述字体名称中的一种。 可以在同一个 font-family 规则中为不同的字母表指定字体，从而对包含不同怨言和书写体系的文本进行格式化。 ​ 创建斜体浏览器通常让一些 HTML 元素默认以斜体显示，因此，不比在 CSS 中对这些元素设置斜体。有时，你需要让一些内容以斜体显示，但是用元素却没有合适的语义，这时，使用 CSS 的 font-style 属性就可以让任何元素中的文本以斜体显示。 123p { font-style: italic;} 因为 font-style 属性是继承的，如果你想要在某些地方不以斜体显示，则可以取消斜体 1font-style: normal; ​ 创建粗体粗体格式可能是让文本突出显示的最常见、最有效的方式。 1234em,a:link { font-weight: bold;} 设置 font-weight 属性的值为 bold，让文本显示为有平均加粗值的字体，或者输入 100 ~ 900 之间的 100 的倍数，其中 400 代表正常粗细，700 代表粗体。 设置 font-weight 为 normal 来取消粗体。 ​ 设置字体大小为网页里的文本设置字体大小有两种方式：直接使用像素指定要使用的特定字号或使用百分数、em、rem 指定相对于父元素文本的大小。 1234567h1 { font-size: 35px;}h2 { font-size: 28px;} 使用 em 这样的相对单位有更大的灵活性，而且对定义页面中特定的设计部件的尺寸很有帮助。 123456789101112// body 中设置的 font-size：100% 声明为 em 字体大小设置了参考的基准。这里的 100% 将被翻译为默认字体大小body { font-size: 100%; /* 16px */}h1 { font-size: 2.1875em; /* 35px/16px */}h2 { font-size: 1.75em; /* 28px/16px */} 使用 rem 设置字体大小 CSS 3 引入了一些新的单位，其中很有意思的一个便是 rem。它同 em 很像，不过它总是以根元素为参照系设置其它元素的字体大小，而不是父元素。这样做字体大小的设置。 ​ 设置行高行高指的是段落的行距，即段落内诶航之间的距离。 123class-news { line-height: 1.5;} 如果使用数字设定行高，那么所有的子元素都会继承这个因子。因此，如果父元素的字体大小是 16 像素或以 em 表示的等价大小，行高是 1.5 的话，则该元素的行高就是 24 像素。 ​ 同时设置所有字体值可以使用 font 简写属性同时设置字体样式，但是需要注意的是 font 简写属性至少应该包括字体系列和字体大小属性。 12345678910111213141516body { font: 100% Geneva, Tahoma, Verdana, sans-serif;}h1,h2 { /* 这些声明无法使用 font 简记法，除非同时声明字体大小 */ font-family: &quot;Gill Sans&quot;, &quot;Gill Sans MT&quot;, Calibri, sans-serif; font-weight: bold;}.class-news p { /* 这些声明无法使用 font 简记法，除非同时声明字体大小 */ font-size: .9375em; ling-height: 1.65;} ​ 设置颜色1234567body { color: blue;}h2 { color: #000;} 除了 link 元素，其它元素都会继承 body 元素中的 color 属性，你必须显示设置 link 元素的 color 属性。 ​ 设置背景设置背景有很多属性可以利用，包括 background-color、background-image、background-repeat、background-attachment 及 background-position 等。 123456789101112body { background-color: #88b2d2;}h2 { background-color: #eaebef;}// 使用背景图像作为背景h3 { background-image: url(bg-pattern.png); background-repeat: repeat-x;} background-color 的默认值是 transparent，background-image 的默认值是 none，background-repeat 的默认值是 repeat，background-attachment 的默认值是 scroll，background-position 的默认值时 0 0。只有在需要覆盖其它样式规则的时候才会显示的指定默认值。 ​ 控制间距可以增加或减少单词之间或字母之间的距离，前者成为字间距，后者称为字偶距。 12345// word-spacing 和 letter-spacing 是继承的body { letter-spacing: 1px; word-spacing: 2px;} 单词间距和字母间距还可能受到所选对齐方式的和字体系列的影响。 要将字母间距和单词间距设置为默认值，可使用 normal 或 0 。 ​ 添加缩进通过设置 text-indent 属性，可以指定段落第一行前面应该空出多大的空间。 123p { text-indent: 2em;} 其实我们也可以为其它元素应用 text-indent 属性，而不仅是段落元素，不过默认情况下对 em、strong、cite 等内联元素没有效果。可以将它们设置为 display：block；或 display: inline-block; 为其添加 text-indent 属性。 ​ 对齐文本根据需要，可以让文本左对齐、右对齐、居中对齐或两端对齐。 123p { text-align: left; // right/center/} 修改文本的大小写使用 text-transform 属性，可以为样式定义文本的大小写。通过这种方法，可以将文本显示为首字母大写、全部大写、全部小写或原样显示。 123456{ text-transform: uppercase; // 让所有字母大写 text-transform：capitalize; // 让每个单词的首字母大写 text-transform：lowercase; // 让所有字母小写 text-transform：none; // 让文本保持原来的样子或用来取消继承的值} 使用小型大写字母很多字体都有对应的小型大写字母变体， 其中一些字母是大写的，但缩小到了小写字母的大小。可以使用 font-variant 调用小型大写字母变体 。 123h2 { font-variant: small-caps;} 装饰文本可以使用 text-decoration 属性装饰文本，如添加下划线或者其他类型的线条。目前最常用到这个属性的情况是为链接状态添加 样式 。 1234567a:link { color: #e1000; text-decoration: none; // 无装饰样式 text-decoration: underline; // 下划线 text-decoration: overline; // 上划线 text-decoration: line-through; // 删除线} 设置空白属性默认情况下，HTML 文档里的多个空格和回车会显示为一个空格，或者被忽略。 如果要让浏览器显示这些额外的空格，可以使 用 white-space 属性 ： 12345body { white-space: nowarp; // 确保所有空格不断行，也就是文本全部显示在一行 white-space: pre; // 显示原文本中的所有空格和回车 white-space: normal; // 按正常方式处理空格} ​ 用CSS进行布局使用 CSS 进行布局的注意事项 内容与显示分离 布局方法 固定布局，真个页面和每一栏都有基于像素的宽度 响应式页面也称为流式页面，使用百分数定义宽度，允许页面随显示环境的改变进行放大或缩小。 浏览器注意事项 并非所有的访问者都是用同样的浏览器，同样的操作系统，甚至同样的设备访问你的网站，因此通常在将网站放到服务器上发布之前，尽量在不同的操作系统用不同的浏览器进行充分的测试。 对默认的样式进行重置或标准化每个浏览器都有内置的默认样式表，HTML 会遵照该样式显示，除非你自己编写的 CSS 覆盖了它们。整体上，不同浏览器提供的默认样式是相似的，但也存在一定的差异，为此，在应用自己的 CSS 之前，应抹平这些差异。 抹平差异的方法主要有两种 ： 使用 CSS 重置开始主样式表 使用 Nicolas Gallagher 和 Jonathan Neal 创建的 normalizes.css 开始主样式表 CSS 重置可以有效地将所有默认样式都设为 ‘零’，而第二种方法，即 normalize.css，则采用了不同的方式，它并非对所有样式进行充值，而是对默认样式进行微调，是它们在不同的浏览器中具有相似的外观。 盒模型CSS 处理网页时，它认为每个元素都包含在一个不可见的盒子里。这就是众所周知的盒模型，这里的盒子由内容区域、内容区 域周围的空间(内边距，padding)、内边距的外边缘(边框，border)和边框外面将元素与相邻元素隔开的不可见区域(外边距，margin)构成 。 宽度、高度和盒模型关于 CSS 的 Width 属性对元素所显示宽度的影响，默认的处理方式实际上有悖常理。浏览器中元素的宽度与其 width 属性并不一致。CSS 中的宽度指示的是内边距里内容区域的宽度，而元素在浏览器中的显示宽度则是内容宽度、左右内边距和左右边框的总和。显示高度与之类似，只不过计算的是上下内边距和边框值。 通过对元素设置 box-sizing: border-box ，可以使元素的显示宽度就等于 width 属性的值。 控制元素的显示类型和可见性每个元素在默认情况下要门显示在单独的行要么显示在行内，造成这种原因的本质是它们的 display 属性，即块级元素被设置为 display：block（对于 li 元素为 display：list-item，而行内元素被设置为 display：inline）。 不过，可以使用 CSS 改变元素的默认显示类型。 指定元素的显示方式 ： 123456{ display: block; // 让元素显示为块级元素，就像开始新的段落 display: inline; // 让元素显示为行内元素 display: inline-block; // 让元素显示为行内元素，同时具有块级元素的特征 display: none; // 隐藏元素} 控制元素的可见性 ： 使用 visibility 属性可以控制元素是否可见。与 display 不同的是，使用 visibility 隐藏元素时，元素及其内容应该出现的位置会留下一片空白区域。 123em { visibility: hidden;} 设置为 display：none；或 visibility：hidden；的元素里的所有内容，包括后代都会受到影响。 设置元素的高度和宽度可以为很多元素设置高度和宽度，如分块内容、段落、列表项、div、图像、video、 表单元素等。 同时，可以为短语内容元素(默认以行内方式显示)设置 display: block; 或 display: inline-block;，再对它们设置宽度 或高度。 1234em { width: w; // w 是元素内容区域的宽度，可以表示为长度或父元素的百分数 height: h; // h 是元素内容区域的高度，只能表示为长度} 需要注意的是，内边距、边框和外边距都不包含在宽度或高度的数值里。 可以使用 * 通配符对所有元素应用 border-box 规则 12345* { -webkit-box-sizing: border-box; -moz-box-sizing: border-box; box-sizing: border-box;} 百分数是相对于父元素的宽度的，而不是相对于元素本身的原始宽度的。 如果不显式设置宽度和高度，浏览器就会使用 auto。对于大多数默认显示为块级元素的元素，width 的 auto 值是由包含块的宽度减去元素的内边距、边框和外边距计算出来的。简单说来， 包含块的宽度指的是父元素给元素留出的宽度。 对于图像这样的元素，auto 宽度等于它们固有的宽度，即外部文件实际尺寸大小。 除非你确定元素的内容不会变的更高，最好避免在样式表中指定高度。大多数情况下，可以让内容和浏览器自动控制高度。 在元素周围添加内边距内边距就是元素内容周围、 边框以内的空间。 可以改变内边距的厚度，不能改变它的颜色或纹理。 1234.about { background-color: #2b2b2b; padding: .3125em .625em .625em;} 同 border 和 margin 属性一样，padding 也可以使用简计法： 123padding: 5px; // 应用于全部四个边距padding: 5px 10px; // 前一个应用于上下两边，后一个应用于左右两边padding: 5px 10px 15px; // 分别应用于 上边 左右两边 下边 默认的情况下，元素的 width 和 height 不包含 padding 的大小，并且，内边距是不继承的。 当 em 值用于内边距和外边距时，它的值是相对于元素的字体大小的，而不是相对于父元素的字体大小的。 设置边框可以在元素周围创建边框，或针对元素的某一边设置边框，并设置它的厚度、风格和颜色。边框可以应用于任何元素，包括图像。 如果希望对一个以上的元素设置相同的边框样式， 最好引入一个类，从而可以复用 。 123.em { border-top: 5px solid #019443;} 定义边框的风格 ： 123456789border-style: none;border-style: dotted;border-style: dashed;border-style: solid;border-style: double;border-style: groove;border-style: ridge;border-style: inset;border-style: outset; 定义边框宽度和颜色 ： 12border-width: n;border-color: color; border 简写属性及各个边框属性 (border-width、border-style 和 border- color)均可接受一至四个值。如果使用一个值，那么它会应用于全部四个边。如果使用两个值，那么前一个值会应用于上下两边， 后一个值会应用于左右两边。如果使用三个值，那么第一个值会应用于上边，第二个值会应用于左右两边，第三个值会应用于下边。 如果使用四个值，那么它们会按照时钟顺序， 依次应用于上、右、下、左四个边。 设置元素周围的外边距外边距是元素与相邻元素之间的透明空间。 123em { margin: 1.25em 0 .8em;} 如果元素位于另一个元素的上面，对 于相互接触的两个 margin(即元素相互接触的下外边距和上外边距)，仅使用其中较大的一个，另一个外边距会被叠加。左右外边 距不叠加。 使元素浮动可以通过 float 属性使得元素浮动在文本或其它元素上。可以使用这种技术让文本环绕在图像或者其它元素周围，也可以使用这种技术创建多栏布局。 12345{ float: left; // 让元素浮动在左边，其它内容环绕在它右边 float: right; // 让元素浮动在右边，其它内容环绕在它左边 float: none; // 让元素不浮动} 需要注意的是，float 属性是不继承的。 控制元素浮动的位置123456{ clear: left; clear: right; clear: both; clear: none;} 使用 clear 属性清除浮动效果。如果对某个元素使用该属性，该元素和它后面的元素就会显示在浮动元素的下面。应该将 clear 属性添加到不希望环绕浮动对象的元素上。 浮动元素的 display 属性会变成 display: block; ，哪怕将其设置为 display: inline;，该属性值依然为 block。 浮动元素并不影响父元素的高度。如果要让浮动元素的祖先元素在高度上包含浮动元素，并消除浮动，可以使用 clearfix 或 overflow 方法。 12345678910111213.clearfix::before,.clearfix::after { content: &quot; &quot;; display: table;}.clearfix::after { clear: both;}.clearfix { *zoom: 1;} 对元素进行相对定位每个元素在页面的文档流中都有一个自然位置。相对于这个原始位置对元素进行移动就称为相对定位。 1234567{ position: relative; top: 16px; right: 1em; bottom: 16px; left: 1em;} 其它元素不会受到便宜的影响，仍然按照这个元素原来的盒子进行排列。设置了相对定位的内容可能与其它内容重叠。 使用相对定位、绝对定位或固定定位时，对于相互重叠的元素，可以用 z-index 属性指定它们的叠放次序。 对元素设置 position: static，可以覆盖 position: relative 设置。static 是元素的默认值，这就是元素出现在常规文档流中的原因。 而且定位是不继承的。 对元素进行绝对定位正如前面提到的，网页中的元素通常按照它们在 HTML 源代码中出现的次序进行排列，除非你使用 CSS 规则改变前面的样式。而通过对元素进行绝对定位，即指定它们相对于 body 或最近的已定位祖先元素的精确位置，可以让元素脱离正常的文档流。这与相对定位不同，绝对定位的元素不会在原先的位置留下空白。这与让元素浮动也不同。对于绝对定位的元素，其他元素不 会环绕在它的周围。事实上，其他内容不知道它的存在，它也不知道其他内容的存在。 12345{ position: absolute; top: 32px; right: 2em;} 由于绝对定位的元素脱离了文档流， 因此它们可能会相互重叠，或与其他元素重叠 。如果不为绝对定位的元素指定偏移量，这个元素将显示在它的自然位置上，但不会影响后续元素在文档流中的位置。 还有一种定位类型称为固定定位。 当访问者滚动浏览器窗口时，页面内容通常随之上下移动。如果对元素设置 position: fixed;，它就会固定在浏览器窗口中。当访问者上下滚动浏览器窗口时，该元素不会随之移动，页面的其余部分仍照常滚动。 在栈中定位元素当你开始使用相对定位、绝对定位和固定定位以后，很可能发现元素相互重叠的情况，这时可以选择哪些元素应该出现在顶层。 123{ z-index: 100; // z-index 的值越大，元素在堆中就越高。} 注意，z-index 属性仅对定位过的元素有效且是不继承的。 处理溢出当元素溢出盒子时，可以使用 overflow 属性控制元素在盒子外面的部分。 123456{ overflow: visible; // 让元素盒子中的所有内容可见，默认项 overflow: hidden; // 隐藏盒子容纳不了的内容 overflow: scroll; // 无论元素是否需要，都在元素上添加滚动条 overflow: auto; // 让滚动条仅在访问者访问溢出内容时出现} 垂直对齐元素可以使用除默认对齐方式以外的多种方式对齐元素，让它们在页面上显得较为整齐 。 12345678910{ vertical-algin: baseline; // 使元素的基准线对齐父元素的基准线 vertical-algin: middle; // 使元素位于父元素的中央 vertical-algin: sub; // 使元素成为父元素的下标 vertical-algin: super; // 使元素成为父元素的上标 vertical-algin: text-top; // 使元素的顶部对齐父元素的顶部 vertical-algin: text-bottom;// 使元素的底部对齐父元素的底部 vertical-algin: top; // 使元素的顶部对齐当前行里最高元素的顶部 vertical-algin: bottom; // 使元素的顶部对齐当前行里最低元素的底部} 修改鼠标指针一般情况下，由浏览器负责控制鼠标指针的形状。 123456789101112{ cursor: pointer; cursor: default; cursor: crosshair; cursor: move; cursor: wait; cursor: help; cursor: text; cursor: progress; cursor: auto; cursor: e-resize;}","link":"/2016/02/25/css-summary/"},{"title":"CSS 备忘","text":"媒体查询12// 基本形式@media &lt;media-type&gt; and|not|only (&lt;media-feature&gt;) { css-code ... } 媒体类型 类型 描述 all 所有设备 screen 电脑屏幕，平板电脑，智能手机等(默认值，可省略) print 打印机和打印预览 speech 屏幕阅读器等发声设备 媒体特征 https://developer.mozilla.org/en-US/docs/Web/CSS/Media_Queries/Using_media_queries 元素定位 相对定位 relative 遵循相对定位的元素相对于在文档中的正常位置偏移给定的值，但不会影响其它元素的偏移。 它原先占据的位置将会被保留。 绝对定位 absolute 相对定位的元素并未脱离文档流，而绝对定位的元素则脱离了文档流。在不知文档流中的其它元素时，绝对定位的元素不占据空间，它相对于最近的非 static 祖先元素定位。当这样的祖先元素不存在时， 则相对于 ICB(Initial Container Block) 定位。 固定定位 fixed 固定定位元素与绝对定位相似，但其包含块为 viewport 。 但当固定定位的元素的祖先的 transform 属性为非 none 时，定位参考更改为该祖先元素。 viewport 是一个网页的用户可视区域 粘性定位 sticky 粘性定位可以被认为是相对定位和固定定位的结合：元素在跨越特定阈值前为相对定位，之后为固定定位。 必须指定 top, right, bottom, left 四个阈值其中之一，才能使粘性定位生效，否则其行为和相对定位相同。 CSS 选择器简单选择器 类型选择器 element { style properties } 选择所有匹配给定的节点名称的元素 类选择器 .className { style properties } 选择所有拥有给定的类属性的元素 ID 选择器 #idname 基于 id 属性的值来选择一个元素，在一个文档中拥有指定的 ID 的元素应该只有一个 通用选择器 * 选择所有元素 属性选择器 [attr] [attr=value] [attr~=value] [attr|=value] [attr^=value] [attr$=value] [attr*=value] 根据给定的属性的值来选择元素 使用连接符 兄弟选择 A ~ B 选择在 A 之后的所有 B 元素，且 A、B 拥有共同的父元素 相邻兄弟选择 A + B 选择紧跟在 A 元素后的 B 元素，且 A 、B 拥有共同的父元素 后代选择 A B 选择作为 A 元素的后代的 B 元素 子元素选择 A &gt; B 选择作为 A 元素直接后代的 B 元素 伪类selector:pseudo-classes { style property } 用于向某些选择器添加特殊的效果 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// 表示被用户激活(触发)的元素，常用于 &lt;a&gt; 和 &lt;button&gt;:active// 表示任何 radio、checkbox 或 option 元素被选中:checked// 表示任何表单元素的默认状态:default// 表示任何被禁用的元素:disabled// 表示任何没有子元素的元素:empty// 表示元素处于可用状态，即可被激活、选中、按下、输入或获得焦点等:enabled// 用于 @page at-rule，表示被打印文档的第一页:first// 表示一组兄弟元素中的第一个:first-child// 表示一组兄弟元素中同类型的第一个元素:first-of-type// 表示用户使用指向设备和元素交互但是没有激活它的状态:hover// 表示任何处于 indeterminate 状态的表单元素:indeterminate// 表示 &lt;input&gt; 元素的当前值是否处于由 min 和 max 属性限制的的范围之内:in-range:out-range// 表示 &lt;input&gt; 或其它表单元素的内容是否校验失败:invalid:valid// 一组兄弟元素中的最后一个元素:last-child// 一组兄弟元素中同类型的最后一个元素:last-of-type// 表示一个元素还未被访问，匹配任何未被访问的拥有 href 属性的 &lt;a&gt; &lt;area&gt; 或 &lt;link&gt; 元素:link// 选择任何非指定元素的元素:not()// 选择一组兄弟元素中的指定位置的元素:nth-child()// 选择一组兄弟元素中的最末尾位置的元素:nth-last-child// 选择一组兄弟元素中的同类型的最后一个元素:nth-last-of-type// 在一组兄弟元素中选择同类型的元素中指定位置的元素:nth-of-type()// 选择一个没有任何兄弟元素的元素:only-child// 选择一个没有任何同类型兄弟元素的元素:only-of-type// 根据是否设置了 required 属性来选择 &lt;input&gt; &lt;select&gt; 或 &lt;textarea&gt; 元素:optional:required// :target 伪元素element::pseudo-elements { style property } 用于向某些选择器添加特殊的效果 12345678910// 在指定的元素中的末尾创建一个子元素，经常使用 content 属性来向指定的元素添加装饰::after::before//::first-line::first-letter// 选中已经被用户高亮的部分::selection//::slotted","link":"/2018/02/09/css-tips/"},{"title":"GoLang Developer Road Map","text":"Go Developer Roadmap","link":"/2021/05/13/golang-road-map/"},{"title":"HTML5 概览进阶篇","text":"构建响应式网站响应式网站设计(Responsive Web design)的理念是：页面的设计与开发应当根据用户行为以及设备环境(系统平台、屏幕尺寸、屏幕定向等)进行相应的响应和调整。具体的实践方式由多方面组成，包括弹性网格和布局、图片、CSS media query 的使用等。无论用户正在使用笔记本还是iPad，我们的页面都应该能够自动切换分辨率、图片尺寸及相关脚本功能等，以适应不同设备；换句话说，页面应该有能力去自动响应用户的设备环境。响应式网页设计就是一个网站能够兼容多个终端——而不是为每个终端做一个特定的版本。这样，我们就可以不必为不断到来的新设备做专门的版本设计和开发了。 可伸缩的图像默认情况下， 图像显示的尺寸是 HTML 中指定的 width 和 height 属性值。如果不指定这些属性值，图像就会自动按照其原始尺寸显示。此外，你还可以通过 CSS 以像素为单位设置 width 和 height。 显然，当屏幕宽度有限的时候，按原始尺寸显示图像就不一定合适了。使用可伸缩图像技术就可以让图像在可用空间内缩放，但不会超过其本来的宽度。可用空间是由包含图像的元素决定的，它们根据包含它们的元素的尺寸按比例缩放。 123.photo-full { max-width: 100%;} 图像缩放的可用空间是由其父元素建立的内容区域。如果父元素有水平方向上的内边距，可用空间就会相应减小。 可以使用 background-size 属性对背景图像进行缩放(对 IE8 无效)。 弹性布局拥有定宽容器的网页对响应式页面来说并不合适，我们希望页面能进行缩放，并正好适应浏览器视觉区域大小，流式布局就可以做到这一点。 创建弹性布局需要使用百分数宽度，并将它们应用于页面里的主要区域。 元素的百分数宽度基于其父元素提供的可用空间。 123.div-flex { width: 60%;} 还可以对元素设置基于百分数的 margin 和 padding 值。 媒体查询媒体查询增强了媒体类型方法，允许根据特定的设备特性定位样式。 要调整网站的呈现样式，让其适应不同的屏幕尺寸，采用媒体查询特别方便。下面列出了可以包含在媒体查询里的媒体特性 ： width/height/device-width/device-height orientation/aspect-ratio/device-aspect-ratio color/color-index/monochrome resolution/scan/grid -wbkit-device-pixel-ration/-moz-device-pixel-ration 除了 orientation/scan/grid 以外，上述属性均可添加 min- 和 max- 前缀。 指向外部样式表的链接 1&lt;link rel=&quot;stylesheet&quot; media=&quot;logic type and (feature: value)&quot; href=&quot;stylesheet.css&quot; /&gt; 关于样式表中的媒体查询 123456// logic 取值为 only 或 not 或 and// type 媒体类型// feature 预定义的媒体特性@media logic type (feature: value) { /* 目标 CSS 样式规则写在这里 */} 下面是一个例子 12// 仅当媒体类型为 screen 且视觉区域最小宽度为 480px 时加载并使用&lt;link rel=&quot;stylesheet&quot; media=&quot;only screen and (min-width: 480px)&quot; href=&quot;style-480.css&quot; /&gt; 可以使用 and 将多个特性和值的组合串接起来，还可以创建一系列媒体查询（使用逗号分隔每个媒体查询）。在用逗号分隔的媒体查询列表中，如果有一个媒体查询为真，则整个媒体查询列表为真。 123&lt;link rel=&quot;stylesheet&quot; media=&quot;only screen and (min-width: 480px) and (max-width: 767px)&quot; href=&quot;style.css&quot; /&gt;//&lt;link rel=&quot;stylesheet&quot; media=&quot;only print and (color)&quot; href=&quot;color-page.css&quot; /&gt; 通过媒体查询，可以根据设备的媒体属性应用不同的样式。尽管媒体查询包含了很多功能，但其中 min-width 和 max-width 是创建响应式网页时用的最多的。 有时你可能希望为高像素密度设备设定样式。一种常见的用例是为这样的显示屏准备双倍尺寸(2x)的 sprite，从而让图像显得更锋利。 假设你的 sprite 的原始尺寸是 200 像素 ×150 像素，其中每个图像都用 1 像素分隔。创建一个双倍大小的版本(400 像素 ×300 像素)，每个图像之间就有 2 像素的间隔。同时， sprite 中的每个图像都是原始尺寸的 2 倍。针对高像素密度设备，可以使用下面的媒体查询: 1234567@media (-o-min-device-pixel-ratio: 5/4), (-webkit-min-device-pixel-ratio:1.25), (min-resolution: 120dpi) { .class { ··· }} 需要注意， 就是 Internet Explorer 8 及以下的版本不支持媒体查询。这意味着这些浏览器只会呈现媒体查询以外的样式，即基准样式。 使用 CSS3 进行增强网站制作者多年来面临的挑战之一就是，使用 CSS 建立丰富布局的选择是有限的。在大多数情况下，要建立丰富的布局，就需要使用额外的 HTML、CSS 及大量图像。这样做的结果就是，页面变得更为复杂，可访问性降低，浏览器需要花费更长的时间下载和显示页面，同时，页面变得更为脆弱，更难维护。 近年来，浏览器快速吸纳了很多新的 CSS3 属性，让上述情况有了改观。如今，仅使用 CSS 创建圆角、渐变和阴影以及调整透 明度等已经变成现实。结果是网页可以使用更少的标记和图像，这样加载的速度也会变快。 渐进增强和 polyfill渐进增强强调创建所有用户都能访问的基本层面内容和功能，同时为更强大的浏览器提供增强的体验。总结来说，就是网站在不同 Web 浏览器中的外观和行为不一样是完全可以接受的，只要内容是可访问的。 如果你想弥合较弱的浏览器和较强的浏览器之间的差距，可以使用 polyfill 。polyfill 通常使用 JavaScript 来实现，它可以为较弱的浏览器提供一定程度的对 HTML5 和 CSS3 的 API 和属性的支持。同时，当浏览器本身就具有相应的能力时，会不动声色地退而使用官方的支持。需要注意的是这样所通常会对性能产生一定的影响，因为较弱的浏览器运行 JavaScript 的速度要慢很多。 理解厂商前缀CSS3 规范要达到 W3C 的推荐标准(即定稿)状态要经过数年。浏览器则通常在 W3C 开发标准的过程中就会提前实现这些特性。这样，标准在最终敲定之前就能知道哪些地方还能进一步改进。 在包含某个特性的初始阶段，浏览器通常会使用厂商前缀实现这类特性。这样，每个浏览器都可以引入自己的 CSS 属性支持方式，从而可以获取反馈， 而且一旦标准发生改变也不会造成影响。 每个出浏览器都有自己的前缀：-webkit- (WebKit/Safari/及版本的 Chrome)、-moz- (Firefox)、-ms- (Internet Explorer)、-o-(Opera)。应该将前缀放在 CSS 属性名的前面。 如今大多数情况下，一般只需要 -webkit 前缀，而且并非所有的 CSS3 属性都需要使用为浏览器准备的前缀。 为元素创建圆角使用 CSS3，可以在不引入额外的标记或图像的情况下，为大多数元素(包括表单元素、 图像，甚至段落文本)创建圆角 。 123456789.all-corners { -webkit-border-radius: 20px; border-radius: 20px;}.left-corner { -webkit-border-top-left-radius: 40px; border-top-left-radius: 40px;} 同 border、margin 和 padding 属性一样，border-radius 属性也有简写方式 ： 1234.corner { border-radius: 10px 20px; // 左上方、右下方设置为 10px，右上方、左下方设置为 20px border-radius: 20px 0 0 // 左上方设置为 20px ，其它为 0} 创建四个相同的圆角 12345// r 为圆角半径.corner { -webkit-border-radius: r; border-radius: r;} 创建一个圆角 12345678910111213141516// r 为圆角半径.corner-top-left { border-top-left-radius: r;}.corner-top-right { border-top-right-radius: r;}.corner-bottom-left { border-bottom-left-radius: r;}.corner-bottom-right { border-bottom-right-radius: r;} 创建椭圆圆角 1234// x 为水平方向上的半径大小，y 为垂直方向上的半径大小.corner-ellipse { border-radius: x/y;} 不支持 border-radius 的旧的浏览器仅会以方角呈现元素。 添加阴影使用 text-shadow 为段落、标题等元素中的文本添加动态的阴影效果。 1text-shadow: x-offset y-offset blur-radius color; 将 text-shadow 改回默认值 1text-shadow: none; 使用 box-shadow 属性则可以为元素本身添加阴影 ，同时还允许使用两个可选的属性 inset 和 spread。 1box-shadow: x-offset y-offset blur-radius inset spread color; 多重背景为单个 HTML 元素指定多个背景是 CSS3 引入的一个特性。 通过减少对某些元素的需求并制定多重背景便可简化 HTML 代码，并让它容易理解和维护。而且多重背景几乎可以用于任何元素。 123456789101112131415161718192021.weather { background-color: #FFF; background-image: url(fine.png),url(rain.png), url(cloud.png),url(fog.png); background-positin: 50% 102%,100% -150px, 0 -150px,50% 100%; background-repeat: no-repeat,no-repeat, no-repeat,repeat-x;}// 或.weather { background-color: #FFF; background: url(fine.png) no-repeat 50% 102%, url(rain.png) no-repeat 100% -150px, url(cloud.png) no-repeat 0 -150px, url(fog.png) repeat-x 50% 100%;} 渐变背景渐变背景也是 CSS3 中的新特性，通过它可以在不使用图像的情况下创建从一种颜色到另一种颜色的过渡。 CSS 渐变是一个背景图像，因此，属性既可以是 background 简记法，也可以是 background-image。应该始终包含一个为旧浏览器准备的基准 background 定义，并放置在渐变背景的定义之前。默认情况下，线性渐变是从上往下渐变的，因此在属性值中不需要指定to bottom。如果要使用相反的方向，则使用to top。 使用CSS创建渐变有两种主要的方式:线性渐变和径向渐变，每种方式都有不同的必选参数和可选参数。除非指定一种颜色向另一种颜色过渡的位置，否则浏览器会自行决定不同颜色之间的过渡。 使用关键字创建对角线方向的渐变： 1234background: linear-gradient(to bottom right,color,color);background: linear-gradient(to bottom left,color,color);background: linear-gradient(to top right,color,color);background: linear-gradient(to top left,color,color); 指定渐变角度数 1background: linear-gradient(90deg,color,color); 数值代表的是圆周上的点的位置:0 代表最顶端的点，90 代表最左边的点，180 代表最底端的点，270 代表最右边的点。 根据渐进增强的原则，最好为不支持背景渐变属性的浏览器提供一个备用选项。在 CSS 中，它可以位于背景渐变规则的前面。 设置不透明度使用 opacity 属性可以修改元素(包括图像)的透明度。其默认值为 1，可以使用 0.00 至 1.00 之间的两位小数。 1opacity: o;","link":"/2016/04/10/html-css-summary-advanced/"},{"title":"HTML5 概览","text":"学习HTML 5 与 CSS 过程中的的基础知识的概要总结。 网页的构造块尽管网页变得越来越复杂，但是构成它的低层结构依旧十分简单，归纳起来，一个网页主要包括三个部分： 文本内容 - 页面内容纯文字 对其它文件的引用 - 如对文件、音视频文件、样式表和 JavaScript 文件的应用 标记 - 描述文本并确保引用正确工作 以上内容都仅由文本构成，因此网页可以保存为纯文本格式。以下是一个基本的 HTML 页面 ： 123456789&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt; This is a simle html page &lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; ​ 标签 ：元素、属性、值及其它 元素 ：大多数元素既包含文本，也包含其它元素 1234// 习惯上，标签采用小写字母&lt;em&gt;content&lt;/em&gt;// 空元素既不包含文本也不包含其它元素，比如 img&lt;img src=&quot;img.jpg&quot; width=&quot;300&quot; height=&quot;300&quot; alt=&quot;img&quot; /&gt; 属性和值 ：属性包含了元素的额外信息（尽量使用小写字母来编写属性的名称），有的属性可以接受任何值，但是最常见的还是仅接受预定义值的属性 1&lt;em property-name=property-value ··· &gt;&lt;/em&gt; 元素可以有多个属性，每个属性都有自己的值，属性的排列顺序并不重要，它们之间用空格隔开。 布尔属性的值时可选的，因为只要这种属性只要出现就表示其值为真 1&lt;input type=&quot;email&quot; name=&quot;emailaddr&quot; required /&gt; 父元素和子元素 ：如果一个元素包含另一个元素，它就是被包含元素的父元素。 ​ 网页的文本内容元素中包含的文本可能是网页上最基本的成分，不过，当浏览器呈现HTML时，会把文本中的多个空格或者制表符压缩成单个空格，把回车符和换行符转换成单个空格或者直接忽略。 ​ 链接、图像和其它非文本内容网页上的图像、视频、音乐等外部文件实际上并没有放在HTML文件中，而是单独保存的，页面只是简单地引用了这些文件。 ​ 文件名和文件夹名在我们开始写一个html文件之前，需要知道如何命名文件和文件夹才能更加有助于组织文件、使访问者更容易找到并访问你的页面，确保它们的浏览器能够正确地处理页面，以及增强搜索引擎优化。 文件名采用小写字母 使用正确的扩展名 用段横线分割单词 ​ URLURL即 Uniform Resource Locator，统一资源定位符，它包含了关于文件存储位置和浏览器应该如何处理它的信息。 互联网上的每个文件都有唯一的URL。 123456// 第一部分称为模式，浏览器如何处理需要打开的文件，最常见的模式是HTTP、ftp、mailto// 第二部分是文件所在的主机名称// 第三部分是路径，路径包含了到达这个文件的文件夹以及文件自身的名称&quot;http://www.site.com/home/index.html&quot;&quot;ftp://ftp.site.com/pub/proposal.pdf&quot;&quot;mailto:somename@somedomain.com&quot; 有时，URL路径不以文件名结尾，而以一个目录结尾，在这种情况下，URL值得是路径中最后一个目录中的默认文件，通常为index.html。 URL可以使绝对的，也可以是相对的。绝对URL包含了指向目录或文件的完整信息，包括模式、主机名和路径。而相对URL则以自身的位置为参考点，描述文件的位置。 相对URL可以 引用同一目录下的文件 如果目标文件与当前页面在同一个目录中，那么这个文件就只有文件名和扩展名 引用子目录下的文件 如果目标文件在当前目录的子目录中，则相对 URL 为 “子目录名/文件名+扩展名” 引用上层目录的文件 目标文件在当前目录的父目录中，则 “../文件名+扩展名” ​ 基本HTML结构每个HTML文档都应该包含以下基本成分 12345678910&lt;!DOCTYPE html&gt; // 声明页面为HTML5文档&lt;html lang=&quot;en&quot;&gt; // lang=&quot;en&quot; 指定页面内容的默认语言 &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; // charset=&quot;utf-8&quot; 声明文档的字符编码 &lt;title&gt;&lt;/title&gt; // 页面的标题 &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 在文档的head部分，通常要致命页面标题，提供为搜索引擎准备的关于页面本身的信息，加载样式表，以及加载 JavaScript 文件（通常处于性能考虑，大多数时候在页面底部 &lt;/body&gt; 结束后才加载 JavaScript）。 ​ 页面标题每一个HTML页面都必须有一个title 元素，标题应该是简短的、描述性的，而且是唯一的。页面标题通常是搜索引擎的搜索结果中链接的文字，它是判断搜索结果这种页面相关度的重要因素。 值得注意的是，标题中不能包含任何格式、HTML、图像或指向其它页面的链接。 分级标题HTML中有六级标题用于创建页面信息的层级关系，使用好h1、h2 ··· h6 来表示。 1234567891011&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;分级标题&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt; 第一级标题 &lt;/h1&gt; &lt;h2 lang=&quot;es&quot;&gt; 第二级标题 &lt;/h2&gt; &lt;/body&gt;&lt;/html&gt; 对于任何页面来说，分级标题都可以说是最重要的HTML元素，由于标题通常传达的是页面的主题，如果这些标题与搜索词匹配，就会被搜索引擎赋予很高的权重。 创建分级标题时，要避免跳过某些级别，尽管这样做是可以的。 ​ 创建页眉一个页面可以有任意数量的header元素，它们的含义可以根据其上下文而有所不同，处于页面顶端的或接近这个位置的header是整个页面的页眉。通常，页眉包裹网站标志、主导航和其它全站链接。 12345678910···&lt;body&gt; &lt;header role=&quot;banner&quot;&gt; // 可选的 role=“banner” 显式的指出该页眉为页面级别的页眉 &lt;nav&gt; &lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt; &lt;/header&gt;&lt;/body&gt; header 也很适合对页面深处的一组介绍性或导航型内容进行标记，但是，你需要只在必要的时候才使用header，大多数情况下使用 h1 ~ h6 就能满足要求。而且需要注意的是，header 与 h1 ~ h6 元素中的标题是不能互换的，它们都有各自的语意目的。 不能在 header 里嵌套 footer 元素或另一个 header，也不能在 footer 或 address 元素里嵌套 header。 ​ 标记导航HTML的早期版本中没有元素明确表示主导航链接的区域，在HTML5中引入了 nav 元素来表示。nav 中的链接可以指向页面中的内容。但应仅对文档中重要的链接群使用 nav。 12345678910···&lt;body&gt; &lt;header role=&quot;banner&quot;&gt; &lt;nav role=&quot;navigation&quot;&gt; &lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt; &lt;/header&gt;&lt;/body&gt; 需要注意的是，nav 元素不会对其内容添加任何默认样式。 HTML5 规范不推荐对辅助性的页脚链接使用 nav，而且也不允许 nav 嵌套在 address 元素中。 ​ 标记页面的主要区域大多数网页都有一些不同的区域，如页眉、页脚、包含额外信息的附注栏、指向其它网站的链接等等，不过一个页面只有一个部分代表其主要内容，可以将这样的内容放在 main 元素中，该元素在一个页面中仅使用一次。main 元素是HTML5中新添加的元素。 12345&lt;body&gt; &lt;main role=&quot;main&quot;&gt; // 页面的主要内容 &lt;/main&gt;&lt;/body&gt; 与 p、header、footer 等元素一样，main 元素的内容显示在新的一行，除此之外不会影响页面的任何样式。 如果创建的是 Web 应用，则应使用 main 包围其主要的功能。 不能将 main 放置在 article、aside、footer、header 或 nav 元素中。 ​ 创建文章HTML5 的另一个新元素 article ： 12345678910111213141516···&lt;body&gt; &lt;header&gt; &lt;nav role=&quot;banner&quot;&gt; // 包含多个链接的导航 &lt;/nav&gt; &lt;/header&gt; &lt;main role=&quot;main&quot;&gt; &lt;article&gt; &lt;h1&gt; ··· &lt;/h1&gt; &lt;p&gt; ··· &lt;/p&gt; &lt;p&gt; ··· &lt;/p ··· &lt;/article&gt; &lt;/main&gt;&lt;/body&gt; 在HTML5 中，article 并不仅仅用于包含像报纸文章一样的内容，钙元素的严格定义如下 ​ articile 元素表示文档、页面、应用或网站中一个独立容器，原则上是可独立分配或可再用的，就像聚合内容中的各部分。 ​ 定义区块HTML5 中的新元素 section ，用来代表文档或应用中的一个一般区块。在这里，section 是具有相似主题的一组内容，通常包含一个标题。 尽管将 section 定义为 ‘通常的’ 区块，但是不要将它与 div 元素混淆。从语义上讲，section 标记的是页面中的特定区域，而 div 则不传达任何语义。 如果只是出于添加样式的原因要对内容添加一个容器，应使用 div 而不是 section。 可以将 section 嵌套在 article 里，从而显式地标出报告、故事、手册等文章中的不同部分或不同章节。 ​ 指定附注栏有时候，页面中有一部分内容与主体内容相关性没有那么强，可以独立存在，则可以使用 aside 元素来标记它们。 使用 aside 的例子还包括重要引述、侧栏、指向相关文章的一组链接、广告、nav 元素组等。 在HTML中，应该将附注栏内容放在 main 的内容之后，处于 SEO 和可访问性的目的，最好将重要的内容放在前面，你可以通过 CSS 来改变它们在浏览器中的显示顺序。 对于与内容有关的图像，使用 figure 而非 aside。 HTML5 不允许将 aside 元素嵌套在 address 元素中。 ​ 创建页脚元素 footer 同 header 一样，不仅仅只能用在页面底部标记页脚，还可以用在其它地方。footer 元素代表嵌套它的最近的 article、aside、blockquote、body、details、fieldset、figure、nav、section 或 td 元素的页脚。 如果一个 footer 抱着它所在区块的所有内容，它代表的是像附录、索引、版权页、许可协议这样的内容。 不能在 footer 里嵌套 header 或另一个 footer，同时，也不能将 footer 嵌套在 header 或 address 元素里。 ​ 创建通用容器有时候需要在一段内容外围包一个容器，从而可以为其应用 CSS 样式或 JavaScript 效果，div 是一个完全没有任何语义含义的容器，是一个通用容器。 12345678910111213141516171819202122232425262728... &lt;body&gt; &lt;div&gt; &lt;header role=&quot;banner&quot;&gt; &lt;nav role=&quot;navigation&quot;&gt; ... [包含多个链接的无序列表] ... &lt;/nav&gt; &lt;/header&gt; &lt;main role=&quot;main&quot;&gt; &lt;article&gt; &lt;h1 id=&quot;gaudi&quot;&gt;Barcelona's ➝ Architect&lt;/h1&gt; ... [文章的其余内容] ... &lt;h2 id=&quot;sagrada-familia&quot; lang=&quot;es&quot;&gt; ➝La Sagrada Família&lt;/h2&gt; ... [图像和段落] ... &lt;h2 id=&quot;park-guell&quot;&gt;Park Guell&lt;/h2&gt; ... [另一个图像和段落] ... &lt;/article&gt; &lt;/main&gt; &lt;aside role=&quot;complementary&quot;&gt; &lt;h1&gt;Architectural Wonders of ➝ Barcelona&lt;/h1&gt; ... [aside的其余内容] ... &lt;/aside&gt; &lt;footer role=&quot;contentinfo&quot;&gt; &lt;p&gt;&lt;small&gt;&amp;copy; Copyright All About ➝ Gaudí&lt;/small&gt;&lt;/p&gt; &lt;/footer&gt; &lt;/div&gt;&lt;/body&gt; &lt;/html&gt; 值得注意的是，div 元素自身没有任何默认样式，知识器其包含的内容从新的一行开始，不过我们可以对 div 添加样式实现自己的设计。div 对使用 JavaScript 实现一些特定的交互行为或效果也是有帮助的。 尽管始终强调 HTML 用于对内容的含义进行描述，但 div 并不是唯一没有语义价值的元素。span 是与 div 对应的一个元素: div 是块级内容的无语义容器，而 span (写作 这里是内容 )则是短语内容的无语义容器，例如它可以放在段落元素 p 之内。 ​ 使用ARIA改善可访问性WAI-ARIA（Web Accessibility Initiative’s Accessible Rich Internet Applications），无障碍网页倡议，无障碍的富互联网应用。ARIA 是一种技术规范，在HTML 提供相应的语义功能之前，它会使用属性来填补一些语义上的空白。 无障碍访问的意义是让所有的访问者都能获取网站的内容。在大多数情况下，让页面具有无障碍访问的功能并不难。只需对内容使用恰当的 HTML 进行标记，就能改进网站的可访问性。 地标角色ARIA 中的地标角色可以帮用户识别页面区域，对这些区域指定 role 属性就可以了。 地标角色 如何使用及何时使用 role=”main” ：文档的主要内容 与 main 元素是对应关系。最好将其添加到 main 元素，也可以添加到其它表示主体内容的元素，在买个页面只使用一次。 role=”complementary” : 补充性内容 与 aside 元素是对应关系。应将其添加到 aside 或 仅含补充性内容的 div 元素。与 nav 元素是对应关系。 role=”contentinfo” : 内容信息 将其添加至整个页面的页脚，通常为 footer 元素，每个页面仅使用一次。 role=”navigation” : 导航 应将其添加到每个 nav 元素，或其它包含导航型链接的容器。 role=”banner” : 横幅 将其添加到页面级的 header 元素，每个页面只使用一次 即便不适用 ARIA 地标角色，页面看起来也没有任何差别，但是使用它们可以提升使用辅助设备的用户的体验。 ​ 为元素指定类别或 ID 名称可以给 HTML 元素分配唯一的标识符，或指定其属于某个类别，或同时使用标识符和类别。添加 ID 和类别后，就可以对具有给定 ID 或 class 名称的元素添加样式、创建指向具有特定 id 的元素的链接或使用 JavaScript 获取 id 和 class 属性从而对元素添加特定的行为。 12345678910111213141516···&lt;body&gt; &lt;div class=&quot;container&quot;&gt; // 如果要制定多个类别，用空格将不通过的分类名称分开即可 &lt;header role=&quot;banner&quot;&gt; &lt;nav role=&quot;navigation&quot;&gt; &lt;/nav&gt; &lt;/header&gt; &lt;main role=&quot;main&quot;&gt; &lt;article class=&quot;architect gaudi&quot;&gt; &lt;h1 id=&quot;gaudi&quot;&gt;&lt;/h1&gt; // id 几乎可以使任何字符，只要不以数字开头且不包含空格。 &lt;h2 id=&quot;sagrada-familia&quot;&gt;&lt;/h2&gt; &lt;/article&gt; &lt;/main&gt; &lt;/div&gt;&lt;/body&gt; 为一个或多个元素添加 class 属性，就可以对所有这类元素统一进行格式化。 HTML 文档中的每个 id 都必须是唯一的，并且每个元素都只能有一个 id。与此相反的是，一个 class 名称可以分配给页面中任意数量的元素，并且一个元素可以有一个以上的 class。 建议你无论打算如何使用 id 和 class，都应该为它们选择有意义的名称。 ​ 为元素添加 title 属性可以使用 title 属性为网站上任何部分加上提示标签，不过用的最多的是链接。 1234···&lt;ul title=&quot;table of contents&quot;&gt; &lt;/ul&gt; 添加了 title 属性的元素，在用户将访问者将鼠标移到该元素上时，会提示该 title。 ​ 添加注释可以在 HTML 文档中添加注释，表明区块开始和结束的位置，提示某段代码的意图，或者阻止内容显示等。 12345678910111213141516171819...&lt;!-- ==== 开始主体内容 ==== --&gt; &lt;main role=&quot;main&quot;&gt; &lt;article class=&quot;architect&quot;&gt; &lt;h1 id=&quot;gaudi&quot;&gt;Barcelona's Architect&lt;/h1&gt; &lt;!-- 这一段不会显示出来，因为它被注释掉了 &lt;p&gt;Antoni Gaudí's incredible buildings bring millions of tourists to Barcelona each year. &lt;/p&gt; --&gt; &lt;p&gt;Gaudí's non-conformity, already visible in his teenage years ... &lt;/p&gt; ... &lt;/article&gt; &lt;/main&gt;&lt;!-- 结束主体内容 --&gt;&lt;!-- ==== 开始附注栏 ==== --&gt; ... [附注栏内容] ...&lt;!-- 结束附注栏 --&gt;... 注释是不可见的，如果将一些内容注释掉，它们将不会显示出来。 在主要区块的开头和结尾添加注释是一种常见的做法，可以让你或和你一起合作开发的人员将来修改代码变的更加容易。 注释不能嵌套在其它注释里。 ​ 文本除非网站添加了太多视频和图片，否则网页的大部分内容还是文本，针对不同的文本类型，选择不同的 HTML 语义化元素是非常重要的一项能力。 内容显示的样子与其使用的标记是没有关系的，为内容添加样式可以用 CSS 来做。 添加段落HTML 会忽略你在文本编辑器中输入的回车符和其它额外的空格，所以要在网页中开始一个新的段落，应使用 p 元素。 1234567···&lt;body&gt; &lt;h1&gt;&lt;/h1&gt; &lt;p&gt; content &lt;/p&gt;&lt;/body&gt; 默认情况下，浏览器会在标题和段落之间，以及不同的段落之间添加垂直间距。使用 CSS 可以控制所有内容元素的格式 ​ 指定细则HTML5 中，small 表示细则一类的旁注，通常包括免责声明、注意事项、法律限制、版权信息等。small 通常是行内文本中的一小块，而不是包含多个段落或其它元素的大块文本。 1234567···&lt;body&gt; &lt;h1&gt;&lt;/h1&gt; &lt;p&gt; &lt;small&gt; some restrications &lt;/small&gt; &lt;/p&gt;&lt;/body&gt; 用 small 标记页面的版权信息时一种常见的做法。不过，small 只适用于短语，不宜用于标记长的的法律声明。 ​ 标记主要和强调的文本我们一般用 strong 元素表示内容的重要性，而 em 则表示内容的着重点。根据内容需要，这两个元素既可以单独使用，也可以一起使用。 1234567···&lt;body&gt; &lt;h1&gt;&lt;/h1&gt; &lt;p&gt; &lt;strong&gt; &lt;em&gt;&lt;/em&gt; &lt;/strong&gt; &lt;/p&gt;&lt;/body&gt; 浏览器通常将 strong 文本用粗体显示，而将 em 文本以斜体显示。如果 em 是 strong 的子元素，将同时以斜体和粗体显示文本。 不要用 b 元素代替 strong，也不要用 i 元素代替 em。尽管它们在浏览器中显示的样式是一样的，但是它们的含义却很不一样。 可以在标记为 strong 的短语中再嵌套 strong 文本。如果这样做，作为另一个 strong 元素的子元素的 strong 文本的重要程度会递增。这种规则对嵌套在另一个 em 里的 em 文本也适用。 HTML 5 强调元素的语义，而非表现。b 和 i 元素是早期 HTML 遗留下的产物，它们分别用于将文本变为粗体和斜体。 HTML 5 将 b 重新定义为出于实用目的提醒读者注意的一块文字，不传达任何额外的重要性，也不表示其它的语态和语气，用于文档摘要中的关键词、评论中的产品名等。 HTML 5 将 i 重新定义为表示一块不同于其它文字的文字，具有不同的语态和语气，或其它不同于常规之处，用于如分类名称、技术术语、外语里的惯用语等。 ​ 创建图在 HTML 5 之前，并没有专门实现图的元素，开发人员通常会使用不那么理想的 div 元素来实现。通过引入 figure 和 figcaption，HTML 5 改变了这种情况。图可以是图表、照片、图形、插图、代码片段以及其它类似的独立内容。 123456789···&lt;body&gt; &lt;h1&gt; ···&lt;/h1&gt; &lt;p&gt; ··· &lt;/p&gt; &lt;figure&gt; &lt;figcaption&gt;&lt;/figcaption&gt; // figcaption 是 figure 的标题，可选，出现在 figure 内容的开头或结尾 &lt;img src=&quot;chart-revenue.png&quot; width=&quot;180&quot; height=&quot;180&quot; alt=&quot;Revenue chart: Clothing 42%, Toys 36%, Food 22%&quot; /&gt; &lt;/figure&gt;&lt;/body&gt; 需要注意的是，figcaption 元素并不是必需的，但如果包含它，它就必须是 figure 元素内嵌的第一个或最后一个元素。figure 通常情况下包含在 article 中。 ​ 指明引用或参考使用 cite 元素可以指明对某内容源的引用或参考。 123456···&lt;body&gt; &lt;p&gt; &lt;city lang=&quot;it&quot;&gt; ··· &lt;/city&gt; &lt;/p&gt;&lt;/body&gt; 对于要从引用来源中引述内容的情况，使用 blockquote 或 q 元素标记因数的文本。cite 只是用于参考源本身，而不是从中引述的内容。 HTML 5 中，不应使用 cite 作为对人名的引用，但在 HTML 以前的版本中允许这样做。 ​ 引述文本有两个特殊的元素用以标记引述的文本。blockquote 元素表示单独存在的引述，通常更长，但也可能不是，它默认显示在新的一行。而 q 则用于短的引述，如句子里面的引述。 12345&lt;p&gt; &lt;blockquote cite=&quot;引用源&quot;&gt; content &lt;/blockquote&gt;&lt;/p&gt; 浏览器默认对 blockquote 文本进行缩进，cite 属性值则并不会显示出来。 如果 blockquote 中仅包含一个单独的段落或短语，可以不必将其包在 p 中再放入 blockquote。 1234&lt;p&gt; &lt;q&gt; ··· &lt;/q&gt; &lt;q lang=&quot;fr&quot;&gt; ··· &lt;/q&gt;&lt;/p&gt; 如果引述文本的语言与页面默认语言不同，就在 q 元素中添加 lang 属性。 浏览器应对 q 元素中的文本自动加上特定语言的引号，不同的浏览器效果不同。 注意，q 元素引用的内容不能跨越不同的段落，在这种情况下应该使用 blockquote。 ​ 指定时间HTML 5 中使用 time 元素标记时间、日期或时间段，time 是HTML 5 新增的元素。 1234&lt;time&gt;08:45&lt;/time&gt;&lt;time datetime=&quot;2018-05-24T10:00:00&quot;&gt;&lt;/time&gt;&lt;time datetime=&quot;03-29&quot;&gt;&lt;/time&gt;&lt;time datetime=&quot;2h 30m&quot;&gt;&lt;/time&gt; 元素 time 中包含的文本内容会出现在屏幕上，对用户可见，而可选的 datetime 属性则是为机器准备的。该属性需要遵循特定的格式。 如果忽略了 datetime 属性，文本内容就必须是合法的日期或时间格式。datetime 属性不会单独产生任何效果，但它可以用于 Web 应用之间同步日期和时间。 需要注意的是，不能在 time 元素中嵌套另一个 time 元素，也不能在没有 datetime 属性的 time 元素中包含其它元素。 理解有效的时间格式属性 datetime 或没有 datetime 属性的 time 元素，必须提供特定的机器可读格式的日期和时间。 常用的如 YYYY-MM-DDThh:mm:ss ，这种格式如果包含时间，秒是可选的。 如果需要提供毫秒数，则格式为 hh:mm:sss。 如果要表示时间段，最简单的语法为：nh nm ns。 全球日期和时间及时间差在格式 YYYY-MM-DDThh:mm:ss 末尾加上字母 Z，就成了 UTC。 UTC 是主要的全球时间标准，可以通过相对 UTC 时差的方式表示时间。这时不写字母 Z，写上 ‘-’ 或 ‘+’及时差即可，比如： 1985-11-02T17:19:00-02:30 ​ 解释缩写词使用 abbr 元素标记缩写词并解释其含义，但是不必对每个缩写词都使用 addr，只在需要帮助访问者了解改词含义的时候使用。 12&lt;abbr title=&quot;National Football League&quot;&gt;NFL&lt;/abbr&gt;&lt;abbr title=&quot;light amplicfication by stimulated emission of radiation&quot;&gt;laser&lt;/abbr&gt; 使用可选的 title 属性提供缩写词的全程。灵位，也可以将全称放在缩写词后面的括号里。 通常，仅在缩写词第一次出现在屏幕上时给出其全称。 ​ 定义术语在 HTML 中定义术语时，可以使用 dfn 元素对其做语义上的区分。仅用 dfn 包围要定义的术语，而不是包围定义。 123&lt;p&gt; &lt;dfn&gt; ··· &lt;/dfn&gt;&lt;/p&gt; 通常，dfn 元素默认以斜体显示。在是当的情况下可以包住其它短语元素。 如果在 dfn 中添加了可选的 title 属性，其值应与 dfn 术语一致。 ​ 创建上标和下标比主体文本稍高或稍低的字母或数字分别称为上标和下标。HTML 中包含用来定义这两种文本的元素。 12&lt;sub&gt; ··· &lt;/sub&gt; //下标&lt;sup&gt; ··· &lt;/sup&gt; //上标 上标和下标字符会轻微地扰乱行与行之间均匀的间距。不过我们可以使用 CSS 解决这个问题。 ​ 添加作者联系信息实际上，address 元素是用以定义与 HTML 页面或页面的一部分有关的作者、相关人士或组织的联系信息，通常位于页面底部或相关部分内。至于 address 具体表示的是哪一种信息，取决于该元素出现的位置。 如果要为一个 article 提供作者联系信息，就将光标放在该元素内。如果要提供整个页面的作者联系信息，就将光标放在 body 中(更常 见的做法是放在页面级的 footer 里) 。 12345678&lt;footer role=&quot;contentinfo&quot;&gt; &lt;p&gt; &lt;small&gt;&amp;copy;2014 The MrSilent Inc&lt;/small&gt; &lt;/p&gt; &lt;address&gt; Have a question or comment about the site? &lt;a href=&quot;feedback.html&quot;&gt;Contact us&lt;/a&gt; &lt;/address&gt;&lt;/footer&gt; ​ 标注编辑和不再准确的文本有时可能需要将在前一个版本之后对页面内容的编辑标出来，或者对不再准确、不再相关的文本进行标记。有两种用于标注编辑的元素:代表添加内容的 ins 元素和标 记已删除内容的 del 元素。这两个元素既可以单独使用，也 可以一起使用。 del 和 ins 都支持两个属性 : cite 和 datetime。 cite 属性(区别于 cite 元素)用 于提供一个 URL，指向说明编辑原因的页面。 datetime 属性提供编辑的时间。 123456&lt;p&gt; &lt;ul&gt; &lt;li&gt;&lt;del&gt;&lt;/del&gt;&lt;/li&gt; &lt;li&gt;&lt;ins&gt;&lt;/ins&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/p&gt; 同时，s 元素用以标注不再准确或不再相关的内容。 ​ 标记代码如果你的内容包含代码示例或文件名，就可以使 用 code 元素 。 123&lt;p&gt; &lt;code&gt;&lt;/code&gt;&lt;/p&gt; code 元素表示其中的文本是代码或文件名，如果你的代码需要显示 &lt; 或 &gt;，应分别使用 &amp;lt；和 &amp;gt； 而如果显示单独的一块代码，则用 pre 元素保住 code 元素以维持其格式。 123456&lt;p&gt; &lt;pre&gt; &lt;code&gt; &lt;/code&gt; &lt;/pre&gt;&lt;/p&gt; ​ 使用预格式化的文本通常，浏览器会将所有额外的回车和空格压缩，并根据窗口的大小自动换行。预格式化的文本可以保持文本固有的换行和空格。 它是计算机代码示例的理想元素，不过你也可以将它用于文本 。 1234&lt;pre&gt; &lt;code&gt; &lt;/code&gt;&lt;/pre&gt; 对包含重要的空格和换行的文本，pre 元素是非常合适的，因为 pre 内容里的缩进和换行都被保留了。 预格式化的文本通常以等宽字体显示。 ​ 突出显示文本HTML 5 使用 mark 元素实现对特定词语的突出显示。 可以用 CSS 对 mark 元素里的文字应用样式。 1234567&lt;pre&gt; &lt;code&gt; &lt;mark&gt;.greenText&lt;/mark&gt; { color:green; } &lt;/code&gt;&lt;/pre&gt; ​ 创建换行浏览器会根据包含内容的块或窗口的宽 度让文本自动换行。大多数情况下，让内容像这样充满整行是很合适的，但有时你希望 手动地强制文字进行换行。可以使用 br 元素 实现这一要求。 要确保使用 br 是最后的选择，因为该元素将表现样式带入了 HTML，而不是让所有呈现样式都交由 CSS 控制。 12 &lt;br /&gt; 创建 span同 div 一样，span 元素是没有任何语义的。 不同的是，span 只适合包围字词或短语内容， 而 div 适合包含块级内容。 由于 span 没有任何语义，因此应将它作为最后的选择，仅在没有其他合适的元素时才使用它。 ​ 图像当前 Web 上使用最广泛的三种图片格式是 GIF、PNG 和 JPEG。 JPEG 格式适用于彩色照片，因为它包含了大量颜色并进行了合理的压缩，采用这种格式保存的文件相对较小。不过，JPEG 是一种有损格式，在将图像保存为 JPEG 时会丢失一部分原始信息。 PNG 和 GIF 是无损的格式，采用这两种格式对图像进行压缩不会造成品质的损失。相对于 JPEG ，PNG 和 GIF 保存的图像的文件尺寸会大很多。因此，只有在压缩造成的质量损失不可忽略的情况下才使用 PNG 保存照片。 一般来说，如果要选择使用无损格式的图片，那么 PNG 应是优先的选择，因为它对透明度的支持更好，压缩算法也更好，产生的文件更小。 JPEG/PNG-24/PNG-32 均支持超过1600万众的颜色，而 GIF 和 PNG-8 只支持 256 中颜色，所以标识和其它颜色较少的图像通常保存为 PNG-8 格式，而照片和颜色复杂的插图等则应选择支持颜色较多的格式。 ​ 在页面中插入图像可以在网页中放置各种各样的图像，从标志到照片都可以。当访问者浏览网页时，浏览器会自动加载像在 HTML 文档中描述的图像。不过， 图像加载时间跟访问者的网络连接强度、图像尺寸，以及页面中包含的图像个数相关。 1&lt;img src=&quot;corner-market.jpg&quot; /&gt; 在实践中，为了保持良好的文件组织结构，通常将图像保存在单独的文件夹中。 ​ 提供替代文本使用 alt 属性，可以为图像添加一段描述性文本，当图像因为某种原因不显示的时候，就将这段文字显示出来。HTML5 规范推荐将 alt 文本理解为图像的替代性描述 : “一般来说，替代文本是考虑图像未能正常加载的情况下需要呈现 文字。”通常，这意味着 alt 文本可以插入到图像两侧的文本流中，在大多数情况下， 它不应是对图像的描述。 1&lt;img src=&quot;market.jpg&quot; alt=&quot;somen description text&quot; /&gt; 如果图像对内容的价值较小，则可以提供空的替代文 本，即 alt=””。 如果图像与邻近的文本表达的信息相似，也可以将 alt 属性留空。 如果图像是页面设计的一部分，而不是内容的一部分，则应使用 CSS background-image 属性引入该图像，而不是使用 img 标记。 ​ 指定图像尺寸通常我们会在 HTML 中明确指定图像的高度和宽度，这样浏览器就不必花时间来判断图像的尺寸，从而更快地将图像显示出来。 而且指定图像的尺寸，浏览器就可以预留空间，在图像加载的同时让文本显示在周围，保持布局的稳定。 可以通过浏览器或图像编辑软件获取图像的精确尺寸。 1&lt;img src=&quot;market.jpg&quot; width=&quot;300&quot; height=&quot;300&quot; /&gt; ​ 链接链接有两个主要的部分:目标和标签。 使用目标(destination)可以指定访问者点击链接时会发生什么。可以创建链接进入另一个页面、在页面内跳转、显示图像、下载文件、 呼叫电话等等。不过，最常见的是连接到其他网页的链接，其次是连接到其他网页特定位置(称为锚，anchor)的链接。目标是通过编写 URL 定义的，通常只能在(桌面)浏览器的状态栏中看到。 链接的第二个部分是标签(label)，即访问者在浏览器中看到或在屏幕阅读器中听到的部分。激活标签就可以到达链接的目标。 例如，航空公司网站上可能有这样的链接标 签:预订航班。标签可以是文本、图像或二者兼有。浏览器通常会将标签文本默认显示为带下划线的蓝色文字。 指向网页的链接1&lt;a href=&quot;https://www.google.com&quot; rel=&quot;external&quot;&gt;Search with Google&lt;/a&gt; 当要连接的页面与当前页面在同一目录下时，只需文件名即可进行访问。 rel 属性是可选的，它用来描述包含链接的页面和链接指向的页面之间的关系。 HTML 块级链接HTML 5 几乎允许在链接内包含任何类型的元素或元素组。 123456&lt;a href=&quot;giraffe-escapes.html&quot;&gt; &lt;p&gt; ··· &lt;/p&gt; &lt;p&gt;Read more&lt;/p&gt;&lt;/a&gt; ​ 创建锚并链接到锚通常，激活一个链接会将用户带到对应网页的顶端。如果要想用户跳至网页的特定区域，可以创建一个锚，并在链接中引用该锚 。 首先你需要在目标网页中创建一个锚 1234&lt;!-- https://www.site.com/home.html --&gt;&lt;p id=&quot;anchro-name&quot;&gt; ··· &lt;/p&gt; 创建链接到特定锚的链接 1&lt;a href=&quot;https://www.site.com/home.html#anchor-name&quot;&gt;&lt;/a&gt; 如果锚位于页面的底部，且它下面的内容的高度小于浏览器的可视区域的高度， 那么它可能不会显示在窗口的顶部，而是显 示在中间。 ​ 其它类型的链接并非只能创建指向其他网页的链接，其实可以创建指向任何 URL 的链接——RSS 源、 图像、希望访问者可以下载的文件、电子邮 件地址、电话号码等 。 12345&lt;a href=&quot;img/market.jpg&quot;&gt; 链接到图片 &lt;/a&gt;&lt;a href=&quot;media/song.mp3&quot;&gt; 链接到音频 &lt;/a&gt;&lt;a href=&quot;media/movie.mp4&quot;&gt; 链接到视频 &lt;/a&gt;&lt;a href=&quot;mailto:someone@somedomain.com&quot;&gt; 链接到邮箱地址 &lt;/a&gt;&lt;a href=&quot;tel:+18002134567&quot;&gt; 链接到电话 &lt;/a&gt; 对于指向万维网上任何文件(包括图像、 ZIP 文件、程序、PDF 及其他等)的链接，输 入 http://www.site.com/dir/file.ext， 其 中 www.site.com 是主机名称，dir/file.ext 是目标文件的路径。后者包括了文件目录和文件名(以及扩展名)。 对于电子邮件地址，输入 mailto:name@domain.com(不以 http:// 开头)，其中 name@domain.com 是电子邮件地址。 对于电话号码，输入 tel:+(不以 http:// 开头)并紧跟着国家代码和电话号码(所有的号码中都不必包含短横线)。 如果链接指向的文件是浏览器不知道如何处理的类型(例如 Excel 文件)，浏览器将试着打开一个辅助程序来查看这个文件，或试着将它下载到访问者的磁盘上。","link":"/2016/03/05/html-css-summary-basic/"},{"title":"网络编程基础","text":"网络编程TCP/IP 协议TCP/IP 协议的基本概念TCP/IP 协议不是 TCP 和 IP 这两个协议的合称，而是指因特网整个 TCP/IP 协议族。 TCP/IP 是 Transmission Control Protocol / Internet Protocol 的简写，即 ‘传输控制协议/因特网互联协议’，又名网络通讯协议，是 Internet 最基本的协议、Internet 国际互联网络的基础。 TCP/IP 由网络层的 IP 协议和传输层的 TCP 协议组成。 TCP/IP 定义了电子设备如何连如因特网，以及数据如何在它们之间传输的标准。协议采用了4层的层级架构，每一层都呼叫它的下一层所提供的协议来完成自己的需求。通俗而言，TCP 负责发现传输的问题，一旦发现问题就发出信号，要求重新传输，直到所有数据正确地传输到目的地。而 IP 是给因特网每一台联网设备规定一个地址。 参考模型TCP/IP 参考模型TCP/IP 参考模型是首先由 ARPANET 所使用的网络体系结构。这个体系结构在它的两个主要协议出现以后被称为 TCP/IP 参考模型。这一网络协议共分为四层： 网络访问层，即 Network Access Layer，在 TCP/IP 参考模型中并没有信息描述，只是指出主机必须使用某种协议与网络相连。 互联网层，即 Internet Layer，是整个体系结构的关键部分，其功能是使主机可以把分组发往任何网络，并使分组独立地传向目标。这些分组可能是经过不同的网络，到达的顺序和发送的顺序也可能不同。高层如果需要顺序收发，那就必须自行处理对分组的排序。互联网层使用因特网协议(IP, Internet Protocol)。 传输层，即 Transport Layer，使源端和目的端机器上的对等实体可以进行会话。在这一层定义了两个端到端的协议：传输控制协议(TCP，Transmission Control Protocol)和用户数据报协议(UDP，User Datagram Protocol)。 TCP 是面向连接的协议，它提供可靠的报文传输和对上层应用的连接服务。为此，除了基本的数据传输外，它还有可靠性保证、流量控制、多路复用、优先权和安全性控制等功能。 UDP 是面向无连接 的不可靠传输协议，主要用于不需要 TCP 的排序和流量控制等功能的应用程序。 应用层，即 Application Layer，包含所有的高层协议，包括：虚拟终端协议(TELNET, TELecommunications NETwork)、文件传输协议(FPT, File Transfer Protocol)、电子邮件传输协议(SMTP, Simple Mail Transfer Protocol)、域名服务(DNS, Domain Name Service)、网上新闻传输协议(NNTP, Net News Transfer Protocol)和超文本传输协议(HTTP, HyperText Transfer Protocol)。 TELNET 允许一台机器上的用户登录到远程机器上，并进行工作。 FTP 提供了有效地将文件从一台机器上转移到另一台机器上的方法。 SMTP 用于电子邮件的收发。 DNS 用于把主机名映射到网络地址。 NNTP 用于新闻的发布、检索和获取。 HTTP 用于在 WWW 上获取网页。 OSI 参考模型OSI 参考模型是国际标准化组织指定的一个用于计算机或通信系统之间互联的标准体系。 物理层 - 通过物理媒体传输原始字节流 链路层 - 定义网络上数据的格式 网络层 - 决定数据通过哪条物理路径进行传输 传输层 - 通过传输协议传输数据 会话层 - 维护链接并负责控制端口和会话 展示层 - 保证数据的格式时可用并加密的 应用层 - 计算机交互层，在这里应用可以访问网络服务 TCP/IP 特点 TCP/IP 协议不依赖于任何特定的计算机硬件或操作系统，提供开放的协议标准。 TCP/IP 并不依赖于特定的网络传输硬件，所以 TCP/IP 协议能够集成各种各样的网络。 统一的网络地址分配方案，使整个 TCP/IP 设备在网中都有唯一的地址。 标准化的高层协议，可以提供多种可靠的服务。 HTTP 协议开发中，我们经常需要向服务器端发送数据或从服务器端请求特定数据，为了完成数据在客户端和服务器端的传输，我们在传输数据时必须用到 HTTP 协议。 什么是 HTTP 协议？HTTP 协议，即 HyperText Transmission Protocol，超文本传输协议，定义了客户端与服务器端的数据传输规则，让客户端和服务器能够有效地进行数据沟通。 HTTP 的基本性质 HTTP 是简单的 HTTP 是可扩展的 - 通过 HTTP headers 可以轻松对协议进行扩展 HTTP 是无状态，有会话的 - 在同一个连接中，两个执行成功的请求之间是没有关系的 HTTP 请求与响应HTTP 请求HTTP 协议规定，一个完整的 HTTP 请求应包含如下内容 请求行 ：包含请求方法、请求统一资源标示符和 HTTP 版本号。 请求头 ：请求头包含客户端传送给服务器端的附加信息。 Name Description Host 目标服务器的网络地址 Accept 告知服务器端客户端能够接收的数据类型，如 ‘text/html’等 Content-Type 请求体中的数据类型，如 ‘Application/Json; charset=UTF-8’等 Accept-Language 客户端的语言环境，如 ‘zh-cn’ 等 Accept_Encoding 客户端支持的数据压缩格式，如 ‘gzip’ 等 User-Agent 客户端的软件环境 Connection : keep-alive 告知服务器这是一个持久连接 Content-Length 请求体的长度 Cookie 记录着用户保存在本地的用户数据 请求体 ：发送给服务器端的数据 在使用 POST-Multipart 上传请求中请求体就是上传文件的二进制数据。 在使用 GET 请求时，请求体为空。 在普通的 POST 请求中，请求体就是表单数据。 响应状态行 ： 服务器返回给客户端的状态信息，一般包含 HTTP 版本号、状态码和状态码对应的英文名称。 一个典型的状态行如下： 1HTTP/1.1 200 OK HTTP 响应基本与 HTTP 请求相同。 HTTP 的版本HTTP 的主要版本如下 Version Feature &lt; HTTP 1.1 不支持持久连接；无请求头和响应头；客户端的前后请求是同步的。 HTTP 1.1 增加请求头和响应头；支持持久连接；客户端的不同请求之间是异步的。 HTTP 2.0 向下兼容 HTTP 1.1，但只用于 https 网址。 HTTP 缓存缓存是一种保存资源副本并在下次请求时直接使用该副本的技术。当 web 缓存发现请求的资源已经被存储，它会拦截请求，返回该资源的拷贝，而不会去源服务器重新下载。这样带来的好处有：缓解服务器端压力，提升性能(获取资源的耗时更短了)。对于网站来说，缓存是达到高性能的重要组成部分。缓存需要合理配置，因为并不是所有资源都是永久不变的：重要的是对一个资源的缓存应截止到其下一次发生改变（即不能缓存过期的资源）。 缓存操作的目标虽然 HTTP 缓存不是必须的，但重用缓存的资源通常是必要的。然而常见的 HTTP 缓存智能存储 GET 响应。 缓存控制Cache-control 头HTTP/1.1 定义的 Cache-Control 头用来区分对缓存机制的支持情况，请求头和响应头都支持这个属性，你可以通过它提供的不同的值来定义缓存策略。 禁止进行缓存 12Canche-Control: no-store,Canche-Control: no-cache, no-store 强制确认缓存 每次有请求发出时，缓存会将次请求发送到服务器，服务器端会验证请求中所描述的缓存是否过期，若未过期，则缓存才使用本地缓存副本 1Cache-Control: must-revalidate 私有缓存和公共缓存 public 指令表示该响应可以被任何中间人缓存。若指定了 public ，则一些通常不被中间人缓存的页面，将被缓存。 private 则表示该响应是专用于某单个用户的，中间人不能缓存此响应。 缓存过期机制 max-age=&lt;seconds&gt; 指令表示资源能够被缓存的最大时间，这个时间是距离请求发起的时间的秒数。一般用来缓存应用中不会改变的文件，通过手动设置一定的时长以保证缓存有效。 1Cache-Control: max-age=10000 缓存验证确认 当使用了 must-revalidate 指令，那就意味着缓存在考虑使用一个资源时，必须先验证它的状态，已过期的缓存将不被使用 Pargma 头Pargma 是 HTTP/1.1 标准中定义的一个 header 属性，请求中包含 Pargma 的效果跟在头信息中定义 Cache-Control: no-cache 相同，但是 HTTP 的响应头不支持这个属性，所以它不能完全替代 Cache-Control 头。 新鲜度在过期时间之前，缓存资源是新鲜的，否则是陈旧的。一个陈旧的资源是不会被直接清除的，当客户端发起一个请求时，检索到已经有一个对应的缓存副本，则会在此次请求上附加一个 If-None-Match 头，然后再发送给服务器，以此来检查此资源是否依然是新鲜的，若返回 304 (Not Modified) ，则表示该副本是新鲜的，否则返回新的资源。 缓存验证用户点击刷新按钮时会开始缓存验证。如果缓存的响应头信息里含有 Cache-control: must-revalidate 的定义，在浏览的过程中也会触发缓存验证。另外，在浏览器偏好设置里设置 Advanced-&gt;Cache 为强制验证缓存也能达到相同的效果。 当缓存的文档过期后，需要进行缓存验证或者重新获取资源。只有在服务器返回强校验器或者弱校验器时才会进行验证。 ETag作为缓存的一种强校验器，ETag 响应头是一个对用户代理不透明的值。对于像浏览器这样的 HTTP UA，不知道 ETag 代表什么，不能预测它的值是多少。如果资源请求的响应头里含有 ETag， 客户端可以在后续的请求的头中带上 If-None-Match 头来验证缓存。 Last-Modified 响应头可以作为一种弱校验器。说它弱是因为它只能精确到一秒。如果响应头里含有这个信息，客户端可以在后续的请求中带上 If-Modified-Since 来验证缓存。 当向服务端发起缓存校验的请求时，服务端会返回 200 ok 表示返回正常的结果或者 304 Not Modified表示浏览器可以使用本地缓存文件。304 的响应头也可以同时更新缓存文档的过期时间。 需要注意的是 If-None-Match 的优先级高于 If-Modified-Since，两者同时存在的话，按照前者进行校验。 带 Vary 头的响应Vary HTTP 响应头决定了对于后续的请求头，如何判断是请求一个新的资源还会使用缓存的文件。 当缓存服务器收到一个请求，只有当前的请求和原始（缓存）的请求头跟缓存的响应头里的Vary都匹配，才能使用缓存的响应。 HTTP CookiesHTTP Cookie（也叫Web Cookie或浏览器Cookie）是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。Cookie 使基于无状态的 HTTP 协议记录稳定的状态信息成为了可能。 创建 Cookie服务器通过在响应头里面添加一个 Set-Cookie 选项，来使浏览器保存下 Cookie，之后对该服务器的每一次请求中都通过 Cookie 请求头部将 Cookie 信息发送给服务器。 Set-Cookie 响应头部和 Cookie 请求头部 服务器使用 Set-Cookie 响应头部向用户代理发送 Cookie 信息 1Set-Cookie: &lt;name&gt;=&lt;value&gt; 保存 Cookie 信息后，对该服务器发起的每一次新请求，浏览器都会将保存的 Cookie 信息通过 Cookeie 请求头再发送给服务器。 会话期 Cookie 会话期 Cookie 是最简单的 Cookie：浏览器关闭后它会被自动删除，即它仅在会话期内有效。 会话期 Cookie 不需要指定过期时间或者有效期 持久性 Cookie 持久性 Cookie 指定了特定的过期时间或有效期，不会随着浏览器的关闭而被删除。 12Set-Cookie: id=asfwa; Expires=Wed, 21 Oct 2015 07:28:00 GMT; 设定的过期时间只和客户端有关，而不是服务端。 Cookie 的 Secure 和 HttpOnly 标记 标记为 Secure 的 Cookie 只应通过被 HTTPS 协议加密过的请求发送给服务器，但由于 Cookie 固有的不安全性，敏感信息不应该通过 Cookie 传输。 为避免跨域脚本攻击，通过 JavaScript 的 Document.cookie API 无法访问带有 HttpOnly 标记的 Cookie，它们只应发送给服务器。 Cookie 的作用域 通过 Domain 和 Path 标识可以定义 Cookie 的作用域：即 Cookie 应该发送给哪些 URL。 Domain 指定哪些主机可以接受 Cookie，如果不指定，则默认为当前文档的主机，且不包含子域名。如果指定了，则会包含子域名。 Path 指定主机下的哪些路径可以接受 Cookie，以字符 %x2F (即 /) 作为路径分隔符，子路径也会被匹配。 SameSite Cookies SameSite Cookie 允许服务器要求某个 Cookie 在跨站请求时不会被发送，从而可以组织跨站请求伪造攻击。 JavaScript 通过 document.cookies 访问 Cookie 通过 Document.cookie 属性可创建新的 Cookie，也可以通过该属性访问非 HttpOnly 标记的 Cookie。 Cookie 安全当机器处于不安全环境时，切记不能通过 Cookie 存储传输敏感信息。 会话劫持和 XSS 在 Web 应用中， Cookie 常用来标记用户或授权会话。因此，如果 Web 应用的 Cookie 被窃取，可能导致授权用户的会话受到攻击。 HttpOnly 类型的 Cookie 由于阻止了 JavaScript 对其的访问性能而在一定程度上缓解了此类攻击。 跨站请求伪造 通过以下方式可以一定程度上阻止宽展请求伪造： 对用户输入进行过滤来阻止 XSS 任何敏感操作都需要确认 用于敏感信息的 Cookie 只能拥有较短的生命周期 追踪和隐私 第三方 Cookie 每个 Cookie 都会有与之关联的域（Domain），如果 Cookie 的域和页面的域相同，那么我们称这个 Cookie 为第一方 Cookie ，如果 Cookie 的域和页面的域不同，则称之为第三方Cookie。一个页面包含图片或存放在其他域上的资源（如图片广告）时，第一方的 Cookie 也只会发送给设置它们的服务器。通过第三方组件发送的第三方 Cookie 主要用于广告和网络追踪。 禁止追踪 Do-Not-Track 虽然并没有法律或者技术手段强制要求使用DNT，但是通过DNT可以告诉Web程序不要对用户行为进行追踪或者跨站追踪。 欧盟 Cookie 指令 僵尸 Cookie 和删不掉的 Cookie HTTP 访问控制跨域资源共享（CORS）是一种使用额外的 HTTP 头来使运行在一个 origin 上的 web 应用被准许访问来自不同源服务器上的指定的资源的机制，即当一个资源从与该资源本身所在的服务器不同的域、协议或端口请求一个资源时，就会发起一个跨域 HTTP请求。 跨域资源共享标准新增了一组 HTTP 首部字段，允许服务器声明哪些源站通过浏览器有权限访问哪些资源。对那些可能对服务器数据产生副作用的 HTTP 请求方法，浏览器必须首先使用 OPTIONS 方法发起一个预检请求（Preflight Request），从而获知服务端是否允许该跨域请求。服务端确认允许后，才发起实际的 HTTP 请求。 HTTP 消息HTTP 消息是客户端和服务器之间交换数据的方式。它们分为两种类型：由客户端发送的用来在服务器上触发动作的消息和从服务器得到的回应。 HTTP 消息由跨越多行的用 ASCII 编码的文本信息组成。在 HTTP/1.1 和更早期的版本的协议中，消息通过连接明文发送。在 HTTP/2 中，为了优化和性能提升，人类可读的消息被分割成 HTTP 帧。 HTTP Request1234567891011121314151617181920212223// 请求头的名称是大小写不敏感的// Start line// [HTTP Method] [Request Target] [HTTP Version]GET /img/me.png HTTP/1.1GET http://developer.mozilla.org/en-US/docs/Web/HTTP/Messages HTTP/1.1// Headers// Request Headers : 对请求的设置User-AgentAcceptAccept-LanguageAccept-Encoding// General Headers : 作用于消息整体Connection// Entity Headers : 作用与请求的 body 部分，如果 body 部分没有数据，则没有这部分头Content-TypeContent-Length// Body// 大体上分为两类 : 单一资源 body 和多资源 body HTTP Response12345678// Status line// [HTTP Version] [Status Code] [Status Text]HTTP/1.1 404 Not Found// Headers// 与 HTTP Request 结构相似// Body HTTP/2 帧HTTP/1.1 的消息在性能上有着一系列的缺点： Header 不像 body，它不会被压缩 两个报文之间的 header 通常非常相似，但它们仍然在连接中重复传输 无法复用。当在同一个服务器打开几个连接时：TCP 热连接比冷连接更加有效 所以在 HTTP/2 中，消息被分割成嵌入到流中的帧。Headers 和 Body 的帧是分开的，这使得 Headers 帧也可以被压缩。多个流可以被组合在一起，这是一种称为多路复用的技术，它使得 TCP 连接下的传输更有效率。 HTTP 会话在类似 HTTP 的客户端-服务器协议中，会话由三个部分组成： 客户端建立一个 TCP 连接 客户端发送请求，等待回应 服务器处理请求，做出回应 从 HTTP/1.1 起，连接在完成第三部后不再被关闭，客户端被允许发起新的请求，这意味着第二和第三部可以重复进行多次。 客户端-服务器协议中，在 HTTP 中打开一个连接，意味着在底层传输层初始化连接。使用 TCP 时，HTTP 服务器默认的端口号是 80。 HTTP 、Scoket 和 TCP 的区别HTTP 是应用层的协议，TCP 是传输层的协议，而 Socket 是从传输层抽象的一个抽象层，本质是接口。 TCP 连接与 HTTP 连接的区别 HTTP 是基于 TCP的，客户端向服务器端发送一个 HTTP 请求时，第一步就是要建立与服务端的 TCP 连接。 TCP 连接与 Socket 连接的区别 Socket 层只是在 TCP/UDP 传输层上做的一个抽象接口层。 基于 TCP 协议的 Socket 连接同样需要通过三次握手建立连接，是可靠的。 基于 UDP 协议的 Socket 连接不需要建立连接的过程，不管对方能不能收到都会发送过去，是不可靠的。 HTTP 连接与 Socket 连接的区别 HTTP 是短连接，基于 TCP 协议的 Socket 连接是长连接。尽管 HTTP 1.1 开始支持持久连接，但仍无法保证始终连接。 而基于 TCP 协议的 Socket 连接一旦建立成功，除非一方主动断开，否则连接状态一直保持。 HTTP 连接，服务器无法主动发送消息，而 Socket 连接，双发请求的发送没有先后限制。 HTTP 采用 ‘请求-响应’ 机制，在客户端没有发送请求给服务端时，服务端无法推送消息给客服端。 Socket 连接双方类似于 P2P 的关系，可以随时互相发送消息。","link":"/2016/01/02/http-summary/"},{"title":"iOS 与设计模式","text":"iOS 与 设计模式设计模式 (Design Pattern) 是一套被反复使用、多数人知晓、经过分类的、代码设计经验的总结。 我们使用设计模式的目的是为了提高代码可重用性、让代码更容易被理解、保证代码可靠性，使人们可以更加简单方便地复用成功的设计和体系结构。 设计原则开闭原则开闭原则就是说模块应该对扩展开放，而对修改关闭，即模块应该在尽量不修改原来代码的情况下进行扩展。 任何软件都需要面临一个很重要的问题，就是需求会随着时间的推移而发生变化。当软件系统需要面对新的需求时，应该尽量保证系统的设计框架是稳定的。如果一个软件符合开闭原则，那么就可以非常方便的对系统进行扩展并无需修改现有代码，使得系统在拥有适应性和灵活性的同时具备较好的稳定性和延续性。 为了满足开闭原则，需要对系统进行抽象化设计，抽象化是开闭原则的关键。为系统定义一个相对稳定的抽象层，而将不同的实现行为移至具体的实现层中完成。在很多面向对象语言中都提供了接口、抽象类等机制，可以通过它们定义系统的抽象层，再通过具体类来进行扩展。如果要修改系统的行为，无须对抽象层进行任何改动，只需要增加新的具体类来实现新的业务功能即可，这就实现了在不修改已有代码的基础上扩展系统的功能，达到开闭原则的要求。 里氏代换原则里氏代换原则严格表述是这样的 ：如果每一个类型为 S 的对象 o1，都有类型为 T 的对象 o2，使得以 T 定义的所有程序 P 在所有的对象 o1 代换 o2 时，程序的 P 的行为没有变化，那么类型 S 就是 类型 T 的子类型。即所有引用父类的地方必须能透明地使用其子类的对象。 里氏代换原则是实现开闭原则的重要方式之一，由于使用父类对象的地方都可以使用子类对象，因此在程序中尽量使用父类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象。 里氏代换原则需要注意的问题 ： 子类的所有方法必须在父类中声明，或子类必须实现父类中声明的所有方法。为了保证系统的可扩展性，在程序中通常使用父类来进行定义，如果一个方法只存在子类中，在父类中不提供相应的声明，则无法在以父类定义的对象中使用该方法。 应该尽量把父类设计成抽象类或接口，让子类继承父类或实现接口，并实现在父类中声明的方法，运行时，子类实例替换父类实例。 在依照里氏代换原则实现的软件中将一个父类对象替换成它的子类对象，程序将不会产生任何错误和异常，反之则不成立。 依赖倒置原则依赖倒置原则，即抽象应该不依赖于细节，细节应该依赖于抽象，换言之，要针对接口编程，而不是针对实现编程。 依赖倒置原则要求我们在程序代码中传递参数时或在关联关系中，尽量引用层次高的抽象层类，即使用接口和抽象类进行变量类型声明、参数类型声明、方法返回类型声明，以及数据类型的转换等，而不要用具体类去做这些事情。为了确保该原则的应用，一个具体类应该只实现接口或抽象类中声明过的方法，而不要给出多余的方法。 在实现依赖倒置原则时，我们需要针对抽象层进行编程，而将具体类的对象通过依赖注入的方法注入到其它对象中，依赖注入是指当一个对象要与其他对象发生依赖关系时，通过抽象来注入所依赖的对象。常用的注入方式包括 ：构造注入、设值注入和接口注入。构造注入是通过构造函数来传入具体类的对象，设值注入是通过 setter 方法来传入具体类的对象，而接口注入是指通过在接口中声明的业务方法来传入具体类的对象。 在大多数情况下，以上三种设计原则一同出现，开闭原则是目标，里氏代换原则是基础，依赖倒转原则时手段。 接口隔离原则接口隔离原则，使用多个专门的接口，而不是使用单一的接口，即客户端不应该依赖那些它不需要的接口。每一个接口应该承担相对独立的角色，不干不该干的事情，该干的事情都要干。 这里的接口往往有两种不同的含义，一种是指一个类型所具有的方特征的集合，仅仅是一种逻辑上的抽象；另外一种是指某种语言的具体的接口定义，有严格的定义和结构。 当把接口理解成一个类型所提供的所有方法特征的集合的时候，这就是一种逻辑上的概念，接口的划分将直接带来类型的划分。可以把接口理解成角色，一个接口只能代表一个角色，每个角色都有它特定的一个接口，此时，这个原则可称为角色隔离原则。 如果把接口理解成狭义的特定语言的接口，那么接口隔离原则是指接口仅仅提供客户端需要的行为，客户端不需要的行为则隐藏，应该为客户端提供尽可能小的单独的接口。在面向对象编程语言中，实现一个接口就需要实现该接口中定义的所有方法，因此大的总接口使用起来不一定很方便，为了使接口的指责单一，需要将大接口中的方法根据其指责不同分别放在不同的小接口中，确保每个接口使用起来都较为方便。接口应该尽量细化，同时接口中的方法应该尽量少。 单一职责原则单一职责原则是最简单的面向对象设计原则，它用于控制类的粒度大小，即一个类只负责一个功能领域中的相应职责，或者说 ：就一个类而言，应该只有一个引起它变化的原因。 单一职责原则是实现高内聚、低耦合的知道方针，它是最简单但又最难运用的原则。 最少知识法则也叫迪米特法则，即一个软件实体应当尽可能少地与其它实体发生相互作用。 迪米特法则要求我们在设计系统时，应该尽量减少对象之间的交互，如果两个对象之间不必彼此直接通信，那么这两个对象就不应该发生任何直接的相互作用，如果其中的一个对象需要调用另一个对象的某一个方法的话，可以通过第三者转发这个调用。 iOS 中的设计模式单例模式单例模式是一种常见的设计模式。在它的核心结构中只包含一个被称为单例的特殊类。通过单例模式可以保证系统中，应用该模式的类一个类只有一个实例。 我们为什么需要单例模式呢？这是因为，对于系统中的某些类来说，只有一个实例很重要。比如如果不使用机制对窗口对象唯一化，将弹出多个窗口，如果这些窗口现实的内容完全一致，则是重复对象，浪费资源。如果这些窗口现实的内容不一致，则意味着某一瞬间系统有多个状态，与实际不符。 如何保证一个类只有一个实例且这个实例易于被访问呢？一般的解决方法是让类自身负责保存它的唯一实例。这个类可以保证没有其它实例被创建，并且它可以提供一个访问该实例的方法。 单例模式的优点 单例模式会阻止其它对象实例化其自己的单例对象的副本，从而确保所有对象都访问唯一实例。 因为类控制了实例化过程，所以类可以灵活更改实例化过程。 单例模式的缺点 虽然数量很少，但是每次对象请求引用时都要检查是否存在类的实例，将仍然需要一些开销。 可能的开发混淆。 不能解决删除单个对象的问题。 单例模式的代码实现Objective-C : 12345678+ (Singleton *)sharedInstance { static dispatch_once_t onceToken; static Singleton *sharedInstance = nil; dispatch_once(&amp;onceToken, ^{ sharedInstance = [[self alloc] init]; }); return sharedInstance;} Swift : 1234class Singleton { static let sharedInstance = Singleton() private init(){}} 代理模式代理模式也是一种常见的设计模式，为其它对象提供一种代理以控制对这个对象的访问。 代理模式的优点 ： 真实的角色就是实现实际的业务逻辑，不用关心其它非本职责的事物，通过后期的代理完成一件事物，附带的结果就是编程简洁清晰。 代理对象在客户端和目标对象之间起到中介作用 高扩展性 iOS 中的代理模式通过 @protocol 方式实现，用来传递事件或值。 123456@protocol ObjectDelegate@required- (void)requiredImplementDelegateMethod;@optional- (void)optionalImplementDelegateMethod;@end 一般使用 weak 关键字来修饰代理属性，这是为了便面形成循环引用。 观察者模式观察者模式也是 iOS 中常见的设计模式，观察者模式定义了一种一对多的依赖关系，一个或多个观察者对象同时监听某一个对象，当被观察者对象状态发生变化时，会通知所有观察者对象，至于观察者对象如何响应这个通知，则要看具体的实现。 在 iOS 中，观察者模式的实现具体表现为 ：通知机制 (Notification) 和 KVO 机制 (Kev-Value Observing) 通知机制被观察者达到某些触发条件后，发送通知给它的观察者对象。 注册通知接收者 ： 1234[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(respondNotificationMethod) name:@&quot;NotificationName&quot; object:nil]; 发布通知 ： 123[[NSNotificationCenter defaultCenter] postNotificationName:@&quot;NotificationName&quot; object:nil userInfo:@{}]; 在 iOS 9 之后，你不需要在观察者的销毁方法中注销观察者，但是在之前的 iOS 版本中，你必须在销毁方法中注销观察者。 KVO 机制被观察的对象的属性变化时，发送通知给它的观察者对象。 KVO 机制的观察者对象观察的是对象的属性的变化，只有遵循 KVO 变更属性值的方式才会执行 KVO 的回调部分。 添加监听者 ： 1234[self.aProperty addObserver:self forKeyPath:@&quot;propertyName&quot;, options:NSKeyValueObservingOptionNew | NSKeyValueObservingOld context:nil]; 接收到属性变化通知时的回调 ： 123456- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context { // execute code } iOS 通过 Runtime 实现 KVO 机制 ： 假设我们要观察对象 Computer 的 name 属性的变化，运行时 KVO 机制会动态的创建一个名为 NSKVONotifying_Computer 的新类，该类继承自 Computer 对象的本类，且 KVO 机制会重写 NSKVONotifying_Computer 的 name 属性的 setter 方法。这个重写的 setter 方法负责在调用 Computer 的 setter 方法的之前和之后，通知所有观察者 name 属性的更改情况。 在这个过程中，Computer 的 isa 指针被 KVO 机制修改为指向 NSKVONotifying_Computer 类，来实现当前类属性值改变的监听。 KVO 机制的键值观察通知依赖于 NSObject 的 willChangeValueForKey: 和 didChangeValueForKey: 两个方法。 工厂模式工厂模式是常用的实例化对象模式，是用工厂方式代替 new 操作的一种模式。 简单工厂简单工厂模式，又称静态工厂方法模式，是一种创建型模式，是由一个工厂对象决定创建出哪一种产品类的实例。 简单工厂的优缺点 优点 ：简单工厂模式能够根据外界给定的信息，决定究竟应该创建哪个具体类的对象。明确区分了各自的指责和权利，有利于整个软件体系结构的优化。 缺点 ：工厂类集中了所有实例的创建逻辑，包含了过度的判断条件，维护起来不方便。 简单工厂的实现12345678910111213141516171819202122232425262728293031typedef NS_ENUM(NSInteger, InstanceType) { InstanceType_001 = 0, InstanceType_002 = 1, ... = ... InstanceType_n = n-1}+ (id)getInstanceWithParameter:(InstanceType)someType { Switch (someType) { case : InstanceType_001 reture [self initInstance_001]; break; ... case : InstanceType_n reture [self initInstance_n]; break; default : break; } }- (id)initInstance_001 { ...}... - (id)initInstance_n { ...} 工厂方法工厂方法模式，又称多态性工厂模式。在工厂方法模式中，核心的工厂类不再负责所有的产品的创建，而是将具体创建的工作交给子类去做。该核心类成为一个抽象工厂的角色，仅负责给出工厂子类必须实现的接口，而不负责哪一个产品类应当被实例化这种细节。 工厂方法模式就是简单工厂模式的衍生，解决了许多简单工厂模式的问题。它在基类中建立一个抽象方法，子类可以通过改写这个方法来改变创建对象的具体过程。工厂方法模式让子类来决定如何创建对象，来达到封装的目的。 工厂方法的优点 优点 ： 子类提供挂钩。基类为工厂方法提供缺省实现，子类可以重写新的实现，也可以集成父类的实现，增加了灵活性。 屏蔽产品类。产品类的实现如何变化，调用者都不需要关心，只需要关心产品的接口，只要接口保持不变，系统中的上层模块就不会发生变化。 典型的解耦框架。高层模块只需要知道产品的抽象类，其它的实现类都不需要关心。 多态性，客户代码可以做到与特定应用无关，适用于任何实体类。 抽象工厂模式抽象工厂模式提供一个接口，用于创建一个对象家族，而无需指定具体类。工厂方法只涉及到创建一个对象的情况，有时候我们需要一族对象。 抽象工厂模式是所有形态的工厂模式中最为抽象和最具一般性的一种形态。抽象工厂模式是指当有多个抽象角色时，使用的一种工厂模式。抽象工厂模式可以向客户端提供一个接口，使客户端在不必指定产品的具体的情况下，创建多个产品族中的产品对象。根据里氏替换原则，任何接受父类型的地方，都应当能够接受子类型。因此，实际上系统所需要的，仅仅是类型与这些抽象产品角色相同的一些实例，而不是这些抽象产品的实例。换言之，也就是这些抽象产品的具体子类的实例。工厂类负责创建抽象产品的具体子类的实例。 抽象工厂的优点/缺点 优点： 抽象工厂模式隔离了具体类的生产，使得客户并不需要知道什么被创建。 当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。 增加新的具体工厂和产品族很方便，无须修改已有系统，符合“开闭原则”。 缺点：增加新的产品等级结构很复杂，需要修改抽象工厂和所有的具体工厂类，对“开闭原则”的支持呈现倾斜性。","link":"/2016/02/05/iOS-Design-Pattern/"},{"title":"内存管理理解与分析","text":"iOS 内存管理iOS 中的程序内存结构 在 iOS 程序中，内存可以粗略的分为五个区域： Name Descroption 栈 由操作系统自动分配和释放，常用来存放函数的参数值、局部变量的值等。优点是快速高效，缺点是有限制，数据 堆 一般由程序员分配和释放，常用来存储对象 全局区 用来存储已经初始化的全局变量和静态变量，程序结束时才会被释放回收 常量区 用来存储常量的区域，程序结束时才会被释放回收 代码段 用来存放程序的执行代码，直到程序结束才会释放回首 在 iOS程序中，只有堆区中存放的数据是需要手动释放回收的，其它区域存储的数据的释放和回收都由系统进行管理。当一个 iOS 程序启动后，它的全局区、常量区和代码区就已经确定了。 栈区 (stack) 是由编译器自动分配和释放，用来存放函数的参数值、局部变量等。栈是系统数据结构，对应进程/线程是唯一的。优点是快速高效，缺点是有限制，数据不灵活。 堆区 (heap) 由程序员分配和释放，如果程序员不释放，程序结束时，可能由操作系统回收。优点是灵活方便，数据适应面广泛，但是效率有一定降低。 全局区/静态区 (static) 存放全局变量和静态变量，初始话的全局变量和静态变量存放在一块区域，未初始化的全局变量和静态变量在另一块区域，程序结束后由系统自动释放。 文字常量区，用来存储常量字符串，程序结束后由系统释放。 代码区，存放函数的二进制代码 iOS 中的内存管理 因为 iOS 程序的内存分配中，只有堆区是有程序员进行管理的，所以 iOS 的内存管理大致上就是可以认为是堆区内存的管理。 在 Objective-C 中，使用引用计数来确定一个对象所占有的内存空间是否应该被回收。它的工作原理可以描述为： Objective-C 中的每一个对象都有一个类型为 unsigned long 的 retainCount 的属性，这个属性由拥有它的对象进行维护。当我们新创建出这个对象的一个实例时，这个对象实例的 retainCount 值为1，每当一个新的引用指向对象，对象的 retainCount 值就会增加1，每当这个对象实例的引用减少一个，retainCount 的值就减少1。当着对象实例的 retainCount 的值为0时，代表这个对象实例没有被引用，系统会自动将这个对象实例的内存空间回收并同时调用这个实例对象的 dealloc 方法。 需要注意的几个问题： 常量是没有引用计数的 使用对象实例的属性值进行赋值，不会引用这个对象 释放对象实例时会调用 dealloc 方法，如果没有调用则会造成内存泄漏 对引用计数为1的对象实例发送 release 消息时，系统不会再对其进行 retainCount - 1 的操作。 MRC 和 ARC使用对象实例的引用计数来进行 iOS的内存管理，分为两种方式： MRC ：手动引用计数，由程序员手动的管理对象实例的引用计数 ARC ：自动引用计数，是基于 MRC 的，系统自动的管理对象实例的引用计数 实际上在 iOS 5 之后，Apple 就开始推荐使用 ARC 来进行 iOS 程序的内存管理工作，目前 MRC 已经非常少见。 ARC 中，编译器会在编译时在代码中插入合适的 retain 和 release 语句。 ARC 中的修饰符ARC 中有四种修饰符 Name Description __strong 强引用，默认值，持有所指向对象的所有权 __weak 弱引用，不持有所指向对象的所有权，所指向的对象销毁后，引用会自动置为 nil __autoreleasing 自动释放对象的引用，一般用来传递参数 __unsafe_unretained 为兼容 MRC 出现的修饰符，可看成 MRC 下的 weak 属性的内存管理常见的属性修饰符 Name Description assign 直接赋值，一般用来修饰基本数据类型。修饰 Objc 对会造成野指针 retain 保留新值，再释放旧值，再设置新值 copy 拷贝新值，再释放旧值，再设置新值 weak ARC 新引入，可代替 assign，自动置 nil strong ARC 新引入，可代替 retain block 的内存管理使用@property声明一个 block 时，使用 copy 来修饰。 block 会对内部使用的对象进行强应用，在使用时可能会造成循环引用，可通过添加弱引用标记来解决： 1__weak typeof(self) weakSelf = self; Autorelease &amp; AutoreleasePool在实际的情境中，经常会遇到不知道一个对象实例再什么时候不再使用，因而造成不知道应该何时才能将其释放的情况。Objective-C 中提供了 autorelease 方法来解决这个问题。 当给一个对象实例发送 autorelease 消息时，它会被添加到合适的自动释放池中，当自动释放池销毁时，会给自动释放池中的所有对象实例发送 release 消息。 autorelease 不会改变对象的引用计数。 创建自动释放池的两种方法： 1234567// 1NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];[pool release];// 2@autoreleasepool { } 值得注意的是自动释放池实质上只是在销毁时给其中的所有对象发送了 release 消息，并不保证对象一定会被销毁。 内存管理问题和解决方案僵尸对象和野指针僵尸对象是指内存已经被回收的对象，而野指针是指向僵尸对象的指针。 向野指针发送消息会导致程序崩溃，就是经典的 : EXC_BAD_ACCESS 错误。 所以为了避免产生僵尸对象和野指针，在对象释放后，应将其指针置为 nil。 循环引用当对象之间相互拥有彼此的强引用，形成闭环引用时，就称为循环引用。 循环引用会造成程序内存消耗过高、程序闪退等问题。 以下几种情况可能会造成循环引用： 由于父类指针可以指向子类对象，当父类对象和子类对象相互引用时，就造成了循环引用 作为对象属性的 block 中强引用了对象，造成循环引用，解决方法如下： 12345__weak typeof(self) weakSelf = self; self.testObject.testCircleBlock = ^{ __strong typeof (weakSelf) strongSelf = weakSelf; [strongSelf doSomething];}; 使用 strong 修饰符修饰代理属性，造成循环引用 作为属性的 NSTimer，造成循环引用 循环中对象占用内存大常见于循环次数较大，循环体生成的对象占用内存较大的情景。 可通过在循环中创建自己的 autoreleasePool 或及时释放占用内存大的 临时变量来解决。","link":"/2015/12/01/iOS-Memory-Management/"},{"title":"多线程编程基础","text":"iOS 多线程进程与线程进程进程(Process)是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础，是正在运行的程序的实例(An instance of a computer program that is being executed)。 进程的概念主要有两点： 进程是一个实体。每一个进程都有它自己的地址空间，一般情况下，包括文本区域(Text Region)、数据区域(Data Region)和堆栈(Stack Region)。文本区域存储处理器执行的代码；数据区域存储变量和进程执行期间使用的动态分配的内存；堆栈区存储着活动过程调用的指令和本地变量。 进程是一个执行中的程序。 线程线程是程序执行流的最小单元。一个标准的线程由线程ID、当前指令指针、寄存器集合和堆栈组成。另外，线程是进程中的一个实体，是被系统独立调度和分配的基本单位，线程自己不拥有系统资源，只拥有一点在运行中必不可少的资源，但它可以与同属一个进程的其它线程共享进程所拥有的全部资源。 进程与线程的关系与区别进程是资源分配的基本单位。所有与该进程有关的资源，都被记录在进程控制块PCB中，以表示该进程拥有这些资源或正在使用它们。另外，进程也是抢占处理机的基本单位，它拥有一个完整的虚拟地址空间。当进程发生调度时，不同的进程拥有不同的虚拟地址空间，而同一进程内的不同线程共享同一地址空间。 与进程相对应，线程与资源分配无关，它属于某一个进程，并与进程内的其它线程一起共享进程的资源。线程只由相关堆栈、寄存器和线程控制表TCB组成。寄存器可被用来存储线程内的局部变量，但不能存储其它线程的相关变量。 通常在一个进程中可以包含多个线程，它们可以利用进程所拥有的资源。在引入线程的操作系统中，通常都是把进程作为分配资源的基本单位，而把线程作为独立运行和独立调度的基本单位。由于线程比进程更小，基本上不拥有系统资源，故对它的调度所付出的开销就会小得多，能更叫高效的提高系统内多个程序之间并发执行的程度。 线程和进程区别： 地址空间和其它资源：进程之间相互独立，同一进程的各线程间共享。某进程内的线程在其它进程不可见。 通信：进程间通信主要方式有管道、系统IPC(消息队列、信号、共享存储)、套接字(Socket)。而线程间可以直接读写进程数据段来进行通信(需要进程同步和互斥手段的辅助，以保证数据的异质性) 调度和切换：线程上下文切换比进程快的多。 在多线程OS中，进程不是一个可执行的实体 线程安全线程安全就是多线程访问时，采用了加锁机制，当一个线程访问该类的某个数据时，进行保护，其它线程不能进行访问直到该线程读取完，其它线程才可以使用。 iOS中的多线程目前在iOS中有四种多线程解决方案： Pthreads NSThread GCD NSOperation &amp; NSOperationQueue PthreadsPOSIX线程，简称Pthreads，是线程的POSIX标准。该标准定义了创建和操作线程的一整套API。在类Unix操作系统中，都使用Pthreads作为操作系统的线程。 NSThreadNSThread是经常Apple封装的完全面向对象的。你可以直观方便的操控线程对象，但是生命周期需要手动管理。 GCDGCD是Apple为多核的并行运算提出的的解决方案，能够自动合理地利用更多的CPU内核，并自动管理线程的声明周期。GCD使用C进行编写，并使用了Block。 ####任务 即代码所要完成的操作。 任务的执行方式有两种：同步执行和异步执行。 同步执行操作，它会阻塞当前线程并等待任务执行完毕，然后当前线程才会继续往下运行。 异步执行操作，则不会阻塞当前线程，当前线程会直接往下执行。 队列用于存放要执行的任务。 串行队列中的任务，GCD会遵循FIFO原则来执行，串行队列的同步执行任务，会在当前线程一个一个执行，而异步执行任务，则会在它线程中一个一个执行。 并行队列中的任务执行顺序则要复杂一点，任务会根据同步或异步有不同的执行方式。并行队列中的同步执行任务会在当前线程中一个一个执行，而异步执行则会开很多线程一起执行。 如何创建队列？ 主队列：特殊的串行队列，主要用于刷新UI，任何需要刷新UI的工作都必须在主队列中执行。 dispatch_queue_t mainQueue = ispatch_get_main_queue(); 自己创建的队列： 创建串行队列 dispatch_queue_t serialQueue = dispatch_queue_create(&quot;CustomSerialQueue&quot;,DISPATCH_QUEUE_SERIAL); ​ 创建并行队列 dispatch_queue_t concurrentQueue = dispatch_queue_create(&quot;CustomConcurrentQueue&quot;,DISPATCH_QUEUE_CONCURRENT); 全局队列：这是一个并行队列，并行任务一般都加入到这个队列。 dispatch_queue_t globalQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,0) 如何创建任务？ 创建同步任务 dispatch_sync(,^{// execute code)); 创建异步任务 dispatch_async(,^{// execute code}); 队列组队列组可以将很多队列添加到一个组里，当组中的所有任务都执行完了，队列组将会通知给用户。 dispatch_group_enter 和 dispatch_group_leave 分别表示一个任务追加到队列组和一个任务执行完毕离开了队列组。 只有当group中未执行完毕的任务数量为0时，才会使 dispatch_group_wait 解除阻塞，以及执行追加到 dispatch_group_notify 的任务。 1234567891011121314151617181920212223dispatch_group_t group = dispatch_group_create();dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIOITY_DEFAULT,0);dispatch_group_async(group, queue, ^{ // execute code});// 向group中添加在主队列中执行的任务dispatch_group_async(group, dispatch_get_main_queue(),^{ // execute code});// 向group中追加任务dispatch_group_enter(group);dispatch_async(queue，^{ // execute code dispatch_group_leave(group);});// 直到前面加入到group中的所有任务都执行完毕后，才会执行dispatch_group_notify(group,dispatch_get_main_queue(),^{ // execute code});OR// 直到前面加入到group中的所有任务都执行完成后，才会继续往下执行dispatch_group_wait(group, DISPATCH_TIME_FOREVER); GCD的信号量机制并发队列可以分配多个线程，同时处理不同的任务，虽然提升了效率，但是多线程的并发是通过时间片轮转的方法实现的，线程的创建、销毁、上下文切换等会消耗资源。适当的并发可以提高效率，但是无节制的并发，则会抢占CPU资源，造成性能下降。此外，提交给并发队列的任务中，有些任务内部会有全局的锁，会导致线程休眠、阻塞，一旦这类任务过多，并发队列还需要创建新的线程来执行其它任务，会造成线程数量的增加。 因此控制并发队列中的线程数量就成了不能忽视的问题。 GCD并发线程数量控制GCD中的信号量（dispatch_semaphore）是一个整形值，有初始计数值，可以接收通知信号和等待信号。当信号量收到通知信号时，计数+1；当信号量收到等待信号时，计数-1。如果信号量为0，线程会被阻塞，直到信号量大于0，才会继续执行。 使用信号量机制可以实现线程的同步，也可以控制最大并发数。 使用GCD信号量机制实现并发线程数量控制12345678910111213141516dispatch_queue_t workConcurrentQueue = dispatch_queue_create(@&quot;WORK_CONCURRENT_QUEUE&quot;,DISPATCH_QUEUE_CONCURRENT);dispatch_queue_t workSerialQueue = dispatch_queue_create(@&quot;WORK_SERIAL_QUEUE&quot;,DISPATCH_QUEUE_SERIAL);int maxConcurrent = 10;dispatch_semaphore_t semaphore = dispatch_semaphore_create(maxConcurrent);for (NSInteger i = 0; i &lt; 10; i++) { dispatch_async(workSerialQueue, ^{ // 使信号量-1，当信号量为0时就一直等待，即阻塞所在线程 // 这里使信号量 maxConcurrent-1，表示最大并发数量已被占用一个位置 dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER); dispatch_async(workConcurrentQueue, ^{ // 发送一个信号，让信号量+1 // 这里使信号量 maxConcurrent+1，表示任务被执行，释放了最大并发数量中的一个位置 dispatch_semaphore_signal(semaphore); }); });} 使用GCD信号量机制实现线程同步有时候我们会遇到需要异步执行一些耗时任务，并在这些任务完成后进行一些额外的操作，相当于将异步执行任务转化为同步执行任务。 1234567891011dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);dispatch_semaphore_t semaphore = dispatch_semaphore_create(0); dispatch_async(queue, ^{ // 执行耗时任务 ··· // 任务完成后使信号量+1，被阻塞的线程继续执行 dispatch_semaphore_signal(semaphore); });// 如果信号量为0，则会阻塞当前线程，直到信号量dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER); 使用GCD信号量机制实现线程安全如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其它变量的值也和预期的是一样的，就是线程安全的。 123456789dispatch_semaphore_t semaphoreLock = dispatch_semaphore_create(1);// 相当于加锁dispatch_semaphore_wait(semaphoreLock, DISPATCH_TIME_FOREVER);{ // 需要保证安全的执行代码}// 相当于解锁dispatch_semaphore_singal(semaphoreLock); GCD的一些使用场景使用GCD实现延迟执行12345dispatch_queue_t queue = dispatch_ger_gloabl_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);double delay = 3;dispatch_after(dispatch_time(DISPATCH_TIME_NOW), (int64_t)(delay*NSEC_PER_SEC)), queue, ^{ // execute code}); 使用GCD实现单例模式12345678static id _instance;+ (instancetype)sharedInstance { static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^{ // initial code }); retur _instance;} 任务同步我们有时需要异步执行两组操作，而且第一组操作执行完之后，才能开始执行第二组操作。这样我们就需要一个相当于 栅栏 一样的一个方法将两组异步执行的操作组给分割起来，当然这里的操作组里可以包含一个或多个任务。这就需要用到dispatch_barrier_async方法在两个操作组间形成栅栏。 dispatch_barrier_async 函数会等待前边追加到并发队列中的任务全部执行完毕之后，再将指定的任务追加到该异步队列中。然后在 dispatch_barrier_async 函数追加的任务执行完毕之后，异步队列才恢复为一般动作，接着追加任务到该异步队列并开始执行。 1234567891011121314151617181920dispatch_queue_t queue = dispatch_queue_create(&quot;com.codelei.queue&quot;, DISPATCH_QUEUE_CONCURRENT); dispatch_async(queue, ^{ // Task 1 }); dispatch_async(queue, ^{ // Task 2 }); dispatch_barrier_async(queue, ^{ // 追加的任务 Task 3 }); dispatch_async(queue, ^{ // 追加的任务 Task 4 }); dispatch_async(queue, ^{ // 追加的任务 Task 5 }); 直到 Task 1 和 Task 2 执行完成后，才会执行使用 dispatch_barrier_asynce 追加的任务 Task 3，然后在 Task 3 执行完成后，并行队列会正常执行。 NSOperation &amp; NSOperationQueueNSOperation是Apple对GCD的封装，完全面向对象。NSOperation和NSOperationQueue分别对应GCD的任务和队列。 添加任务NSOperation只是一个抽象类，并不能直接封装任务。它有两个子类NSInvocationOperation和NSBlockOperation用来完成封装任务的操作。创建一个Operation后，需要调用start方法来启动任务，它默认在当前队列同步执行。如果需要在执行途中取消执行一个任务，调用cancel方法即可。 NSInvocationOperation 12NSInvocationOperation *invocationOperation = [[NSInvocation alloc] initWithTarget:self selector:@selector(executeMethod)];invocationOperation start]; NSBlockOperation 12345NSBlockOperation *blockOperation = [NSBlockOperation blockOperationWithBlock:^{ // execute code}];[blockOperation start]; 上面提到，NSInvocationOperation和NSBlockOperation创建的任务默认在当前线程执行，但是NSBlockOperation可以通过addExecutionBlock:方法向Operation中添加多个可执行的Block。这样的Operation中的任务会并发执行，它会在主线程和其它多个线程执行这些任务。 1234567NSBlockOperation *blockOperation = [NSBlockOperation blockOperationWithBlock:^{ // execute code}];[blockOpertation addExecutionBlock:^{ // execute code}];[blockOperation start]; NOTE:addExecutionBlock:方法必须在start方法之前执行，否则会报错。 自定义的Operation 自定义Operation类需要继承Operation类，并实现其main()方法，因为在调用start()方法的时候，内部会调用main()方法完成相关逻辑。 创建队列通过调用一个NSOperation类的start()方法来启动的任务，默认在当前线程同步执行。如果要避免占用当前线程，就需要使用到队列NSOperationQueue。只要将Operation添加到队列，就会自动调用任务的start()方法。 主队列 添加到主队列中的任务时串行执行的。 1NSOperationQueue *mainQueue = [NSOperationQueue mainQueue]; 其它队列 其它队列中的任务会在其它线程并行执行。 12345NSOperationQueue *queue = [NSOperatin alloc] init];NSBlockOperatin *blockOperation = [NSBlockOperation blockOperationWithBlock:^{ // execute code}][queue addOperation:blockOperation]; 如果需要任务在队列中串行执行，可以通过设置NSOperationQueue的maxConcurrentOperationCount来实现。 12NSOperationQueue *queue = [NSOperatin alloc] init];[queue setMaxConcurrentOperationCount:1]; 你还可以通过addOperationWithBlock:方法来向队列中添加新任务。 1234NSOperationQueue *queue = [NSOperatin alloc] init];[queue addOperationWithBlock:^{ // cxecute code}] 添加任务依赖 12345678910111213NSBlockOperation *blockOperationFirst = [NSBlockOperation blockOperationWithBlock:^{ // execute code}];NSBlockOperation *blockOperationSecond = [NSBlockOperation blockOperationWithBlock:^{ // execute code}];NSBlockOperation *blockOperationThird = [NSBlockOperation blockOperationWithBlock:^{ // execute code}];[blockOperationSecond addDependency:blockOperationFirst];[blockOperationThird addDependency:blockOperationSecond];NSOperationQueue *queue = [NSOperatin alloc] init];[queue addOperations:@[blockOperationFirst,blockOperationSecond,blockOperationThird]]; NOTE: 添加相互依赖会造成死锁。 使用removeDependency方法来移除依赖关系 其它方法 NSOperation类的一些其它方法 12345678910// 判断任务是否正在执行BOOL exccuting;// 判断任务是否完成BOOL finished；// 设置任务完成后的后续操作void (^completionBlock) (void);// 取消任务- (void)cancle;// 阻塞当前线程直到此任务执行完毕- (void)waitUntilFinished; NSOperationQueue 12345678// 获取队列的任务数量NSUInteger operationCount;// 取消队列中的所有任务- (void)cancelAllOperations;// 阻塞当前线程直到此队列中的所有任务执行完毕- (void)waitUntilAllOperationsAreFinished;// 暂停或继续队列BOOL suspended;","link":"/2015/11/01/iOS-Multi-Thread/"},{"title":"事件传递与响应链探索","text":"iOS App 使用响应者对象( Responder)来接收和处理事件。一个响应者对象是 UIResponder 类的实例，它常见的子类包括 UIView 、UIViewController 和 UIApplication。响应者对象接收原始事件数据，并且必须处理该事件或将它转发给另一个响应者对象。 当你的 App 接收到一个事件时，UIKit 自动将它发送给最适合的响应者对象，即第一响应者对象(First Responder)。未处理的事件从响应者对象被发送到正在活动的响应链中的响应者对象(响应者链是应用程序的响应者对象的动态配置,在应用程序中没有单个响应者链)。 UIKit 为事件如何从一个响应者对象传递到另一个响应者对象预定义了规则，但是你可以通过覆盖响应者对象中的属性来改变这些规则。 响应者对象 (Responder Object)Responder 对象是 UIResponder 类的实例，构成了 UIKit 应用程序事件处理的主干。许多重要对象也是响应者，包括 UIApplication 对象，UIViewController 对象和所有 UIView 对象（包括 UIWindow）。当事件发生时，UIKit 将它们分派给你的应用程序的响应者对象进行处理。UIResponder 对象能处理的事件，包括触摸事件，动作事件，远程控制事件和新闻事件。 为了处理特定类型的事件，响应者必须覆盖相应的方法。例如，为了处理触摸事件，响应者实现了 touchesBegan:with:，touchesMoved:with:，touchesEnded:with: 和 touchesCancelled:with:方法。在触摸事件发生时，响应者使用 UIKit 提供的事件信息来跟踪触摸的变化，并适当地更新应用的界面。 除了处理事件之外，UIKit响应者还负责将未处理事件转发到应用程序的其他部分。如果给定的响应者不处理事件，则将该事件转发给响应者链中的下一个响应者对象。 UIKit 动态地管理响应者链，使用预定义的规则来确定接下来哪个对象应该接收事件。 响应者处理 UIEvent 对象，但也可以通过输入视图接受自定义输入。系统的键盘是输入视图最明显的例子。当用户点击屏幕上的 UITextField 和 UITextView 对象时，视图成为第一响应者并显示其输入视图，这是系统键盘。同样，你可以创建自定义输入视图，并在其它响应者激活时显示它们。要将自定义输入视图与响应者相关联，请将该视图分配给响应者的 inputView 属性。 NOTE 与加速度计、陀螺仪和磁力计相关的运动事件不遵循响应者链。Core Motion 会直接将这些事件发送给你指定的对象。 第一响应者对象 (The First Responder)UIKit 为各种类型的事件指定第一响应者对象并在事件发生时首先发送到第一响应者对象。 Touch events 第一响应者对象是触摸发生的视图 Press events 第一响应者对象是获得焦点的响应者对象 Shake-motion events 第一响应者对象是你或 UIKit 指定的对象 Remote-control events 第一响应者对象是你或 UIKit 指定的对象 Editing menu messages 第一响应者对象是你或 UIKit 指定的对象 控件使用动作消息 (Action message) 与其关联的目标对象 (Target Object) 直接进行通信。当用户与控件进行交互时，控件调用其目标对象的动作方法 (Action Method)，向目标对象(Target object)发送一个动作消息。动作消息不是一个事件，但它们仍可利用响应链。当控件的目标对象为 nil 时，UIKit 从目标对象开始，遍历响应者链，直到寻找到实现了相应方法的对象。 如果视图中有添加手势，那么手势会在视图接收之前接收触摸和按下事件。如果视图中的所有手势都无法处理这个事件，则将事件传递给视图进行处理。如果视图也不能处理，则 UIKit 会将事件传递给响应者链。 基于视图的点击测试 (View-Based Hit-Testing)UIKit 使用基于视图的点击测试来确定触摸事件到底发生在哪里。UIKit 将触摸位置与处在视图层级中的视图的 bounds 进行比较。hitTest:withEvent: 方法遍历视图层级，寻找包含指定触摸的层级最深的子视图。 然后这个视图就成为第一响应者对象。 当用户触摸屏幕进行交互时，系统检测到手指触摸操作，并将触摸以 UIEvent 的方式加入 UIApplication 的事件队列中。UIApplication 从事件队列中取出最新的触摸事件进行分发传递到 UIWindow 进行处理。而 UIWindow 会通过 hitTest:withEvent: 方法寻找触点所在的视图，这个过程称之为 Hit-Test。 UIKit 将每个触摸永久绑定到包含它的视图对象。UIKit 在触摸第一次发生时创建 UITouch 对象，并只在触摸结束时释放它。当触摸位置或其它参数改变时，UIKit 使用新的信息来更新 UITouch 对象。唯一不改变的属性就是包含它的视图，即使触摸位置已经移出原始的视图。 Hit-Test 从顶级视图开始调用 pointInside:withEvevt: 方法判断触摸点是否在当前视图内，如果返回为 NO ，则 hitTest:withEvent: 方法返回 nil；如果返回 YES ，则向当前视图的所有子视图发送 hitTest:withEvent: 消息，所有子视图的遍历顺序是从最顶层视图一直到最底层视图，直到有子视图返回非空对象或者全部子视图遍历完毕。 NOTE 如果一个触摸的位置超出了视图的边界，hitTest:withEvent: 方法就会忽略这个视图及其所有子视图。 响应者链 （Resoponder Chain）当系统通过 Hit-Test 找到触摸点所在的视图，但是这个视图并没有或者无法正常处理此次触摸事件，这个时候，系统便会通过响应者链寻找下一个响应者，以对此次触摸事件进行响应。 如果一个 View 有一个视图控制器，它的下一个响应者就是这个视图控制器，然后才是它的父视图，如果一直到根视图都没能处理这个事件，事件会传递到 UIWindow ，若在 UIWindow 中也没有处理，则会传递给 UIApplication ，它是一个响应者链的终点，它的下一个响应者指向 nil ，以劫数整个循环。 改变响应者链 (Altering the Responder Chain)你可以通过覆盖你的响应者对象中的 nextResponder 属性来改变响应者链。当你这样做时，下一个响应者就是你返回的对象。 很多 UIKit 类已经覆盖了这个属性 : UIView 对象。如果视图是视图控制器的根视图，那它的 nextResponder 是视图控制器，否则是视图的父视图。 UIViewController 对象。 如果视图控制器的视图是一个窗口的根视图，nextResponder 是窗口对象。 如果一个视图是被其它视图控制器推出的，nextResponder 是推出它的视图控制器。 UIWindow 对象。窗口的 nextResponder 是 UIApplication 对象。 UIApplication 对象。只有在应用代理是 UIResponder 的实例而不是视图、视图控制器或者应用对象自身时，UIApplication 的 nextResponder 是应用程序代理。","link":"/2016/01/25/iOS-Responder-Chain/"},{"title":"RunLoop 探索与分析","text":"RunLoop 基础什么是RunLoop？RunLoop 是一种让线程能随时处理事件但并不退出的机制，是一个用来调度工作的和协调接受的事件的循环。 iOS系统中，提供了 NSRunLoop 和 CFRunLoopRef 两个对象来实现 RunLoop。RunLoop 对象管理其需要处理的事件和消息，并提供了一个入口函数来执行事件循环的逻辑。线程执行了这个函数之后，就会一直处于这个函数内部的循环中，直到这个循环结束，函数返回。 CFRunLoopRef 是在 CoreFoundation 框架内的，提供了纯C函数的API，所有这些API都是线程安全的。 NSRunLoop 是基于 CFRunLoopRef 的封装，提供了面向对象的API，但这些API不是线程安全的。 RunLoop与线程的关系线程和 RunLoop 之间是一一对应的，其关系保存在一个全局的 Dictionary 中。线程刚创建是并没有 RunLoop，如果你不主动获取，那它一直不会有。RunLoop 的创建是在第一次获取时发生的，RunLoop 的销毁是在线程结束时发生的。 你只能在一个线程内部获取它的 RunLoop(主线程除外)。 RunLoop的对外接口在 CoreFoundation 中关于 RunLoop 的类有以下几个： CFRunLoopRef CFRunLoopModeRef CFRunLoopSourceRef CFRunLoopTImerRef CFRunLoopObserverRef 一个 RunLoop 包含若干个 Mode ，每个 Mode 又包含若干个 Source/Timer/Observer。每次调用 RunLoop 的主函数时，只能指定其中一个 Mode。如果需要切换 Mode ，只能退出 RunLoop，再重新指定一个 Mode 进入。这样做的目的是为了分隔开不同组的 Source/Timer/Observer，使其不能互相影响。 CFRunLoopSourceRef 是事件产生的地方，有两个版本 Source0 和 Source1： Source0 只包含了一个回调(函数指针)，它并不能主动触发事件。使用时，你需要先调用 CFRunLoopSourceSignal(source)，将这个 Source 标记为待处理，然后手动调用 CFRunLoopWakeUp(runLoop) 来唤醒 RunLoop ，让其处理这个事件。 Source1 包含了一个 mach_port 和一个回调(函数指针)，被用于通过内核和其它线程相互发送消息，它能主动唤醒 RunLoop 的线程。 CFRunLoopTimerRef 是基于时间的触发器，他和 NSTimer 是 toll-free bridge 的，可以混用。包含一个时间长度和一个回调(函数指针)。当其加入到 RunLoop 中时，RunLoop 会注册对应的时间点，当时间点到时，RunLoop 会被唤醒执行那个回调。 CFRunLoopObserverRef 是观察者，每个 Observer 都包含了一个回调(函数指针)，当 RunLoop的状态发生变化时，观察者就能通过回调接收到这个变化。 12345678typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActiviry) { kCFRunLoopEntry = (1UL &lt;&lt; 0), // 即将进入 RunLoop kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1), // 即将处理 Timer kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), // 即将处理 Source kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), // 即将进入休眠 kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6), // 刚从休眠中唤醒 kCFRunLoopExit = (1UL &lt;&lt; 7), // 即将退出 RunLoop}; Source/Timer/Observer 被统称为 Mode Item，一个 item 可以被同时加入多个 Mode。但是一个item被重复加入一个 Mode 不会产生效果。如果一个 Mode 中没有一个 item，则 RunLoop会直接退出，不进入循环。 RunLoop 的ModeCFRunLoopMode 和 CFRunLoop 的结构大致如下： 1234567891011121314struct __CFRunLoopMode { CFStringRef _name; CFMutableSetRef _source0; CFMutableSetRef _source1; CFMutableArrayRef _observers; CFMutableArrayRef _timers;}struce __CFRunLoop { CFMutableSetRef _commonModes; CFMutableSetRef _commonModeItems; CFRunLoopModeRef _currentMode; CFMutableSetRef _modes;} 一个 Mode 可以将自己标记为 “Common” 属性(通过将其 ModeName 添加到 RunLoop 的 “CommonModes”中)。每当 RunLoop 的内容发生变化时，RunLoop 都会自动将 _commonModeItmes 里的 Source/Observer/Timer 同步到具有 “Common” 标记的所有 Mode 里。 CFRunLoop对外暴露的管理 Mode 的接口只有两个： 12CFRunLoopAddCommonMode(CFRunLoopRef runloop, CFStringRef modeName);CFRunLoopRunInMode(CFStringRef modeName); CFRunLoopModeRef 暴露的管理 Mode Item 接口有： 123456CFRunLoopAddSource(CFRunLoopRef runloop, CFRunLoopSourceRef source, CFStringRef modeName);CFRunLoopAddObserver(CFRunLoopRef runloop, CFRunLoopObserverRef observer, CFStringRef modeName);CFRunLoopAddTimer(CFRunLoopRef runloop, CFRunLoopTimerRef timer, CFStringRef modeName);CFRunLoopRemoveSource(CFRunLoopRef runloop, CFRunLoopSourceRef source, CFStringRef modeName);CFRunLoopRemoveObserver(CFRunLoopRef runloop, CFRunLoopObserverRef observer, CFStringRef modeName);CFRunLoopRemoveTimer(CFRunLoopRef runloop, CFRunLoopTimerRef timer, CFStringRef modeName); 你只能通过 mode name 来操作内部的 mode，当你传入一个新的 mode name 时但 RunLoop内部没有对应的 mode 时，RunLoop 会自动的帮你创建对应的 CFRunLoopModeRef。对于一个 RunLoop ，其内部的 mode 只能添加不能删除。 Apple公开提供的 Mode 只有两个：kCFRunLoopDefaultMode(NSDefaultRunLoopMode) 和 UITrackingRunLoopMode，你可以用这两个 Mode Name 来操作其对应的 Mode。 同时 Apple 还提供了一个操作 Common 标记的字符串 : kCFRunLoopModes(NSDefaultRunLoopCommonModes)，你可以用这个字符串来操作 Common Items，或标记一个 Mode 为 “Common”。使用时要注意区分这个字符串和其它 Mode Name。 RunLoop 的内部逻辑123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101// DefaultMode 启动void CFRunLoopRun(void) { CFRunLoopRunSpecific(CFRunLoopGetCurrent(),kCFRunLoopDefaultMode, 1.0e10, false);}// 用指定的 Mode 启动，允许设置 RunLoop 超时时间int CFRunLoopRunInMode(CFStringRef ModeName, CFTimeInterval seconds, Boolean stopAfterHandle) { return CFRunLoopSpecific(CFRunLoopGetCurrent(), modeName , seconds ,returnAfterSourceHandle)}// RunLoop 的实现int CFRunLoopRunSpecific(runloop, modeName ,seconds , stopeAfterHandle) { // 根据 ModeName 找到对应 Mode CFRunLoopModeRef currentMode = __CFRunLoopFinMode(runloop, modeName, false); // 如果 Mode 里没有 source/timer/observer，直接返回 if (__CFRunLoopModeIsEmpty(currentMode)) { return; } // 通知 Observer , RunLoop 即将进入 loop __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopEntry); // 进入 loop __CFRunLoopRun(runloop, currentMode, seconds, returnAfterSourceHandle) { Boolean sourceHandledThisLoop = NO; int retVal = 0; do { // 通知 Observers : RunLoop 即将触发 Timer 回调 __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeTimers); // 通知 Observers : RunLoop 即将触发 Source0 (非port) 回调 __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeSources); // 执行被加入的 block __CFRunLoopDoBlocks(runloop, currentMode); // RunLoop 触发 Source0(非port) 回调 sourceHandledThisLoop = __CFRunLoopDoSource0(runloop, currentMode, stopAfterHandele); // 执行被加入的 block __CFRunLoopDoBlocks(runloop, currentMode); // 如果有 Source1 处于 ready 状态，直接处理这个 Source1 然后跳转去处理消息 if (__Source0DidDispatchPortLastTime) { Boolean hasMsg = __CFRunLoopServiceMachPort(dispatchPort, &amp;msg); if (hasMsg) { goto handle_msg; } } // 通知 Observers : RunLoop 的线程即将结束进入休眠(Sleep) if (!sourceHandleThisLoop) { __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeWaiting); } // 调用 mach_msg 等待接受 mach_port 的消息。线程进入休眠，直到被下面一个事件唤醒 // 1.一个基于 port 的 Source 的事件 // 2.一个 Timer 时间到了 // 3.RunLoop 自身的超时时间到了 // 4.被其它调用者手动唤醒了 __CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort) { mach_msg(msg, MACH_RCV_MSG, port); } // 通知 Observers : RunLoop 的线程刚刚被唤醒了 __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopAfterWaiting); // 收到消息，处理消息 handle_msg; // 如果一个 Timer 的时间到了，触发这个 Timer 的回调 if (msg_is_timer) { __CFRunLoopDoTimers(runloop, currentMode, mach_absolute_time()); } else if (msg_is_dispatch) { // 如果有 dispatch 到 main_queue 的 block ，执行 block __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE_(msg); } else { // 如果有一个 Source1 发出事件了， 处理这个事件 CFRunLoopSourceRef source1 = __CFRunLoopModeFindSourceForMachPort(runloop, currentMode, livePort); sourceHandleThisLoop = __CFRunLoopDoSource1(runloop, currentMode, source1, msg); if (sourceHandleThisLoop) { mach_msg(reply, MACH_SEND_MSG, reply); } } // 执行加入到 Loop 的 block __CFRunLoopDoBlocks(runloop, currentMode); if (sourceHandleThisLoop &amp;&amp; stopAfterHandle) { // 进入 loop 时参数说处理完事件就返回 retVal = kCFRunLoopRunHandledSource; } else if (timeOut) { // 超出传入参数标记的超时时间了 retVal = kCFRunLoopRunTimeOut; } else if (__CFRunLoopIsStoped(runloop)) { // 被外部调用者强行停止了 retVal = kCFRunLoopRunStoped; } else if (__CFRunLoopModeIsEmpty(runloop, currentMode)) { // Source/Timer/Observer 一个都没有了 retVal = kCFRunLoopRunFinished; } // 如果没超时，mode 里没空， loop 也没有被停止，那就继续 loop } while (retVal == 0) }} RunLoop有什么用？App 启动后 RunLoop 的状态 ： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899CFRunLoop { current mode = kCFRunLoopDefaultMode common modes = { UITrackingRunLoopMode kCFRunLoopDefaultMode } common mode items = { // source0 (manual) CFRunLoopSource {order =-1, { callout = _UIApplicationHandleEventQueue}} CFRunLoopSource {order =-1, { callout = PurpleEventSignalCallback }} CFRunLoopSource {order = 0, { callout = FBSSerialQueueRunLoopSourceHandler}} // source1 (mach port) CFRunLoopSource {order = 0, {port = 17923}} CFRunLoopSource {order = 0, {port = 12039}} CFRunLoopSource {order = 0, {port = 16647}} CFRunLoopSource {order =-1, { callout = PurpleEventCallback}} CFRunLoopSource {order = 0, {port = 2407, callout = _ZL20notify_port_callbackP12__CFMachPortPvlS1_}} CFRunLoopSource {order = 0, {port = 1c03, callout = __IOHIDEventSystemClientAvailabilityCallback}} CFRunLoopSource {order = 0, {port = 1b03, callout = __IOHIDEventSystemClientQueueCallback}} CFRunLoopSource {order = 1, {port = 1903, callout = __IOMIGMachPortPortCallback}} // Ovserver CFRunLoopObserver {order = -2147483647, activities = 0x1, // Entry callout = _wrapRunLoopWithAutoreleasePoolHandler} CFRunLoopObserver {order = 0, activities = 0x20, // BeforeWaiting callout = _UIGestureRecognizerUpdateObserver} CFRunLoopObserver {order = 1999000, activities = 0xa0, // BeforeWaiting | Exit callout = _afterCACommitHandler} CFRunLoopObserver {order = 2000000, activities = 0xa0, // BeforeWaiting | Exit callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv} CFRunLoopObserver {order = 2147483647, activities = 0xa0, // BeforeWaiting | Exit callout = _wrapRunLoopWithAutoreleasePoolHandler} // Timer CFRunLoopTimer {firing = No, interval = 3.1536e+09, tolerance = 0, next fire date = 453098071 (-4421.76019 @ 96223387169499), callout = _ZN2CAL14timer_callbackEP16__CFRunLoopTimerPv (QuartzCore.framework)} }, modes ＝ { CFRunLoopMode { sources0 = { /* same as 'common mode items' */ }, sources1 = { /* same as 'common mode items' */ }, observers = { /* same as 'common mode items' */ }, timers = { /* same as 'common mode items' */ }, CFRunLoopMode { sources0 = { /* same as 'common mode items' */ }, sources1 = { /* same as 'common mode items' */ }, observers = { /* same as 'common mode items' */ }, timers = { /* same as 'common mode items' */ }, }, CFRunLoopMode { sources0 = { CFRunLoopSource {order = 0, { callout = FBSSerialQueueRunLoopSourceHandler}} }, sources1 = (null), observers = { CFRunLoopObserver &gt;{activities = 0xa0, order = 2000000, callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv} )}, timers = (null), }, CFRunLoopMode { sources0 = { CFRunLoopSource {order = -1, { callout = PurpleEventSignalCallback}} }, sources1 = { CFRunLoopSource {order = -1, { callout = PurpleEventCallback}} }, observers = (null), timers = (null), }, CFRunLoopMode { sources0 = (null), sources1 = (null), observers = (null), timers = (null), } }} 系统注册了五个默认的 Mode： 1.kCFRunLoopDefaultMode ：App 的默认 Mode，通常主线程就是在这个 Mode 下运行的。 2.UITrackingRunLoopMode : 界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其它 Mode 影响。 3.UIInitializationRunLoopMode ：在刚启动 App 时进入的第一个 Mode，启动完成后就不再使用。 4.GSEventReceiveRunLoopMode ：接受系统事件的内部 Mode，通常用不到。 5.kCFRunLoopCommonModes ：这是一个占位的 Mode，没有实际作用。 当 RunLoop 进行回调时，一般都是通过一个很长的函数调用出去(call out)，当你在你的代码中下断点时，通常能在调用栈中看到这些函数： 12345678910111213141516171819202122232425262728293031323334353637383940414243{ /// 1. 通知Observers，即将进入RunLoop /// 此处有Observer会创建AutoreleasePool: _objc_autoreleasePoolPush(); __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopEntry); do { /// 2. 通知 Observers: 即将触发 Timer 回调。 __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeTimers); /// 3. 通知 Observers: 即将触发 Source (非基于port的,Source0) 回调。 __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeSources); __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__(block); /// 4. 触发 Source0 (非基于port的) 回调。 __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__(source0); __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__(block); /// 6. 通知Observers，即将进入休眠 /// 此处有Observer释放并新建AutoreleasePool: _objc_autoreleasePoolPop(); _objc_autoreleasePoolPush(); __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeWaiting); /// 7. sleep to wait msg. mach_msg() -&gt; mach_msg_trap(); /// 8. 通知Observers，线程被唤醒 __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopAfterWaiting); /// 9. 如果是被Timer唤醒的，回调Timer __CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__(timer); /// 9. 如果是被dispatch唤醒的，执行所有调用 dispatch_async 等方法放入main queue 的 block __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(dispatched_block); /// 9. 如果如果Runloop是被 Source1 (基于port的) 的事件唤醒了，处理这个事件 __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__(source1); } while (...); /// 10. 通知Observers，即将退出RunLoop /// 此处有Observer释放AutoreleasePool: _objc_autoreleasePoolPop(); __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopExit);} AutoreleasePoolApp 启动后，Apple 在主线程的 RunLoop 里注册了两个 Observer，其回调都是 _wrapRunLoopWithAutoreleasePoolHandler()。 第一个 Observer 监视的事件是 Entry(即将进入 Loop)，其回调内会调用 _objc_autoreleasePoolPush() 创建自动释放池，优先级最高，保证创建释放池发生在其它所有回调之前。 第二个 Observer 监视了两个事件：BeforeWaiting(准备进入休眠)时调用 _objc_autoreleasePoolPop() 和 _objc_auroreleasePoolPush() 释放旧的池并创建新池。Exit(即将退出Loop)时调用 _objc_autoreleasePoolPop() 来释放自动释放池，优先级最低，保证其释放发生在其它所有回调之后。 在主线程执行的代码，通常是写在诸如事件回调、Timer 回调内的。这些回调会被 RunLoop 创建好的 AutoreleasePool 环绕着，所以不会出现内存泄漏。 事件响应Apple 注册了一个 Source1 (基于 mach port) 用来接收系统事件，其回调函数为 __IOHIDEventSystemClientQueueCallBack()。 当一个硬件事件发生后，首先由 IOKit.framework 生成一个 IOHIDEvent 事件并由 SpringBoard 接收。SpingBoard 只接收按键、触摸、加速、接近传感器等几种 Event，随后用 mach port 转发给需要的 App 进程。随后 Apple 注册的那个 Source1 就会触发回调，并调用 _UIApplicationHandleEventQueue() 进行应用内的分发。 _UIApplicationHandleEventQueue() 会把 IOHIDEvent 处理并包装成 UIEvent 进行处理或分发，其中包括识别 UIGesture、处理屏幕旋转、发送给 UIWindow等。通常事件比如 UIButton 点击、touchesBegin/Move/End/Cancle 事件都是在这个回调中完成的。 手势识别当 _UIApplicationHandleEventQueue() 识别了一个手势时，其首先会调用 Cancel 将当前的 touchesBegin/Move/End 系列回调打断。随后系统将对应的 UIGestureRecognizer 标记为待处理。 Apple 注册了一个 Observer 检测 BeforeWaiting 事件，这个 Observer 的回调函数是 _UIGestureRecognizerUpdateObsever(), 其内部会获取所有刚被标记为待处理的 GestureRecognizer，并执行 GestureRecognizer 的回调。 当有 UIGestureRecognizer 的变化(创建/销毁/状态改变)时，这个回调都会进行相应处理。 界面更新当在操作 UI 时，比如改变了 Frame、更新了 UIView/CALayer 的层次时，或者手动调用了 UIView/CALayer 的 setNeedsLayout/setNeedsDisplay方法后，这个 UIView/CALayer 就被标记为待处理，并被提交到一个全局的容器去。 苹果注册了一个 Observer 监听 BeforeWaiting(即将进入休眠) 和 Exit (即将退出Loop) 事件，回调去执行一个很长的函数： _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()。这个函数里会遍历所有待处理的 UIView/CAlayer 以执行实际的绘制和调整，并更新 UI 界面。 1234567891011_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv() QuartzCore:CA::Transaction::observer_callback: CA::Transaction::commit(); CA::Context::commit_transaction(); CA::Layer::layout_and_display_if_needed(); CA::Layer::layout_if_needed(); [CALayer layoutSublayers]; [UIView layoutSubviews]; CA::Layer::display_if_needed(); [CALayer display]; [UIView drawRect]; 定时器NSTimer 其实就是 CFRunLoopTimerRef，他们之间是 toll-free bridged 的。一个 NSTimer 注册到 RunLoop 后，RunLoop 会为其重复的时间点注册好事件。例如 10:00, 10:10, 10:20 这几个时间点。RunLoop为了节省资源，并不会在非常准确的时间点回调这个Timer。Timer 有个属性叫做 Tolerance (宽容度)，标示了当时间点到后，容许有多少最大误差。 如果某个时间点被错过了，例如执行了一个很长的任务，则那个时间点的回调也会跳过去，不会延后执行。就比如等公交，如果 10:10 时我忙着玩手机错过了那个点的公交，那我只能等 10:20 这一趟了。 CADisplayLink 是一个和屏幕刷新率一致的定时器（但实际实现原理更复杂，和 NSTimer 并不一样，其内部实际是操作了一个 Source）。如果在两次屏幕刷新之间执行了一个长任务，那其中就会有一帧被跳过去（和 NSTimer 相似），造成界面卡顿的感觉。在快速滑动TableView时，即使一帧的卡顿也会让用户有所察觉。Facebook 开源的 AsyncDisplayLink 就是为了解决界面卡顿的问题，其内部也用到了 RunLoop。 PerformSelector当调用 NSObject 的 performSelecter:afterDelay: 后，实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 中。所以如果当前线程没有 RunLoop，则这个方法会失效。 当调用 performSelector:onThread: 时，实际上其会创建一个 Timer 加到对应的线程去，同样的，如果对应线程没有 RunLoop 该方法也会失效。 关于GCD实际上 RunLoop 底层也会用到 GCD 的东西，比如 RunLoop 是用 dispatch_source_t 实现的 Timer。但同时 GCD 提供的某些接口也用到了 RunLoop， 例如 dispatch_async()。 当调用 dispatch_async(dispatch_get_main_queue(), block) 时，libDispatch 会向主线程的 RunLoop 发送消息，RunLoop会被唤醒，并从消息中取得这个 block，并在回调 CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE() 里执行这个 block。但这个逻辑仅限于 dispatch 到主线程，dispatch 到其他线程仍然是由 libDispatch 处理的。 关于网络请求iOS 中，关于网络请求的接口自下至上有如下几层: 1234CFSocketCFNetwork -&gt;ASIHttpRequestNSURLConnection -&gt;AFNetworkingNSURLSession -&gt;AFNetworking2, Alamofire CFSocket 是最底层的接口，只负责 socket 通信。 CFNetwork 是基于 CFSocket 等接口的上层封装，ASIHttpRequest 工作于这一层。 NSURLConnection 是基于 CFNetwork 的更高层的封装，提供面向对象的接口，AFNetworking 工作于这一层。 NSURLSession 是 iOS7 中新增的接口，表面上是和 NSURLConnection 并列的，但底层仍然用到了 NSURLConnection 的部分功能 (比如 com.apple.NSURLConnectionLoader 线程)，AFNetworking2 和 Alamofire 工作于这一层。 通常使用 NSURLConnection 时，你会传入一个 Delegate，当调用了 [connection start] 后，这个 Delegate 就会不停收到事件回调。实际上，start 这个函数的内部会会获取 CurrentRunLoop，然后在其中的 DefaultMode 添加了4个 Source0 (即需要手动触发的Source)。CFMultiplexerSource 是负责各种 Delegate 回调的，CFHTTPCookieStorage 是处理各种 Cookie 的。 当开始网络传输时，我们可以看到 NSURLConnection 创建了两个新线程：com.apple.NSURLConnectionLoader 和 com.apple.CFSocket.private。其中 CFSocket 线程是处理底层 socket 连接的。NSURLConnectionLoader 这个线程内部会使用 RunLoop 来接收底层 socket 的事件，并通过之前添加的 Source0 通知到上层的 Delegate。 NSURLConnectionLoader 中的 RunLoop 通过一些基于 mach port 的 Source 接收来自底层 CFSocket 的通知。当收到通知后，其会在合适的时机向 CFMultiplexerSource 等 Source0 发送通知，同时唤醒 Delegate 线程的 RunLoop 来让其处理这些通知。CFMultiplexerSource 会在 Delegate 线程的 RunLoop 对 Delegate 执行实际的回调。 RunLoop 怎么用？AFNetWorkingAFURLConnectionOperation 这个类是基于 NSURLConnection 构建的，其希望能在后台线程接收 Delegate 回调。为此 AFNetworking 单独创建了一个线程，并在这个线程中启动了一个 RunLoop： 123456789101112131415161718+ (void)networkRequestThreadEntryPoint:(id)__unused object { @autoreleasepool { [[NSThread currentThread] setName:@&quot;AFNetworking&quot;]; NSRunLoop *runLoop = [NSRunLoop currentRunLoop]; [runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode]; [runLoop run]; }} + (NSThread *)networkRequestThread { static NSThread *_networkRequestThread = nil; static dispatch_once_t oncePredicate; dispatch_once(&amp;oncePredicate, ^{ _networkRequestThread = [[NSThread alloc] initWithTarget:self selector:@selector(networkRequestThreadEntryPoint:) object:nil]; [_networkRequestThread start]; }); return _networkRequestThread;} RunLoop 启动前内部必须要有至少一个 Timer/Observer/Source，所以 AFNetworking 在 [runLoop run] 之前先创建了一个新的 NSMachPort 添加进去了。通常情况下，调用者需要持有这个 NSMachPort (mach_port) 并在外部线程通过这个 port 发送消息到 loop 内；但此处添加 port 只是为了让 RunLoop 不至于退出，并没有用于实际的发送消息。 12345678910- (void)start { [self.lock lock]; if ([self isCancelled]) { [self performSelector:@selector(cancelConnection) onThread:[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]]; } else if ([self isReady]) { self.state = AFOperationExecutingState; [self performSelector:@selector(operationDidStart) onThread:[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]]; } [self.lock unlock];} 当需要这个后台线程执行任务时，AFNetworking 通过调用 [NSObject performSelector:onThread:..] 将这个任务扔到了后台线程的 RunLoop 中。 AsyncDisplayKitAsyncDisplayKit 是 Facebook 推出的用于保持界面流畅性的框架，其原理大致如下： UI 线程中一旦出现繁重的任务就会导致界面卡顿，这类任务通常分为3类：排版，绘制，UI对象操作。 排版通常包括计算视图大小、计算文本高度、重新计算子式图的排版等操作。 绘制一般有文本绘制 (例如 CoreText)、图片绘制 (例如预先解压)、元素绘制 (Quartz)等操作。 UI对象操作通常包括 UIView/CALayer 等 UI 对象的创建、设置属性和销毁。 其中前两类操作可以通过各种方法扔到后台线程执行，而最后一类操作只能在主线程完成，并且有时后面的操作需要依赖前面操作的结果 （例如TextView创建时可能需要提前计算出文本的大小）。ASDK 所做的，就是尽量将能放入后台的任务放入后台，不能的则尽量推迟 (例如视图的创建、属性的调整)。 为此，ASDK 创建了一个名为 ASDisplayNode 的对象，并在内部封装了 UIView/CALayer，它具有和 UIView/CALayer 相似的属性，例如 frame、backgroundColor等。所有这些属性都可以在后台线程更改，开发者可以只通过 Node 来操作其内部的 UIView/CALayer，这样就可以将排版和绘制放入了后台线程。但是无论怎么操作，这些属性总需要在某个时刻同步到主线程的 UIView/CALayer 去。 ASDK 仿照 QuartzCore/UIKit 框架的模式，实现了一套类似的界面更新的机制：即在主线程的 RunLoop 中添加一个 Observer，监听了 kCFRunLoopBeforeWaiting 和 kCFRunLoopExit 事件，在收到回调时，遍历所有之前放入队列的待处理的任务，然后一一执行。 转载整理自 ： ibireme 的博客 深入理解RunLoop","link":"/2015/11/20/iOS-RunLoop/"},{"title":"Objective-C Runtime","text":"Objective-C Runtime动态语言，是指程序在运行时可以改变其结构：新的函数可以被引进，已有的函数可以被删除等在结构上的变化，类型的检查是在运行时做的，优点为方便阅读，清晰明了，缺点为不方便调试。 这里有三个名词容易被混淆： Dynamic Programming Language，即动态语言或动态编程语言 Dynamically Typed Language，即动态类型语言 Statically Typed Language，即静态类型语言 所谓的动态类型语言，指的是类型的检查是在运行时做的；与此相对，静态类型语言的类型判断是在运行前判断(如编译阶段)，C#、Java 等就是静态类型语言，静态类型的语言为了达到多态会采取一些类型鉴别手段，如接口、继承，而动态类型的语言却不需要，所以一般动态语言都会采用 dynamic typing，常出现于脚本语言中。 Objective-C 就是一门动态语言，它有一个运行时系统来执行编译的代码。这个运行时系统就是 Objc Runtime，它是一个由 C 和汇编语言编写的库。 Runtime 库的主要工作是封装和找出最终执行的代码。 封装 ：在 Objc Runtime 库中，对象可以用 C 中的结构体表示，而方法可以用 C 中的函数来实现，另外再加上一些额外的特性。这些结构体和函数被 Runtime 函数封装后，我们就可以在程序运行时创建，检查，修改类、对象和它们的方法了。 找出方法的最终执行代码：当程序执行 [object doSomething]时，会向消息接收者发送一条消息，Runtime 会根据消息接收者是否能响应该消息而做出不同的反应。 Objective-C Runtime 目前有两个版本：Modern Runtime和 Legacy Runtime。Moder Runtime覆盖了64位的 Mac OS X Apps和 iOS Apps，Legacy Runtime是早期用来给32位的 Mac OS X Apps用的。 Objective-C Runtime 中的类与对象类与对象的基本数据结构ClassObjective-C 中的类是由 Class 类型来表示的，实际上是一个指向 objc_class 结构体的指针 1typedef struct objc_class *Class; 它的结构体定义如下 123456789101112131415struct objc_class { Class isa OBJC_ISA_AVAILABILITY; #if !__OBJC2__ Class super_class OBJC2_UNAVAILABLE; const char *name OBJC2_UNAVAILABLE; long version OBJC2_UNAVAILABLE; long info OBJC2_UNAVAILABLE; long instance_size OBJC2_UNAVAILABLE; struct objc_ivar_list *ivars OBJC2_UNAVAILABLE; struct objc_method_list **methodLists OBJC2_UNAVAILABLE; struct objc_cache *cache OBJC2_UNAVAILABLE; struct objc_protocol_list *protocols OBJC2_UNAVAILABLE; #endif} OBJC2_UNAVAILABLE; 这些字段的意义如下： isa：Objective-C 中所有类自身也是对象，这个对象的 Class 里也有一个 isa 指针，它指向 metaClass 元类。 super_class ：指向该类的父类，如果该类已经是最顶层的根类，则为 NULL。 name ：类名。 version ：类的版本信息，默认为0。我们可以使用这个字段来提供类的版本信息，这对于对象的序列化非常有用，它可以让我们识别出不同类定义版本中实例变量布局的改变。 info ：类信息，供运行期使用的一些位标识。 instance_size ：类的实例变量的大小。 ivars ：类的成员变量链表。 methodLists ：方法定义的链表。 cache ：用于缓存最近使用的方法。当一个接收者对象接收到一个消息时，它会根据 isa 指针去查找能够响应这消息的对象。在实际情况里，这个对象只有一部分方法是常用的，很多方法其实很少用或根本用不上。这种情况下，如果每次消息来时，都是在 methodLists 链表中遍历一遍，性能势必很差。更好的做法是，在我们每次调用过一个方法后，就将这个方法缓存到 cache 列表中，下次调用就会优先去 cache 中查找。 protocols ：协议链表。 当我们向一个 Objective-C 对象发送消息时，Runtime 会根据实例对象的 isa 指针找到这个实例对象所属的类，然后 Runtime 会在类的方法列表及其父类的方法列表中寻找与消息对应的 selector 指向的方法，找到后即运行这个方法。 当创建一个特定类的实例对象时，分配的内存会包含一个 objc_object 数据结构，然后是类的实例变量的数据。NSObject 类的 alloc 和 allocWithZone: 方法使用函数 class_createInstance 来创建 objc_object 数据结构。 12345struct objc_object { Class isa OBJC_ISA_AVAILABILITY;}typedef struct objc_object *id; 常见的 id 是一个 objc_object 结构类型的指针。 objc_cacheobjc_class 中的 cache 字段用于缓存调用过的方法，它是一个指向 objc_cache 结构体的指针。 12345struct objc_cache { unsigned int mask OBJC2_UNAVAILABLE; unsigned int occupied OBJC2_UNAVAILABLE; Method buchets[1] OBJC2_UNAVAILABLE;} 该结构体的字段描述如下： mask ：一个整数，指定分配的缓存 bucket 的总数。在方法查找过程中，Runtime 使用这个字段来确定开始线性查找数组的索引位置。指向方法的 selector 指针与该字段做一个 AND 位操作。 occupied ：一个整数，指定实际占用的缓存 bucket 的总数。 buckets ： 指向 Method 数据结构指针的数组。这个数组可能包含不超过 mask+1 个元素。如果指针为 NULL，表明这个缓存 bucket 没有被占用，另外被占用的 bucket 可能是不连续的。 元类(Meta Class)所有的类自身也是一个对象，我们也可以向这个对象发送消息。 当我们向一个对象发送消息时，Runtime 会在这个对象所属的类的方法列表中查找方法；而向一个类发送消息时，会在这个类的 meta-class 的方法列表中查找。 meta-class 存储着一个类的所有类方法。每个类都会有个一个单独的 meta-class ，因为每个类的类方法基本不可能完全相同。 meta-class 的 isa 指针指向基类的 meta-class ，以此作为它的所属类。可以理解为，任何 NSObject 继承体系下的 meta-class 都使用 NSObject 的 meta-class 作为自己的所属类，而基类的 meta-class 的 isa 指针则指向它自己。 对于 NSObject 继承体系来说，其实例方法对体系中的所有实例、类和 meta-class 都是有效的；而类方法对于体系内的所有类和 meta-class 都是有效的。 类与对象操作函数Runtime 提供了大量函数来操作类与对象。类的操作方法大部分以 class_ 为前缀，对象的操作方法大部分是以 objc_ 或 object_ 为前缀。 类名12// 获取类的类名const char * class_getName (Class cls); 对于 class_getName 函数来说，如果传入的 cls 为 nil，则返回一个字字符串。 父类(super_class)和元类(meta-class)1234// 获取类的父类Class class_getSuperClass (Class cls);// 判断给定的类是否是元类BOOL class_isMetaClass (Class cls); class_getSuperClass 函数，当cls 为 nil 或 cls 为根类时，返回 nil。 class_isMetaClass 函数，如果 cls 是元类，返回 YES。如果传入的 cls 为 nil，则返回 NO。 实例变量大小(instance_size)12// 获取实例大小size_t class_getInstanceSize (Class cls); 成员变量(ivar)及属性objc_class 中，所有的成员变量、属性的信息都是放在链表 ivars 中。ivars 是一个数组，数组中的每个元素是指向 ivar 的指针。 成员变量操作函数 12345678// 获取类中指定名称实例成员变量的信息Ivar class_getInstanceVariable (Class cls, const char *name); // 获取类成员变量的信息Ivar class_getClassVariable (Class cls, const char *name);// 添加成员变量BOOL class_addIvar (Class cls, const char *name, size_t size, uint8_t alignment, const char *types);// 获取整个成员变量列表Ivar * class_copyIvarList (Class cls, unsigned int *outCount); class_getInstanceVariable 函数，它返回一个指向包含 name 指定的成员变量信息的 objc_ivar 结构体的指针 Ivar。 class_getClassVariable 函数，目前没有找到关于 Objective-C 中类变量的信息，一般认为 Objective-C 不支持类变量。 Objective-C 不支持向已经存在的类中添加实例变量，但如果通过 Runtime 来创建一个类的话，就可以使用 class_addIvar 函数了。需要注意的是，这个函数只能在 objc_allocateClassPair 与 objc_registerClassPair 之间调用。另外这个类也不能是元类。 class_copyIvarList ，返回一个包含成员变量信息的数组，数组中的每个元素是指向该成员变量信息的 objc_ivar 结构体的指针。这个数组不包含在父类中声明的变量。outCount 指针返回数组的大小。需要注意的是，我们必须使用 free() 来释放这个数组。 属性操作函数 12345678// 获取指定的属性objc_property_t class_getProperty (Class cls, const char *name);// 获取属性列表objc_property_t * class_copyPropertyList (Class cls, unsigned int *outCount);// 为类添加属性BOOL class_addProperty (Class cls, const char *name, const objc_property_attribute_t *attributes, unsigned int attributeCount);// 替换类的属性void class_replaceProperty (Class cls, const char *name, const objc_property_attribute_t *attributes, unsigned int attributeCount); 在 Mac OS X 系统中，Runtime 提供了几个函数来确定一个对象的内存区域是否可以被垃圾回收器扫描，以处理 strong/weak 引用。 1234const uint8_t * class_getIvarLayout (Class cls);void class_setIvarLayout (Class cls, const uint8_t *layout);const uint_8 * class_getWeakIvarLayout (Class cls);void class_setWeakIvarLayout (Class cls, const uint8_t *layout); 通常情况下，我们不需要去主动调用这些方法，在调用 objc_registerClassPair 时，会生成合理的布局。 方法(methodLists)123456789101112131415// 添加方法BOOL class_addMethod (Class cls, SEL name, IMP imp, const char *types);// 获取实例方法Method class_getInstanceMethod (Class cls, SEL name);// 获取类方法Method class_getClassMethod (Class cls, SEL name);// 获取所有方法的数组Method * class_copyMethodList (Class cls, unsigned int *outCount);// 替代方法的实现IMP class_replaceMethod (Class cls, SEL name, IMP imp, const char *types);// 返回方法的具体实现IMP class_getMethodImplementation (Class cls, SEL name);IMP class_getMethodImplementation_stret (Class cls, SEL name);// 类实例是否响应指定的 selectorBOOL class_respondsToSelector (Class cls, SEL sel); class_addMethod 的实现会覆盖父类的方法实现，但不会取代本类中已经存在的实现，如果本类中包含一个同名的实现，则函数会返回 NO。如果要修改已经存在的实现，可以使用 method_setImplementation。一个 Objectice-C 方法是一个简单的 C 函数，它至少包含两个参数 self 和 _cmd，所以我们实现函数至少需要两个参数。 123void myMethodIMP (id self, SEL _cmd) { // implementation} 与成员变量不同的是，我们可以动态的为类添加方法，不管这个类是否已经存在。 参数 types 是一个描述传递给方法的参数类型的字符数组。 class_getInstanceMethod 、class_getClassMethod 函数，与 class_copyMethodList 不同的是，这两个函数都会去搜索父类的实现。 class_copyMethodList 函数，返回包含所有实例方法的数组，如果需要获取类方法，则可使用 class_copyMethodList(object_getClass(Class cls), &amp;count) (一个类的实例方法是定义在元类中的)。该列表不包含父类实现的方法。outCount 参数返回方法的个数。在获取到列表后，我们需要使用 free() 来释放它。 class_replaceMethod 函数，该函数的行为可以分为两种 ：如果类中不存在参数 name 指定的方法，则类似于 class_addMethod 函数一样会添加方法；如果类中已经存在 name 指定的方法，则类似于 method_setImplementation 一样替代原方法的实现。 class_getMethodImplementation 函数，该函数在向类实例发送消息时会被调用，并返回一个指向方法实现函数的指针。这个函数会比 method_getImplementation(Class cls, const char * name) 更快。返回的函数指针可能是一个指向 Runtime 内部的函数，而不一定是方法的实际实现。 class_respondsToSelector 函数，我们经常使用 NSObject 类的 respondsToSelector: 或 instanceRespondToSelector: 方法来达到同样的目的。 协议 (objc_protocol_list)协议相关的操作包含以下函数：： 123456// 添加协议BOOL class_addProtocol (Class cls, Protocol *protocol);// 返回类是否实现指定的协议BOOL class_conformsToProtocol (Class cls, Protocol *protocol);// 返回类实现的协议列表Protocol *class_copyProtocolList (Class cls, unsigned int *outCout); 版本(version)版本相关的操作函数： 1234// 获取版本号int class_getVersion (Class cls);// 设置版本号void class_setVersion (Class cls, int version) 动态创建类和对象Runtime 经常被用到的功能就是在运行时创建类和对象。 动态创建类动态创建类涉及到一下几个函数 123456// 创建一个新类和元类Class objc_allocateClassPair (Class superclass, const char *name, size_t extraBytes);// 销毁一个类及其相关的类void objc_disposeClassPair (Class cls);// 在应用中注册由 objc_allocateClassPair 创建的类void objc_registerClassPair (Class cls); objc_allocateClassPair 函数 ：如果我们要创建一个根类，则指定 superClass 为 Nil。extraBytes 通常指定为 0 ，该参数是分配给类和元类对象尾部的索引 ivars 的字节数。 为了创建一个新类，我们需要调用 objc_allocateClassPair ，然后使用诸如 class_addMethod , class_addIvar 等函数来为新创建的类添加方法、实例变量和属性等。完成这些后，我们需要调用 objc_registerClassPair 函数来注册类，之后这个类就可以在程序中使用了。 实例方法和实例变量应该添加到类自身上，而类方法应该添加到类的元类上。 objc_disposeClassPair 函数用于销毁一个类，值得注意的是，如果程序运行中还存在类或其子类的实例，则不能对针对类调用该方法。 动态创建对象动态创建对象的函数如下： 123456// 创建类实例id class_createInstance (Class cls, size_t extraBytes);// 在指定位置创建类实例id objc_constructInstance (Class cls, void *bytes);// 销毁类实例void * objc_destructInstance (id obj); class_createInstance 函数 ：创建实例时，会在默认的内存区域为类分配内存。extraBytes 表示分配的额外字节数。这些额外的字节数可用于存储在类定义中所定义的实例变量之外的实例变量。该函数在ARC环境下无法使用。 调用 class_createInstance 的效果和 +alloc 方法类似。 objc_constructInstance 函数 ：在指定的位置(bytes)创建类实例。 objc_destructInstance 函数 ：销毁一个类的实例，但不会释放并移除任何与其先关的引用。 实例操作函数实例操作函数主要是针对创建的实例对象的一系列操作函数。 针对整个对象进行操作的函数1234// 返回指定对象的一份拷贝id object_copy (id obj, size_t size);// 释放指定对象占用的内存id object_dispose (id obj); 针对对象实例变量进行操作的函数12345678910// 修改类实例的实例变量的值Ivar object_setInstanceVariable (id obj, const char *name, void *value);// 获取对象实例变量的值Ivar object_getInstanceVariable (id obj, const char *name, void **outValue);// 返回指向给定对象分配的任何额外字节的指针void * object_getIndexedIvars (id obj);// 返回对象中实例变量的值id object_getIvar (id obj, Ivar ivar);// 设置对象中实例变量的值void object_setIvar (id obj, Ivar ivar, id value); 如果实例变量的 Ivar 已经知道，那么调用 objc_getIvar 会比 objc_getInstanceVariable 函数快。相同情况下，object_setIvar 也比 object_setInstanceVariable 快。 针对对象的类进行操作的函数123456// 返回给定对象的类名const char * object_getClassName (id obj);// 返回对象的类Class object_getClass (id obj);// 设置对象的类Class object_setClass (id obj, Class cls); 获取类定义Objective-C Runtime 会自动注册我们代码中定义的所有的类。我们也可以在运行时创建类定义并使用 objc_addClass 来注册它们。 获取类定义的相关函数 12345678910// 获取以注册的类定义的列表int objc_getClassList (Class *buffer, int bufferCount);// 创建并返回一个指向所有已注册类的指针列表Class * objc_copyClassList (unsigned int *outCount);// 返回指定类的类定义Class objc_lookUpClass (const char *name);Class objc_getClass (const char *name);Class objc_getRequiredClass (const char *name);// 返回指定类的元类Class objc_getMetaClass (const char *name); objc_getClassList 函数 ：获取已注册的类定义的列表。我们不能假设从该函数中获取的类对象是继承自 NSObject 体系的，所以在这些类上调用方法时，都应该先检测一下这个方法是否在这个类中实现。 获取类定义的方法有三个 ：objc_lookUpClass , objc_getClass 和 objc_getRequiredClass。如果类在运行时未注册，则 objc_lookUpClass 会返回 nil，而 objc_getClass 会调用类处理回调，并在此确认类是否注册，如果确认未注册，再返回 nil。而 objc_getRequiredClass 函数的操作与 objc_getClass 相同，只不过没有找到类，就会杀死进程。 objc_getMetaClass 函数 ：如果指定的类没有注册，则该函数会调用类处理回调，并在此确认类是否注册，如果确认未注册，再返回 nil。不过，每个类定义都必须有一个有效的元类定义，所以这个函数总是会返回一个元类定义。不管它是否有效。 Objective-C Runtime 中的成员变量与属性类型编码(Type Encoding)作为对 Runtime 的补充，编译器将每个方法的返回值和参数类型编码为一个字符串，并将其与方法的 selector 关联在一起。这种编码方案在其它情况下也是非常有用的，因此我们可以使用 @encod 编译器指令来获取它。当给定一个类型时，@encode 会返回这个类型的字符串编码。 成员变量、属性Runtime 中关于成员变量和属性的相关数据结构并不多，只有三个。 基础数据类型IvarIvar 是表示实例变量的类型，其实际上是一个指向 objc_ivar 结构体的指针 ： 1234567891011typedef struct objc_ivar *Ivar;struct objc_ivar { char *ivar_name OBJC2_UNAVAILABLE; // 变量名 char *ivar_type OBJC2_UNAVAILABLE; // 变量类型 int ivar_offset OBJC2_UNAVAILABLE; // 基地址偏移字节 #ifdef __LP64__ int space OBJC2_UNAVAILABLE;#endif} objc_property_tobjc_property_t 是声明属性的类型，是一个指向 objc_property 结构体的指针 ： 1typedef struct objc_property *objc_property_t; objc_property_attribute_tobjc_property_attribute_t 定义了属性的特性，它是一个结构体： 1234typedef struct { const char *name; // 特姓名 const char *value; // 特性值} 关联对象(Associated Object)关联对象是Runtime 中一个非常实用的特性。关联对象类似于成员变量，不过是在运行时添加的。我们通常会把变量(Ivar)放在类声明的头文件中，或者放在类实现的 @implementation 后面。但这有一个缺点，我们不能在分类中添加成员变量。Objective-C 针对这一问题，提出了一个解决方案：即关联对象(Associated Object)。 我们可以把关联对象想象成一个Objective-C 对象(如字典)，这个对象通过给定的key连接到类的一个实例上。不过由于使用的是C接口，所以key是一个void 指针。我们还需要指定一个内存管理策略，告诉Runtime 如何管理这个对象的内存，这个内存管理策略可以由一下指定： 12345OBJC_ASSOCIATION_ASSIGNOBJC_ASSOCIATION_RETAIN_NONATOMICOBJC_ASSOCIATION_COPY_NONATOMICOBJC_ASSOCIATION_RETAINOBJC_ASSOCIATION_COPY 当宿主对象被释放时，会根据指定的内存管理策略来处理关联对象。如果指定的是 OBJC_ASSOCIATION_ASSIGN ，则宿主释放时，关联对象不会被释放；而如果指定的是 retain 或者是 copy ，则宿主释放时，关联对象会被释放。 将一个对象连接到其它对象所需的就是下面两行代码： 12static char aKey;objc_setAssociatedObject(self, &amp;aKey, anObject, OBJC_ASSOCIATION_RETAIN); 在这种情况下，self 对象将获取一个新的关联对象 anObject ，且内存管理策略是自动 retian 管理对象，当self 对象释放时，会自动 release 关联对象。另外，如果我们使用同一个key来关联另外一个对象时，也会自动释放之前关联的对象，在这种情况下，先前的关联对象会被妥善的处理掉，并且新的对象会使用它的内存。 12// 获取指定key的关联对象id anObject = objc_getAssociatedObject(self, &amp;aKey); 使用 objc_removeAssociatedObjects 函数来移除一个关联对象，或者使用 objc_setAssociatedObject 函数将key指定的关联对象设置为nil 。 成员变量、属性的操作方法成员变量成员变量的操作函数包括 ： 123456// 获取成员变量名const char * ivar_getName (Ivar v);// 获取成员变量类型编码const char * ivar_getTypeEncoding (Ivar v);// 获取成员变量的偏移量ptrdiff_t ivar_getOffset (Ivar v); ivar_getOffset 函数，对于 id 或其它对象类型的实例变量，可以调用 object_getIvar 和 object_setIvar 来直接访问成员变量，而不使用偏移量。 关联对象关联对象的操作函数包括 ： 123456// 设置关联对象void objc_setAssociatedObject (id object, const void *key, id value, objc_AssociationPolicy policy);// 获取关联对象id objc_getAssociatedObject (id object, const void *key);// 移除关联对象void objc_removeAssociatedObjects (id object); 属性属性操作相关函数包括 ： 12345678// 获取属性名const char * property_getName (objc_property_t property);// 获取属性特性描述字符串const char * property_getAttributes (objc_property_t property);// 获取属性中指定的特性char * property_copyAttributeValue (objc_property_t property, const char *attributeName);// 获取属性的特性列表objc_property_attribute_t * property_copyAttributeList (objc_property_t property, unsigned int *outCount); property_copyAttributeValue 函数，返回的 char* 在使用完后需要调用 free() 释放。 property_copuAttributeList 函数，返回值在使用完后需要调用 free() 释放。 Objective-C Runtime 中的方法与消息基础数据类型SELSEL 又叫做选择器，是表示一个方法的 selector 的指针，定义如下： 1typedef struct objc_selector *SEL; 方法的 selector 用于表示运行时方法的名字。Objective-C 在编译时，会根据每一个方法的名字、参数序列，生成一个唯一的整型标识(Int 类型的地址)，这个标识就是 SEL。 两个类之间，不管它们是不是父类与子类的关系，还是之间没有这种关系，只要方法名相同，那么方法的 SEL 就是一样的。每一个方法都对应着一个 SEL。所以在 Objective-C 的同一个类(及类的继承体系)中，不能存在两个同名的方法，即使参数类型不同也不行。因为相同的方法只能对应一个 SEL，这导致 Objectice-C 在处理相同方法名且参数个数相同但类型不同的方法方面能力很差。 当然不同的类可以拥有相同的 selector ，这个没有问题。不同类的实例对象执行相同的 selector 时，会在各自的方法列表中根据 selector 去寻找自己对应的 IMP。 工程中的所有的 SEL 组成了一个 Set 集合，Set 特点就是唯一，因此 SEL 也是唯一的。因此，如果我们想到这个方法集合中查找某个方法时，只需要去找到这个方法对应的 SEL 就行了，SEL 实际上就是根据方法名 hash 化了的一个字符串，而对于字符串的比较仅仅需要比较它们的地址就可以了。 本质上，SEL 只是一个指向方法的指针(准确地说，只是一个根据方法名 hash 化了的 KEY 值，能唯一代表一个方法)，它的存在只是为了加快方法的查询速度。 我们可以在运行时添加新的 selector ，也可以在运行时获取已经存在的 selector ，我们可以通过下面三种方式来获取 SEL : sel_registerName 函数 Objective-C 编译器提供的 @selector() NSSelectorFromString() 方法 IMPIMP 实际上是一个函数指针，指向函数实现的首地址。 1id (*IMP)(id, SEL, ...) 这个函数使用当前 CPU 架构实现的标准 C 调用约定。第一个参数是指向 self (如果是实例方法，则是类实例的内存地址；如果是类方法，则是指向元类的指针)的指针，第二个参数是 selector ，接下来是方法的实际参数列表。 通过取得 IMP ，我们可以跳过 Runtime 的消息传递机制，直接执行 IMP 指向的函数实现，这样就省去了 Runtime 消息传递过程中所做的一系列查找操作。 MethodMethod 用于表示类定义中的方法 1234567typedef struct objc_method *Method;struct objc_method { SEL method_name OBJC2_UNAVAILABLE; // 方法名 char *method_types OBJC2_UNAVAILABLE; // IMP method_imp OBJC2_UNAVAILABLE; // 方法实现 } 方法操作相关函数Runtime 提供了一系列的方法来处理与方法相关的操作，包括方法本身及 SEL 。 方法方法的相关操作函数如下： 1234567891011121314151617181920212223242526// 调用指定方法的实现id method_invoke ( id receiver, Method m, ... );// 调用返回一个数据结构的方法的实现void method_invoke_stret ( id receiver, Method m, ... );// 获取方法名SEL method_getName ( Method m );// 返回方法的实现IMP method_getImplementation ( Method m );// 获取描述方法参数和返回值类型的字符串const char * method_getTypeEncoding ( Method m );// 获取方法的返回值类型的字符串char * method_copyReturnType ( Method m );// 获取方法的指定位置参数的类型字符串char * method_copyArgumentType ( Method m, unsigned int index );// 通过引用返回方法的返回值类型字符串void method_getReturnType ( Method m, char *dst, size_t dst_len );// 返回方法的参数的个数unsigned int method_getNumberOfArguments ( Method m );// 通过引用返回方法指定位置参数的类型字符串void method_getArgumentType ( Method m, unsigned int index, char *dst, size_t dst_len );// 返回指定方法的方法描述结构体struct objc_method_description * method_getDescription ( Method m );// 设置方法的实现IMP method_setImplementation ( Method m, IMP imp );// 交换两个方法的实现void method_exchangeImplementations ( Method m1, Method m2 ); method_invoke函数，返回的是实际实现的返回值。参数receiver不能为空。这个方法的效率会比method_getImplementation和method_getName更快。 method_getName函数，返回的是一个SEL。如果想获取方法名的C字符串，可以使用sel_getName(method_getName(method))。 method_getReturnType函数，类型字符串会被拷贝到dst中。 method_setImplementation函数，注意该函数返回值是方法之前的实现。 方法选择器选择器的相关操作函数包括 ： 12345678// 返回给定选择器指定的方法的名称const char * sel_getName ( SEL sel );// 在Objective-C Runtime系统中注册一个方法，将方法名映射到一个选择器，并返回这个选择器SEL sel_registerName ( const char *str );// 在Objective-C Runtime系统中注册一个方法SEL sel_getUid ( const char *str );// 比较两个选择器BOOL sel_isEqual ( SEL lhs, SEL rhs ); sel_registerName函数：在我们将一个方法添加到类定义时，我们必须在Objective-C Runtime系统中注册一个方法名以获取方法的选择器。 方法调用流程在 Objective-C 中，消息直到运行时才绑定到方法实现上。编译器会将消息表达式 [receiver message] 转化为一个消息调用的函数，即 objc_msgSend 。这个函数将消息接收者和方法名作为其基础参数。 1objc_msgSend(receiver, selector) 如果消息中还有其它参数，则该方法的形式如下 1objc_msgSend(receiver, selector, arg1, arg2, ...) 这个函数完成了动态绑定的所有事情： 首先它找到 selector 对应的方法实现。因为同一个方法在不同的类中有不同的实现，所以我们需要依赖于接收者的类来找到确切的实现。 它调用方法实现，并将接收者对象及方法的所有参数传递给它。 最后，它将实现返回的值作为它自己的返回值。 消息的关键在于结构体 objc_class ，这个结构体中有两个字段是我们在分发消息时关注的： 指向父类的指针 一个类的方法分发表，即 methodLists。 当我们创建一个新对象时，先为其分配内存，并初始化其成员变量。其中 isa 指针也会被初始化，让对象可以访问类及类的继承体系。 当消息发送给一个对象时，objc_msgSend 通过对象的 isa 指针获取到类的结构体，然后在方法列表里查找方法的 selector 。如果没有找到 selector ，则通过 objc_class 结构体中指向父类的指针找到其父类，并在父类的方法列表里寻找方法的 selector 。依此，会一直沿着类的的继承体系到达 NSObject 类。一旦定位到 selector ，函数就会获取到实现的入口点，并传入相应的参数来执行方法的具体实现。如果没有定位到 selector ，则会走消息转发流程。 为了加速消息的处理，运行时系统缓存使用过的 selector 及对应的方法的地址。 隐藏参数objc_msgSend 有两个隐藏参数 ： 消息接受对象 方法的 selector 这两个参数为方法的实现提供了调用者的信息，之所以说是隐藏的，是因为它们在定义方法的源代码中没有声明，而是在编译期被插入实现代码的。 虽然这些参数没有声明，但是我们仍然能在代码中引用它们。我们可以用 self 来引用接收者对象，使用 _cmd 来引用选择器。 获取方法地址Runtime 中方法的动态绑定让我们写代码时更具灵活性，如我们可以把消息转发给我们想要的对象，或者随意交换一个方法的实现等。不过灵活性的提升也带来了性能上的一些损耗。毕竟我们需要去查找方法的实现，而不像函数调用来得那么直接。当然，方法的缓存一定程度上解决了这一问题。 我们上面提到过，如果想要避开这种动态绑定方式，我们可以获取方法实现的地址，然后像调用函数一样来直接调用它。特别是当我们需要在一个循环内频繁地调用一个特定的方法时，通过这种方式可以提高程序的性能。 NSObject 类提供了methodForSelector:方法，让我们可以获取到方法的指针，然后通过这个指针来调用实现代码。我们需要将methodForSelector:返回的指针转换为合适的函数类型，函数参数和返回值都需要匹配上。 我们通过以下代码来看看methodForSelector:的使用： 123456void (*setter)(id, SEL, BOOL);int i;setter = (void (*)(id, SEL, BOOL))[target methodForSelector:@selector(setFilled:)];for (i = 0 ; i &lt; 1000 ; i++) setter(targetList[i], @selector(setFilled:), YES); 这里需要注意的就是函数指针的前两个参数必须是id和SEL。 当然这种方式只适合于在类似于for循环这种情况下频繁调用同一方法，以提高性能的情况。另外，methodForSelector:是由Cocoa运行时提供的；它不是Objective-C语言的特性。 消息转发当一个对象能接收一个消息时，就会走正常的方法调用流程。但如果一个对象无法接收指定消息时，又会发生什么事呢？默认情况下，如果是以[object message]的方式调用方法，如果object无法响应message消息时，编译器会报错。但如果是以perform...的形式来调用，则需要等到运行时才能确定object是否能接收message消息。如果不能，则程序崩溃。 通常，当我们不能确定一个对象是否能接收某个消息时，会先调用respondsToSelector:来判断一下。如下代码所示： 123if ([self respondsToSelector:@selector(method)]) { [self performSelector:@selector(method)];} 不过，我们这边想讨论下不使用respondsToSelector:判断的情况。这才是我们这一节的重点。 当一个对象无法接收某一消息时，就会启动所谓”消息转发(message forwarding)“机制，通过这一机制，我们可以告诉对象如何处理未知的消息。默认情况下，对象接收到未知的消息，会导致程序崩溃，并由 NSObject 的 doesNotRecognizeSelector 方法抛出 ‘unrecognized selector sent to instance’ 错误信息。不过，我们可以采取一些措施，让我们的程序执行特定的逻辑，而避免程序的崩溃。 消息转发机制基本上分为三个步骤： 动态方法解析 备用接收者 完整转发 下面我们详细讨论一下这三个步骤。 动态方法解析对象在接收到未知的消息时，首先会调用所属类的类方法+resolveInstanceMethod:(实例方法)或者+resolveClassMethod:(类方法)。在这个方法中，我们有机会为该未知消息新增一个”处理方法””。不过使用该方法的前提是我们已经实现了该”处理方法”，只需要在运行时通过class_addMethod函数动态添加到类里面就可以了。如下代码所示： 1234567891011void functionForMethod1(id self, SEL _cmd) { NSLog(@&quot;%@, %p&quot;, self, _cmd);} + (BOOL)resolveInstanceMethod:(SEL)sel { NSString *selectorString = NSStringFromSelector(sel); if ([selectorString isEqualToString:@&quot;method1&quot;]) { class_addMethod(self.class, @selector(method1), (IMP)functionForMethod1, &quot;@:&quot;); } return [super resolveInstanceMethod:sel];} 不过这种方案更多的是为了实现@dynamic属性。 备用接收者如果在上一步无法处理消息，则 Runtime会继续调以下方法 : 1- (id)forwardingTargetForSelector:(SEL)aSelector 如果一个对象实现了这个方法，并返回一个非nil的结果，则这个对象会作为消息的新接收者，且消息会被分发到这个对象。当然这个对象不能是self自身，否则就是出现无限循环。当然，如果我们没有指定相应的对象来处理aSelector，则应该调用父类的实现来返回结果。 使用这个方法通常是在对象内部，可能还有一系列其它对象能处理该消息，我们便可借这些对象来处理消息并返回，这样在对象外部看来，还是由该对象亲自处理了这一消息。 这一步合适于我们只想将消息转发到另一个能处理该消息的对象上。但这一步无法对消息进行处理，如操作消息的参数和返回值。 完整消息转发如果在上一步还不能处理未知消息，则唯一能做的就是启用完整的消息转发机制了。此时会调用以下方法： 1- (void)forwardInvocation:(NSInvocation *)anInvocation 运行时系统会在这一步给消息接收者最后一次机会将消息转发给其它对象。对象会创建一个表示消息的NSInvocation对象，把与尚未处理的消息有关的全部细节都封装在anInvocation中，包括selector，目标(target)和参数。我们可以在forwardInvocation方法中选择将消息转发给其它对象。 forwardInvocation:方法的实现有两个任务： 定位可以响应封装在anInvocation中的消息的对象。这个对象不需要能处理所有未知消息。 使用anInvocation作为参数，将消息发送到选中的对象。anInvocation将会保留调用结果，运行时系统会提取这一结果并将其发送到消息的原始发送者。 不过，在这个方法中我们可以实现一些更复杂的功能，我们可以对消息的内容进行修改，比如追回一个参数等，然后再去触发消息。另外，若发现某个消息不应由本类处理，则应调用父类的同名方法，以便继承体系中的每个类都有机会处理此调用请求。 还有一个很重要的问题，我们必须重写以下方法： 1- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector 消息转发机制使用从这个方法中获取的信息来创建NSInvocation对象。因此我们必须重写这个方法，为给定的selector提供一个合适的方法签名。 1234567891011121314- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector { NSMethodSignature *signature = [super methodSignatureForSelector:aSelector]; if (!signature) { if ([SUTRuntimeMethodHelper instancesRespondToSelector:aSelector]) { signature = [SUTRuntimeMethodHelper instanceMethodSignatureForSelector:aSelector]; } } return signature;}- (void)forwardInvocation:(NSInvocation *)anInvocation { if ([SUTRuntimeMethodHelper instancesRespondToSelector:anInvocation.selector]) { [anInvocation invokeWithTarget:_helper]; }} NSObject的forwardInvocation:方法实现只是简单调用了doesNotRecognizeSelector:方法，它不会转发任何消息。这样，如果不在以上所述的三个步骤中处理未知消息，则会引发一个异常。 从某种意义上来讲，forwardInvocation:就像一个未知消息的分发中心，将这些未知的消息转发给其它对象。或者也可以像一个运输站一样将所有未知消息都发送给同一个接收对象。这取决于具体的实现。 消息转发与多重继承回过头来看第二和第三步，通过这两个方法我们可以允许一个对象与其它对象建立关系，以处理某些未知消息，而表面上看仍然是该对象在处理消息。通过这种关系，我们可以模拟“多重继承”的某些特性，让对象可以“继承”其它对象的特性来处理一些事情。不过，这两者间有一个重要的区别：多重继承将不同的功能集成到一个对象中，它会让对象变得过大，涉及的东西过多；而消息转发将功能分解到独立的小的对象中，并通过某种方式将这些对象连接起来，并做相应的消息转发。 不过消息转发虽然类似于继承，但NSObject的一些方法还是能区分两者。如respondsToSelector:和isKindOfClass:只能用于继承体系，而不能用于转发链。如果我们想让这种消息转发看起来像是继承，则可以重写这些方法，如以下代码所示： 1234567891011- (BOOL)respondsToSelector:(SEL)aSelector{ if ( [super respondsToSelector:aSelector]) return YES; else { /* Here, test whether the aSelector message can * * be forwarded to another object and whether that * * object can respond to it. Return YES if it can. */ } return NO; } Objective-C Runtime Method SwizzlingMethod Swizzling是改变一个selector的实际实现的技术。通过这一技术，我们可以在运行时通过修改类的分发表中selector对应的函数，来修改方法的实现。 例如，我们想跟踪在程序中每一个view controller展示给用户的次数：当然，我们可以在每个view controller的viewDidAppear中添加跟踪代码；但是这太过麻烦，需要在每个view controller中写重复的代码。创建一个子类可能是一种实现方式，但需要同时创建UIViewController, UITableViewController, UINavigationController及其它UIKit中view controller的子类，这同样会产生许多重复的代码。 这种情况下，我们就可以使用Method Swizzling，如在代码所示： 123456789101112131415161718192021222324252627282930313233343536#import &lt;objc/runtime.h&gt;@implementation UIViewController (Tracking) + (void)load { static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^{ Class class = [self class]; // When swizzling a class method, use the following: // Class class = object_getClass((id)self); SEL originalSelector = @selector(viewWillAppear:); SEL swizzledSelector = @selector(xxx_viewWillAppear:); Method originalMethod = class_getInstanceMethod(class, originalSelector); Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector); BOOL didAddMethod = class_addMethod(class, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod)); if (didAddMethod) { class_replaceMethod(class, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod)); } else { method_exchangeImplementations(originalMethod, swizzledMethod); } });}#pragma mark - Method Swizzling- (void)xxx_viewWillAppear:(BOOL)animated { [self xxx_viewWillAppear:animated]; NSLog(@&quot;viewWillAppear: %@&quot;, self);}@end 在这里，我们通过method swizzling修改了UIViewController的@selector(viewWillAppear:)对应的函数指针，使其实现指向了我们自定义的xxx_viewWillAppear的实现。这样，当UIViewController及其子类的对象调用viewWillAppear时，都会打印一条日志信息。 上面的例子很好地展示了使用method swizzling来向一个类中注入一些我们新的操作。当然，还有许多场景可以使用method swizzling，在此不多举例。在此我们说说使用method swizzling需要注意的一些问题： Swizzling应该总是在+load中执行在Objective-C中，运行时会自动调用每个类的两个方法。+load会在类初始加载时调用，+initialize会在第一次调用类的类方法或实例方法之前被调用。这两个方法是可选的，且只有在实现了它们时才会被调用。由于method swizzling会影响到类的全局状态，因此要尽量避免在并发处理中出现竞争的情况。+load能保证在类的初始化过程中被加载，并保证这种改变应用级别的行为的一致性。相比之下，+initialize在其执行时不提供这种保证–事实上，如果在应用中没有给这个类发送消息，则它可能永远不会被调用。 Swizzling应该总是在dispatch_once中执行与上面相同，因为swizzling会改变全局状态，所以我们需要在运行时采取一些预防措施。原子性就是这样一种措施，它确保代码只被执行一次，不管有多少个线程。GCD的dispatch_once可以确保这种行为，我们应该将其作为method swizzling的最佳实践。 选择器、方法与实现在Objective-C中，选择器(selector)、方法(method)和实现(implementation)是运行时中一个特殊点，虽然在一般情况下，这些术语更多的是用在消息发送的过程描述中。 以下是Objective-C Runtime Reference中的对这几个术语一些描述： Selector(typedef struct objc_selector *SEL)：用于在运行时中表示一个方法的名称。一个方法选择器是一个C字符串，它是在Objective-C运行时被注册的。选择器由编译器生成，并且在类被加载时由运行时自动做映射操作。 Method(typedef struct objc_method *Method)：在类定义中表示方法的类型 Implementation(typedef id (*IMP)(id, SEL, ...))：这是一个指针类型，指向方法实现函数的开始位置。这个函数使用为当前CPU架构实现的标准C调用规范。第一个参数是指向对象自身的指针(self)，第二个参数是方法选择器。然后是方法的实际参数。 理解这几个术语之间的关系最好的方式是：一个类维护一个运行时可接收的消息分发表；分发表中的每个入口是一个方法(Method)，其中key是一个特定名称，即选择器(SEL)，其对应一个实现(IMP)，即指向底层C函数的指针。 为了swizzle一个方法，我们可以在分发表中将一个方法的现有的选择器映射到不同的实现，而将该选择器对应的原始实现关联到一个新的选择器中。 调用 _cmd我们回过头来看看前面新的方法的实现代码： 1234- (void)xxx_viewWillAppear:(BOOL)animated { [self xxx_viewWillAppear:animated]; NSLog(@&quot;viewWillAppear: %@&quot;, NSStringFromClass([self class]));} 乍看上去是会导致无限循环的。但令人惊奇的是，并没有出现这种情况。在swizzling的过程中，方法中的[self xxx_viewWillAppear:animated]已经被重新指定到UIViewController类的-viewWillAppear:中。在这种情况下，不会产生无限循环。不过如果我们调用的是[self viewWillAppear:animated]，则会产生无限循环，因为这个方法的实现在运行时已经被重新指定为xxx_viewWillAppear:了。 注意事项Swizzling通常被称作是一种黑魔法，容易产生不可预知的行为和无法预见的后果。虽然它不是最安全的，但如果遵从以下几点预防措施的话，还是比较安全的： 总是调用方法的原始实现(除非有更好的理由不这么做)：API提供了一个输入与输出约定，但其内部实现是一个黑盒。Swizzle一个方法而不调用原始实现可能会打破私有状态底层操作，从而影响到程序的其它部分。 避免冲突：给自定义的分类方法加前缀，从而使其与所依赖的代码库不会存在命名冲突。 明白是怎么回事：简单地拷贝粘贴swizzle代码而不理解它是如何工作的，不仅危险，而且会浪费学习Objective-C运行时的机会。阅读Objective-C Runtime Reference和查看&lt;objc/runtime.h&gt;头文件以了解事件是如何发生的。 小心操作：无论我们对Foundation, UIKit或其它内建框架执行Swizzle操作抱有多大信心，需要知道在下一版本中许多事可能会不一样。 Objective-C Runtime 中的协议与分类Objective-C 中的分类允许我们通过给一个类添加方法来扩充它（但是通过category不能添加新的实例变量），并且我们不需要访问类中的代码就可以做到。 Objective-C 中的协议是普遍存在的接口定义方式，即在一个类中通过@protocol定义接口，在另外类中实现接口，这种接口定义方式也称为“delegation”模式，@protocol声明了可以被其他任何方法类实现的方法，协议仅仅是定义一个接口，而由其他的类去负责实现。 基础数据类型CategoryCategory 是表示一个指向分类的结构体的指针。 123456789typedef struct objc_category *Category;struct objc_category { char *category_name OBJC2_UNAVAILABLE; // 分类名 char *class_name OBJC2_UNAVAILABLE; // 分类所属的类名 struct objc_method_list *instance_methods OBJC2_UNAVAILABLE; // 实例方法列表 struct objc_method_list *class_methods OBJC2_UNAVAILABLE; // 类方法列表 struct objc_protocol_list *protocols OBJC2_UNAVAILABLE; // 分类所实现的协议列表 } 这个结构体主要包含了分类定义的实例方法与类方法，其中instance_methods列表是objc_class中方法列表的一个子集，而class_methods列表是元类方法列表的一个子集。 ProtocolProtocol 的定义如下 1typedef struct objc_object Protocol; 可以看到，Protocol 其实就是一个对象结构体。 操作函数Runtime并没有在&lt;objc/runtime.h&gt;头文件中提供针对分类的操作函数。因为这些分类中的信息都包含在objc_class中，我们可以通过针对objc_class的操作函数来获取分类的信息。 而对于Protocol，runtime提供了一系列函数来对其进行操作，这些函数包括： 123456789101112131415161718192021222324252627282930// 返回指定的协议Protocol * objc_getProtocol ( const char *name );// 获取运行时所知道的所有协议的数组Protocol ** objc_copyProtocolList ( unsigned int *outCount );// 创建新的协议实例Protocol * objc_allocateProtocol ( const char *name );// 在运行时中注册新创建的协议void objc_registerProtocol ( Protocol *proto );// 为协议添加方法void protocol_addMethodDescription ( Protocol *proto, SEL name, const char *types, BOOL isRequiredMethod, BOOL isInstanceMethod );// 添加一个已注册的协议到协议中void protocol_addProtocol ( Protocol *proto, Protocol *addition );// 为协议添加属性void protocol_addProperty ( Protocol *proto, const char *name, const objc_property_attribute_t *attributes, unsigned int attributeCount, BOOL isRequiredProperty, BOOL isInstanceProperty );// 返回协议名const char * protocol_getName ( Protocol *p );// 测试两个协议是否相等BOOL protocol_isEqual ( Protocol *proto, Protocol *other );// 获取协议中指定条件的方法的方法描述数组struct objc_method_description * protocol_copyMethodDescriptionList ( Protocol *p, BOOL isRequiredMethod, BOOL isInstanceMethod, unsigned int *outCount );// 获取协议中指定方法的方法描述struct objc_method_description protocol_getMethodDescription ( Protocol *p, SEL aSel, BOOL isRequiredMethod, BOOL isInstanceMethod );// 获取协议中的属性列表objc_property_t * protocol_copyPropertyList ( Protocol *proto, unsigned int *outCount );// 获取协议的指定属性objc_property_t protocol_getProperty ( Protocol *proto, const char *name, BOOL isRequiredProperty, BOOL isInstanceProperty );// 获取协议采用的协议Protocol ** protocol_copyProtocolList ( Protocol *proto, unsigned int *outCount );// 查看协议是否采用了另一个协议BOOL protocol_conformsToProtocol ( Protocol *proto, Protocol *other ); objc_getProtocol函数，需要注意的是如果仅仅是声明了一个协议，而未在任何类中实现这个协议，则该函数返回的是nil。 objc_copyProtocolList函数，获取到的数组需要使用free()来释放 objc_allocateProtocol函数，如果同名的协议已经存在，则返回nil objc_registerProtocol函数，创建一个新的协议后，必须调用该函数以在运行时中注册新的协议。协议注册后便可以使用，但不能再做修改，即注册完后不能再向协议添加方法或协议 需要强调的是，协议一旦注册后就不可再修改，即无法再通过调用protocol_addMethodDescription、protocol_addProtocol和protocol_addProperty往协议中添加方法等。 Objective-C Runtime 补充知识super在Objective-C中，如果我们需要在类的方法中调用父类的方法时，通常都会用到super。 如何使用super我们都知道。现在的问题是，它是如何工作的呢？ 首先我们需要知道的是super与self不同。self是类的一个隐藏参数，每个方法的实现的第一个参数即为self。而super并不是隐藏参数，它实际上只是一个”编译器标示符”，它负责告诉编译器，当调用viewDidLoad方法时，去调用父类的方法，而不是本类中的方法。而它实际上与self指向的是相同的消息接收者。为了理解这一点，我们先来看看super的定义： 1struct objc_super { id receiver; Class superClass; }; 这个结构体有两个成员： receiver：即消息的实际接收者 superClass：指针当前类的父类 当我们使用super来接收消息时，编译器会生成一个objc_super结构体。就上面的例子而言，这个结构体的receiver就是当前对象，与self相同；superClass指向当前类的父类。 接下来，发送消息时，不是调用objc_msgSend函数，而是调用objc_msgSendSuper函数，其声明如下： 1id objc_msgSendSuper ( struct objc_super *super, SEL op, ... ); 该函数第一个参数即为前面生成的objc_super结构体，第二个参数是方法的selector。该函数实际的操作是：从objc_super结构体指向的superClass的方法列表开始查找viewDidLoad 的selector，找到后以objc-&gt;receiver去调用这个selector，而此时的操作流程就是如下方式了 1objc_msgSend(objc_super-&gt;receiver, @selector(viewDidLoad)) 由于objc_super-&gt;receiver就是self本身，所以该方法实际与下面这个调用是相同的： 1objc_msgSend(self, @selector(viewDidLoad)) 库相关操作库相关的操作主要是用于获取由系统提供的库相关的信息，主要包含以下函数： 123456// 获取所有加载的Objective-C框架和动态库的名称const char ** objc_copyImageNames ( unsigned int *outCount );// 获取指定类所在动态库const char * class_getImageName ( Class cls );// 获取指定库或框架中所有类的类名const char ** objc_copyClassNamesForImage ( const char *image, unsigned int *outCount ) 通过这几个函数，我们可以了解到某个类所有的库，以及某个库中包含哪些类。 块操作我们都知道block给我们带到极大的方便，苹果也不断提供一些使用block的新的API。同时，苹果在runtime中也提供了一些函数来支持针对block的操作，这些函数包括： 123456// 创建一个指针函数的指针，该函数调用时会调用特定的blockIMP imp_implementationWithBlock ( id block );// 返回与IMP(使用imp_implementationWithBlock创建的)相关的blockid imp_getBlock ( IMP anImp );// 解除block与IMP(使用imp_implementationWithBlock创建的)的关联关系，并释放block的拷贝BOOL imp_removeBlock ( IMP anImp ); imp_implementationWithBlock函数：参数block的签名必须是method_return_type ^(id self, method_args …)形式的。该方法能让我们使用block作为IMP。 弱引用操作1234// 加载弱引用指针引用的对象并返回id objc_loadWeak ( id *location );// 存储__weak变量的新值id objc_storeWeak ( id *location, id obj ); objc_loadWeak函数：该函数加载一个弱指针引用的对象，并在对其做retain和autoreleasing操作后返回它。这样，对象就可以在调用者使用它时保持足够长的生命周期。该函数典型的用法是在任何有使用__weak变量的表达式中使用。 ● objc_storeWeak函数：该函数的典型用法是用于__weak变量做为赋值对象时。 宏定义在Runtime 中，还定义了一些宏定义供我们使用，有些值我们会经常用到，如表示BOOL值的YES/NO；而有些值不常用，如OBJC_ROOT_CLASS。在此我们做一个简单的介绍。 布尔值12#define YES (BOOL)1#define NO (BOOL)0 这两个宏定义定义了表示布尔值的常量，需要注意的是YES的值是1，而不是非0值。 空值12#define nil __DARWIN_NULL#define Nil __DARWIN_NULL 其中nil用于空的实例对象，而Nil用于空类对象。 分发函数原型1#define OBJC_OLD_DISPATCH_PROTOTYPES 1 该宏指明分发函数是否必须转换为合适的函数指针类型。当值为0时，必须进行转换 Objective-C根类1#define OBJC_ROOT_CLASS 如果我们定义了一个Objective-C根类，则编译器会报错，指明我们定义的类没有指定一个基类。这种情况下，我们就可以使用这个宏定义来避过这个编译错误。该宏在iOS 7.0后可用。 其实在NSObject的声明中，我们就可以看到这个宏的身影，如下所示： 12345678__OSX_AVAILABLE_STARTING(__MAC_10_0, __IPHONE_2_0)OBJC_ROOT_CLASSOBJC_EXPORT@interface NSObject &lt;NSObject&gt; { Class isa OBJC_ISA_AVAILABILITY;} 我们可以参考这种方式来定义我们自己的根类。 局部变量存储时长1#define NS_VALID_UNTIL_END_OF_SCOPE 该宏表明存储在某些局部变量中的值在优化时不应该被编译器强制释放。 我们将局部变量标记为id类型或者是指向ObjC对象类型的指针，以便存储在这些局部变量中的值在优化时不会被编译器强制释放。相反，这些值会在变量再次被赋值之前或者局部变量的作用域结束之前都会被保存。 关联对象行为1234567enum { OBJC_ASSOCIATION_ASSIGN = 0, OBJC_ASSOCIATION_RETAIN_NONATOMIC = 1, OBJC_ASSOCIATION_COPY_NONATOMIC = 3, OBJC_ASSOCIATION_RETAIN = 01401, OBJC_ASSOCIATION_COPY = 01403}; Objective-C Runtime 实际应用动态交换两个方法的实现当第三方框架或系统原生方法功能不能满足我们的需求的时候，可以通过交换方法实现在保持原有方法功能的基础上，添加额外的功能。 12345+ (void)load { Method originalMethod = class_getClassMethod(self, @selector(originalMethodName)); Method targetMethod = class_getClassMethod(self, @selector(targetMethodName)); method_exchangeImplementations(originalMethod, targetMethod);} 动态添加属性属性赋值的本质就是让属性与一个对象产生关联。 1234567891011121314151617@interface NSObject (AssociatedProperty) @property NSString *propertyName;@end @implementation NSObject (AssociatedProperty) - (void)setPropertyName:(NSString *)stringValue { objc_setAssociatedObject(self, @&quot;propertyName&quot;, stringValue, OBJC_ASSOCIATION_RETAIN_NONATOMIC); }- (NSString *)propertyName { return objc_getAssociatedObject(self, @&quot;propertyName&quot;);}@end 实现字典转模型的动态转换利用 Runtime 遍历模型中所有属性，根据模型的属性名，去字典中查找 key，去除对应的值，给模型的属性赋值。 12345678910111213141516// 最简单实现，不考虑字典中含有数组或对象的情况+ (instancetype)modelWithDict:(NSDictionary *)dict { id objc = [[self alloc] init]; unsigned int count = 0; Ivar *ivarList = class_copyIvarList(self, &amp;count); for (int index = 0; index &lt; count; index++) { Ivar ivar = ivarList[index]; NSString *ivarName = [NSString stringWithUTF8String:ivar_getName(ivar)]; NSString *key = [ivarName substringFromIndex:1]; id value = dict[key]; if (value) { [objc setValue:value forKey:key]; } } return objc;} 动态添加方法如果一个类的方法很多，加载类到内存的时候比较耗费资源，使用动态给类添加方法的方式可以解决。 123456789void methodAddWhenRun(id self, SEL _cmd, id argument ···) {}+ (BOOL)resolveInstanceMethod:(SEL)self { if (sel == NSSelectorFromString(@&quot;methodAddWhenRun&quot;)) { class_addMethod(self, sel, (IMP)methodAddWhenRun, &quot;v@:@&quot;); return YES; } return [super resolveInstanceMethod:sel];} 动态变量控制123456789101112// 假设要修改 `_propertyName`unsigned int count = 0;Ivar *ivarList = class_copyIvarList([self class], &amp;count);for (int index = 0; index &lt; count; index++) { Ivar ivar = ivarList[index]; const char *varName = ivar_getName(ivar); NSString *name = [NSString stringWithUTF8String:varName]; if ([name isEqualToString:@&quot;_propertyName&quot;]) { object_setIvar([self class], var, (id)newValue); break; }} 实现 NSCoding 的自动归解档12345678910111213141516171819202122232425262728- (void)encodeWithCoder:(NSCoder *)encoder { unsigned int count = 0; Ivar *ivarList = class_copyIvarList([TargetClass class], &amp;count); for (int index = 0; index &lt; count; index++) { Ivar ivar = ivarList[index]; const char *name = ivar_getName(ivar); NSString *key = [NSString stringWithUTF8String:name]; id value = [self valueForKey:key]; [encoder encodObject:value forKey:key]; } free(ivarList);}- (id)initWithCoder:(NSCoder *)decoder { if (self = [super init]) { unsigned int count = 0; Ivar *ivarList = class_copyIvaarList([TargetClass class], &amp;count); for (int index = 0; index &lt; count; index++) { Ivar ivar = ivarList[index]; const char *name = ivar_getName:(ivar); NSString *key = [NSString stringWithUTF8String:name]; id value = [decoder decodeObjectForKey:key]; [self setValue:value forKey:key]; } free(ivarList); } return self;} 转载整理自 南风子的技术博客 参考 百度百科 动态语言 参考 白水ln的简书","link":"/2016/01/10/iOS-Runtime/"},{"title":"应用程序生命周期和状态转换操作策略","text":"iOS 应用程序生命周期 基本概念介绍The Main Function - 程序的入口main函数是每个基于C的应用程序的入口，iOS也是这样。在Xcode中开发iOS程序的话，Xcode会自动为你创建这个函数作为你工程的一部分。 12345int main(int argc, char * argv[]) { @autoreleasepool { return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class])); }} main函数控制UIKit framework的工作。UIApplicationMain函数通过创建应用程序的核心对象，从可用的storyboard文件加载应用程序的用户界面，调用自定义代码，以便让你可以在程序启动时进行一些初始设置，并将应用程序的运行循环启动。 The Structure of an App - 程序的结构在启动过程中，UIApplicationMain函数设置了几个关键对象，启动应用程序并开始运行它。 每个iOS应用程序的核心都是UIApplication对象，其工作是为了方便系统与应用程序中的其他对象之间的交互。 一个iOS应用程序中包含的关键对象： 一个iOS应用程序中各个对象的所起到的作用： Object Description UIAppplication UIApplication对象管理着App的事件循环和一些高级App行为，并向它的委托对象报告App的状态转换和一些特殊事件。 Appdelegate Appdelegate是你编写的程序代码的核心 ，它与UIApplication对象一起工作，处理应用程序初始化，状态转换和许多高级App行为。 这个对象也是唯一一个保证在每个应用程序中都出现的对象，因此通常用于设置应用程序的初始数据结构。 ViewController View Controller对象管理着你的App内容在屏幕上是如何呈现的。一个View Controller对象管理着一个视图和这个视图的子视图。 UIWindow UIWindow对象协调屏幕上一个或多个视图的呈现。 大多数应用程序只有一个窗口，它在主屏幕上显示内容，但应用程序可能会在外部显示器上显示内容的附加窗口。要更改应用程序的内容，可以使用视图控制器更改相应窗口中显示的视图。 你永远不会更换窗口本身。除了托管视图之外，Windows还可以使用UIApplication对象将事件传递给的视图和控制器。 View,Control and Layer View和Control提供了应用内容的可视化表示。 除了包含View和Control之外，应用程序还可以将Core Animation图层纳入其视图和控制层次结构中。 层对象实际上才是表示可视内容的数据对象。 The Main Run Loop - 主运行循环应用程序的主运行循环处理所有与用户相关的事件。 UIApplication对象在启动时设置主运行循环，并使用它来处理事件并处理基于视图的接口的更新。 顾名思义，主运行循环在应用程序的主线程上执行，这确保了与用户相关的事件按照接收的顺序连续处理。 当用户与设备进行交互时，与这些交互相关的事件由系统生成，并通过由UIKit设置的特殊端口传送到应用。 事件在应用程序内部进入队列，并逐个分派到主运行循环执行。UIApplication对象是接收事件的第一个对象，并且决定需要做什么来处理这个事件。 触摸事件通常被分派到主窗口对象，主窗口对象又将其发送到触摸发生的视图。 可以在iOS应用程式中分发许多类型的事件。 最常见的如下表所示。 这些事件大多是使用应用程序的主运行循环分发的，但也有些不是。 一些事件被分发到一个委托对象或被分发给你提供的一个block。 事件类型 分发对象 备注 触摸事件 事件发生的视图 视图是响应者对象。任何没有被当前视图处理的触摸事件都会被沿着响应链继续向下分发进行处理。 遥控器事件和摇动运动事件 首要响应对象 遥控器事件用于控制媒体播放，并由耳机和其他附件产生。 加速度计、磁力仪和陀螺仪 你指定的对象 与加速度计，磁力计和陀螺仪硬件相关的事件传递给你指定的对象。 定位 你指定的对象 你注册定位服务以接收使用Core Location框架位置的事件。 重绘 需要更新的视图 重绘事件不涉及事件对象，而是简单地调用视图来绘制自身。 一些事件，如触摸和遥控事件，由你的应用程序的响应者对象处理。响应者对象在你的应用程序中无处不在。 大多数事件都针对特定的响应者对象，但如果需要处理事件，则可以将其传递给其他响应方（通过响应者链）。 例如，不处理事件的视图可以将事件传递到其父视图或父视图控制器。 触摸控件（如按钮）中发生的事件的处理方式与在许多其他类型的视图中发生的触摸事件的处理方式不同。 通常只有有限数量的交互可能与控件相关联，因此这些交互被重新封装到动作消息中并传递到适当的目标对象。 这种目标动作(Target-Action)设计模式可以轻松地使用控件来触发你应用中自定义代码的执行。 Execution States for Apps - 应用程序的执行状态在任何给定的时刻，你的应用程序都处在下表所列的状态之一。 系统会改变应用程序的状态以响应整个系统中发生的操作。 状态 描述 Not running 应用程序没有运行或被系统终止运行。 Inactive 应用程序正在前台运行，但当前没有收到事件 (它可能正在执行其他代码)。应用程序通常在转换到不同的状态时暂时保持在此状态。 Active 应用程序正在前台运行，并且正在接收事件(这是前台应用程序的正常模式)。 Background 应用程序在后台执行代码。 大多数应用程序短暂地进入此状态。 但是，请求额外执行时间的应用程序可能会保持此状态一段时间。 Suspended 应用程序是在后台，但不执行代码。 系统将应用程序自动转换到这个状态，在这样做之前并不会通知应用程序。 挂起时，应用程序保留在内存中，但不执行任何代码。当出现低内存条件时，系统可能会清除已挂起的应用程序，以为前台应用程序腾出更多空间。 下图展示了应用程序在各种状态之间的转换： 大多数状态转换伴随着对应用程序委托对象的方法的相应调用 ，这些方法是你以适当方式响应状态变更的地方。 application:willFinishLaunchingWithOptions: 告诉代理对象启动过程已经开始，但还没有发生状态恢复。 application:didFinishLaunchingWithOptions: 告诉代理对象启动过程快要完成，应用程序快要准备好运行。 applicationDidBecomeActive: 告诉代理对象应用程序已经处于Active状态。 applicationWillResignActive: 告诉代理对象应用程序即将进入Inactive状态。 applicationDidEnterBackground: 告诉代理对象应用程序已经进入后台。 applicationWillEnterForeground: 告诉代理对象应用程序即将进入前台。 applicationWillTerminate: 告诉代理对象应用程序即将被终止。 App Termination - 应用程序的终止应用程序必须随时准备终止运行，不应等待保存用户数据或执行其他关键任务。 System-initiated termination是应用程序生命周期的正常部分。该系统通常终止应用程序，以便它可以回收内存并为用户启动的其他应用程序腾出空间，但是系统也可能会终止行为不当或未及时响应事件的应用程序。 挂起的应用程序终止时不会收到通知，系统将杀死该进程并回收相应的内存。如果一个应用程序当前在后台运行并且没有挂起，系统会在终止之前调用应用程序委托的applicationWillTerminate：。当设备重新启动时，系统不会调用此方法。 除了系统终止你的应用程序，用户可以使用多任务UI显式地终止你的应用程序。System-initiated termination与终止挂起的应用程序具有相同的效果。该应用程序的进程被杀死，并且不会有通知发送到该应用程序。 Threads and Concurrency - 线程和并发系统创建你的应用程序的主线程，你可以根据需要创建其他线程来执行其他任务。 对于iOS应用，首选技术是使用Grand Central Dispatch（GCD），操作对象和其它异步编程接口，而不是自己创建和管理线程。 GCD等技术可以让你定义想要执行的工作以及要执行的顺序，但让系统决定如何在可用的CPU上执行该工作。让系统处理线程管理简化了必须编写的代码，使得更容易确保代码的正确性，并提供更好的整体性能。 在考虑线程和并发时，请考虑以下几点： 涉及视图，核心动画和许多其他UIKit类的工作通常必须发生在应用程序的主线程上。 长时间的任务（或潜在的长度任务）应始终在后台线程上执行。任何涉及网络访问，文件访问或大量数据处理的任务都应使用GCD或操作对象异步执行。 在启动时，尽可能将任务从主线程移出。在启动时，您的应用程序应尽可能快地设置用户界面。只有有助于设置用户界面的任务才能在主线程上执行。 所有其他任务应该是异步执行的。 操作应用程序的状态转换 对于应用程序的任何一个可能的运行状态，系统都对你的应用程序有不同的期望。当应用程序的状态发生转换时，系统会通知应用对象，应用对象又通知其代理。你可以使用UIApplicationDelegate协议的状态转换方法来检测这些状态变化并进行适当的响应。 应用程序启动时应该做什么当应用程序启动(进入前台货后台)时，你应该使用应用程序委托对象的application:willFinishLaunchingWithOptions:和application：didFinishLaunchingWithOptions：方法执行一些操作： 检查启动选项字典的内容(launch options dictionary)，了解应用程序启动的原因，并作出适当的响应。 初始化应用程序的关键数据结构。 准备应用程序的窗口和视图以进行内容显示。 使用OpenGL ES进行绘图的应用程序不能使用这些方法来准备绘图环境，使用OpenGL ES绘图应该在applicationDidBecomeActive:方法中进行准备。 Show your app window from your application:willFinishLaunchingWithOptions: method. UIKit delays making the window visible until after the application:didFinishLaunchingWithOptions: method returns. 在application:willFinishLaunchingWithOptions:方法中配置如何显示应用程序的Window。UIKit延迟Window的显示直到application:didFinishLaunchingWithOptions:方法进行了返回。 在启动时，系统会自动的加载应用程序的主要storyBoard文件，并加载初始视图控制器。对于支持状态恢复的应用程序，状态恢复机制会在调用application:willFinishLaunchingWithOptions:和 application:didFinishLaunchingWithOptions:方法之间将应用程序恢复到以前的状态。使用application:willFinishLaunchingWithOptions:方法显示应用程序窗口，并确定状态恢复是否应该发生。使用application:didFinishLaunchingWithOptions:方法对应用程序的用户界面进行任何最终调整。 application:willFinishLaunchingWithOptions:和application:didFinishLaunchingWithOptions:方法应始终尽可能轻量级，以减少应用程序的启动时间。如果应用程序没有及时完成其启动周期，系统将使其无法响应。因此，任何可能减慢启动速度的任务（如访问网络）都应该在辅助线程上执行。 The Launch Cycle - 启动周期当你的应用程序启动后，在短暂的停留在非活动状态(Inactive)后，将会从非运行状态(Not Running)转换到活动状态(Active)或后台状态(Background)。作为启动周期的一部分，系统会为你的应用程序创建一个进程和一个主线程，并在主线程中调用应用程序的main函数。 下图显示了应用程序启动到前台时发生的事件序列，包括调用的应用程序委派方法。 当你的应用程序启动到后台时，通常要处理一些后台事件，启动周期会有些许改变。主要的不同在于，在后台的应用程序不是处于活动状态，只是进入后台来处理一些事件，之后可能会被挂起。当启动到后台时，系统仍然会加载用户界面文件，但不会显示应用程序的窗口。 你可以通过在代理方法 application:willFinishLaunchingWithOptions: 和application:didFinishLaunchingWithOptions:中检查UIApplication的applicationState属性来决定应用程序是启动到前台还是后台。当你的应用程序启动到前台时，这个属性的值是UIApplicationStateInactive，当你的应用程序启动到后台时，这个属性的值是UIApplicationStateBackground。 Launching in Landscape Mode - 以横屏模式启动对于界面只使用横屏的应用程序来说，必须明确地请求系统以横屏模式启动。通常来说，应用程序以纵屏模式启动，只有在需要适应设备的方向的时候才旋转屏幕的方向。 对于支持纵向和横向方向的应用程序，应始终为纵向模式配置视图，然后让视图控制器处理任何旋转。但是，如果您的应用程序支持横向而不是纵向方向，请执行以下任务，让使其以横向模式启动： 像你应用程序中的Infl.plist文件中添加UIInterfaceOrientation字段，并将其值设为UIInterfaceOrientationLandscapeLeft或UIInterfaceOrientationLandscapeRight。 在横屏模式下布局你的视图并确保视图的布局和自动调整大小选项设置正确。 重写试图控制器的shouldAutorotateToInterfaceOrientation:方法并在左向横屏或右向横屏时返回YES，在纵屏模式下返回NO。 重要提示: 应用程序应该总是用视图控制器来管理基于窗口(Window)的内容。 在Info.plist文件中的UIInterfaceOrientation字段告诉iOS系统该如何配置应用程序状态栏的方向(如果显示的话)以及任何视图控制器管理的视图在启动时的方向。视图控制器根据这个字段设置它的视图的初始方向。 使用此字段相当于在执行你的applicationDidFinishLaunching:方法的早期调用应用程序的setStatusBarOrientation：animated:方法。 Installing App-Specific Data Files at First Launch - 配置应用程序数据文件你可以使用应用程序的第一个启动周期来设置任何应用程序运行所需要的数据或配置文件。 应用程序特定的数据文件应在应用程序沙箱的Library/Application Support/&lt;bundleID&gt;/目录中创建，其中是应用程序的标识符。你可以根据需要细分目录来组织你的数据文件。 如果应用程序包中包含你打算进行修改的数据文件，你应该将要修改的数据文件从应用程序的数据包中复制出来进行修改。你不能在应用程序包中修改数据文件，因为iOS应用程序是代码签名的，在应用程序包中修改数据文件会使应用程序的签名失效，使得你的应用程序无法启动。将打算修改的数据文件复制到Application Support(或者其它可写的目录)目录下进行修改是唯一安全的方式。 应用程序临时被打断时应该做什么基于警报的打断会导致你的应用程序临时性的失去控制。这种情况下，你的应用程序仍然运行在前台，但是不接收任何来自系统的触摸事件(但是会继续接收推送通知等其他类型的时间，比如加速度计时间等)。你应该在applicationWillResignActive:方法中进行如下操作来处理这种情况： 保存数据以及任何相关的状态信息。 停止计时器和其他周期性任务。 停止任何进行的数据请求任务。 不要创建任何新的任务。 停止视屏播放(除了通过AriPlay播放的视屏) 如果你的应用程序是游戏的话，是游戏进入暂停状态。 提高OpenGL ES 帧速率。 暂停执行非关键代码的任何调度队列或操作队列。 (可以在不活动的情况下继续处理网络请求和其他时间敏感的后台任务) 当你的应用程序返回活动状态时，在applicationDidBecomeActive:方法中应该进行与applicationWillResignActive:相反的操作步骤。因此，一但重新活动，你的应用程序应重新启动计时器，恢复调度队列，并再次调低OpenGL ES帧速率。 但是，游戏不应该自动恢复，它们应该保持暂停，直到用户选择恢复它们为止。 当用户按下睡眠或唤醒按钮时，含有NSFileProtectionComplete保护选项的文件的应用程序必须关闭这些被保护文件的任何引用。对于设置了相应密码的设备，按下睡眠或唤醒按钮时应该锁定屏幕并强制系统丢弃对拥有完全保护文件的解密密钥。当屏幕锁定时，任何尝试访问相关文件的操作都会失败。所以你如果有这样的文件，你应该在applicationWillResignActive:方法中关闭对它们的任何引用，在applicationDidBecomeActive:中打开新的引用。 重要提示: 你应该总是在适当的时候保存用户数据。虽然你可以使用应用程序状态转换来强制对象将为保存的变更写入磁盘，但是合适的做法是永远不要等到状态转换时才去保存数据。 Responding to Temporary Interruptions - 响应临时打断当基于警报的打断发生时(比如打进电话)，应用程序暂时进入非活动状态已便系统可以提示用户如和继续操作。应用程序保持在这个状态直到用户拒绝了这个警报，这时应用程序会返回前台进入活动状态或进入后台。 以横幅形式显示的通知不会像基于警报的通知那样是你的应用程序进入非活动状态。尽管横幅放置在你应用程序窗口的顶部边缘，但是你的应用程序还是能够继续接收触摸事件。然而如果用户下拉横幅以便查看通知中心，你的应用程序就会像基于警报的打断发生时那样进入非活动状态。你的应用程序保持在非活动状态直到用户退出通知中心或启动另一个应用程序，这时，你的应用程序相应的会进入非活动转台或后台。 按下睡眠或唤醒按钮是另一种类型的可以导致你的应用程序暂时进入非活动状态的打断。当用户按下这个按钮，系统会使触摸事件变得不可用并让应用程序进入后台，同时将applicationState的值设置为UIApplicationStateBackground并锁定屏幕。 应用程序在前台时做什么当你的应用程序返回前台进入活动状态时，你可以重新启动在进入后台时停止的任务。移动到前台时出现的步骤如下图所示，applicationWillEnterForeground：方法应该撤消在applicationDidEnterBackground：方法中完成的任何内容，并且applicationDidBecomeActive：方法应该继续执行与启动时相同的激活任务。 Be Prepared to Process Queued Notifications - 准备处理通知队列一个处于挂起状态的应用程序必须做好在返回前台或进入后台执行状态时处理任何在队列中的通知。处于挂起状态的应用程序不执行任何代码，因此不能处理通知引发的屏幕方向改变，时间改变，偏好改变以及其它会影响应用程序的外观和状态的改变。为了确保这些改变不会丢失，系统将相关的通知放入队列并在应用程序开始执行代码(无论在前台还是后台)时分发通知给它。为了防止应用程序在恢复通知时变得超负荷，系统会将事件合并，并提供一个单一的通知（每种相关类型），反映自您的应用程序被挂起以来的净变化。 下表列出了分发给你的应用程序的可以合并的通知。这些通知的大多数都直接分发给已经注册的观察者。 Event Notifications An accessory is connected or disconnected. EAAccessoryDidConnectNotification EAAccessoryDidDisconnectNotification 设备方向改变 UIDeviceOrientationDidChangeNotification除了这个通知，视图控制器自动的改变自己的方向。 重要的时间改变 UIApplicationSignificantTimeChangeNotification 电池状态改变 UIDeviceBatteryLevelDidChangeNotification UIDeviceBatteryStateDidChangeNotification The proximity state changes. UIDeviceProximityStateDidChangeNotification 被保护的文件的状态的改变 UIApplicationProtectedDataWillBecomeUnavailable UIApplicationProtectedDataDidBecomeAvailable 内建显示器连接或失去连接 UIScreenDidConnectNotification UIScreenDidDisconnectNotification 屏幕显示模式改变 UIScreenModeDidChangeNotification 通过设置应用程序改变了应用程序的设置 NSUserDefaultsDidChangeNotification 当前语言或本地化设置改变 NSCurrentLocaleDidChangeNotification 用户的iCloud账户状态改变 NSUbiquityIdentityDidChangeNotification 通常在任何触摸事件或用户输入事件之前，在主线程中分发队列化的通知。大多数的应用程序应该足够快地处理这些事件，避免在重启是导致可观察到的延迟。 应用程序返回前台时也会接收到要更新自从上次更新以来被标记为dirty的视图的通知。一个运行在后台的应用程序仍然能调用setNeedsDisplay 和 setNeedsDisplayInRect:方法来请求更新视图。然而，因为这些请求更新的视图不可见，系统合并了这些请求并在应用程序进入前台后才更新它们。 Handle iCloud Changes - 处理iCloud改变当iCloud的状态发生改变时，系统会发送一个NSUbiquityIdentityDidChangeNotification通知给你的应用程序。用户登入或登出iCloud账号，关闭了文档和数据的同步，都会引起iCloud状态的改变。这个通知表示应用程序应该更新缓存和与iCloud有关的用户界面元素。 如果你的应用程序已经提示了用户是否要在iCloud存储文件的话，不要在iCloud状态发生改变时再次提醒。在第一次提醒了用户后，将用户的选择保存在本地的偏好设置中。 Handle Locale Changes - 处理本地化改变如果用户在你的应用程序挂起时改变了当前的本地化方案，当你的应用程序返回前台时，你可以使用NSCurrentLocaleDidChangeNotification通知来强制更新包含了对本地化方案敏感的信息，比如日期，时间和数字。当然，最好的避免发生本地化相关的问题的方法是用能简单更新视图的方法来编写代码： 使用autoupdatingCurrentLocale类方法当你检索到NSLocal对象。这个方法返回一个可以自动更新自己来响应本地化方案改变的本地化对象，所以你永远不需要重新创建它。然而，当本地化方案发生改变时，你仍然需要更新包含来自于当前本地化方案的信息的视图。 重新创建任何缓存的日期和数字格式，无论当前本地化方案何时发生变化。 Handle Changes to Your App’s Settings - 处理偏好设置的改变如果你的应用程序含有被设置应用程序管理的设置选项，你应该监测NSUserDefaultsDidChangeNotification通知，因为用户可以改变这些设置当你的应用程序被挂起或在后台。你可以使用这个通知来响应并处理在这些设置上的重要改变。 一旦收到NSUserDefaultsDidChangeNotification通知，你的应用程序应该重新加载任何相关的设置，如果需要，恰当地重置用户界面。 应用程序在后台时做什么当应用程序从前台转为后台执行时，使用你的代理对象的applicationDidEnterBackground:方法来做： 准备应用程序的照片。当你的applicationDidEnterBackground:返回时，系统会对你的应用程序的用户界面拍照并用这个照片来做过度动画。如果你的应用程序里的视图包含敏感信息，你应该在applicationDidEnterBackground:返回之前隐藏或更改这些视图。 保存任何应用程序状态的相关信息。在进入后台之前，你的应用程序应该已经保存好了所有重要的用户数据。使用转换到后台来保存应用程序状态的最后一分钟更改。 你的应用程序代理对象的applicationDidEnterBackground:方法大约有5分钟的时间来结束任何任务并返回。实际上，这个方法应该可能快的返回。如果这个方法没有在时间耗尽前返回，你的应用程序将会被终止并被移出内存。如果你仍然需要更多的时间来执行任务，调用beginBackgroundTaskWithExpirationHandler:方法来请求后台执行时间，然后在一个次要线程里开始任何长时任务。不管你有没有开始一个后台任务，applicationDidEnterBackground:方法都会在5分钟内退出。 提示: 除了调用applicationDidEnterBackground:方法外，系统还会发送UIApplicationDidEnterBackgroundNotification通知。你可以使用这个通知将清理任务分发给应用程序里的其它对象。 The Background Transition Cycle - 后台转换周期When the user presses the Home button, presses the Sleep/Wake button, or the system launches another app, the foreground app transitions to the inactive state and then to the background state. These transitions result in calls to the app delegate’s applicationWillResignActive: and applicationDidEnterBackground: methods, as shown in Figure 4-5. After returning from the applicationDidEnterBackground: method, most apps move to the suspended state shortly afterward. Apps that request specific background tasks (such as playing music) or that request a little extra execution time from the system may continue to run for a while longer. 当用户按下Home键，按下睡眠或唤醒按钮，或者系统启动了另一个应用程序，运行在前台的应用程序会转换为非活动状态然后进入后台。这些状态转换会导致调用applicationWillResignActive: 和 applicationDidEnterBackground:方法，如下图所示。从applicationDidEnterBackground：方法返回后，大多数应用程序不久之后就会转换到挂起状态。 请求特定后台任务（如播放音乐）或从系统请求一点额外执行时间的应用程序可能会持续运行一段时间。 Prepare for the App Snapshot - 准备应用程序快照系统在应用程序代理对象applicationDidEnterBackground:方法返回的不久之前，对应用程序的窗口进行快照。相似的，当应用程序被唤醒执行后台任务时，系统会对应用程序进行一次新的反应改变的快照。 如果在进入后台更改视图时，可以调用主视图的snapshotViewAfterScreenUpdates：方法来强制执行这些更改。在一个视图上调用setNeedsDisplay方法对快照是无效的，因为快照发生在下一个绘制周期之前。调用值为“YES”的snapshotViewAfterScreenUpdates：方法将立即使用机器的底层缓冲区更新快照。 Reduce Your Memory Footprint每个应用程序应该在进入后台时释放尽可能多的内存。 系统尝试尽可能多地在内存中保留应用程序，但是当内存不足时，会终止挂起的应用程序以回收该内存。 在后台消耗大量内存的应用程序是第一个要终止的应用程序。 实际上，你的应用程序应该在不再需要的时候删除对对象的强引用。 删除强引用使编译器能够立即释放对象，以便可以回收对应的内存。 但是，如果要缓存某些对象以提高性能，则可以等到应用程序转换到后台再删除对它们的引用。 应该尽快删除强引用的对象的一些示例包括： 你创建的图像对象。 可以从磁盘重新加载的大型媒体或数据文件 您的应用程序不需要的任何稍后可以重新创建其他对象。 为了帮助你减少应用程序的内存占用空间，系统会自动清除在应用程序移动到后台时代表应用程序分配的数据。 系统清除所有Core Animation层的后备存储。 此功能不会从应用程序的图层对象中删除内存，也不会更改当前图层属性。 它只是防止这些图层的内容出现在屏幕上，这表明应用程序在后台应该不会发生。 它删除任何系统对缓存图像的引用。 它删除了对其他系统管理的数据高速缓存的强引用。","link":"/2015/10/18/ios-application-life-cycle/"},{"title":"属性修饰符分析","text":"基础概念 atomic &amp; nonatomic决定编译器生成的setter/getter是否为原子操作 。atomic是Objc使用的一种线程保护技术，防止在某个操作未完成时被另外一个线程操作，造成数据错误。然而这种多线程安全机制对资源的占用很大，在iPhone等小型设备中，除非需要使用多线程之间通讯编程，采用这种技术需要慎重考量。一般情况下，使用nonatomic来修饰成员变量，存取器直接返回一个值，而不需要管当不同的线程同时访问时会发生什么。 readwrite &amp; readonly 任何属性都可以声明为readwrite或readonly，且默认设置为readwrite 。 将一个属性声明为readwrite时，编译器将会为这个属性生成setter和getter。 将一个属性生命为readonly时，编译器将只会生成getter。 assign 直接赋值，不更改引用计数，一般用于基础数据类型和C语言类型数据。 retain 释放旧对象，并使传入的新对象引用计数+1。 此属性只能用于NSObject及其子类，而不能用于Core Foundation（因为其没有使用引用计数，需要另外使用CFRetain和CFRelease来进行CF的内存管理）。 strong 释放旧对象，并使传入的新对象引用计数+1。 在ARC下，strong为对象类型属性声明时的默认值。 copy 创建一个引用计数为1的新对象，这个新对象是传入对象的拷贝。 会拷贝传入的对象（即创建一个引用计数为1的新对象，但是内容与传入对象相同），并把新对象赋值给实例变量。 weak 弱引用，要求不保留传入的属性（既不会使传入的对象引用计数+1）。 类似于assign，但与assign不同的是，当它们指向的对象被释放后，weak会被自动置为nil，而assign则不会。 进阶问题 strong &amp; weak这里采用 stack overflow 上的一个对强/弱引用的解释 如果将对象想象成一只想要逃跑(be deallocated)的狗的话。 强引用就像是拴住狗的绳子。只要你还还牵着拴住狗的绳子，狗就逃跑不了。如果有五个人都将绳子拴住了狗，那么除非五个人都解开了绳子，否则狗就不可能逃跑。 而弱引用，就像一个小孩子指着狗说：看，那里有一直狗。只要狗仍被狗绳拴着，小孩就还能看见狗，他们仍会指着它。然而一但狗绳被解开，狗就会逃跑而不管多少小孩子指着它。 copy &amp; retaincopy实际上是建立了一个新的相同的对象，而retain是将传入对象的引用计数+1 。 深拷贝 &amp; 浅拷贝浅拷贝就是对内存地址的复制，让目标对象指针和源对象指向同一片内存空间 。浅拷贝只是对对象的简单拷贝，让几个对象共用一片内存，当内存销毁的时候，指向这片内存的几个指针需要重新定义才可以使用，要不然会成为野指针。在iOS中，使用retain修饰的属性变量，就是一种浅拷贝。它既让几个指针共用同一片内存空间，又可以在release时由于计数的存在，不会轻易的销毁内存，达到更加简单使用的目的。深拷贝是指拷贝对象的具体内容，而内存地址是自主分配的，拷贝结束之后，两个对象虽然存的值是相同的，但是内存地址不一样，两个对象也互不影响，互不干涉。值得注意的是，对可变对象如NSMutableArray等无论是copy还是mutableCopy都是进行了深拷贝。 @property &amp; @synthesize如果我们希望使用默认的实例变量命名方式，那么我们在.m文件中就不需要使用@synthesize声明，系统会帮我们自动完成。如果我们希望自己命名实例变量命，那么我们就使用@synthesize显式声明我们希望的实例变量名 。 block作为实例变量为何要用copy修饰？因为block如果在栈上的话，其所属的变量作用域结束，该block就被释放掉，block中的__block变量也同时被释放掉。为了解决栈块在其变量作用域结束之后被释放掉的问题，我们就需要把block复制到堆中。 为什么NSString、NSDictionary、NSArray要使用copy修饰？对于NSString、NSDictionary、NSArray等经常使用copy关键字，是因为它们有对应的可变类型：NSMutableString、NSMutableDictionary、NSMutableArray，它们之间可能进行赋值操作，为确保对象中的字符串值不会无意间变动，应该在设置新属性时拷贝一份。 weak、copy、strong、assgin分别用在什么地方？什么情况下会使用weak关键字？ 在ARC中，出现循环引用的时候，会使用weak关键字。 自身已经对它进行了一次强引用，没有必要再强调引用一次。 assgin适用于基本的数据类型，比如NSInteger、BOOL等。 NSString、NSArray、NSDictionary等经常使用copy关键字，是因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary； 除了上面的三种情况，剩下的就使用strong来进行修饰。","link":"/2015/09/02/ios-property/"},{"title":"后台运行探索与解析","text":"iOS 后台运行 当用户没有主动的使用你的应用程序时，系统会将它转换为后台运行状态。对于大多说应用程序来说，后台运行状态只是应用程序在被系统挂起前的一个阶段。挂起应用程序是一个改善电池寿命并让系统为前台应用程序释放重要资源的方式。 大多数应用程序都能很容易的挂起，但是拥有合理的理由在后台继续运行的应用程序也是有的。一个远足应用程序想要随着时间来定位用户的位置，让它能够在地图上显示用户的运动进程。一个音频应用程序可能需要在屏幕锁定时继续播放音乐。其它的应用程序可能想要在后台下载内容以便能够减少将内容呈献给用户的延迟。当你发现你的应用程序需要保持在后台继续运行的时候，iOS系统能够帮助你有效率的且尽可能少地占用系统资源的完成这个目的。 iOS提供的技术分为三类： 在前台开始短任务的应用程序可以在进入后台状态时向系统请求完成这个任务的额外时间。 在前台启动下载的应用程序可以将这些下载的管理移交给系统，从而允许在下载过程中暂停或终止该应用。 需要在后台运行以支持特定类型任务的应用程序可以声明对一个或多个后台执行模式的支持。 尽可能避免在后台执行任何任务除非这样做能全面的提升用户的体验。应用程序可能会因为启动了另一个应用程序，锁定了屏幕或现在不使用它而被转入后台。在这些情况下，用户都表明你的应用程序现在不需要做任何有意义的工作。在这种情况下继续运行只会浪费设备的电量并可能导致用户强制的完全退出你的应用程序。所以你应该审慎的考虑在后台运行应用程序。 执行有限长度的任务被转入后台的应用程序期待尽可能快的进入非活动状态以便它们能够被系统挂起。如果你的应用程序正在执行某个任务而且完成这个任务还需要一些时间的话，你可用调用 UIApplication 的beginBackgroundTaskWithName:expirationHandler: 或beginBackgroundTaskWithExpirationHandler:方法来请求一些额外的执行时间。调用这两个方法的任一个都会暂时的推迟你的应用程序被挂起，从而为完成你正在进行的任务赢得一些额外的时间。一旦你的应用程序完成了任务，你必须调用endBackgroundTask:方法让系统知道你的应用程序已经完成了任务，可以被挂起了。 每个调用beginBackgroundTaskWithName:expirationHandler: 或 beginBackgroundTaskWithExpirationHandler: 方法的应用程序都会生成一个与相应的任务相关的标记。当你的应用程序完成任务时，它必须以这个标记来调用 endBackgroundTask:方法告知系统任务已经完成。调用 endBackgroundTask:方法失败会导致你的应用程序被终止。如果你在启动任务的时候提供了一个完成处理模块，系统会调用这个模块并给你最后一次结束任务避免程序被终止的机会。 你不需要一直到等到应用程序进入后台才指定后台任务。一个更有用的设计是在开始任务之前调用beginBackgroundTaskWithName：expirationHandler：或beginBackgroundTaskWithExpirationHandler：方法，一旦完成就调用endBackgroundTask：方法. 下面的的代码展示了当你的应用程序进入后台时如何开始一个长时运行的任务。在这个例子中，开始后台任务的请求包含了一个完成处理模块以防这个任务耗时太长。这个任务稍后会被提交到一个异步执行的队列中以便applicationDidEnterBackground:方法能够正常返回。blocks的使用简化了维护一些重要变量引用所需要的代码。bgTask变量是指向存储当前任务标识符的指针的类的成员变量，它在调用这个方法之前被初始化。 1234567891011121314151617- (void)applicationDidEnterBackground:(UIApplication *)application { bgTask = [application beginBackgroundTaskWithName:@&quot;MyTask&quot; expirationHandler:^{ // Clean up any unfinished task business by marking where you // stopped or ending the task outright. [application endBackgroundTask:bgTask]; bgTask = UIBackgroundTaskInvalid; }]; // Start the long-running task and return immediately. dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{ // Do the work associated with the task, preferably in chunks. [application endBackgroundTask:bgTask]; bgTask = UIBackgroundTaskInvalid; });} 注意: 你总是要在开始一个任务的时候提供完成处理模块，但是如果你想知道你的应用程序还能运行多长时间，你可以通过UIApplication对象的backgroundTimeRemaining属性来获得。 在你的完成处理模块中，你可以加入一些必须的代码来关闭你的任务。但是，完成处理模块中的任何代码都不应该耗费太长的时间去执行，因为你的完成处理模块一旦被调用，就说明你的应用程序已经快要被关闭了。因此，只执行最少的清理状态信息并结束任务。 在后台执行下载任务当下载文件时，应用程序应该使用NSURLSession对象来开始下载，这样系统就能控制下载的进程即使应用程序被挂起或终止。当你配置NSURLSession对象进行后台传输时，系统用一个单独的队列管理这些任务并以常规方式将传输的状态报告给你的应用程序。如果你的应用程序在传输正在进行时被终止，系统会在后台继续传输，并在传输完成或一个甚至多个任务需要你的应用程序时启动你的应用程序(若果使用)。 为了支持后台传输，你必须合适地配置你的NSURLSession对象。为了配置NSURLSession有必须先创建一个NSURLSessionConfiguration对象并给它的一些属性赋予合适的值。然后将这个NSURLSessionConfiguration对象在初始化NSURLSession对象时传递过去。 创建支持后台下载的NSURLSessionConfiguration对象的过程如下： 1.使用NSURLSessionConfiguration的backgroundSessionConfigurationWithIdentifier：方法创建配置对象。 2.将配置对象的sessionSendLaunchEvents属性的值设置为YES。 3.如果你的应用程序在前台进行转移，建议你将sessionSendsLaunchEvents属性设置为YES。 4.根据需要配置配置对象的任何其他属性。 5.使用配置对象创建您的NSURLSession对象。 一旦配置完成，你的NSURLSession对象会在合适的时间将上传和下载任务移交给系统。如果任务在你的应用程序仍在运行时完成(无论是在前台或是后台)，NSURLSession对象都会以常规方式通知它的代理。如果任务还未完成时你的应用程序就被终止，系统会自动地在后台管理任务。如果用户终止了你的应用程序，系统会停止任何待处理的任务。 当所有与后台会话管理的任务完成时，系统会重启被终止的应用程序(假定sessionSendsLaunchEvents属性被设置为YES而且这个应用程序不是被用户强制终止的)并调用应用代理的application:handleEventsForBackgroundURLSession:completionHandler:方法。(系统还可以重新启动应用程序来处理身份验证或其他需要你的应用程序注意的任务的相关事件)在执行该委托方法时，请使用提供的标识符创建一个新的与之前相同的NSURLSessionConfiguration和NSURLSession对象。 系统将你的新会话对象重新连接到先前的任务，并将其状态报告给会话对象的委托。 执行长时间运行的任务对于需要更多后台执行时间的任务，你必须请求特定的权限才能在后台运行它们而不被挂起。iOS中，只有特定类型的应用程序被允许在后台运行： 在后台播放音频内容给用户，比如音乐播放器 在后台录制音频文件 使用户随时了解其位置的应用程序，比如导航应用程序 支持VoIP的应用程序 需要经常性的下载和处理新内容的应用程序 周期性的从外部配件接收更新的应用程序 使用这些服务的应用程序必须声明其支持的服务，并使用系统框架来实现这些服务的相关方面。 声明你的应用程序支持的后台模式你必须在应用程序使用后台任务之前声明你要支持的后台任务类型。在Xcode 5和之后，你需要在你工程的Capabilities选项卡中声明你要支持哪些后台模式。启用后台模式选项将UIBackgroundModes键添加到应用程序的Info.plist文件中。 下表列出了你可以指定的后台模式的值： Xcode后台模式 UIBackgroundModes 值 描述 音频和AirPlay audio 应用程序在后台播放或录制音频内容。用户必须在第一次使用前就授权使用麦克风。 位置更新 location 使用户随时知道他们的位置，即使应用在后台运行。 网络电话 voip 应用程序提供给用户通过网络连接进行通话的能力。 Newsstand下载 newsstand-content Newsstand类型的应用程序在后台下载并处理报纸或杂志内容。 外部附件通信 external-accessory 应用程序与需要通过外部附件框架定期提供更新的硬件配件配合使用。 使用蓝牙设备 bluetooth-central 应用程序使用需要通过Core Bluetooth框架定期发送更新的蓝牙设备。 作为蓝牙LE附件 bluetooth-peripheral 应用程序通过Core Bluetooth框架支持外设模式下的蓝牙通信。使用此模式需要用户授权 后台抓取 fetch 应用程序定期的从网路下载并处理少量数据。 远程推送 remote-notification 应用程序想要在接收到一个远程推送时开始下载内容。 以上每种模式都让系统知道应该在合适的时间唤醒或启动应用程序来响应相关的事件。 追踪用户位置在后台追踪用户的位置的方式有好几种，大多数方式实际上并不需要你的应用程序在后台不断的运行。 重大位置变更 仅在前台定位服务 后台定位服务 对于不需要高精度位置数据的应用程序来说，推荐使用重大位置变更定位服务。这个服务只有在用户的位置发生非常重大的变化时才会产生位置更新；它对社交类应用程序或者给用户提供不是很重要的位置相关信息的应用程序来说是非常理想的定位方式。如果当一个位置更新发生时应用程序被终止，系统会在后台唤醒它来处理这个更新。如果应用程序开始使用了这个服务然后被终止，当新的位置更新产生时，系统会自动重启它。 仅前台定位服务和后台定位服务都使用标准的Core Location服务获取位置数据。唯一的区别是，如果应用程序被挂起，则仅前台定位服务停止发送更新。 前台定位服务适用于只在前台需要位置数据的应用程序。 你可以在Xcode工程中的Capabilities选项卡中启用支持定位服务(你也可以通过在Info.plist文件中设置UIBackgroundModes的值为location来启用这个服务)。启用这个服务并不会阻止系统挂起你的应用程序，但是它会告知系统无论何时新的位置更新被发送过来都应该唤醒应用程序来处理。 重要提示:鼓励你谨慎使用标准的定位服务或改用重要的位置更改服务。 定位服务需要经常使用iOS设备的板载无线电硬件。 连续运行这个硬件会消耗大量的电量。 如果你的应用程序不需要向用户提供精确且连续的位置信息，则最好尽量减少使用位置服务。 在后台播放或录制音频一个需要连续播放或录制音频的应用程序(即使应用处在后台)可以注册后台服务，实现即使在后台也能执行这些任务。你可以在Xcode工程中的Capabilities选项卡中启用服务(你也可以通过在Info.plist文件中设置UIBackgroundModes的值为audio来启用这个服务)。在后台播放音频内容的应用程序必须播放听得见的内容而不能是无声的。 后台音频应用程序的典型例子包括： 音乐播放程序 音频录制程序 支持通过AirPlay播放音频或视频的程序 VoIP程序 当UIBackgroundModes键包含audio值时，系统的媒体框架会自动阻止相关的应用程序被挂起。只要应用程序还在播放视屏或音频内容，录制音频，它就还能在后台运行。然而，一旦录制或播放停止，就会被系统挂起。 你可以使用任何系统音频框架来处理后台音频播放，并且使用这些框架的过程和在前台使用相同(对于通过AriPlay播放视频内容来说，你可以使用Media Player或AVFoundation框架来实现)。因为应用程序在播放媒体文件时不会被挂起，所以即使应用程序在后台也能正常的进行回调操作。在你的回调中，你应该只做为播放提供数据的工作，不应该在回调中执行任何与播放无关的任务。 在任何给定的时刻，因为可能有不止一个应用程序支持音频服务，所以由系统来决定哪个应用程序能够播放或录制音频。前台应用程序总是有优先的音频操作权利。可能有不止一个应用程序被允许在后台播放音频，这个时候决定哪个应用程序能够播放音频就取决于每个应用程序的音频会话的配置。 实现一个VoIP应用程序一个Voice over Internet Protocol应用程序允许用户通过互联网而不是设备的蜂窝网络设备进行语音通话。这样的一个应用程序需要为它的服务维持一个持续的网络连接，以便它能接收到打进来的电话和其它相关数据。系统允许VoIP应用程序被挂起并给它提供了监测它们的sockets的便利，而不是让它一直处于唤醒状态。当检测到传入流量时，系统唤醒VoIP程序并将socket的控制权交还给它。 为了配置VoIP应用程序，你必须： 在Xcode工程中的Capabilities选项卡中启用服务(你也可以通过在Info.plist文件中设置UIBackgroundModes的值为voip来启用这个服务)。 为VoIP应用程序配置一个socket。 在移动到后台之前，调用setKeepAliveTimeout:handler:方法来安装一个定期执行的程序。你的应用程序可以使用这个处理程序来保持服务连接。 配置你的音频会话来操作进入或退出活跃的使用状态的转换。 设置UIBackgroundModes的值为voip让系统知道，当VoIP应用程序需要管理它的网络会话时，系统应该允许它在后台运行。为了让VoIP应用程序总是可用，系统会在启动后立刻重新启动拥有这个键值的应用程序。 大多数的VoIP应用程序也需要配置后台音频模式，因为它也需要在后台发送音频内容。因此，你应该将UIBackgroundModes的值设置为audio和voip。如果你不这样做的话，你的应用程序将不能在后台播放或录制音频内容。 适时的获取少量内容需要定期的检查新内容的应用程序可以请求系统唤醒它们，以便它们可以初始化一个获取内容的拉取操作。为了支持这种模式，你需要在Xcode工程中的Capabilities选项卡中启用服务(你也可以通过在Info.plist文件中设置UIBackgroundModes的值为fetch来启用这个服务)。启用这个服务并不能保证系统会给你的应用程序任何时间来执行后台拉取操作。系统必须在你的应用程序拉取内容的请求和其它应用程序以及系统自身之间做出平衡。在评估所有信息后，如果有很好的机会的话，系统会给请求拉取内容的应用程序一些执行时间。 当有好机会产生时，系统会唤醒或启动你的应用程序到后台并调用应用程序代理对象的application:performFetchWithCompletionHandler:方法。使用这个方法来检查新内容，如果新内容可用则开始下载操作。一旦新内容下载完成，你必须将新内容是否可用的结果传递给提供好的完成处理块。执行这个块告诉系统它可以将你的应用程序转换到挂起状态并评估其使用功率。可以快速下载少量内容并在它们有可用的下载内容时准确反应的应用程序，比起花费更长的下载时间或声称有可用的下载内容但没有下载任何东西的应用程序，更可能在未来获得执行时间。 在下载任何内容时，推荐你使用NSURLSession类来开始和管理你的下载。 使用推送通知来开始下载如果你的服务器在有新的应用程序可用内容时向用户的设备发送了一个推送通知，你可以请求系统在后台运行你的应用程序并立即开始下载新的可用内容。这种后台模式意图在于尽可能减少从你的用户看见推送通知到你的应用程序可以展示相关内容之间的时间。应用程序通常会在用户看见推送通知的差不多相同的时间被唤醒，但是仍会给你更多的准备时间。 为了支持这种模式，你需要在Xcode工程中的Capabilities选项卡中启这项用服务(你也可以通过在Info.plist文件中设置UIBackgroundModes的值为remote-notification来启用这个服务)。 对于一个使用推送通知来触发下载操作的应用程序来说，通知的有效内容必须包含值为1的content-available的键。当这个键值对被检测到时，系统会启动或唤醒你的应用程序到后台同时调用应用程序的代理对象的application:didReceiveRemoteNotification:fetchCompletionHandler:方法。你应该在这个方法里实现对相关内容的下载并将下载好的内容在加入到你的应用程序中。 在下载任何内容时，推荐你使用NSURLSession类来开始和管理你的下载。 在后台下载新闻站内容下载新闻和新的杂志文章的新闻站应用程序可以注册在后台进行这些下载。你需要在Xcode工程中的Capabilities选项卡中启这项用服务(你也可以通过在Info.plist文件中设置UIBackgroundModes的值为newsstand-content来启用这个服务)。当你提供这个关键字时，如果你的应用程序没有在运行，系统会启动你的应用程序以便它能开始下载新的文章。 当你使用Newsstand Kit框架来开始一个下载时，由系统为你的应用程序操作下载的进程。即使你的应用程序被挂起或终止，系统仍会继续下载文件。当下载操作完成后，系统将下载好的文件传输到你的应用程序的沙盒并向你的应用程序发送一个通知。如果应用程序没有在运行，这个通知会唤醒它并给它一个处理新的下载文件的机会。如果在下载过程中发生了错误，你的应用程序也会这样被唤醒来处理这个错误。 与外部附件通信使用外部附件的应用程序可以请求在附件发送了一个更新时被唤醒，即使它处在挂起状态。这种支持对于某些定期发送数据的附件来说是非常重要的，比如心率监视器。你需要在Xcode工程中的Capabilities选项卡中启这项用服务(你也可以通过在Info.plist文件中设置UIBackgroundModes的值为external-accessory来启用这个服务)。当你启用这个模式时，外部附件框架不会关闭活跃的外部附件会话。当外部附件发送来新的内容时，这个框架唤醒你的应用程序以便它能处理这些数据内容。在外部附件建立连接或失去连接时，系统也会唤醒应用程序来进行处理。 任何支持附件更新后台处理的应用程序都必须遵循以下基本准则： 应用程序必须提供一个界面，让用户来开始或者停止附件更新事件的发送。 一旦被唤醒，应用程序大约有10S时间来处理数据。理想情况下，它应该尽可能快速地处理数据然后转换到挂起状态。但是，如果需要更多的时间，应用程序可以使用beginBackgroundTaskWithExpirationHandler:方法来申请额外的执行时间。 与蓝牙附件通信使用蓝牙外设的应用程序可以请求在外设发送了一个更新时被唤醒，即使它处在挂起状态。这种支持对于需要定期发送数据的Bluetooth-LE外设来说是非常重要的。你需要在Xcode工程中的Capabilities选项卡中启这项用服务(你也可以通过在Info.plist文件中设置UIBackgroundModes的值为bluetooth-central来启用这个服务)。当你启用这个模式时，Core Bluetooth框架会保持相应外设的任何活跃会话连接。此外，当有新的数据从外设传来，系统会唤醒应用程序让他能够处理数据。在外设建立连接或失去连接时，系统也会唤醒应用程序来进行处理。 iOS 6中，一个使用蓝牙外设的应用程序也可以在外设模式下运行。要充当蓝牙外设，你需要在Xcode工程中的Capabilities选项卡中启这项用服务(您也可以通过在应用程序Info.plist文件中包含UIBackgroundModes键和bluetooth-peripheral值来启用此支持)。启用此模式可让Core Bluetooth框架在后台简单地唤醒应用程序，以便它可以处理外设的相关请求。 支持蓝牙数据后台处理的任何应用程序都必须基于会话，并遵循以下基本准则： 应用程序必须提供一个界面，允许用户启动和停止蓝牙事件的传递。 被唤醒后，应用程序大概需要10秒钟才能处理数据。理想情况下，它应该尽可能快地处理数据，并允许自己再次暂停。但是，如果需要更多的时间，应用程序可以使用beginBackgroundTaskWithExpirationHandler：方法来请求更多的时间，它应该只有在绝对必要的时候才这样做。 在后台获得用户的注意通知是处在挂起，在后台运行或没有运行的应用程序获得用户的注意的一种方式。应用程序可以使用本地通知来显示提醒框，播放声音，标记应用程序的图标或者全部一起使用。比如，一个闹钟应用程序可能会使用本地通知来播放闹铃声并显示一个提醒框来使闹钟不可用。当一个通知被发送给用户，用户必须决定是否授权让应用程序来到前台。如果应用程序已经在前台，本地通知将会被静默的发送给你的应用程序而不是发送给用户。 为了安排本地通知的发送，需要创建一个配置了通知的各个参数的UILocalNotification类的实例并调用UIApplication类的方法。本地通知对象包含了发送通知的类型和在什么时间发送它的信息。UIApplication类的方法提供了是立即发送还是按时间表发送通知的选项。 下面的代码片段展示了如何安排一个由用户设置的使用了日期和时间的闹钟的例子。这个例子在一个时间只配置了一个闹钟并在安排它之前终止了前一个闹钟(你的应用程序在任何给定的时刻都不能拥有超过128个处在活跃状态的本地通知，它们每一个都能设置成以固定的时间间隔重复)。如果闹钟被触发时，应用程序没有运行或者处在后台，闹钟会弹出提醒框并在后台播放音频。如果应用程序是活动且处在前台，则会调用应用程序的代理对象的application:didReceiveLocalNotification:方法。 123456789101112131415161718192021- (void)scheduleAlarmForDate:(NSDate*)theDate { UIApplication* app = [UIApplication sharedApplication]; NSArray* oldNotifications = [app scheduledLocalNotifications]; // Clear out the old notification before scheduling a new one. if ([oldNotifications count] &gt; 0) [app cancelAllLocalNotifications]; // Create a new notification. UILocalNotification* alarm = [[UILocalNotification alloc] init]; if (alarm) { alarm.fireDate = theDate; alarm.timeZone = [NSTimeZone defaultTimeZone]; alarm.repeatInterval = 0; alarm.soundName = @&quot;alarmsound.caf&quot;; alarm.alertBody = @&quot;Time to wake up!&quot;; [app scheduleLocalNotification:alarm]; }} 本地通知使用的音频文件和推送通知使用的要求相同。自定义的音频文件必须位于你应用程序主要包中且必须是以下几种格式：Linear PCM，MA4，μ-Law或者a-Law。你也可以指定UILocalNotificationDefaultSoundName常量来使设备播放默认的提醒声音。当通知被发送且音频被播放时，系统也会触发设备震动来配合。 何时启动应用程序进入后台支持后台执行的应用程序可能会被系统重启来处理发生的事件。如果应用程序不是被用户强制退出，系统会启动应用程序在下列事件发生时： 对于定位应用程序 系统收到一个满足发送给应用程序标准的位置更新。 设备进入或退出一个已注册的区域。 对于音频应用程序，音频框架需要应用程序来处理某些数据。 对于蓝牙应用程序 应用程序作为从连接的外设接收数据的核心角色。 应用程序作为从连接核心接收命令的外设。 对于后台下载应用程序 应用程序收到一个包含 content-available 键并且值为 1的远程通知。 系统在随机时间唤醒应用程序来开始新内容的下载。 使用NSURLSession对象在后台下载内容的应用程序，当这个会话相关的任务全部成功完成或发生了一个错误。 Newsstand应用程序内容下载完成。 在大多数情况下，系统并不会重启被用户强制退出的应用程序。定位应用程序是个例外，在iOS8和之后。如果不是的话，用户必须显式的启动应用程序或者重启设备，系统才能自动的启动程序进入后台。当启用密码保护时，在用户第一次解锁设备之前，系统不会启动任何应用程序进入后台。 成为一个负责的后台运行应用程序在使用系统资源和硬件时，前台应用程序始终比后台应用程序的优先级高。后台应用程序需要为这个差异做准备并调整它们的行为： 不要在你的代码中进行任何OpenGL ES调用。在后台运行时，你绝不能创建EAGLContext对象或发出任何OpenGL ES绘图命令。使用这些会使你的应用程序被立即终止。应用程序必须保证任何先前提交的命令在移入后台之前完成。 在挂起之前停止任何Bonjour-related服务。在你的应用程序移入后台但未被挂起之前，它应该从Bonjour注销并关闭任何与网络服务相关的监听sockets。一个挂起的应用程序无论如何不能响应任何传入的服务请求。如果你没有关闭Bonjour服务，在应用程序挂起时，系统会自动的关闭它们。 准备好处理基于网络的sockets的连接失败。系统可能会销毁socket连接，当你的应用程序因为某些原因被挂起时。只要你的基于网络的socket代码准备好了如何处理其他类型的网络失败，比如使用失败信号或网络转化，socket被销毁就不会导致出现任何不寻常的问题。当你的应用程序重新开始运行时，如果使用socket遭遇故障，只需重新建立一个。 在转入后台之前保存你的应用程序的状态。处于低内存的情况下，后台应用程序可能会被从内存中移除以释放空间。挂起的应用程序首先被移除，并且不会在移除之前通知应用程序。因此，应用程序应该利用iOS 6及之后提供的状态保存机制将应用程序状态信息保存到磁盘。 在转入后台时移除对任何不需要的对象的强引用。 在挂起之前停止使用共享系统资源。与共享系统资源进行交互的应用程序应该在被挂起之前停止使用这些资源。前台应用程序总是拥有这些资源的优先使用权。当你的应用程序挂起时，如果被发现它在使用这些共享资源，则会被系统杀死进程。 避免更新窗口和视图。因为你的应用程序的窗口和视图在后台是不可见的，你应该避免更新它们。如果你的应用程序需要在系统拍摄快照前更新窗口的内容的话则是一种例外情况。 响应外部附件的连接和断开通知。对于和外部附件通信的应用程序来说，当应用程序转入后台时系统会自动的发送一个断开通知。应用程序必须注册这个通知并用它来关闭当前附件的会话。当应用程序转入前台时，一个匹配连接的通知被发送，给应用程序重新连接的机会。 在转入后台时清理活动的提醒框的资源。为了在各个应用程序之间进行切换时保存上下文，在你的应用程序进入后台时，系统不会自动地释放上拉菜单或提醒视图。在应用程序转入后台之前，你需要提供合适的清理行为。 在转入后台之前从视图中移除敏感信息。当应用程序转入后台时，系统会对应用程序的主窗口拍摄快照，当应用程序转入到前台时，这个快照会短暂的显示。在从applicationDidEnterBackground:方法返回之前，你应该隐藏或混淆可能被作为快照一部分拍摄的密码和其它敏感的个人信息 在后台运行时尽可能的少做工作。给与后台应用程序的执行时间相比于前台应用程序来说有更多的限制。应用程序不应该在后台执行太长时间，这可能导致应用程序被终止。 选择退出后台执行如果你不希望你的应用程序在后台运行，你可以通过将值为YES的UIApplicationExitsOnSuspend键加入Info.plist来显式的退出后台模式。当一个应用程序选择退出后台，它的生命周期将在未运行，非活动和活动状态之间转换，永远不会进入后台或被挂起状态。当用户按下Home按钮来退出应用程序时，应用程序代理对象的applicationWillTerminate:方法将会被调用，应用程序将有大约5秒时间在它被终止或移入未运行状态之前来执行清理任务并退出。 强烈不鼓励退出后台执行，但在某些情况下可能是首选。 具体来说，如果后台执行的编码对你的应用程序来说增加了很大的复杂性，那么终止应用程序可能会更简单。 此外，如果你的应用程序消耗大量内存，并且无法轻松释放任何内存，系统可能会迅速杀死你的应用程序，为其他应用程序腾出空间。 因此，选择终止，而不是切换到后台，可能会产生相同的结果，并节省你的开发时间和精力。","link":"/2015/10/21/ios-background-execution/"},{"title":"JavaScript 高级程序设计 - 基础概念篇","text":"JavaScript 简介JavaScript 诞生于 1995 年，当时， 它的主要目的是处理以前由服务器端语言负责的一些输入验证操作。而今，JavaScript 已经从一个简单的输入验证器发展成为一门强大的编程语言：功能全面，能够处理复杂的计算和交互，拥有了闭包、匿名函数，甚至元编程等特性。 虽然 JavaScript 和 ECMAScript 通常被人们用来表达相同的含义，但 JavaScript 的含义却又要多得多。一个完整的 JavaScript 实例由 ECMAScript、DOM 和 BOM 组成。 ECMAScriptECMAScript-262 定义的 ECMAScript 与 Web 浏览器没有依赖关系，它定义的只是这门语言的基础，而在此基础上可以构建更完善的脚本语言。常见的 Web 浏览器只是 ECMAScript 实现可能的宿主环境之一 ： 宿主环境提供基本的 ECMAScript 实现，同时也会提供该语言的扩展，以便语言与环境之间对接交互。 文档对象模型 DOM文档对象模型（DOM，Document Object Model）是针对 XML 但经过扩展用于 HTML 的应用程序编程接口。DOM 把整个页面映射为一个多层节点结构。即 HTML 或 XML 页面中的每个组成部分都是某种类型的节点，这些节点又包含着不同类型的数据。而开发人员通过 DOM 提供的 API 可以轻松自如的删除、添加或修改任何节点。 浏览器对象模型 BOM浏览器对象模型使开发人员可以控制浏览器显示的页面以外的部分。从根本上讲，BOM 只处理浏览器窗口和框架，但是人们习惯上也把所有针对浏览器的 JavaScript· 扩展算作 BOM 的一部分。 在 HTML 中使用 JavaScript向 HTML 页面中插入 JavaScript 的主要方法，就是使用 &lt;script&gt; 元素。这个元素由 Netscape 创造并在 Netscape Navigator 2 中首先实现。后来，这个元素被加入到正式的 HTML 规范中。HTML 4.01 为 &lt;script&gt; 定义了6个属性 async : 表示应该立即下载脚本，但不应妨碍页面中的其它操作。这是一个可选属性，只对外部脚本文件有效。 charset : 可选。表示通过 src 属性指定的代码的字符集。 defer : 可选。表示脚本可以延迟到文档完全被解析和显示之后再执行。只对外部脚本文件有效。 language : 已废弃。原来用于表示编写代码使用的脚本语言。 src ：可选。表示包含要执行代码的外部文件。 type : 可选。可以看成是 language 的替代属性；表示编写代码使用的脚本语言的内容类型（MIME 类型）。虽然 text/javscript 和 text/ecmascript 都已经不被推荐使用，但人们一直以来使用的都还是 text/javascript 。实际上，服务器在传送 JavaScript 文件时使用的是 MIME 类型通常是 application/x-javascript , 但在 type 中设置这个值却可能导致脚本被忽略。考虑到约定俗成和最大限度的浏览器兼容性，目前 type 属性的默认值依旧还是 text/javascript。 使用 &lt;script&gt; 元素的方式有两种 ：直接在页面中嵌入 JavaScript 代码和包含外部 JavaScript 文件。 在使用 &lt;script&gt; 元素嵌入 JavaScript 代码时，只需为 &lt;script&gt; 指定 type 属性，然后直接把 JavaScript 代码放在元素内部即可。 123&lt;script&gt; // JavaScript Code&lt;/script&gt; 包含在 &lt;script&gt; 元素内部的 JavaScript 代码将被从上到下依次解释。在解释器对 &lt;scirpt&gt; 元素内部的所有代码求值完毕以前，页面中的其余内容都不会被浏览器加载或显示。 如果要通过 &lt;script&gt; 元素来包含外部 JavaScript 文件，那么 src 属性就是必须的。这个属性的值是一个指向外部 JavaScript 文件的链接。 1&lt;script type=&quot;text/javascript src=&quot;example.js&quot;&gt;&lt;/script&gt; 与解析嵌入式 JavaScript 代码一样，在解析外部 JavaScript 文件（包括下载该文件）时，页面的处理也会暂时停止。 无论如何包含代码，只要不存在 defer 和 async 属性，浏览器都会按照 &lt;script&gt; 元素在页面中出现的先后顺序对它们依次进行解析。 因此，在包含较多外部 JavaScript 文件的 HTML 页面中，将 &lt;script&gt; 标签放在 &lt;head&gt; 元素中，可能会造成严重的延迟。一般通过将全部 JavaScript 引用放在 &lt;body&gt; 元素中页面内容的后面。 在 HTML 中嵌入 JavaScript 代码虽然没有问题，但一般认为最好的做法还是尽可能使用外部文件来包含 JavaScript 代码。 基本概念任何语言的核心都必然会描述这门语言最基本的工作原理，而描述的内容通常都要涉及这门语言的语法、操作符、数据类型、内置功能等用于构建复杂解决方案的基本概念。 语法ECMAScript 的语法大量借鉴了 C 及其它类 C 语言的语法。 区分大小写ECMAScript 中的一切都区分大小写（变量、函数名和操作符）。 标识符所谓标识符，就是指变量、函数、属性的名字，或者函数的参数。标识符的组合规则如下： 第一个字符必须是一个字母、下划线或一个美元符号； 其它字符可以是字母、下划线、美元符号或数字。 按照惯例，ECMAScript 标识符采用驼峰大小写格式，也就是第一个字母小写，剩下的每个单词的首字母大写。 严格模式ECMAScript 5 引入了严格模式的概念。严格模式是为 JavaScript 定义了一种不同的解析与执行模型。 1&quot;use strict&quot;; // 这是一个编译指示，用于告诉支持的 JavaScript 引擎切换到严格模式 语句ECMAScript 中的语句以一个分号结尾；如果省略分号，则由解析器确定语句的末尾。虽然语句末尾的分号不是必须的，但建议任何时候都不要省略它。 关键字和保留字ECMAScript 描述了一组具有特定用途的关键字，这些关键字可用于表示控制语句的开始或结束，或者用于执行特定操作，它们不能用作标识符。 ECMAScript 还描述了一组将来可能被用作关键字的保留字。 变量ECMAScript 的变量是松散类型的，所谓松散类型就死可以用来保存任何类型的数据。即每个变量仅仅是一个用于保存值得占位符。未被初始化的变量会保存一个特殊的值 ：undefined 。ECMAScript 也支持直接初始化变量。 修改变量的值得同时也可以同时修改值得类型，虽然这样做是可行而且有效的，但是并不推荐。 如果定义变量时省略了 var 操作符，变量将会被定义为全局变量。给未经声明的变量赋值在严格模式下会导致抛出 ReferenceError 错误。 数据类型ECMAScript 中有 5 中简单数据类型 ：Undefined、Null、Boolean、Number 和 String。还有一种复杂数据类型 - Object。ECMAScript 不支持任何创建自定义类型的机制，所有值最终都将是上述 6 种数据类型之一。 typeof 操作符ECMAScript 是松散类型的，因此需要有一种手段来监测给定变量的数据类型，使用 typeof 可以完成这个目的。 “undefined” : 未定义 “boolean” ：布尔值 “string” ：字符串 “number” ：数值 “object” ： 对象或 null “function” ： 函数 Undefined 类型如果使用 var 声明变量但未对其加以初始化时，这个变量的值就是 undefined 。 值得注意的是，对未初始化的变量执行 typeof 操作符会返回 undefined 值，而对未声明的变量执行 typeof 同样也会返回 undefined 值。这两种变量虽然从技术角度上看有本质区别，但实际上无论对哪种变量也不可能执行真正的操作。 即便未初始化的变量会被自动赋予 undefined 值，但显式地初始化变量依然是明智的选择。如果能够做到这一点，那么当 typeof 返回 undefined 值时，我们就知道被检测的变量还没有被生命，而不是尚未初始化。 Null 类型从逻辑角度来看，null 值表示一个空对象指针，而这也正是使用 typeof 操作符检测 null 值时会返回 “object” 的原因。 如果定义的变量准备在将来用于保存对象，那么最好将该变量初始化为 null 而不是其它值。这样一来，只要直接检查 null 值就可以知道相应的变量是否已经保存了一个对象对的引用。 实际上，undefined 是派生自 null 值得，因此规定它们的相等性测试返回 true 。 Boolean 类型ECMAScript 中的 Boolean 类型只有两个字面值 ：true 和 false 。这两个值与数字值不是一回事，因此 true 不一定等于 1，而 false 也不一定等于 0 。 虽然 Boolean 类型的字面值只有两个，但 ECMAScript 中所有类型的值都有与这两个 Boolean 值等价的值。使用转型函数 Boolean() 可以将一个值转换为其对应的 Boolean 值。 数据类型 转换为 true 的值 转换为 false 的值 Boolean true false String 任何非空字符串 “”（空字符串） Number 任何非零数字值 0 和 NaN Object 任何对象 null Undefined n/a undefined Number 类型ECMAScript 中的 Number 类型使用 IEEE754 格式来表示整数和浮点数值。为了支持各种数值类型，ECMA 定义了不同的数值字面量格式。 123var intNum = 55; // 整数var octalNum = 070; // 八进制整数 56var hexNum = 0xA; // 十六进制整数 10 需要注意的是，八进制字面量在严格模式下是无效的，会导致支持的 JavaScript 引擎抛出错误。 在进行算数运算时，所有以八进制和十六进制表示的数值最终都将被转换为十进制数值。 浮点数值保存浮点数值需要的内存空间是保存整数值的两倍，ECMAScript 会不失时机的将浮点数值转换为整数值。 对于那些极大或极小的数值，可以用科学表示法表示的浮点数值表示。 1var floatNum = 3.14e7; // 等价于 3.14 * 10^7 浮点数值的最高精度是17位小数，但在进行算数运算时其精确度远远不如整数。例如，0.1 加 0.2 的结果不是 0.3， 而是 0.30000000000000004 。这个舍入误差会导致无法测试特定的浮点数值。 数值范围由于内存的限制，ECMAScript 并不能保存所有的数值。它能够表示的最小数值为 Number.MIN_VALUE ，在大多数浏览器中，这个值是 5e-234 。能够表示的最大数值为 Number.MAX_VALUE ，在大多数浏览器中，这个值是 1.976931348623157e+308 。如果某次计算的结果得到了一个 超出 JavaScript 数值范围的值，那么这个数值将被自动转换为特殊的 Infinity 值。如果某次计算返回了正或负的 Infinity 值，那么该值将无法继续参与下一次的计算，因为 Infinity 不是能够参与计算的数值。 可以使用 isFinite() 函数确定一个数值是不是无穷的。 NaNNaN，即非数值，它是一个特殊的数值，这个数值用于表示一个本来要返回数值的操作数未返回数值的情况。比如在 ECMAScript 中，0 除以 0 会返回 NaN，正数除以 0 会返回 Infinity ，负数除以 0 返回 -Infinity。 NaN 本省有两个非同寻常的特点。 首先，任何涉及 NaN 的操作都会返回 NaN，这个特点在多步计算中可能导致问题。 其次，NaN 与任何值都不相等，包括 NaN 本身。 针对 NaN 的特点，ECMAScript 定义了 isNaN() 函数。这个函数接受一个参数，该参数可以是任何类型，而函数会帮我们确定这个参数是否 “不是数值”。 isNaN() 在接收到一个值后，会尝试将这个值转换为数值。某些不是数值的值会直接转换为数值，而任何不能被转换为数值的值都会导致这个函数返回 true 。 数值转换有三个函数可以将非数值转换为数值 ：Number() , paresInt() , parseFloat() 。Number() 可以用于任何数据类型，而 parseInt() , parseFloat() 则用于把字符串转换成数值。 Number() 函数的转换规则如下 ： true 和 false 将分别转换为 1 和 0 null 返回 0 undefined 返回 NaN 如果是字符串，则 如果只包含数字，返回十进制数值 如果为十六进制格式，返回相同大小的十进制数值 如果是空字符串，则返回 0 如果包含除上述格式之外的字符，返回 NaN 由于 Number() 函数在转换字符串时比较复杂而且不够合理，因此处理整数的时候更常用的是 parseInt() 函数。它会忽略字符串前面的空格，直到找到第一个非空格字符。如果第一个字符不是数字字符或者负号，则返回 NaN。如果第一个字符是数字字符，parseInt() 会继续解析第二个字符，直到解析玩所有后续字符或者遇到了一个非数字字符。 需要注意的是，”1.1” 这样的字符串会被 parseInt() 转换为 1 ，因为小数点并不是有效的数字字符。 还可以为 parseInt() 函数指定第二个参数 ：转换时使用的基数。 1var num = parseInt(&quot;0xAF&quot;, 16); // 以十六进制转换字符串 与 parseInt() 不同的是，parseFloat() 只解析十进制值。 String 类型String 类型用于表示由零活多个 16 位 Unicode 字符组成的字符序列，即字符串。字符串可以由双引号或单引号表示。 字符字面量String 数据类型包含一些特殊的字符字面量，也叫转移序列，用于表示非打印字符，或者具有其它用途的字符。 字面量 含义 \\n 换行 \\t 制表 \\b 空格 \\r 回车 \\\\ 斜杠 \\' 单引号 \\&quot; 双引号 \\xnn 以十六进制代码表示的一个字符 \\unnn 以十六进制代码表示的一个 Unicode 字符 \\f 进纸 这些字符字面量可以出现在字符串中的任意位置，而且也将被作为也给字符来解析。 字符串的特点ECMAScript 中的字符串是不可变的，也就是说，字符串一旦创建，它们的值就不能改变。要改变某个变量保存的字符串，首先要销毁原来的字符串，然后再用另一个包含新值得字符串填充该变量。 转换为字符串几乎每个值都有 toString() 方法，它将返回相应值得字符串表现（null 和 undefined 没有这个方法 ）。多数情况下，调用 toString() 方法不必传递参数，但是在调用数值的 toString() 方法时，可以传递一个表示输出数值基数的参数。 在不知道要转换的值是不是 null 或 undefined 的情况下，还可以使用转型函数 String() ，这个函数能够将任何类型的值转换为字符串 ： 如果值有 toString() 方法，则调用该方法 如果值是 null ，则返回 “null” 如果值是 “undefined” ，则返回 “undefined” Object 类型ECMAScript 中的对象其实就是一组数据和功能的集合。对象可以通过执行 new 操作符后跟要创建的对象类型的名称来创建。而创建 Object 类型的实力并为其添加属性和方法，就可以创建自定义对象。 在 ECMAScript 中，Object 类型是所有它的实例的基础。 Object 的每个实例都具有下列属性和方法 ： constructor : 保存着用于创建当前对象的函数。 hasOwnProperty(propertyName) : 用于检查给定的属性在当前的对象实例中是否存在。 isPrototypeOf(object) : 用于检查传入的对象是否是传入的对象的原型。 propertyIsEnumerable(propertyName) : 用于检查给定的属性是否能够使用 for-in 语句来枚举。 toLocalString() : 返回与执行环境的地区对应的字符串表示。 toString() : 返回对象的字符串表示。 valueOf() : 返回对象的字符串、数值或布尔值表示。 操作符一元操作符递增和递减操作符前置递增/递减操作符，变量的值都是在包含它的语句被求值之前改变的，而后置递增/递减操作符的则是在包含它的语句被求值之后改变变量的值。 而且递增/递减操作符不仅适用于整数，还可以用于字符串、布尔值、浮点数职和对象 ： 在应用于一个包含有效数字字符的字符串时，先将其转换为数字值，再执行加减 1 的操作。字符串变量变成数值变量。 在应用于一个不包含有效数字字符的字符串时，将变量的值设置为 NaN。字符串变量变成数值变量。 在应用于布尔值时，先将其转换为 1 或 0，再执行加减 1 的操作。布尔值变量变成数值变量。 在应用于对象时，先调用对象的 valueOf() 方法以取得一个可供操作的值。然后对该值应用前述规则。如果结果是 NaN，则在调用 toString() 方法后再应用前述规则。对象变量变成数值变量。 加和减操作符+ 放在数值之前，对数值不会产生影响。不过，对非数值应用 + 时，它会像 Number() 转型函数一样对这个值进行转换。 - 主要用于表示负数。对非数值应用时，先转换为数值，再转换为负数。 位操作符位操作符用于在最基本的层次上，即按内存中表示数值的位来操作数值。ECMAScript 中的所有数值都以 IEEE-754 64 位格式存储，但位操作符并不直接操作 64 位的值，而是先将 64 位的值转换成 32 位的整数，然后执行操作，最后再讲结果转换回 64 位。 对于有符号的整数，32 位中的前 32 位用来表示整数的值，第 32 位用于表示数值的符号 ：0 表示正数，1 表示负数。这个表示符号的位叫做符号位，符号位的值决定了其它位数值的格式。其中，正数以纯二进制格式存储，32 位中的每一位都表示 2 的幂，没有用到的位以 0 填充，即忽略不计。负数同样以二进制码存储，但使用的格式是二进制补码。 要注意的是，在处理有符号整数时，是不能访问位 31 的。 对数值进行位操作时，NaN 和 Infinity 会被当做 0 来处理。 默认情况下，ECMAScript 中的所有整数都是有符号整数。不过，当然也存在无符号整数，对于无符号整数来说，第 32 位不再表示符号，因为无符号整数只能是整数。 按位非按位非操作符由 ~ 表示，执行按位非的结果就是返回数值的反码。即操作数的负值减 1. 按位与按位与操作符由 &amp; 表示，它有两个操作符数。从本质上来讲，按位与操作就是将两个数值的每一位对齐，然后对相同位置上的两个数执行 AND 操作。 按位或按位或操作符由 | 表示，同样有两个操作数。从本质上来讲，按位或操作就是将两个数值的每一位对齐，然后对相同位置上的两个数执行 OR 操作。 按位异或按位异或操作符由 ^ 表示，同样有两个操作数。从本质上来讲，按位异或操作就是将两个数值的每一位对齐，然后对相同位置上的两个数执行 XOR 操作。 左移左移操作符由 &lt;&lt; 表示，它会将数值的所有位向左移动指定的位数，出现的空位用 0 进行填充。 注意，左移不会影响操作数的符号位。 有符号右移右移操作符由 &gt;&gt; 表示，它会将数值的所有位向右移动指定的位数，但保留符号位，原数值中出现的空位以符号位的值来填充所有空位。 无符号右移无符号左移由 &lt;&lt;&lt; 表示，它会将数值的所有 32 位都向右移动。对正数来说，无符号右移的结果与有符号右移相同。但对负数来说，其结果就不一样了，而且无符号右移会将负数的二进制码当成整数的二进制码，因此导致无符号右移后的结果非常之大。 布尔操作符逻辑非逻辑非操作符由 ! 表示，可以应用于 ECMAScript 中的任何值。无论这个值是什么数据类型，这个操作符都会返回一个布尔值。逻辑非操作符首先会将它的操作数转换为一个布尔值，然后再对其求反。 逻辑非操作符也可以用于讲一个值转换为与其对应的布尔值。而同时使用两个逻辑非操作符，实际上就会模拟 Boolean() 转型函数的行为。 逻辑与逻辑与操作符由 &amp;&amp; 表示，有两个操作数。逻辑与操作可以应用于任何类型的操作数，而不仅仅是布尔值。在有一个操作数不是布尔值的情况下，逻辑与操作就不一定返回布尔值 ： 如果第一个操作数是对象，则返回第二个操作数 如果第二个操作数是对象，则只有在第一个操作数的求值结果为 true 的情况下才会返回该对象 如果两个操作数都是对象，则返回第二个操作数 如果有一个操作数是 null , NaN 或 undefined，则返回 null , NaN 或 undefined 逻辑与操作属于短路操作，即如果第一个操作数能够决定结果，那么就不会对第二个操作数求值。 注意，不能在逻辑与操作中使用未定义的值。 逻辑或逻辑或操作由 || 表示，有两个操作数。与逻辑与操作相似，如果有一个操作数不是布尔值，逻辑或也不一定返回布尔值 ： 如果第一个操作数是对象，则返回第一个操作数 如果第一个操作数的求值结果为 false ，则返回第二个操作数 如果两个操作数都是对象，则返回第一个操作数 如果两个操作数都是 null , NaN 或 undefined ，则返回 null , NaN 或 undefined 逻辑或操作符也是短路操作符，也就是说，如果第一个操作数的求值结果为 true ，就不会对第二个操作数求值了。 乘性操作符ECMAScript 定义了 3 个乘性操作符 ：乘法、除法和求模，在操作数为非数值的情况下会执行自动的类型转换。 乘法乘法操作符由 * 表示，用于计算两个数值的乘积。 如果乘积结果超过了 ECMAScript 的数值表示范围，则返回 Infinity 或 -Infinity 如果有一个操作数是 NaN ，则结果是 NaN Infinity 与 0 相乘，结果是 NaN Infinity 与非 0 数值相乘，结果是 Infinity 或 -Infinity ，取决于有符号操作数的符号 如果 Infinity 与 Infinity 相乘，则结果是 Infinity 如果有一个操作数不是数值，则使用 Number() 将其转换为数值 除法除法操作符由 / 表示，执行第二个操作数除第一个操作数的计算。 如果商超过了 ECMAScript 的数值表示范围，则返回 Infinity 或 -Infinity 如果有一个操作数是 NaN ，则结果是 NaN Infinity 被 Infinity 除，结果是 NaN 如果 0 被 0 除，结果是 NaN 如果非零的有限数被零除，则结果是 Infinity 或 -Infinity ，取决于有符号的操作数 如果 Infinity 被任何非 0 数值除，则结果是 Infinity 或 -Infinity ，取决于有符号的操作数 如果有一个操作数不是数值，则使用 Number() 将其转换为数值 求模求模操作符由 % 表示。 如果被除数是无穷大值而出除数是有限大的数值，则结果是 NaN 如果被除数是有限大的数值而除数是 0 ，则结果是 NaN 如果是 Infinity 被 Infinity 除，则结果是 NaN 如果被除数是有限大的数值而除数是无穷大的数值，则结果是被除数 如果被除数是 0 ，则结果是0 如果有一个操作数不是数值，则使用 Number() 将其转换为数值 加性操作符加法加法操作符由 + 表示。 如果两个操作数都是数值，执行常规的加法计算，然后按照下列规则返回结果 ： 如果一个操作数是 NaN ，则结果是 NaN 如果是 Infinity 加 Infinity ，则结果是 Infinity 如果是 -Infinity 加 -Infinity ，则结果是 -Infinity 如果是Infinity 加 -Infinity ，则结果是 NaN 如果有一个操作数是字符串 ： 如果两个操作数都是字符串，则将它们拼接起来 如果只有一个操作数是字符串，则将另一个操作数转换为字符串，然后再将两个字符串拼接起来 如果有一个操作数是对象、数值或布尔值，则调用它们的 toString() 方法取得相应的字符串值，然后再应用前述规则。 对于 undefined 和 null ，则分别调用 String() 函数并取得字符串 “undefined” 和 “null” 。 减法减法操作符由 - 表示。 如果有一个操作数是 NaN ，则结果是 NaN 如果是 Infinity 减 Infinity ，则结果是 NaN 如果是 -Infinity 减 -Infinity ，则结果是 NaN 如果是 Infinity 减 -Infinity ，则结果是 Infinity 如果是 -Infinity 减 Infinity ，则结果是 Infinity 如果有一个操作数是字符串、布尔值、null 或 undefined ，则先调用 Number() 函数将其转换为数值，然后在按照前述规则执行减法计算。如果转换的结果是 NaN ，则减法的结果就是 NaN 如果有一个操作数是对象，则调用对象的 valueOf() 方法以取得表示该对象的数值。如果得到的是 NaN ，则减法的结果就是 NaN 。如果对象没有 valueOf() 方法，则调用其 toString() 方法并将得到的字符串转换为数值 关系操作符与 ECMAScript 中其它操作符一样，当关系操作符的操作数使用了非数值时，也要进行数据转换或完成某些奇怪的操作 ： 如果两个操作数都是数值，则执行数值比较 如果两个操作数都是字符串，则比较两个字符串对应的字符编码值 如果一个操作数是数值，则将另一个操作数转换为一个数值，然后执行数值比较 如果一个操作数是对象，则调用这个对象的 valueOf() 方法，用得到的结果按照前述规则执行比较。如果对象没有 valueOf() 方法，则调用 toString() 方法，并用得到的结果根据前述规则执行比较 如果一个操作数是布尔值，则先将其转化为数值，然后再执行比较 在比较两个字符串时，实际比较的是两个字符串中对应位置的每个字符的字符编码值，因此一般需要将两个操作数转换为相同的大小写形式，然后再执行比较。 相等操作符相等和不相等ECMAScript 中的相等操作符由 == 表示，如果两个操作数相等，则返回 true 。而不相等操作符由 != 表示，如果两个操作数不相等，则返回 true 。这两个操作符都会先转换操作数，然后在比较它们的相等性。 在转换不同的数据时，需遵守以下规则 ： 如果有一个操作数是布尔值，则在比较相等性之前先将其转换为数值 – false 转换为 0 ，true 转换为 1 如果一个操作数是字符串，另一个操作数是数值，在比较相等性之前先将字符串转换为数值 如果一个操作数是对象，另一个操作数不是，则调用对象的 valueOf() 方法，用得到的基本类型值按照前述规则进行比较 这两个操作符在进行比较时要遵守下列规则 ： null 和 undefined 时相等的 比较相等性之前，不能将 null 和 undefined 转换为其它任何值 如果有一个操作数是 NaN ，则相等操作符返回 false ，而不相等操作符返回 true 如果两个数都是对象，则比较它们是否是同一个对象。如果两个操作数都指向同一个对象，则相等操作符返回 true ；否则， 返回 false 。 特殊情况 ： 1234567891011null == undefined // truetrue == 1 // truetrue == 2 // false&quot;NaN&quot; == NaN // false5 == NaN // falseundefined == 0 // falseNaN == NaN // falsenull == 0 // falseNaN != NaN // true&quot;5&quot; == 5 // truefalse == 0 // true 全等和不全等除了在比较之前不能转换为操作数之外，全等和不全等操作符与相等和不相等操作符没有什么区别。全等操作符由 === 表示，它只在两个操作数未经转换就想等的情况下返回 true 。 由于相等和不相等操作符存在类型转换问题，为了保持代码中数据类型的完整性，推荐使用全等和不全等操作符。 条件操作符1variable = boolean_expression ? true_value : false_value; 基于对 boolean_expression 的求值结果，决定给变量 variable 赋什么值。 语句if 语句、do-while 语句、while 语句、for 语句、for-in 语句与其它语言并没有不同，在此不做介绍。 label 语句使用 label 语句可以在代码中添加标签，以便将来使用。 break 和 continue 语句break 和 continue 语句用于在循环中精确地控制代码的执行。break 语句会立即退出循环，强制继续执行循环后面的语句。而 continue 语句虽然也是立即退出循环，但退出循环后会从循环的顶部继续执行。 with 语句with 语句的作用是将代码的作用域设置到一个特定的对象中 ： 1with (expression) statment; 定义 with 语句的目的主要是为了简化多次编写同一个对象的工作。 1234567891011var qs = location.search.substring(1);var hostName = location.hostName;var url = location.href;// 使用 with 语句改写with(location) { var qs = search.substring(1); var hostName = hostName; var url = href;} 严格模式下不允许使用 with 语句，视为语法错误。 由于大量使用 with 语句会导致性能下架，同时也会给调试代码造成困难，因此在开发大型应用程序时，不建议使用 with 语句。 swithc 语句ECMAScript 中的 switch 有两个特点 ： 可以在 switch 中使用任何数据类型 每个 case 的值不一定是常量，可以是变量，甚至是表达式 需要主要的是，switch 语句在比较值时使用的是全等操作符，不会发生类型转换。 函数ECMAScript 中的函数使用 function 关键字来声明，后跟一组参数及函数体。 123function functionName (arg_0, arg_1, ...) { statments} ECMAScript 中的函数在定义时不必指定是否返回值。 return 语句也可以不带有任何返回值。在这种情况下，函数在停止执行后将返回 undefined 值。这种用法一般用在需要提前停止函数执行而又不需要返回值的情况下。 严格模式下 ： 不能把函数或参数命名为 eval 或 arguments 不能出现两个命名参数同名的情况 参数ECMAScript 函数的参数不介意传递进来多少个参数，也不在乎传进来的参数是什么数据类型。ECMAScript 中函数的参数在内部是用一个数组来表示的，函数接收到的始终都是这个数组，而不关心数组中包含哪些参数。在函数体内，可以通过 arguments 对象来访问这个参数数组，从而获得传递给函数的每一个参数。 命名的参数只提供便利，但并不是必需的。而且在 ECMAScript 中，解析器不会验证命名参数。 没有传递值得命名参数将自动被赋予 undefined 值。 严格模式对如何使用 arguments 对象做出了一些限制 ：无法对命名参数进行赋值；重写 arguments 的值会导致语法错误。 arguments 本质上并不是一个数组，只是与数组类似，你可以使用方括号语法来访问它的每一个元素。 没有重载ECMAScript 中函数的参数有包含零或多个值得数组来表示，所以没有函数签名。而没有函数签名，真正的重载是不可能做到的。如果在 ECMAScript 中定义了同名函数，则该名字只属于后定义的函数。","link":"/2017/05/01/javascript-advanced-programming-basic/"},{"title":"迭代器、for...in 和 for...of","text":"如果一个对象实现了 Symbol.iterator 属性，则被认为是一个可迭代的对象。一些内建对象如 Array、Map、String 等都有自己的 Symbol.iterator 属性实现。对象上 Symbol.iterator 的方法负责返回用来迭代的值列表。 for...of 语句for...of 循环访问一个可迭代对象，并调用对象上的 Symbol.iterator 属性。 12345let someArray = [1, 'string', false];for (let entry of someArray) { console.log(entry); // 1, 'string', false} for...of 和 for...infor...of 和 for...in 都能遍历列表，但是它们遍历的值是不同的：for...in 返回被遍历对象上所有键的列表，而 for...of 则返回被遍历对象上数字属性键的值列表。 123456789let list = [4, 5, 6];for (let i in list) { console.log(i); // 0, 1, 2}for (let i of list) { console.log(i); // 4, 5, 6} 另一点不同的是，for...in 被用作检查对象属性的一种方法；而 for...of 则主要关注可迭代对象的属性值 123456789101112let aSet = new Set(['Cat', 'Dog', 'Tiger']);console.log(aSet); // Set(3) { 'Cat', 'Dog', 'Tiger' }aSet['species'] = 'mammals';console.log(aSet); // Set(3) { 'Cat', 'Dog', 'Tiger', spespecies: 'mammals' }for (let i in aSet) { console.log(i); // species}for (let i of aSet) { console.log(i); // Cat, Dog, Tiger} 如果对象是不可迭代的，则会报错 12345678910111213141516171819function iterateOverByForOf(target: any) { for (let i of target) { console.log(i); }}function iterateOverByForIn(target: any) { for (let i in target) { console.log(i); }}const aObj = { 1: 'One', 'A': 2};iterateOverByForIn(aObj); // 1, 'A'iterateOverByForOf(aObj); // target is not iterable","link":"/2018/01/09/iterators/"},{"title":"JavaScript 高级程序设计 - 变量、作用域和内存问题","text":"基本类型和引用类型ECMAScript 变量可能包含两种不同数据类型的值 ：基本类型值和引用类型值。基本类型值指的是简单的数据段，而引用数据类型指那些可能由多个值构成的对象。 在将一个值赋值给变量时，解析器必须确定这个值时基本数据类型还是引用类型值。基本类型的值是按值访问的，因为可以操作保存在变量中的实际的值。 引用类型的值时保存在内存中的对象，JavaScript 不允许直接访问内存中的位置，即不能直接操作对象的内存空间。在操作对象时，实际上是操作对象的引用而不是实际的对象（当复制保存着对象的某个变量时，操作的是对象的引用；但在为对象添加属性时，操作的是实际的对象）。 在很多其它语言中，字符串以对象的形式来表示，因此被认为是引用类型的。 动态的属性对于引用类型的值，我们可以为其添加属性和方法，也可以改变和删除属性和方法 ： 12var aObject = new Object();aObject.name = &quot;ObjectName&quot;; 复制变量值除了保存的方式不同之外，在从一个变量向另一个变量复制基本类型值和引用类型值时，也存在不同。 如果从一个变量向另一个变量复制基本类型值，会在变量对象上创建一个新值，然后把该值复制到为新变量分配的位置上。 当从一个变量向另一个变量复制引用类型值时，同样也会将存储在变量对象的值复制一份放到为新变量分配的空间中。不同的是，这个值的副本实际上是一个指针，而这个指针指向存储在堆中的一个对象。复制操作结束后，两个变量实际上将引用同一个对象。 传递参数ECMAScript 中函数的参数都是按值传递的。基本类型值得传递如同基本类型变量的复制一样，而引用类型值得传递，则如同引用类型变量的复制一样。 在向参数传递基本类型的值时，被传递的值会被复制给一个局部变量（即命名参数）。在向参数传递引用类型的值时，会把这个值在内存中的地址复制给一个局部变量，因此这个局部变量的变化会反映在函数的外部。 检测类型基本类型检测的最佳工具是 typeof 操作符。但在检测引用类型的值时，这个操作符的用处不大，我们并不是想知道某个值是对象，而是想知道它是什么类型的对象。 使用 instanceof 操作符来确定实例是否是给定的引用类型 ： 1result = variable instanceof constructor 所有引用类型的值都是 Object 的实例。因此，在检测一个引用类型值和 Object 构造函数时，instanceof 操作符始终会返回 true 。当然，如果使用 instanceof 操作符检测基本类型的值，则该操作符始终会返回 false , 因为基本类型不是对象。 执行环境及作用域执行环境是 JavaScript 中最为重要的一个概念。执行环境定义了变量或函数有权访问的其它数据，决定了它们各自的行为。每个执行环境都有一个与之关联的变量对象，环境中定义的所有变量和函数都保存在这个对象中。 全局执行环境是最外围的一个执行环境。根据 ECMAScript 实现所在的宿主环境不同，表示执行环境的对象也不一样。在 Web 浏览器中，全局执行环境被认为是 window 对象。 某个执行环境中的所有代码执行完毕后，该环境被销毁，保存在其中的所有变量和函数定义也随之销毁（全局执行环境直到应用程序退出时，才会被销毁）。 每个函数都有自己的执行环境。当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。而在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境。 当代码在一个环境中执行时，会创建变量对象的一个作用域链。作用域链的用途是保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端，始终都是当前执行代码所在环境的变量对象。如果这个环境是函数，则将其活动对象作为变量对象。活动对象在最开始时只包含一个变量，即 arguments 对象。作用域链中的下一个变量对象来自包含环境，而再下一个变量对象则来自下一个包含环境。这样，一直延续到全局执行环境；全局执行环境的变量对象始终都是作用域链中的最后一个对象。 标识符解析是沿着作用域链一级一级地搜索标识符的过程。搜索过程始终从作用域链的前端开始，然后逐级地向后回溯，直到找到标识符为止（如果找不到标识符，通常会导致错误发生）。 延长作用域链虽然执行环境的类型总共只有两种 ：全局和局部，但是还有其它办法来延长作用域链。这是因为有些语句可以在作用域链的前端临时增加一个变量对象，该变量对象会在代码执行后被移除。 在两种情况下会发生这种现象 ： try-catch 语句的 catch 块 with 语句 这两个语句都会在作用域链的前端添加一个变量对象。对 with 语句来或，会将指定的对象添加到作用域链中。对于 catch 语句来说，会创建一个新的变量对象，其中包含的是被抛出的错误对象的声明。 没有块级作用域JavaScript 没有块级作用域经常会导致理解上的困惑。在其它类 C 语言中，由花括号封闭起来的代码块都有自己的作用域，因而支持根据条件来定义变量。 1234if (true) { var color = &quot;red&quot;;}console.log(color); // red 上面的例子中，在 if 语句中定义了变量 color ，它被添加到当前的执行环境，所以在 if 语句结束后还能够被访问。 在使用 for 语句时尤其要牢记这一差异 ：由 for 语句创建的循环变量即使 for 循环执行结束后，也依旧会存在于循环外部的执行环境中。 声明变量使用关键字 var 声明的变量会自动被添加到最接近的环境中。在函数内部，最接近的环境就是函数的局部环境；在 with 语句中，最接近的环境是环境函数。如果初始化变量时没有使用 var 声明，该变量会自动被添加到全局环境。 在编写 JavaScript 代码的过程中，不声明而直接初始化变量是一个常见的错误做法。 查询标识符当在某个环境中为了读取或写入而引用一个标识符时，必须通过搜索来确定该标识符实际代表什么。搜索过程从作用域链的前端开始，向上逐级查询与给定名字匹配的标识符。如果在局部环境中找到了该标识符，搜索过程停止，变量就绪。如果在局部环境中没有找到该变量名，则继续沿作用域链向上搜索。搜索过程将一直追溯到全局环境的变量对象。如果在全局环境中也咩有找到这个标识符，则意味着该变量尚未声明。 变量查询也不是没有代价的。很明显，访问局部变量要比访问全局变量更快。 垃圾收集JavaScript 具有自动垃圾收集机制，也就是说，执行环境会负责管理代码执行过程中使用的内存。在 JavaScript 中，所需内存的分配和无用内存的回收完全实现了自动管理 ：找出那些不再继续使用的变量，然后释放其占用的内存。为此，垃圾收集器会按照固定的时间间隔，周期性的执行这一操作。 局部变量只在函数执行的过程中存在。在这个过程中，会为局部变量在栈或堆上分配相应的空间，以便存储它们的值。然后在函数中使用这些变量，直到函数执行结束。此时，局部变量就没有存在的必要了，因此可以释放它们的内存以供将来使用。在这种情况下，很容易判断变量是否还有存在的必要；但并非所有情况下都能这么容易得出结论。垃圾收集器必须跟踪哪个变量有用哪个变量没用，对于不再有用的变量打上标记，以备将来回收其占用的内存。 标记清除JavaScript 中最常用的垃圾收集方式是标记清除。当变量进入环境时，就将这个变量标记为 “进入环境” 。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开环境时，则将其标记为 “离开环境” 。 标记变量的方式很多，它并不重要，关键在于才去什么策略。 垃圾收集器在运行的时候回给存储在内存中的所有变量都加上标记。然后，它会去掉环境中的变量以及被环境中的变量引用的变量的标记。而在此之后再被加上标记的变量被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后，垃圾收集器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。 性能问题垃圾收集器是周期性运行的，而且如果为变量分配的内存数量很可观，那么回收工作量也是相当大的。这种情况下，确定垃圾收集的时间间隔是一个非常重要的问题。 管理内存使用具备垃圾收集机制的语言编写程序，开发人员一般不必操心内存管理问题。但是，JavaScript 在进行内存管理及垃圾收集时面临的最主要问题是分配给 Web 浏览器的可用内存数量通常比分配桌面应用程序的少。这样做的目的是防止运行 JavaScript 的网页耗尽全部系统内存而导致系统崩溃。内存限制不仅会影响给变量分配内存，同时还会影响调用栈以及在一个线程中能够同时执行的语句数量。 因此，确保占用最少的内存可以让页面获得更好的性能。而优化内存占用的最佳方式，就是为执行中的代码只保存必要的数据。一旦数据不再有用，最好通过将其设置为 null 来释放其引用。这一做法适用于大多数全局变量和全局对象的属性。 解除一个值的应用的真正作用是让值脱离执行环境，以便垃圾收集器下次运行时将其回收。","link":"/2017/05/17/javascript-advanced-variable-scope/"},{"title":"JSON.stringify 的解析","text":"JSON.stringify(value[, replacer [, space]]) 方法将一个 JavaScript 对象或值转换为 JSON 字符串，如果指定了一个 replacer 函数，则可以选择性地替换值，或者指定的 replacer 是数组，则可选择性地仅包含数组指定的属性。 Note 1在 JSON.stringify 方法对对象进行序列化时，如果对象的属性是 undefined/Symbol 值或任意函数时，不会对其进行处理。 这会导致被序列化的对象中的属性并不会按照原定的顺序被输出。 123456789101112131415161718192021222324252627282930313233const someObj = { _id: 'id', productCode: 'P28120068', productDetail: { name: 'Star Insure', price: 1200, amount: 1000000 }, created_at: 'Fri Nov 13 2020 09:25:31 GMT+0800 (China Standard Time)', updated_at: 'Fri Nov 13 2020 09:25:31 GMT+0800 (China Standard Time)', nullValue: null, undefinedValue: undefined, // JSON.stringify 不会序列化 undefined symbolValue: Symbol('TypeScript'), // JSON.stringify 不会序列化 Symbol arrowLog: () =&gt; console.log(this), // JSON.stringify 不会序列化 箭头函数 funLog: function() { console.log(this) }, // JSON.stringify 不会序列化 函数}/** * Note 1 : undefined、Symbol、任何函数作为对象的属性值时，JSON.stringify 不对其(忽略)进行序列化 * { * &quot;_id&quot;:&quot;id&quot;, * &quot;productCode&quot;:&quot;P28120068&quot;, * &quot;productDetail&quot;:{&quot; * name&quot;:&quot;Star Insure&quot;, * &quot;price&quot;:1200, * &quot;amount&quot;:1000000 * }, * &quot;created_at&quot;:&quot;Fri Nov 13 2020 09:25:31 GMT+0800 (China Standard Time)&quot;, * &quot;updated_at&quot;:&quot;Fri Nov 13 2020 09:25:31 GMT+0800 (China Standard Time)&quot;, * &quot;nullValue&quot;:null * } */console.log(JSON.stringify(someObj)); Note 2在 JSON.stringify 方法对数组进行序列化时，如果数组元素的值是 undefined、Symbol 值或任意函数时，会被序列化为 null。 1234567891011121314const someArr = [ null, undefined, // JSON.stringify 将数组中的 undefined 序列化为 null Symbol('TypeScript'), // JSON.stringify 将数组中的 Symbol 序列化为 null () =&gt; console.log(this), // JSON.stringify 将数组中的 箭头函数 序列化为 null function() { console.log(this) } // JSON.stringify 将数组中的 函数 序列化为 null]/** * Note 2 : undefined, Symbol, 任意函数作为数组的元素时，JSON.stringify 将其序列化为 null * [null,null,null,null,null] */console.table(JSON.stringify(someArr)); Note 3如果 undefined、Symbol 值或任意函数作为单独的值被 JSON.stringify 序列化为 undefined。 123456/** * Note 3 : undefined, Symbol, 任意函数作为单独的值时，JSON.stringify 序列化会返回 undefined */console.log(JSON.stringify(undefined)); // undefinedconsole.log(JSON.stringify(Symbol('TypeScript'))); // undefinedconsole.log(JSON.stringify(() =&gt; console.log(this))); // undefined Note 4如果目标值有 toJSON 方法，则 toJSON 来决定 JSON.stringify 返回的值。 12345console.log(JSON.stringify({ name: 'Jimmy', age: 20, toJSON: () =&gt; 'this is a toJSON function',})); // this is a toJSON function Note 5NaN, InInfinity 及 null 会被JSON.stringify 序列化为 null。 123456789/** * NaN, InInfinity 及 null 会被 JSON.stringify 序列化为 null */console.log(NaN); // NaNconsole.log(JSON.stringify(NaN)); // nullconsole.log(Infinity); // Infinityconsole.log(JSON.stringify(Infinity)); // nullconsole.log(null); // nullconsole.log(JSON.stringify(null)); // null Note 6数字、字符串和布尔值的包装值在被 JSON.stringify 序列化时会解包成对应的基础值。 123const packArr = [ new Number(1), new String('TypeScript'), new Boolean(false)];console.log(packArr); // [ [Number: 1], [String: 'TypeScript'], [Boolean: false] ]console.log(JSON.stringify(packArr)); // [1,&quot;TypeScript&quot;,false] Note 7JSON.stringify 在序列化对象时，仅会序列化可枚举的属。 12345const enumerableObj = Object.create(null, { name: { value: 'jack', enumerable: true }, age: { value: 20, enumerable: false }});console.log(JSON.stringify(enumerableObj)); // { name: 'jack' } Note 8如果 JSON.stringify 的目标对象发生循环引用时，会报错。 123456789101112131415161718/** * 对于相互引用的对象，会报错 * TypeError: Converting circular structure to JSON --&gt; starting at object with constructor 'Object' | property 'refA' -&gt; object with constructor 'Object' --- property 'refB' closes the circle */const objA = { name: 'Object A', refB: null,};const objB = { name: 'Object B', refA: objA,};objA.refB = objB; Note 9以 Symbol 值为键的属性值，在被 JSON.stringify 序列化时会被忽略。 123456789/** * 以 Symbol 值为键的属性值，在被 JSON.stringify 序列化时会被忽略 */const symbolObj = { name: 'Symbol', [Symbol.for('Age')]: 20,};console.log(symbolObj); // { name: 'Symbol', [Symbol(Age)]: 20 }console.log(JSON.stringify(symbolObj)); // {&quot;name&quot;:&quot;Symbol&quot;} Note 10当 JSON.stringify 的第二个参数是函数时, 可单独对某个值进行处理。 12345678910111213141516171819202122232425const someObj = { _id: 'id', productCode: 'P28120068', productDetail: { name: 'Star Insure', price: 1200, amount: 1000000 }, created_at: 'Fri Nov 13 2020 09:25:31 GMT+0800 (China Standard Time)', updated_at: 'Fri Nov 13 2020 09:25:31 GMT+0800 (China Standard Time)', nullValue: null, undefinedValue: undefined, // JSON.stringify 不会序列化 undefined symbolValue: Symbol('TypeScript'), // JSON.stringify 不会序列化 Symbol arrowLog: () =&gt; console.log(this), // JSON.stringify 不会序列化 箭头函数 funLog: function() { console.log(this) }, // JSON.stringify 不会序列化 函数}/** * 当 JSON.stringify 的第二个参数是函数时, 可单独对某个值进行处理 */console.log(JSON.stringify(someObj, (k, v) =&gt; { console.log(v) if (typeof v === 'undefined') return 'undefined'; return JSON.stringify(v);})); 当 JSON.stringify 的第二个参数是数组时，可在数组中加入属性名，来规定返回哪些属性的序列化值。 12345678910111213141516171819202122const someObj = { _id: 'id', productCode: 'P28120068', productDetail: { name: 'Star Insure', price: 1200, amount: 1000000 }, created_at: 'Fri Nov 13 2020 09:25:31 GMT+0800 (China Standard Time)', updated_at: 'Fri Nov 13 2020 09:25:31 GMT+0800 (China Standard Time)', nullValue: null, undefinedValue: undefined, // JSON.stringify 不会序列化 undefined symbolValue: Symbol('TypeScript'), // JSON.stringify 不会序列化 Symbol arrowLog: () =&gt; console.log(this), // JSON.stringify 不会序列化 箭头函数 funLog: function() { console.log(this) }, // JSON.stringify 不会序列化 函数}/** * 当 JSON.stringify 的第二个参数是数组时，可在数组中加入属性名，来规定返回哪些属性的序列化值 * 但当值是 undefined、Symbol、任何函数时无效 */console.log(JSON.stringify(someObj, ['productCode', 'arrowLog'])); // { productCode: 'P28120068' }","link":"/2018/05/12/json-stringify/"},{"title":"JavaScript Tutorial","text":"JavaScript Where ToScript can be placed in the , or in the section of an HTML page , or in both. But placing scripts at the bottom of the element improves the display speed , because script complation slow down the display. Scripts can also be placed in external files and it is a practical method to solve the problem the same code is used in many different web pages . It’s important to note that you can’t contain tags in external scripts . Placing scripts in external files has some advantages as below : It separates HTML and code It makes HTML and JavaScript easier to read and maintain Cached JavaScript files can speed up page loads External scripts can be referenced with a full URL or with a path relative to the current web page . JavaScript OutputJavaScript can display data use innerHTML/document.write()/window.alert()/console.log() . Using innerHTML 1document.getElementById().innHTML = 'content'; Changing the innerHTML property of an HTML element is a common way to display data in HTML. Using document.write() For testing purposes , it is convenient to use document.write() . 1document.write('content'); Noted: Using document.write() after an HTML document is fully loaded , will delete all existing HTML . Using window.alert() 1window.alert('content'); Using console.log() For debugging purpose, you can use the console.log() method to display data. 1console.log('content'); JavaScript StatementsA JavaScript program is a list of programming statements. In HTML, JavaScript programs are executed by the web browser. A JavaScript statement consists of values, operators, expressions, keywords and comments. The statements are executed one by one, in the same order as they are written. SemicolonsJavaScript statements separated by semicolons. 1234var a, b, c;a = 1;b = 2;c = 3; When separated by semicolons, you are allowed write multiple statements on one line. Ending statements with semicolons is not required, but highly recommended. JavaScript White SpaceJavaScript ignores multiple spaces. You can add white space to your script to make ite more readable and put spaces around operators is a good practice. JavaScript Line Length and Line BreaksYou should avoid code lines longer than 80 characters for best readability. JavaScript Code BlocksJavaScript statements can be grouped together in code blocks, inside curly brackets {}. The purpose of code blocks is to define statements to be executed together. JavaScript KeywordsJavaScript statements often start with a keyword to identify the JavaScript action to be performed and they are all reserved words. Reserved words cannot be used as names of variables. JavaScript SyntaxJavaScript syntax is the set of rules, how JavaScript programs are constructed. JavaScript ValuesThe JavaScript syntax defines two types of values: Fixed values and variable values. Fixed values are called literals. Variable values are called variables. JavaScript OperatorsJavaScript uses arithmetic operators (+ - * /) to compute values and use an assignment operator (=) to assign values to variables. JavaScript ExpressionsAn expressions is a combination of values, variables, and operators, which computes to a value. JavaScript is Case SensitiveAll JavaScript identifiers are case sensitive. JavaScript and Camel CaseHistorically, programmers have used different ways of joining multiple words into one variable name . Hyphens are not allowed in JavaScript. They are reserved for subtractions Underscore Upper Camel case (Pascal Case) Lower Camel Case JavaScript tend to use camel case that start with a lowercase letter, such as : 1firstName, lastName, masterCard, interCity JavaScript Character SetJavaScript uses the Unicode character set JavaScript CommentsJavaScript comments can be used to explain JavaScript code, and to make it more readable. Single line comments start with //. Any text between // and the end of line will be ignored by JavaScript Multi-line Comments start with /* and end with /. Any text between /\\ and */ will be ignored by JavaScript JavaScript VariablesJavaScript variables are containers for storing data values. In programming, just like in algebra, we use variables to hold values. All JavaScript variables must be identified with unique names. These unique names are called identifiers. The general rules for constructing names for varialbes ard : Names can contain letters, digits, underscores, and dollar signs. Names must begin with a letter Names can also begin with $ and __ Names are case sensitive Reserved words cannot be used as names It is a good programming practice to declare all variables at the beginning of a script. A variable declared without a value will have the value undefined . If you put a number in quotes, the rest of numbers will be treated as strings and concatenated. JavaScript Data TypesJavaScript variables can hold many data types: numbers, string, objects and mored. In programming, data types is an import concept. To be able to operate on variables, it is important to konw something about the type. When adding a number and a string, JavaScript will treat the number as a string. JavaScript evaluates expression from left to right. Different sequences can produce different results. JavaScript has dynammic types. This means that the same variable can be used to hold different data types. You can use the JavaScript typeof operator to find the type of a JavaScript variable. The typeof operator returns the type of a variable or an expression. In JavaScript, a variable without a value, has the value undefined . The typeof is also undefined . In JavaScript null is “nothing”. It is supposed to be something that doesn’t exist. Unfortunately, in JavaScript, the data of null is an object. You can consider it a bug in JavaScript that typeof null is an object. It should be null. Difference Between Undefined and NullUndefined and null are equal in value but different in type 12345typeof undefined // undefinedtypeof null // objectnull === undefined // falsenull == undefined // true JavaScript FunctionsA JavaScript function is a block of code designed to perform a particular task. A JavaScript function is executed when “something” invokes it. Syntax A JavaScript function is defined with the function keyword, followed by a name, followed by parentheses (). Function names can contain letters, digits, underscored, and dollar signs. The parentheses may include parameter names separated by commas: (parameter, parameter, …). Invocation The code inside the function will execute when “something” invokes the function : when an event occurs When it is invoked from JavaScript code Automatically Return When JavaScript reaches a return statement, the function will stop executing. If the function was invoked from a statement, JavaScript will return to execute the code after the invoking statement. Function often compute a return value. The return value is “returned” back to the caller. 1234567// define a functionfunction convertStringToLowerCase (text) { return text.toLocaleLowerCase();}// invoke a function var lowerCaseStr = convertStringToLowerCase(&quot;Hello JavaScript !&quot;); Accessing a function without () will return the function definition instead of the function result. Why Functions? You can reuse code by using function. As it is : Define the code once, and use it many times. Functions used as variable values Functions can be used the same way as you use variables, in all types of formulas, assignments, and calculations. 1console.log(&quot;text&quot;.toLocalLowerCase()); JavaScript ObjectJavaScript objects are containers for named values called properties or methods. Object Definition You define a JavaScript object with an object literal 1var object = {key: value, key: value, ...}; Object Properties The name:values pairs in JavaScript objects are called properties. You can access object properties in two ways : objectName.propertyName objectName[&quot;propertyName&quot;] Object Methods Objects can also have methods - actions that can be performed on objects. Methods are stored in properties as function definitions. A method is a function stored as a property. 123456var objct = { key: value, key: value, ... methodName: function () {}}; The this keyword In a function definition, this refers to the “owner” of the function. Accessing Object Mehtods You access an object method with the following syntax : 1objctName.methodName(); Do Not Declare Strings, Numbers, and Booleans as Objects! When a JavaScript variable is declared with the keyword “new”, the variable is created as an object. Avoid String, Number, and Boolean objects. They complicate your code and slow down execution speed. JavaScript ScopeScope determines the accessibility of variables. Function Scope In JavaScript there are two types of scope: Local scope Global scope JavaScript has function scope: Each function creates a news scope. Scope determines the accessibility of these variables. Variables defined inside a function are not accessible from outside the function. Local Variables Variables declared within a JavaScript function, become Local to the function. Local variables have local scope: They can only be accessed within the function. Since local variables are only recognized inside their functions, variables with the same name can be used in different functions. Local variables are created when a function starts, and deleted when the function is completed. Global Variables A variable declared outside a function, become Global. A global variable has global scope: All scripts and functions on a web page can access it. JavaScript Variables In JavaScript, objects and functions are also variables. Scope determines the accessibility of variables, objects, and functions from different parts of the code. Automatically Global If you assign a value to a variable that has not been declared, it will automatically become a global variable, even if the variable inside a function. Strict Mode All modern browsers support running JavaScript in “Strict Mode”. In Strict mode, global variables are not created automatically. Global Variables in HTML With JavaScript, the global variable scope is the complete JavaScript environment. In HTML, the global scope is the window object. All global variables belong to the window object. The Lifetime of JavaScript Variables The lifetime of a JavaScript variable starts when it is declared. Local variables are deleted when the function is completed. In a web browser, global variables are deleted when you close the browser window, but remain available to new pages loaded into the same window. JavaScript EventsHTML events are “things” that happen to HTML elements. When JavaScript is used in HTML pages, JavaScript can “react” on these events. HTML Events An HTML event can be something the browser dose, or somthing a user does. JavaScript lets you execute code whtn events are detected. HTML allows event handler attributes, with JavaScript code, to be added to HTML elements. 1&lt;element event=&quot;some JavaScript&quot;&gt; JavaScript code is often several lines long. It is more common to see event attributes calling functions. 1&lt;element event=&quot;functoinName&quot;&gt; What can JavaScript Do ? Event handlers can be used to handle, and verify, user input, user actions, and browser actions. JavaScript StringsJavaScript strings are used for storing and manipulating text. String Length The length of a string is found in the built in property length. 12var txt = &quot;AaBbCcDdEeFfGg&quot;;var length = txt.length; Special Characters Because strings must be written within quotes, JavaScript will misunderstand this string and the solution to avoid this problem, is to use the backslash escape character. Breaking Long Code Lines For best readability, programmers often like to avoid code lines longer than 80 characters. If a JavaScript statements does not fit on one line, the best place to break it is after an operator. 12document.getElementById(&quot;element-id&quot;).innerHTML =&quot;content&quot;; You can also break up a code line within a text string with a single backslash. 123var text = &quot;Line - 1 \\Line - 2&quot;; Strings Can be Objects Normally, JavaScript strings are primitive values, created from literals, but strings can also be defined as objects with the keyword new. 12var literalStr = &quot;literal string&quot;;var objectStr = new String(&quot;object string&quot;); JavaScript String Methods Primitive values cannot have propertiess or methods, because they are not objects. But with JavaScript, methods and properties are also available to primitive values, because JavaScript treats primitive values as objects when executing methods and properties. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768var orignalStr = &quot;AaBbCcDdAaBbCcDd&quot;;var subStr = &quot;aB&quot;;// the length property returns the length of a string// strLength is 8var strLength = orignalStr.length; // the indexOf() method returns the index of the first occurrence of a specified text in a string// subStrIndex is 1// the lastIndexOf() method returns the index of the last occurrence of a specified text in a string// lastIndexOfSubStr is 9// Both indexOf() and lastIndexOf() return -1 if the text is not found// Both indexOf() and lastIndexOf() accept a second parameter as the starting position for search.var subStrIndex = orignalStr.indexOf(subStr);var lastIndexOfSubStr = orignalStr.lastIndexOf(subStr);// the search() method search a string for a specified value and return the position of the match// search() method cannot accept second parameter and can take regular expressions as search values// subStrIndex is 1var subStrIndex = orignalStr.search(subStr);// slice(start, end),substring(start, end), and substr(start, length) for extracting a part of a string.// slice() extracts a part of a string and returns the extracted part in a new string// substring() is similar to slice(), the difference is that substring() cannot accept negative indexes// substr() is similar to slice(), the difference is that the second parameter specifies the length of the extracted part.// now resultStr1, resultStr2, resultStr3 is AaBbvar resultStr1 = orignalStr.slice(0, 3);var resultStr2 = orignalStr.substring(0, 3);var resultStr3 = orignalStr.substr(0, 4);// the replace() method replaces a specified value with anthor value in a string// resultStr now is Hello JavaScript// the replace() method does not change the string it is called on, it returns a new string.// By default, the replace() function replaces only the first match// To replace all matches, use a regular expression with a /g flagorignalStr = &quot;Hello Lee Code&quot;;resultStr = orignalStr.replace(&quot;Lee Code&quot;, &quot;JavaScript&quot;);// A string is converted to upper case with toUpperCase()// now resultStr is ABCDEFGorignalStr = &quot;abcdefg&quot;;resultStr = orignalStr.toUpperCase();// A string is converted to lower case with toLowerCase()resultStr = resultStr.toLowerCase();// contact() joins two or more stringsvar contactStr = &quot;A&quot;.contact(&quot;B&quot;,&quot;C&quot;,&quot;D&quot;);// trim() method remove whitespace from both sides of a string// now resultStr is ABCorignalStr = &quot;A B C&quot;;resultStr = orignalStr.trim();// the charAt() method returns the character at a specified index in a string// now resultStr is A resultStr = orignalStr.charAt(0);// Accessing a string as an array is unsafe// You can accessing a string as an array but it is upsafe and unpredictable// If you want read a string as an array, convert it to an array first// split() method can convert a string to an array// now charArr is [a, b, c, d, e, f, g]orignalStr = &quot;a,b,c,d,e,f,g&quot;;var charArr = orignalStr.split(&quot;,&quot;); All string methods return a new string. They don’t modify the orignal string. Formally said: Strings are immutable: Strings cannot be changed, only replaced. JavaScript NumbersJavaScript has only one type of number. Numbers can be writtenn with or without decimals. Extra large or extra small numbers can be written with scientific notation. 12let x = 123e5;let y = 123e-5; JavaScript Numbers are always 64-bit Floating Point JavaScript numbers are always stored as double precision floating point numbers, following the international IEEE 754 standard. This format stores numbers in 64 bits, where the number is stored in bits 0 to 51, the exponent in bits 52 to 62, and the sign in bit 63. Precision Integers are accurate up to 15 digits. The maximum number of decimals is 17, but floating point arithmetic is not always 100% accurate. 12// x will be 0.3000000000000004let x = 0.2 + 0.1; To solve the problem above, it helps to multiply and divide 1let x = (0.2*10 + 0.1*10) / 10; Adding Numbers and Strings JavaScript uses the + operator for both addition and concatenation. Numbers are added. Strings are concatenated. 123456789// strResult will be 12let strX = &quot;1&quot;;let strY = &quot;2&quot;;let strResult = strX + strY;// numberResult will be 3let numberX = 1;let numberY = 2;let numberResult = numberX + numberY; The JavaScript compiler works from left to right. Numeric Strings JavaScript strings can have numeric content and JavaScript will try to convert strings to numbers in all numeric operations. 1234// result will be 0.5let x = &quot;1&quot;;let y = &quot;2&quot;;let result = x / y; NaN - Not a Number NaN is a JavaScript reserved word indicating that a number is not a legal number. Try to do arithmetic with a non-numberic string will result in NaN. 12// x will be NaNlet x = 100 / &quot;a&quot;; You can use the global JavaScript function isNaN() to find out if a value is a number. NaN is a number : typeof NaN returns number: 12// returns &quot;number&quot;typeof NaN; Infinity Infinity is the value JavaScript will return if you calculate a number outside the largest possible number. Division by 0 also generates Infinity. Infinity is a number: typeof Infinity returns number. Hexadecimal JavaScript interprets numeric constants as hexadecimal if they are preceded by 0x. Never write a number with a leading zero. Some JavaScript versions interpret numbers as octal if they are written with a leading zero. By default, JavaScript displays numbers as base 10 decimals. But you can use the toString() method to output numbers from base 2 to base 36. 123456let number = 32;number.toString(10); // 32number.toString(32); // 10number.toString(16); // 20number.toString(8); // 40number.toString(2); // 100000 Numbers Can be Objects Normally JavaScript numbers are primitive values created from literals, but numbers can also be defined as objects with the keyword new. 12let x = 123; // typeof x return numberlet y = new Number(123); // typeof y return object Do not create Number objects. It slows down execution speed. Or even worse, Objects cannot be compared. JavaScipt Number Methods Number methods help you work with numbers. All number methods can be used on any type of numbers. toString() toString() returns a number as a string toExponential() toExponential() returns a string, with a number rounded and written using exponential notation. A parameter defines the number of characters behind the decimal point. The parameter is optional, if you don’t specify it, JavaScript will not round the number. 1234let x = 1.23456;x.toExponential(2); // 1.23e+0x.toExponentail(4); // 1.2345e+0;x.toExponentail(6); // 1.234560e+0 toFixed() toFixed() returns a string, with the number written with a specified number of decimals. 12345let x = 1.2345;x.toFixed(0); // 1x.toFixed(2); // 1.23x.toFixed(4); // 1.2345x.toFixed(6); // 1.234500 toPrecision() toPrecision() returns a string, with a number written with a specified length 12345let x = 1.2345;x.toPrecision(); // 1.2345x.toPrecision(2); // 1.2x.toPrecision(4); // 1.235x.toPrecision(6); // 1.234500 valueOf() valueOf() returns a number as a numer. This method is used internally in JavaScript to convert Number objects to primitive values. All JavaScript data types have a valueOf() and a toString() method. Converting Variables to Numbers There are 3 JavaScript methods that can be used to convert variables to numbers : Number() , parseInt() , parseFloat() . These methods are not number methods, but global JavaScript methods. JavaScript global methods can be used on all JavaScript data types. Number() This method returns a number, converted from its argument. 123456Number(true); // 1Number(false); // 0Number(&quot;10&quot;); // 10Number(&quot; 10&quot;); // 10Number(&quot;10 20&quot;); // NaNNumber(&quot;John&quot;); // NaN If the number cannot be converted, NaN is returned. Number() can also convert a date to a number 1Number(new Date(&quot;2016-06-10&quot;); // returns the number of milliseconds since 1.1.1970 parseFloat() This method parses its argument and returns a floating point number. Space are allowed. 12345parseFloat(&quot;10&quot;); // 10parseFloat(&quot;10.33&quot;); // 10.33parseFloat(&quot;10 20&quot;); // 10parseFloat(&quot;10 years&quot;); // 10parseFloat(&quot;years 10&quot;); // NaN parseInt() This method parsed its argument and returns an integer. Space are allowed. 12345parseInt(&quot;10&quot;); // 10parseInt(&quot;10.33&quot;); // 10parseInt(&quot;10 20 30&quot;); // 10parseInt(&quot;10 years&quot;); // 10parseInt(&quot;years 10&quot;); // NaN Number Properties Number properties belongs to the JavaScript’s number object wrapper called Number. These properties can only be accessed as Number.propertyName . And these properties cannot be used on variables. MAX_VALUE Returns the largest number possible in JavaScript MIN_VALUE Returns the smallest number possible in JavaScript NEGATIVE_INFINITY Represents negative infinity (returned on overflow) NaN Represents a “Not-a-Number” value POSITIVE_INFINITY Return infinity (return on overflow) JavaScript ArraysJavaScript arrays are used to store multiple values in a single variable. An array can hold many values under a single name, and you can access the values by referring to an index number. Creating an Array Using an array litral is the easiest way to create a JavaScript Array. 1var array_name = [item, item, item, ...]; Using the keyword new create an array. 1var array_name = new Array(item, item, ...); Accessing the Elements of an Array You refer to an array element by referring to the index number. 1234let arrayNum = [1, 2, 3, 4];let element = arrayNum[0]; // element is 1arrayNum[1] = 0;element = arrayNum[1]; // element is 0 Accessing the Full Array With JavaScript, the full array can be accessed by referring to the array name. Arrays are a special type of objects, with numberd indexes. The typeof operator in JavaScript returns “object” for arrays. How to Recognize an Array? Array.isArray() Create your own isArray() function 123function isArray(arr) { return arr.constructor.toString().indexOf(&quot;Array&quot;) &gt; -1;} instanceof operator 12let arrayNum = [1, 2, 3, 4];arrayNum instanceof Array // true JavaScript Array Methods toString() The method toString() converts an array to a string of array values. 12let arrayStr = [&quot;Hello &quot;, &quot; World&quot;, &quot; !&quot;];let resultStr = arrayStr.toString(); // result is Hello World ! JavaScript automatically converts an array to a comma separated string when a primitive value is expected. This is always the case when you try to output an array. 12let strArr = [&quot;Apple&quot;, &quot;Google&quot;, &quot;Facebook&quot;, &quot;Twitter&quot;];let result = strArr.toString(); // result is &quot;Apple&quot;,&quot;Google&quot;,&quot;Facebook&quot;,&quot;Twitter&quot; join() The method join() alos joins all array elements into a string. It behaves just like toString(), but in addition you can specify the separator. 12let arrayNum = [1, 2, 3, 4];let rusultStr = arrayNum.join(&quot;*&quot;); // resultStr is 1*2*3*4 pop() The method pop() removes the last element from an array 12let arrayNum = [1, 2, 3, 4];let result = arrayNum.pop(); // arrayNum now is [1, 2, 3] and result is 4 push() The method push() adds a new element to an array at the end and return the new array length. 12let arrayNum = [1, 2, 3];let result = arrayNum.push(4); // now arrayNum is [1, 2, 3, 4] and result is t shift() The method shift() removes the first array element and shifts all other elements to a lower index. 12let arrayNum = [1, 2, 3, 4];let result = arrayNum.shift(); // arrayNum is [2, 3, 4] and result is 1 unshift() The method unshift() method adds a new element to an array at the beginning and return the new array length 12let arrayNum = [1, 2, 3, 4];let result = arrayNum.unshift(0); // now arrayNum is [0, 1, 2, 3, 4] and result is 5 splice() The method splice() method can be used to add new items to an array. 12let arrayNum = [1, 2, 3];arrayNum.splice(2, 0, 0.1, 0.2); // now arrayNum is [1, 2, 0.1, 0.2, 3] Also can be used to remove elements 12let arrayNum = [1, 2, 3];arrayNum.splice(0, 1); // now arrayNum is [2, 3] concat() The method concat() creates a new arry by merging existing arrays and it can take any number fo array arguments. 123let arrX = [1, 2, 3];let arrY = [4, 5];let result = arrX.concat(arrY); // result is [1, 2, 3, 4, 5] The concat() method can also take values as arguments. slice() The slice() method slices out a piece of an array into a new array and creates a new array. It does not remove any elements from the source array. 123let strArr = [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;];let result = strArr.slice(1); // result is [&quot;B&quot;, &quot;C&quot;, &quot;D&quot;]result = strArr.slice(1, 3); // now result is [&quot;B&quot;, &quot;C&quot;] Sorting an Array sort() The sort() method sorts an array alphabetically 12let strArr = [&quot;b&quot;, &quot;d&quot;, &quot;a&quot;, &quot;c&quot;];strArr.sort(); // now strArr is [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;] By default, the sort() function sorts values as strings. Because of this, the sort() method will produce incorrect result when sorting numbers. You can fix this by providing a compare function. 1234567let numArr = [100, 20, 50 10, 40];numArr.sort( function (numX, numY) { return numX - numY;}); // now numArr is [10, 20, 40, 50, 100]numArr.sort( function (numX, numY) { return numY - numX;}); // now numArr is [100, 50, 40, 20, 10] The purpose of the compare function is to define an alternative sort order. The compare function should return a negative, zero, or positive value, depending on the arguments. You can even sorting an array in random order. 1234let numArr = [1, 2, 4, 3, -1];numArr.sort( function (numX, numY) { return 0.5 - Math.random();}); reverse() The reverse() method reverses the elements in an array. 123let strArr = [&quot;b&quot;, &quot;d&quot;, &quot;a&quot;, &quot;c&quot;];strArr.sort(); // now strArr is [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]strArr.reverse(); // now strArr is [&quot;d&quot;, &quot;c&quot;, &quot;b&quot;, &quot;a&quot;] Find the highest (or lowest) array value There are no built-in functions for finding the max or min value in an array. However, after you have sorted an array, you can use the index to obtain the highest and lowest values 123456789let numArr = [100, 20, 50, 10, 40];numArr.sort( function (numX, numY) { return numX - numY;}); // now numArr is [10, 20, 40, 50, 100]const minValue = number[0]numArr.sort( function (numX, numY) { return numY - numX;}); // now numArr is [100, 50, 40, 20, 10]const maxValue = numArr[0]; You can also use Math.max.apply to find the highest number in an array 12345let numArr = [100, 20, 50, 10, 40];function maxValueInArr (arr) { return Math.max.apply(null, arr);};const maxValue = maxValueInArr(numArr); // maxValue is 100 Or ues Math.min.apply() to find th lowest number in an array 12345let numArr = [100, 20, 50, 10, 40];function minValueInArr (arr) { return Math.min.apply(null, arr);};const minValue = minValueInArr(numArr); // minValue is 100 The fastest solution is to use a “home made” method. The function loops through an array comparing each value with the highest value found. 12345678910function maxValueInArr (arr) { let arrLen = arr.length; let maxValue = - Infinity; while (arrLen --) { if (arr[arrLen] &gt; max) { maxValue = arr[arrLen]; } } return maxValue;} The function loops through an array comparing each value with lowest value found. 12345678910function minValueInArr (arr) { let arrLen = arr.length; let minValue = Infinity; while (arrLen--) { if (arr[arrLen] &lt; minValue) { minValue = arr[arrLen]; } } retrun minValue;} JavaScript arrays often contain objects. Even if objects have properties of different data types, ther short() method can be used to sort the array. The solution is to write a compare function to compare the property values. 12345678let objArr = [{name:&quot;a&quot;, age: 19}, {name:&quot;b&quot;, age: 9}, {name:&quot;ac&quot;, age: 80}];objArr.sort(function sortObjByAge (objX, objY) {let ageX = objX.age; let ageY = objY.age; if (ageX &lt; ageY) { return -1;} if (ageX &gt; ageY) {return 1;} return 0;}); JavaScript Array Iteration Array iteration methods operate on every array item. Array.forEach() The forEach() method calls a function once fro each array element. 12345let strArr = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;];let result = &quot;&quot;;strArr.forEach( function (value, index, arr) { result = result + value + &quot;\\n&quot;;}); Array.map() The map() method creates a new array by performing a function on each arry element. 1234let numArr = [12, 2, 33, 21, 4];let newNumArr = numArr.map( function (value, index, array) { return value*2;}); Array.filter() The filter() method creates a new array with array elements that passes a test. 1234let numArr = [1, 3, 5, 7, 9, 2, 4, 6, 8, 0];let evenNumArr = numArr.filter( function (value, index, arr) { if (value % 2 == 0) { return value;}}); Array.reduce() The reduce() method reduces an array to single variable. 1234let numArr = [1, 3, 5, 7, 9];let result = numArr.reduce( (sum, value) =&gt; { return sum + value;}); Array.every() The every() method check if all array values pass a test. 1234let numArr = [1, 3, 5, 7, 9, 2, 4, 6, 8, 0];let evenNumArr = numArr.every( function (value) { if (value % 2 == 0) { return value;}}); Array.indexOf() Search an array for an element value and returns its position. 12let numArr = [1, 3, 5, 7, 9];let result = numArr.idnexOf(5); Array.lastIndexOf() Array.lastIndexOf() is the same as Array.indexOf() , but searches from the end of the array. JavaScript Date ObjectsBy default, JavaScript will use the browser’s time zone and display a date as a full text string ： Fri Jun 13 2016 14:24:54 GMT+0800 (China Standard Time) Creating Date Objects Date objects are created with the new Date() constructor. 123456789// new Date() create a new date object with current date and timenew Date();// new Date(year, month, ...) create a new date object with a specified date and timenew Date(year, month, day, hours, minutes, seconds, milliseconds);// JavaScript store dates as number of milliseconds since January 01, 1970, 00:00:00 UTC// new Date(milliseconds) creates a new date object as zero time plus millisecondsnew Date(milliseconds);// new Date(date string) creates a new date object from a date stringnew Date(date string); Date Methods When a Date object is created, a number of methods allow you to operate on it. toString() JavaScript will output dates in full text string format in HTML with the toString() method. toUTCString() The toUTCString() method convert a date to a UTC string toDateString() The toDateString() method converts a date to a ore readable format. Date Formats There are generally 3 types of JavaScript date input formats ISO Date - “2016-06-10” The ISO format follows a strict standard in JavaScript. ISO 8601 is the international standard for the representation of date and times. The ISO 8601 syntax (YYYY-MM-DD) is also the preferred JavaScript date format. The computed date will be relative to your time zone. Short Date - “06/10/2016” In some browsers, months or days with no leading zeroes may produce an error. Long Date - “Jun 10 2016” Long dates are most often written with a “MMM DD YYYY” syntax like this. Time Zone When setting a date, without specifying the time zone, JavaScript will use the browser’s time zone. Date Input - Parsing Dates If you have a valid date string, you can use the Date.parse() method to convert it to milliseconds. Date.parse() returns the number of milliseconds between the date and January 1, 1970. 1let milliSeconds = Date.parse(&quot;Jun 10, 2016&quot;); You can the use the number of milliseconds to convert it to a date object. Get Date Methods These methods can be used for getting information from a date object Method Description getFullYear() Get the year as a four digit number (yyyy) getMonth() Get the month as a number (0-11) getDate() Get the day as a number(1-31) getHours() Get the hour(0-23) getMinutes() Get the minute(0-59) getSeconds() Get the second(0-59) getMilliseconds() Get the millisecond(0-999) getTime() Get the time(milliseconds since January 1, 1970) getDay() Get the weekday as a number(0-6) Set Date Methods Set date methods let you set date values for a date object Method Description setDate() Set the day as a number (1-31) setFullYear() Set the year setHours() Set the hour (0-23) setMilliseconds() Set the milliseconds (0-999) setMinutes() Set the minutes (0-59) setMonth() Set the month (0-11) setSeconds() Set the seconds (0-59) setTime() Set the time (milliseconds since January 1, 1970) Compare Dates Dates can easily be compared. JavaScript counts months from 0 to 11. January is 0. December is 11. JavaScript Math ObjectThe JavaScript Math object allows you to perform mathematical tasks on numbers. Math.round() Math.round(x) returns the value of x rounded to its nearest integer 1const result = Math.round(4.1); // result is 4 Math.pow() Math.pow(x, y) returns the value of x to the power of y. 1const result = Math.pow(2, 10); // result is 1024 Math.sqrt() Math.sqrt(x) returns the square root of x 1const result = Math.sqrt(64); // result is 8 Math.abs() Math.abs(x) returns the absolute values of x 1const result = Math.abs(-1); // result is 1 Math.ceil() Math.ceil(x) returns the value of x rounded up to its nearest integer 1const result = Math.ceil(4.4); // result is 5 Math.floor() Math.floor(x) returns the value of x rounded down to its nearest integer. 1const result = Math.floor(4.7); // result is 4 Math.sin() Math.cos() Math.min() and Math.max() Math.min() and Math.max() can be used to find lowest or highest value in a list of arguments Math.random() Math.random() returns a random number between 0 and 1 Math Properties JavaScript provides 8 mathematical constants that can be accessed with the Math object. 12345678Math.E // returns Euler's numberMath.PI // returns PIMath.SQRT2 // returns the square root of 2Math.SQET1_2 // returns the square root of 1/2Math.LN2 // returns the natural logarithm of 2Math.LN10 // returns the natural logarithm of 10Math.LOG2E // returns the base 2 logarithm of EMath.LOG10E // returns the base 10 logarithm of E All methods and properties can be used without creating a Math object first. Random Math.random() returns a random number between 0(inclusive), and 1(exclusive) 12345Math.floor(Math.random() * 10); // returns a random integer from 0 to 9function getRandomInteger (min, max) { return Math.floor(Math.random() * (max - min)) + min;}; // This function returns a random number min(include) to max(excluded) BooleansJavaScript has a Boolean data types. It can only take the values true or false. The Boolean() Function You ca use the Boolean() function to find out if an expression is true 1const result = Boolean(-1 &gt; 0); // result is false Everything with a “Value” is true. Everything without a “Value” is false. 12345678910111213// result is trueBoolean(100);Boolean(-100);Boolean(&quot;100&quot;);Boolean(&quot;false&quot;);// result is falseBoolean(0);Boolean(-0);Boolean(&quot;&quot;);Boolean(null);Boolean(false);Boolean(NaN); Object can’t be compared. JavaScript Comparison and Logical OperatorsComparison and Logical operators are used to test for true or false. Comparison operators are used in logical statements to determine equality or difference between variables or values. Operator Description == Equal to === Equal value and equal type != Not equal !== Not equal value or not equal type &gt; Greater than &lt; Less than &gt;= Greater than or equal to &lt;= Less than or equal to Logical operators are used to determine the logic between variables or values. Operator Description &amp;&amp; and ` ! not JavaScript also contains a conditionnal operator that assigns a value to a variable based on some condition. 1variableName = (condition) ? valueX:valueY; Comparing data of different types may give unexpected results. To secure a proper result, variables should be converted to the proper type before comparison. JavaScript Bitwise Operators Operator Name Description &amp; AND Sets each bit to 1 if both bits are 1 ` ` OR ^ XOR Sets each bit to 1 only one of two bits is 1 ~ NOT Inverts all the bits &lt;&lt; Zero fill left shift Shifts left by pushing zeros in from the right and let the leftmost bits fall of &gt;&gt; Signed right shift Shifts right by pushing copies of the leftmost bit in from the left, and let the rightmost bits fall off &gt;&gt;&gt; Zero fill right shift Shifts right by pushing zeros in from the left, and let the rightmost bits fall off JavaScript stores numbers as 64 bits floating point numbers, but all bitwise operations are performed on 32 bits binary numbers. Before a bitwise operation is performed, JavaScript converts numbers to 32 bits signed integers. After the bitwise operation is performed, the result is converted back to 64 bits JavaScript numbers. JavaScript Regular ExpressionsA regular expression is a sequence of characters that forms a search pattern. The serarch pattern can be used for text search and tet replace operations. A regular expression ban be a single character, or more complicated pattern. Regular expression can be used to perform all types of text search and text replace operations. 1/pattern/modifiers; Using string methods In JavaScript, regular expressions are often used with the two string methods: search() and replace(). The search() method uses an expression to search for match, and returns the position of the match. The replace() method returns a modified string where the pattern is replaced. 1234let originStr = &quot;Hello JavaScript!&quot;;let searchResult = originStr.search(&quot;Hello&quot;); // reulst is 0let replaceResult = originStr.replace(&quot;Hi&quot;, &quot;Hello&quot;); // result is Hi JavaScript!repalceResult = originStr.replace(/hi/i, &quot;Visit&quot;); // result is Visit JavaScript! Regular Expression Modifiers Modifier Description i Perform case-insensitive matching g Perform a global match (find all matches rather than stopping after the first match) m Perform multiline matching Regular Expression Patterns Brackets are used to find a range of characters Expression Description [a-zA-Z] Find any of the characters between the brackets [0-9] Find any of the digits between the brackets [x|y] Find any of the alternatives separated with ` Metacharacters are characters with a special meaning Metacharacter Description \\d Find a digit \\s Find a whitespace character \\b Find a match at the beginning or at the end of a word \\uxxxx Find the Unicode character specified by the hexadecimal number xxxx Quantifiers define quantities Quantifier Description n+ Matches any string that contains at least one n n* Matches any string that contains zero or more occurrences of n n? Matches any string that contains zeor or one occurrences of n Using test() The test() method is a RegExp expression method. It searches a string for a pattern, and returns true or false, depending on the result. 12let pattern = /e/;pattern.test(&quot;The best things in life are free!&quot;); // return true Using exec() The exec() method is a RegExp expression method. It searches a string for a specified pattern, and returns the found text. If no match is found, it returns null. 1/e/.exec(&quot;The best things in life are free!&quot;); // return e JavaScript ErrorsThe try statments lets you test a block of code for errors. The catch statments lets you handle the error. The throw statments lets you create custom errors. The finally statment lets you execute code, after try and catch, regardless of the result. 12345678910111213141516171819try { // Block of code to try} catch (err) { // Block of code to handle errors}try { throw 'error'; // you can throw a exception} catch (err) { // Block of code to handle errors}try { // Block of code to try} catch () { // Block of code to handle errors} finally { // Block of code to be executed regardless of the try/catch result} Ther Error Object JavaScript has built in error object that provides error information when an error occurs. The error object provides two useful properties: name and message. Property Description name Sets or returns an error name message Sets or returns an error message Error Name Values Error Name Description EvalError An error has occurred in the eval() function.(Newer versions of JavaScript does not throw an EvalError. Use SyntaxError instead.) RangeError A number “out of range” has occurred ReferenceError An illegal reference has occurred SyntaxError A syntax error has occurred TypeError A type error has occurred URIError An error in encodeURI() has occurred JavaScript DebuggingDebuggin is not easy. But fortunately, all modern browsers have a built-in JavaScript devugger. Built-in debugger can be turned on and off, forcing errors to be reported to the user. The console.log() Method If your browsers supports debugging, you can use console.log() to display JavaScript values in the debugger window. 123&lt;script&gt; console.log(value);&lt;/script&gt; Setting Breakpoints In the debugger window, you can set breakpoints in the JavaScript code. At each breakpoint, JavaScript will stop execution, and let you examine JavaScript values. After examining values, you can resume the execution of code. The debugger Keyword The debugger keyword stops the execution of JavaScript, and calls (if available) the debugging function. 123let x = 0;debugger;document.getElementById(&quot;ele_id&quot;).innerHTML = x; JavaScript HoistingHoisting is JavaScript’s default behavior of moving declarations to the top. In JavaScript, a variable can be declared after it has been used. In others words, a variable can be used before it has been declared. 123numberX = 5;numberX += 10;let numberX; To understand this, you have to understand the term ‘hoisting’. Hoisting is JavaScript’s default behavior of moving all declarations to the top of current scope. Beware, JavaScript only hoists declarations, not initializations. Declare your variables at the top Hoisting is an unknown or overlooked behavior of JavaScript. If a developer doesn’t understand hoisting, programs may contain bugs or errors. To avoid bugs, always declare all variables at the beginning of every scope. Since this is how JavaScript interprets the code, it is always a good rule. JavaScript in strict mode does not allow variables to be used if they are not decalred. JavaScript Use Strictuse strict; Defines that JavaScript code should be executed in ‘strict mode’. The use strict directive was new in ECMAScript version 5. It is not a statment, but a literal expression, ignored by eraily version of JavaScript. The purpose of use strict is to indicate that the code should be executed in ‘strict mode’. With strict mode, you can not, for example, use undeclared variables. You can use strict mdoe in all your programs. It helps you to write cleaner code, like preventing you from using undeclared variables. Declaring Strict Mode Strict mode is decalred by adding &quot;use strict&quot;; to the beginning of a script or a function. Declared at beginning of a script, it has global scope. 1234&lt;script&gt;&quot;use strict&quot;; // your JavaScript code&lt;/script&gt; Declared inside a function, it has local scope 1234567numberX = 3.14; // this will not cause an errortestFunction();function testFunction () { &quot;use strict&quot;; numberY = 3.14; // this will cause an error} Why Strict Mode Strict mdoe makes it easier to write “secure” JavaScript. Strict mode changes previously accepted “bad syntax” into real errors. Not allowed in strict mode Usging a variable/object, without declaring it, is not allowed. Deleting a variable/object/function is not allowed. Duplicating a parameter name is not allowed. Octal numberic literals and octal escape characters are not allowed. Writing to read-only/get-only propery is not allowed. Deleting an undeletable property is not allowed. The string “eval”/“arguments” cannot be used as a variable The with statment is not allowed For security reasons, eval() is not allowed to create variables in the scope from which it was called The JavaScript this KeywordIn a function definition, this refers to the “owner” of the function. Default Binding When used along, this refers to the Global object. In a browser the global object is [object Window]. But in strict mode, this will be undefined, because strict mode does not allow default binding. JavaScript Style Guide and Coding ConventionsAlways use the same coding conventions for all your JavaScript projects. JavaScript Coding Conventions Coding conventions are style guidelines for programming. They typically over: Naming and declaration rules for variables and functions. Rules for the use of white space, indentation, and comments. Programming practices and principles. Coding conventions secure quality: Improve code readability Make code maintenance easier Coding conventions can be documented rules for teams to follow, or just be your individual coding practice. JavaScript Best PracticesAvoid global variables, avoid new, avoid ==, avoid eval() Avoid Global Variables Minimize the use of global variables. This inclueds all data types, objects, and functions. Global variables and functions can be overwritten by other scripts. Use local variables instead, and learn how to use closures. Always Declare Local Variables All variables used in a function should be declared as local variables. Local variables must be declared with the var/let keyword, otherwise they will become global variables. Declarations on Top It is good coding practice to put all declarations at the top of each script or function. This will: Give cleaner code Provide a single place to look for local variables. Make it easier to avoid unwanted global variables Reduce the possibility of unwanted re-declarations Initialize Variables It is good coding practice to initialize variables when you declare them. Never Declare Number, String, or Boolean Objects Always treat numbers, strings, or boolean as primitive values. Not as objects. Declare these types as objects, slow down execution speed, and produces nasty side effects. Beware of Automatic Type Conversions Beware that numbers can accidentally be converted to string or NaN. JavaScript is loosely typed. A variable can contain different data types, and a variable can change its data type. Use === Comparison The == comparison operator always convert before comparison. The === operator forces comparison of values and type. Use Parameter Defaults If a function is called with a missing argument, the value of the missing argument is set to undefined. Undefined values can break your code. It is a good habit to assign default values to arguments. End Your Switches with Defaults Always end your switch statments with a default. Even if you think there is no need fot it. Avoid Using eval() The eval() function is used to run text as code. In almost all cases, it should not be necessary to use it. Because it allows arbitaray code to be run, it also represents a security problem. JavaScript JSONJSON is a format for storing and transporting data. JSON is often used when data is sent from a server to a web page. JSON stands for JavaScript Object Notation JSON is lightweight data interchange format JSON is language independent * JSON is “self-describing” and easy to understand The JSON syntax is derived from JavaScript object notation syntax, but JSON format is text only. Code for reading and generating JSON data can be written in any programming language. The JSON format is syntactically identical to the code for creating JavaScript objects. Because of this similarity, a JavaScript program can easily convert JSON data into native JavaScript objects. JSON data is written as name/value pairs, just like JavaScript object properties. A name/value pair consists of a field name, followed by a colon, followed by a value. JSON names require double quotes, JavaScript names do not. Converting a JSON Text to a JavaScript Object A common use of JSON is to read data from a web server, and display the data in web page. For simplicity, this can be demonstrated using a string as input. JavaScript ObjectsIn JavaScript, alomost “everything” is an Object. JavaScript Primitives A primitive value is a value that has no properties or methods. A primitive data type is data that has a primitive value. JavaScript defines 5 types of primitive data types: string number boolean null undefined Primitive values are immutable (they are hardcoded and therefore cannot be changed) Objects are Variables containing Variables JavaScript variables can contain single values. Objects are variables too. But objects can contain many values. The values are written as name : pairs. 12345let objectVar = { key: value, key: value, ...} A JavaScript object is a collection of named values. Object Properties The named values, in JavaScript objects, are called properties. Object properties can be both primitive values, other objects, and functions. Object Methods Methods are actions that can be performed on objects. An Object method is an object property containing a function definition. JavaScript objects are containers for named values, called properties and mthods. Creating a JavaScript Object 1234567// Create an object using literallet objectByLiteral = {keyX: &quot;valueX&quot;, keyY: &quot;valueY&quot;};// Create an object using keyword newlet objectByNew = new Object();objectByNew.keyX = &quot;valueX&quot;;objectByNew.keyY = &quot;valueY&quot;; JavaScript Objects are Mutable Objects are mutable: They are addressed by reference, not by value. JavaScript variables are not mutable. Only JavaScript objects. JavaScript Object PropertiesProperties are the most important part of any JavaScript object. Properties are the values associated with a JavaScript object. A JavaScript object is a collection of unorderd properties. Properties can usually be changed, added, and deleted, but some are read only. Accessing JavaScript Properties The syntax for accessing the property of an object is : 12345objectName.propertyName// orobjectName[&quot;property&quot;]// orobjectName[expression] // The expression must be evaluate to a property name JavaScript for…in Loop The JavaScript for…in statment loops through the properties of an object. 123for (variable in object) { code to be executed} The block of code inside of the for…in loop will be executed once for each property. Add New Properties You can add new properties to an existing object by simply giving it a value. You cannot use reserved words for property names. JavaScript naming rules apply. Deleting Properties The delete keyword deletes a property from an object. 12let objByLiteral = {keyX: &quot;valueX&quot;};delete objByLiteral.keyX; The delete keyword deletes both value of the property and the property itself. After deletion, the property cannot be used before it is added back again. The delete operator is designed to be used on object properties. It has no effect on variables or functions. The delete operator should not be used on predefined JavaScript object propertis. It can crash your application. Property Attribute All properties hava a name. In addition they also have a value. The value is one of the property’s attributes. Other attributes are: enumerable, configurable, and writable. These attributes define how the property can be accessed. JavaScript Object MethodsJavaScript methods are actions that can be performed on objects. A JavaScript method is a property containing a function definition. Methods are functions stored as object properties. Accessing Object Methods You access an object method with the following syntax: 1objectName.methodName(); If you access the method property, without () , it will return the function definition. Adding a method to an Object 123obj.methodName = function () { code to be executed} JavaScript Object ConstructorsIt is considered good practice to name constructor functions with an upper-case first letter. In a constructor function this does not have a value. It is a substitute for the new object. The value of this will become the new object whent a new object is created. Note taht this is not a variable. It is a keyword. You cannot change the value of this. JavaScript PrototypesAll JavaScript objects inherit properties and methods from a prototype. Prototype Inheritance Date objects inherit from Date.prototype. Array objects inherit from Array.prototype. The Object.prototype is on the top of the prototype inheritance chain. Using the prototype Property The JavaScript prototype allows you to add new properties to object constructors 1234function Person (value) { this.key = value;}Person.prototype.keyNew = &quot;valueNes&quot;; The JavaScript prototype proterty also allows you to add new methods to objects constructors: 123456function Person (value) { this.key = value;}Person.prototype.methodNew = function () { code to be executed} Only modify your own prototypes. Never modify the prototypes of standard JavaScript objects. JavaScript Function DefinitionsJavaScript functions are defined with the function keyword. You can use a functin declaration or a function expression. 123function functionName (parameters) { code to be executed} Declared functions are not executed immediately. They are “saved for later use”, and will be executed later, when they are invoked. Semicolons are used to separate executable JavaScript statments. Since a function declaration is not an executable statment, it is not common to end it with a semicolon. Function Expressions A JavaScript function can also be defined using an expression. A function expression can be stored in a variable. 1let expressionFun = function (parameters) { execuate code }; After a function expression has been stored in a variable, the variable can be used as a function. Function stored in variables do not nedd function names. They are always invoked using the variable name. The Function() Constructor JavaScript functions are defined with the function keyword. Functions can also be defined with a built-in JavaScript function consturctor called Function() . 1let newFunction = new Function(&quot;parameterX&quot;, &quot;parameterY&quot;, ... &quot; execuated code&quot;); You actually don’t have to use the function constructor. Most of time, you can avoid using the new keyword in JavaScript. Function Hoisting Hoisting is JavaScript’s default behavior of moving declarations to the top of the current scopt. Hoisting applies to variable declarations and to function declarations. Because of this, JavaScript functions can be called before the declared. Self-Invoking Functions Function expression can be made “self-invoking”. A “self-invoking” expression is invoked automatically, without being called. Function expression will execute automatically if the expression is followed by (). You cannot self-invoke a function declaration. You have to add parentheses around the function to indicate that it is a function expression. 123( function () { executed code}) (); Functions Can Be Used as Values JavaScript functions can be used as values. 12345function parameterFun (parameters) { executed code}let result = parameterFun(parameters); Functions are Objects The typeof operator in JavaScirpt returns “function” for functions. But, JavaScript functions can best be descripted as objects. JavaScript functions have both properties and methods. JavaScript Function ParametersA JavaScript function does not perform any checking on parameter values. Function parameters are the names listed in the function definition. Function arguments are the real values passed to the function. JavaScript function do not check the number of arguments received. Parameter Defaults If a function is called with missing arguments, the missing value are set to undefined . But sometimes it is better to assign a default value to the parameter. 12345function arguementsMissingFun (x, y) { if ( x === undefined ) { x = 0; }} If a function is called with too many arguments, these arguments can be reached using the arguments object. The Arguments Object JavaScirpt functions have a built-in object called the arguments object. The argument object contains an array of the arguments used when the function was called. This way you can simply use a function to find the highest value in a list of numbers. Arguments are Passed by Value The parameters, in a function call, are the function’s arguments. JavaScript arguments are passed by value: The function only gets to know the values, not arguments’s locations. If a function changes an argument’s value, it does not change the parameter’s original value. That is, changes to arguments are not visible outside the function. Objects are Passed by Reference In JavaScript, object references are values. Because of this, objects will behave like they are passed by reference: If a function changes an object property, it changes the original value. That is, changes to object properties are visible outside the function. JavaScript Function InvocationThe code inside a function is not executed when the function is defined. The code inside a function is executed when the function is invoked. It is common to use the term “call a function” instead of “invoke a function”. It is also common to say “call upon a function”, “start a function”, or “execute a function”. 123456function invokeFunction (numX, numY) { return numX * numY;}// Invoking a Function as a FunctioninvokeFunction(1, 3); The function above does not belong to any object. But in JavaScript there is always a default global object. In HTML the default object is the HTML page itself, so the function above “belongs” to the HTML page. In a browser the page object is the browser window. The function above automatically becomes a window function. This is a common way to invoke a JavaScript function, but not a very good practice. Global variables, methods, or function can easily create name conflicts and bugs in the global object. The this Keyword In JavaScript, the thing called this, is the object that “owns” the current code. The value of this, when used in a function, is the object that “owns” the function. Note that this is not a variable. It is a keyword. You cannot change the value of this. The Global Object When a function is called without an owner object, the value of this becomes the global object. In a web browser the global object is the browser window. Invoking a function as a global function, causes the value of this to be the global object. Using the window object as a variable can easily crash your program. Invoking a Function as a Method In JavaScript you can define functions as object methods. 12345678let aObject = { propertyX: &quot;valueX&quot;, methodY: function () { // some execute code }}aObject.methodY(); Invoking a Function with a Function Constructor If a function invocation is preceded with the new keyword, it is constructor invocation. 12345678// This is a function constructorfunction aFun (argX, argY) { this.propertyX = argX; this.propertyY = argY;}// This create a new objectlet result = new aFun(&quot;valueX&quot;, &quot;valueY&quot;); A counstructor invocation creates a new object. The new object inherits the properties and methods from its constructor. The this keyword in the constructor does not have a value. The value of this will be the new object created when the function is invoked. JavaScript Function CallWith the call() method, you can write a method that can be used on different objects. In JavaScript all functions are object methods. If a function is not a method of a JavaScript object, it is a function of the global object. The JavaScript call() Method The call() method is a predefined JavaScript method. It can be used to invoke a method with an owner object as argument. With call(), an object can use a method belonging to another object. JavaScript Function ApplyWith the apply() method, you can write a method that can be used on different objects. The apply() method is similar to the call() method. The difference Between call() and apply() : The call() method takes arguments separately. The apply() method takes arguments as an array. The apply() method is very handy if you want to use an array instead of an argument list. The apply() method accepts arguments in an array. JavaScript Function ClosuresGlobal variables live as long as your application lives. Local variables have shourt lives. They are created when the function is invoked, and deleted when the function is finished. All functions have access to the global scope. In fact, in JavaScript, all functions have access to the scope “above” them. JavaScript supports nested functions. Nested functions have access to the scope “above” them. JavaScript closures make it possible for a function to have “private” variables. A closures is a function having access to the parent scope, even after the parent function has closed. JavaScript HTML DOMWith the HTML DOM, JavaScript can access and change all the elements of an HTML document. When a web page is loaded, the browser creates a Document Object Model of the page. The HTML DOM model is constructed as a tree of Objects. With the object model, JavaScript gets all the power it needs to create dynamic HTML : JavaScript can change all the HTML elements in the page JavaScript can change all the HTML attributes in the page JavaScript can change all the CSS styles in the page JavaScript can remove existing HTML elements and attributes JavaScript can add new HTML elements and attributes JavaScript can react to all existing HTML events in the page JavaScript can create new HTML events in the page The DOM is W3C standard and it defines a standard for accessing documents: The W3C Document Object Model is a platform and language-neutral interface that allows programs and scripts to dynamically access and update the content, structure, and style of a document. The W3C DOM standard is separated into 3 different parts: Core DOM - standard model for all document types XML DOM - standard model for XML documents HTML DOM - standard model for HTML documents The HTML DOM is a standard object model and programming interface for HTML. It defines : The HTML elements as objects The properties of all HTML elements The mehtods to access all HTML elements The events for all HTML elements In other words: The HTML DOM is a standard for how to get, change, add, or delete HTML elements. JavaScript HTML DOM MethodsHTML DOM methods are you can perform on HTML elements. HTML DOM properties are values of HTML elements that you can set or change. The HTML DOM can be accessed with JavaScript. In the DOM, all HTML elements are defined as objects. The getElementById() method The most common way to access an HTML element is to use the id of the element. 1document.getElementById(&quot;demo&quot;).innerHTML = &quot;Hello DOM!&quot;; The innerHTML Property The easiest way to get the content of an element is by using the innerHTML property. The innerHTML property can be used to get or change any HTML element, including and . JavaScript HTML DOM DocumentThe HTML DOM document object is the owner of all other objects in your web page. Finding HTML Elements Method Description document.getElementById(id) Find an element by element id document.getElementsByTagName(name) Find elements by tag name document.getElementsByClassName(name) Find elements by class name Changing HTML Elements Method Description element.innerHTML = new html content Change the inner HTML of an element element.attribute = new value Change the attribute value of an HTML element element.setAttribute(attribute, value) Change the attribute value of an HTML element element.style.property = new style Change the style of an HTML element Adding and Deleting Elements Method Description document.createElement(element) Create an HTML element document.removeChild(element) Remove an HTML element document.appendChild(element) Add an HTML element document.replaceChild(element) Replace an HTML element document.write(text) Write into the HTML output stream Adding Events Handlers Method Description document.getElementById(id).onclick() = function () {code} Add event handler code to an onclick event Finding HTML Objects Property Description document.anchors Return all elements that have a name attribute document.applets Return all elements (Deprecated in HTML 5) document.baseURI Return the absolute base URI of the document document.body Return the element document.cookie Return the document’s cookie document.doctype Return the document’s doctype document.documnetElement Return the element document.documentMode Return the mode used by the browser document.documentURL Return the URI of the document document.domain Return the domain name of the document server document.domConfig Obsolete. Return the DOM configuration document.embeds Return all elements document.forms Return all elements document.head Return the element document.images Return all elements document.implementation Return the DOM implementation document.inputEncoding Return the document’s encoding document.lastModified Return the data and time the document was updated document.links Return all and elements that have a href attribute document.readyState Return the status of the document document.referrer Return the URI of the referrer (the linking document) document.scripts Return all elements document.strictErrorChecking Return if error checking is enforced document.title Returns the element document.URL Return the complete URL of the document Finding HTML Elements The easiest way to find an HTML element in the DOM, is using the element id. 1let targetElement = document.getElementById(&quot;targetElementId&quot;); If the element is found, the method will return the element as an object, otherwise null is returned. You can find HTML elements by tag name 1let targetElement = document.getElementByTagName(&quot;targetTagName&quot;) Finding HTML elements by class name 1let targetElement = document.getElementByClassName(&quot;targetClassName&quot;) The getElementsByClassName() method will return a list of all elements with a specified class name. Finding HTML elements by CSS selectors If you want to find all HTML elements that matches a specified CSS selector, use the querySelectorAll() method. 1let targetElements = document.querySelectorAll(&quot;targetCSSSelector&quot;) Finding HTML elements by HTML object collections JavaScript HTML DOM - Changing HTMLThe HTML DOM allows JavaScript to change the content of HTML elements. Changing the HTML Output StreamIn JavaScript, document.write() can be used to write directly to the HTML output stream. 123&lt;script&gt; document.write(Date ());&lt;/script&gt; Never use document.write() after the document is loaded. It will overwrite the document. Changing HTML ContentThe easiest way to modify the content of an HTML element is by using the innerHTML property. 1document.getElementById(id).innerHTML = new HTML Changing the Value of an AttributeTo change the value of an HTML attribute, use this syntax 1document.getElementById(id).attribute = new value Changing HTML StyleTo change the style of an HTML element, use this syntax 1document.getElementById(id).style.property = new style Using EventsThe HTML DOM allows you to execute code when an event occurs. Events are generated by the browser when \"things happen\" to HTML elements An element is clicked on The page has loaded Input fields are changed JavaScript HTML DOM AnimationAll animations should be relative to a container element. The container element should be created with style = \"position: relative\". The animation element should be created with style = \"position: absolute\". JavaScript animations are done by programming gradual changes in an element's style. The changes are called by a timer. When the timer interval is small, the animation looks continuous. Create the Animation Using JavaScript1234567891011121314function moveAnimation () { let animateEle = document.getElementById(&quot;animate&quot;); let pos = 0; let id = setInterval(frame, 5); function frame () { if (pos == 350) { clearInterval(id); } else { pos++; animateEle.style.top = pos + 'px'; animateEle.style.left = pos + 'px'; } }} JavaScript HTML DOM EventsHTML DOM allows JavaScript to react to HTML events. Reacting to EventsA JavaScript can be executed when an event occurs, like when a user clicks on an HTML element. To execute code when a user click on an element, add JavaScript code to an HTML event attribute. 1onclick=JavaScript The onload and onunload EventsThe onload and onunload Events are triggered when the user enters or leaves the page. The onload event can be used to check the visitor's browser type and browser version, and load the proper version of the web page based on the information. The onload and onunload events can be used to deal with cookies. 1&lt;body onload=&quot;checkCookies()&quot;&gt; The onchange EventThe onchange event is often used in combination with validation of input fields. 1&lt;input type=&quot;text&quot; id=&quot;frame&quot; onchange=&quot;upperCase()&quot;&gt; The onmouseover and onmouseout EventsThe onmouseover and onmouseout events can be used to trigger a function when the user mouse over, or out of, an HTML element. The onmousedown, onmouseup and onclick EventsThe onmousedown, onmouseup, and onclick events are all parts of a mouse-click. First when a mouse-button is clicked, the onmousedown event is triggered, then, when the mouse-button is released, the onmouseup event is triggered, finally, when the mouse-click is completed, the onclick event is triggered. JavaScript HTML DOM EventListenerThe addEventListener() method attaches an event handler to the specified element without overwriting existing event handlers. The addEventListener() method makes it easier to control how the event reacts to bubbing. When using the addEventListener() method, the JavaScript is separated from the HTML markup, for better readability and allows you to add event listeners even when you do not control the HTML markup. 1element.addEventListener(event, function, useCapture) The third parameter is a boolean value specifying whether to use event bubbling or event capture. This parameter is optional. Note that you don't use the \"on\" prefix for the event; use \"click\" instead of \"onclick\" Add an Event Handler to an Element12345678element.addEventListener(&quot;click&quot;, function () { executed code});//element.addEventListener(&quot;click&quot;, aFunction);function aFunction () { executed code}; Add an Event Handler to the Window ObjectThe addEventListener() method allows you to add event listeners on any HTML DOM object as HTML elements, the HTML document, the window object, or other objects that support events. 123window.addEventListener(&quot;resize&quot;, function () { executed code}); Passing ParametersWhen passing parameter values, use an \"anonymous function\" that calls the specified function with the parameter 1234element.addEventListener(&quot;click&quot;, function () { aFunction(parameter)});function aFunction (parameter) { executed code} Event Bubbling or Event CapturingThere are two ways of event propagation in the HTML DOM, bubbling and capturing. Event propagation is a way of defining the element order when an event occurs. If you have a element inside a element, and the user clicks on the element, which elements's \"click\" event should be handled first ? In bubbling the inner most element's event is handled first and then the outer: the element's click event is handled first, then the element's click event. In capturing the outer most element's event is handled first and then the inner: the element's click event will be handled first, the the element's click event. With the addEventListener() method you can specify the propagation type by using the useCapture parameter. 1addEventListener(event, function, useCapture); THe default value is false, which will use the bubbling propagation, when the value is set to true, the event uses the capturing propagation. The removeEventListener() methodThe removeEventListener() method removes event handlers that have been attached with the addEventListener() method. 1element.removeEventListener(&quot;mousemove&quot;, aFunction); JavaScript HTML DOM NavigationWith the HTML DOM, you can navigate the node tree using node relationships. DOM NodesAccording to the W3C HTML DOM standard, everything in an HTML document is a node. All node in the node tree can be accessed by JavaScript. New nodes can be created, and all nodes can be modified or deleted. Node RelationshipsThe nodes in the node tree have a hierarchical relationship to each other. The terms parent, child, and sibling are used to describe the relationships. In a node tree, the top node is called the root Every node has exactly one parent, except the root A node can have a number of children Sibling are nodes with the same parent Navigating Between Nodes You can use the following node properties to navigate between nodes with JavaScript parentNode childNodes[nodenumber] firstChild lastChild nextChild previousSibling Child Nodes and Node Values A common error in DOM processing is to expect an element node to contain text 1&lt;title&gt; JavaScript Tutorial &lt;/title&gt; The element node dose not contain text. It contains a text node with the value \"JavaScript Tutorial\". The value of the text node can be accessed by the node's innerHTML property. InnerHTMLYou can retrieve the content of an HTML element. DOM Root NodesThere are two special properties that allow access to the full document document.body - The body of the document document.documentElement - The full document The nodeName PropertyThe nodeName property specifies the name of a node. nodeName is read-only nodeName of an element node is the same as the tag name nodeName of an attribute node is the attribute name nodeName of a text node is always #text nodeName of the document node is always #document Note: nodeName always contains the uppercase tag name of an HTML element The nodeValue PropertyThe nodeValue property specifies the value of a node. nodeValue for element nodes is undefined nodeValue for text nodes is text itself nodeValue for attribute nodes is the attribute value The nodeType PropertyThe nodeType property is read only. It returns the type of a node. Node Type Example ELEMENT_NODE 1 ATTRIBUTE_NODE 2 class = &quot;&quot; TEXT_NODE 3 JavaScript Tutorials COMMENT_NODE 8 DOCUMENT_NODE 9 The HTML document itself DOCUMENT_TYPE_NODE 10 &lt;!Doctype html&gt; Type 2 is deprecated in the HTML DOM (but works). It is not deprecated in the XML DOM JavaScript HTML DOM ElementsAdding and Removing Nodes. Creating New HTML Elements To ad a new element to HTML DOM, u must create the element first, and then append it to an existing element. 12document.createElement(&quot;elementName&quot;);document.createTextNode(&quot;textContent&quot;); insertBefore()The appendChild() method appended the new element as the last child of the parent. If you don't want that you can use the insertBefore() method. Removing Existing HTML Elements To remove an HTML element, you must know the parent of the element. 1parentElement.removeChild(&quot;childElement&quot;); It would be nice to be able to remove an element without referring to the parent. But sorry, the DOM needs to know both the element you want to remove, and its parent. Replacing HTML ElementsTo replace an element to the HTML DOM, use the replaceChild() method. 1parentElement.replaceChild(element, child); JavaScript HTML DOM CollectionsThe getElementsByTagName() method returns an HTMLCollection object. An HTMLCollection object is an array-like list of HTML elements. The elements in the collection can be accessed by an index number. HTML HTMLCollection LengthThe length property defines the number of elements in an HTMLCollction. 1let pElementsCollectionLength = document.getElementsByTagName(&quot;p&quot;).length; The length property is useful when you want to loop through the elements in a collection. An HTMLCollection is not an array. An HTMLCollection may look like an array, but it is not. JavaScript HTML DOM Node ListsA NodeList object is a list of nodes extracted from a document. A NodeList object is almost the same as an HTMLCollection object. All browsers return a NodeList object for the property childNodes. Most browsers return a NodeList object for the method querySelectorAll(). 1let pNodeList = document.querySelectorAll(&quot;p&quot;); The elements in the NodeList can be accessed by an index number. HTML DOM Node List LengthThe length property defines the number of nodes in a node list. 1let pNodeListLength = document.querySelectorAll(&quot;p&quot;).length; The length property is useful when you want to loop through the node in a node list. The Difference Between an HTMLCollection and NodeListAn HTMLCollection is a collection of HTML elements. A NodeList is a collection of document nodes. A NodeList and an HTMLCollection is very much the same thing. Both an HTMLCollection object and a NodeList object is an array-like list of objects. Both have a length property defining the number of items in the list. Both provide an index to access each item like an array. HTMLCollection items can be accessed by their name, id, or index number. NodeList items can only be accessed by their index number. Only the NodeList object can contain attribute nodes and text nodes. JavaScript Browser BOMThe browser object model allows JavaScript to \"talk to\" the browser. There are no official standards for the Browser Object Model. Since modern browser have implemented the same methods and properties for JavaScript interactivity, it is often referred to, as methods and properties of the BOM. The Window ObjectThe window object is supported by all browsers. It represents the browser's window. All global JavaScript objects, functions, and variables automatically become members of the window object. Global variables are properties of the window object. Global functions are methods of the window object. Even the document object is a property of the window object. Window SizeTwo properties can be used to determine the size of the browser window. Both properties return the sizes in pixels: window.innerHeight - the inner height of the browser window window.innderWidth - the inner width of the browser window The browser window is not including toolbars and scrollbars Other Window Methods window.open() - open a new window window.close() - close the current window window.moveTo() - move the current window window.resizeTo() - resize the current window Window ScreenThe window.screen object can be written without the window prefix. screen.width - return the width of the visitor's screen in pixels screen.height - return the height of the visitor's screen in pixels screen.availWidth - return the width of the visitor's, in pixels, minus interface features like the window Taskbar screen.availHeight - return the height of the visitor's, in pixels, minus interface features like the window Taskbar screen.colorDepth - return the number of bits used to display one color screen.pixelDepth - return the pixel depth of the screen For modern computers, Color Depth and Pixel Depth are equal Window LocationThe window.location object can be written without the window prefix. Window Location HrefThe window.location.href property return the URL of the current page. Window Location HostnameThe window.location.hostname property return the name of the internet host of the current page. Window Location PathnameThe window.location.pathname property return the pathname of the current page. Window Location ProtocolThe window.location.protocol property return the web protocol of the page. Window Location PortThe window.location.port property returns the number of the internet host port of the current page. Most browsers will not display default port numbers (80 for http and 443 for https) Window Location AssignThe window.location.assign() method loads a new document. Window HistoryThe window.history object contains the browsers history. To protext the privacy of the users, there are limitations to how JavaScript can access this object. Some methods: history.back() - same as clicking back in the browser history.forward() - same as clicking forward in the browser Window NavigatorThe window.navigator object contains information about the visitor's browser. Browser CookiesThe cookieEnabled property return true if cookies are enabled, otherwise false Browser Application NameThe appName property return the application name of the browser Browser Application Code NameThe appCodeName property return the application code name of the browser The Browser EngineThe product property return the product name of the browser engine. The Browser VersionThe appVersion property return version information about the browser. The Browser AgentThe userAgent property returns the user-agent header sent by the browser to the server The information from the navigator object can often be misleading, and should not be used to detect browser versions . The Browser PlatformThe platform property return the browser platform. The Browser LanguageThe language property returns the browser's language. Is The Browser Online?The online property return true if the browser is online. Is Java Enabled?The javaEnabled() method return true if Java is enabled. Timing EventsThe window object allows execution of code at specified time intervals. These time intervals are called timing events. setTimeout(function, milliseconds) Executes a function, after waitting a specified number of milliseconds 123window.setTimeout(function, milliseconds);// orsetTimeout(function, milliseconds); setInterval(function, milliseconds) Same as setTimeout , but repeats the execution of the function continously. How to stop the execution?The clearTimeout() method stops the execution of the function specified in setTimeout(). 1window.clearTimeout(timeoutVariable); If the function has not already been executed, you can stop the execution by calling the clearTimeout() method. CookiesCookies let you store user information in web pages. What are cookies?Cookies are data, stored in small text files, on your computer. When a web server has sent a web page to a browser, the connection is shut down, and the server forgets everything about the user. Cookies were invented to solve the problem \"how to remember information about the user\". Cookies are saved in name-value pairs like : 1username = Mr Van When a browser requests a web page from a server, cookies belonging to the page is added to the request. This way the server gets the necessary data to \"remember\" information about users. None of the examples below will work if your broswer has local cookies support turned off Create a Cookie with JavaScriptJavaScript can create, read, and delete cookies with the document.cookie property. 1document.cookie = &quot;username=Van&quot;; You can also add an expiry date in UTC time. By default, the cookie is deleted when the browser is closed. 1document.cookie = &quot;username=Van; expires=Wed, 25 July 2016 12:00:00 UTC&quot;; With a path parameter, you can tell the browser what path the cookie belongs to. By default, the cookies belongs to the current page. 1document.cookie = &quot;username=Van; path=/;&quot;; Read a Cookie with JavaScriptWith JavaScript, cookies can be read like this : 1let cookie = document.cookie; document.cookie will return all collkies in one string much like: cookie1=value; cookie2=value; cookie3=value; Change a Cookie with JavaScriptWith JavaScript, you can change a cookie the same way as you create it : 1document.cookie = &quot;username=HH; path=/;&quot;; The old cookies is overwritten. Delete a cookie with JavaScriptDeleting a cookie is very simple. You don't have to specify a cookie value when you delete a cookie. Just set the expires parameter to a passed date : 1document.cookie = &quot;username=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;&quot;; You should define the cookie path to ensure that you delete the right cookie. Some browser will not let you delete a cookie if you don't spcify the path. The Cookie StringThe document.cookie property looks like a normal text string. But it is not. Even if you write a whole cookie string to document.cookie, when you read it out again, you can only see the name-value pair of it. If you set a new cookie, older cookies are not overwritten. The new cookie is added to document.cookie.","link":"/2016/06/20/javascript-tutorial/"},{"title":"NPM 命令","text":"NPMnpm 安装与升级1234// 获取当前使用的 npm 的版本npm -v// 升级 npmnpm install npm -g package 安装与卸载本地安装将会把安装包安装在运行 npm 命令时所在目录的 ./node_modules 目录下；全局安装则会将安装包安装在你的 node 所在目录； 1234npm install &lt;package name&gt; // localnpm install &lt;package name&gt; -g // globalnpm install &lt;package name&gt; --save-dev | -D// developmentnpm install &lt;package name&gt; --save | -S // production 通过命令 npm install &lt;package name&gt; —save 安装的 package 会被加到 package.json 文件中的 dependencies 部分，而通过命令 npm install &lt;package name&gt; —save-dev 安装的 package 会被加到 devDependencies 部分。命令如果不加 —save 或 —save-dev 则 package 不会被添加到 package.json 文件中 卸载某个 package 1npm uninstall &lt;package name&gt; 更新某个 package 1npm update &lt;package name&gt; 安装最新版本的 package 1npm install &lt;package name&gt;@latest 安装指定版本号的 package 1npm install &lt;package name&gt;@[verion number] 查看信息可以通过命令来查看已经安装的 packeage 1234npm listnpm list -g# --depth 表示深度，深度为 0 时，不显示依赖模块npm list --depth=0 -g 查看某个 package 是否安装或查看其版本号(若已存在) 1npm list &lt;package name&gt; 查看某个 package 是否存在 1npm ls 搜索某个模块 1npm search &lt;package name&gt; 查看某个 package 的路径 1npm root &lt;package name&gt; 切换安装源1234# 淘宝镜像npm config set registry https://registry.npm.taobao.org# 官方源npm config set registry https://registry.npmjs.org/","link":"/2018/02/06/npm-commands/"},{"title":"iOS 中 UITableView 的优化","text":"UITableView的性能优化UITableView 是 iOS 开发中经常会用到的一种控件，复杂的 UITablView 如果不进行优化，会严重影响用户体验。那么我们可以从那些方面如后来对其进行优化呢？ 首先 我们使用 UITableView 的大致流程如下 ： 获取将要在 UITableView 中显示的数据； 把数据进行处理，封装为相应的 Model，并存入数组 UITableView 调用 reloadData 刷新数据 在代理方法中获取或创建 UITableViewCell ，并将数据赋值给它 UITableViewCell 根据拿到的数据对其中的 UI 控件进行赋值 在代理方法中计算 UITableViewCell 的行高 UITableViewCell 布局子控件 我们的优化就是针对这几个步骤来进行的。 针对 UITableView 的数据处理的优化需要显示在 UITableView 中的数据一般是通过网络请求从服务器获得的数据，我们需要发起网络请求获得数据后进行处理，以使其能够适合我们要显示的 Cell。然而网络请求和数据处理都是比较耗时的操作，将它们在后台异步线程中进行处理完成后，再来刷新 UITableView 会使得显示更加流畅。 关于 UITableView 的重用机制UITableView 只会创建在当前屏幕显示或多一点的 UITableViewCell，其它的都是从中取出来重用的。每当 Cell 不再屏幕中显示时，系统将其放入一个集合中，一般称为重用池。当要显示某一位置的 Cell 时，会优先去重用池中取，如果重用池中存在，则直接拿来显示，如果没有才会创建。这极大的减少了内存的开销。 UITableView 最主要的两个回调方法是 tableView:cellForRowAtIndexPath: 和 tableView:heightForRowAtIndexPath: 。在显示 Cell 时，UITableView 显示多次调用 tableView:heightForRowAtIndexPath: 以确定 contentSize 及 Cell 的位置，然后才会调用 tableView:cellForRowAtIndexPath: ，来显示当前屏幕上的 Cell。 UITableView 的显示优化实际上主要就是针对这两个回调方法的优化。 UITableViewCell 高度计算固定高度的 Cell 的显示自不必说，直接设置固定的高度即可： 1self.tableView.rowHeight = HEIGHT_OF_CELL; 而对于动态高度的 Cell 来说，则需要在 tableView:heightForRowAtIndexPath: 方法中给出相应的高度。动态高度的计算依赖于要显示在 Cell 中的数据内容，我们可以直接在处理数据时就进行高度的计算，而不是在 tableView:heightForRowAtIndexPath: 方法中进行计算，这也会节省一些时间。 1234- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath { DataModel *model = self.dataSourceList[indexPath.row]; returen model.heightOfCell;} 如果不提前进行 Cell 高度的计算，将已经计算好的高度进行缓存，避免重复进行计算也是一个可以优化的地方。 UITableViewCell 的内容布局对象的调整也经常是消耗 CPU 资源的地方。这里特别说一下 CALayer：CALayer 内部并没有属性，当调用属性方法时，它内部是通过运行时 resolveInstanceMethod 为对象临时添加一个方法，并把对应属性值保存到内部的一个 Dictionary 里，同时还会通知 delegate、创建动画等等，非常消耗资源。UIView 的关于显示相关的属性（比如 frame/bounds/transform）等实际上都是 CALayer 属性映射来的，所以对 UIView 的这些属性进行调整时，消耗的资源要远大于一般的属性。对此你在应用中，应该尽量减少不必要的属性修改。 对于布局内容不固定的 Cell 来说，根据要显示的数据内容进行内容的布局即可，如果要进行布局的控件很多，则会极大的消耗系统的资源。 而实际上我们 Cell 添加控件时，实质上都是系统调用底层的接口进行绘制，因此对于控件较多的动态 Cell 来说，我们可以直接进行绘制，提高效率。 直接在 drawRect 方法中进行绘制： 123- (void)drawRect { // } 或将绘制好的内容作为图片返回后直接显示 ： 123456789- (UIImage *)draw { // 内容绘制 CGContextRef context = UIGraphicsGetCurrentContext(); ··· // 需要注意的是，绘制是比较耗时的操作，放入异步后台线程进行任务比较好 UIImage *contentImage = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); return contentImage;} 异步处理耗时操作获取数据并对其进新处理等耗时操作，应该放入后台线程异步处理，等到数据完成处理后再通知主线程刷新 UI。 另外，UIKit 和 CoreAnimation 相关的操作必须在主线程中进行，其它诸如图像的绘制等则应该在后台线程异步执行。 在 Cell 上添加系统控件时，实质上系统都需要调用底层的接口进行绘制，当 Cell 上有大量的控件需要添加时，对资源的开销也会很大，直接绘制将会大大地提高效率。在遇到需要显示复杂的 UITableViewCell 时，使用自定义绘制会更好。 避免频繁的创建对象对象的创建会产生内存分配、属性调整等操作，频繁大量的创建对象会消耗大量的资源和时间，应尽量避免频繁大量的创建对象。应该使用轻量对象来代替重量对象，或将对象创建后进行缓存。 减少对象的属性赋值操作对象的调整也经常是消耗 CPU 资源的地方。这里特别说一下 CALayer：CALayer 内部并没有属性，当调用属性方法时，它内部是通过运行时 resolveInstanceMethod 为对象临时添加一个方法，并把对应属性值保存到内部的一个 Dictionary 里，同时还会通知 delegate、创建动画等等，非常消耗资源。UIView 的关于显示相关的属性（比如 frame/bounds/transform）等实际上都是 CALayer 属性映射来的，所以对 UIView 的这些属性进行调整时，消耗的资源要远大于一般的属性。对此你在应用中，应该尽量减少不必要的属性修改。 简化视图结构GPU在绘制图像前，会把重叠的视图进行混合，视图结构越复杂，这个操作就越耗时，如果存在透明视图，混合过程会更加复杂。 减少离屏渲染下面的情况或操作会引发离屏渲染： 为图层设置遮罩（layer.mask） 将图层的 layer.masksToBounds / view.clipsToBounds 属性设置为 true 将图层 layer.allowsGroupOpacity 属性设置为 YES 和 layer.opacity 小于1.0 为图层设置阴影（layer.shadow *）。 为图层设置 layer.shouldRasterize = true 具有 layer.cornerRadius，layer.edgeAntialiasingMask，layer.allowsEdgeAntialiasing 的图层 文本（任何种类，包括UILabel，CATextLayer，Core Text等）。 使用 CGContext 在 drawRect : 方法中绘制大部分情况下会导致离屏渲染，甚至仅仅是一个空的实现 按需加载","link":"/2017/04/06/tableview-optimize/"},{"title":"TypeScript 概览","text":"TypeScriptTypeScript 是 JavaScript 类型的超集，它可以编译成纯 JavaScript，可以在任何浏览器、任何计算机和任何操作系统上运行，并且是开源的。 基础类型TypeScript 支持与 JavaScript 几乎相同的数据类型，此外还提供了方便使用的枚举类型。 123456789101112131415161718192021222324252627282930313233// booleanlet isDone: boolean = false;// number// JavaScript 和 TypeScript 中的数字不是浮点类型 floating point 就是大整数类型 BigIntegerlet decLiteral: number = 6;let bigLiteral: number = 100n;// stringlet name: string = 'bob';// Arraylet list: number[] = [1,2,3];let list: Array&lt;number&gt; = [1,2,3];// Tuple// 元组类型要求值类型、顺序和个数一一对应let tuple: [string, string] = ['string', 'string'];// enumenum Color {Red = 0, Green, Blue}let c: Color = Color.Green;// Anylet source: any = 4// Voidlet unusable: void = undefined;// Null &amp; Undefinedlet u: undefined = undefined;let n: null = null;// Neverfunction error(message: string): never { throw new Error(message);}// 类型断言// 明确知道值的类型时可使用类型断言let strValue: any = 'str';let length: number = (&lt;string&gt;strValue).length;let length: number = (strValue as string).length 变量声明 var 可以通过 var 关键字定义变量，但是 var 声明可以在包含它的函数、模块、命名空间或全局作用域内部任何位置被访问，包含它的代码块对此没有影响，这可能会引发一些错误，比如多次声明同一个变量并不会报错。 let 当用 let 声明一个变量，它使用的是词法作用域或块作用域。不同于使用 var 声明的变量那样可以在包含它们的函数外访问，块作用域变量在包含它们的块之外是不能访问的。 const const 拥有与 let 相同的作用域规则，但是声明的变量被赋值后不能再改变。 每次进入一个作用域时，它创建了一个变量的环境，就算作用域内代码已经执行完毕，这个环境与其捕获的变量依然存在。当 let 声明出现在循环体里时拥有完全不同的行为，不仅是在循环里引入了一个新的变量环境，而是针对每次迭代都会创建这样一个新作用域。 接口TypeScript 的核心原则之一是对值所具有的结构进行类型检查。 它有时被称做 “鸭式辨型法”或”结构性子类型化”。 在 TypeScript 里，接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约。 JavaScript 为开发者提供了非常大的灵活性：比如你可以为一个初始化为整数的变量赋值一个函数。但同时这种不确定性也会带来很多的麻烦，TypeScript 内置的接口就可以用来解决这个问题。 接口帮助我们在赋值和传递参数时进行类型检查，确保我们给变量的赋值符合变量的类型或接收参数正确(接口在某种程度上表示了变量或函数对于赋值给它的值或传递给它的参数的一种期望和要求)。 可选属性接口里的属性不全都是必需的，有些是只在某些条件下存在，或者根本不存在，可以为接口定义可选属性来实现这些需求。 1234interface OptionAttribute { optionNum?: number; optionStr?: string;} 可选属性的好处之一是可以对可能存在的属性进行预定义，好处之二是可以捕获引用了不存在的属性时的错误。 只读属性如果希望对象的某些属性只有在刚创建的时候修改其值，可以通过在属性名前用 readonly 来指定属性为只读属性。 1234interface ReadonlyAttribute { readonly num: number; readonly str: string;} TypeScript 具有 ReadonlyArray&lt;T&gt; 类型，它与 Array&lt;T&gt; 类似，只是把所有可变方法去掉了，因此可以保证数组创建后再也不能被修改。 readonly vs const 使用 const 来修饰变量，使用 readonly 来修饰属性 额外的类型检查在 TypeScript 中，对象字面量赋值给变量或作为参数进行传递的时候，会经过 “额外属性检查”，如果一个对象字面量存在任何 “目标类型” 不包含的属性时，会发生错误。 1234567891011121314interface SquareConfig { width: number; color?: string;}function createSquare(config: SquareConfig): { color: string, area: number } { let newSquare = { color: 'blue', area: 0 }; if (config.width) newSquare.area = config.width * config.width; if (config.color) newSquare.color = config.color; return newSquare;}// error: height not expected in type SquareConfiglet mySquare = createSquare({ color: 'green', width: 10, height: 10 }); 使用 ‘类型断言’ 可以绕开额外属性检查 1let mySquare = createSquare({ color: 'green', width: 10, height: 10 } as SquareConfig); 但是更好的做法是在接口中提供一个字符串索引签名 12345interface SquareConfig { width: number; color?: string; [propName: string]: any;} 函数类型接口能够描述 JavaScript 中对象拥有的各种各样的外形。 除了描述带有属性的普通对象外，接口也可以描述函数类型。 为了使用接口表示函数类型，我们需要给接口定义一个调用签名。 它就像是一个只有参数列表和返回值类型的函数定义。 参数列表里的每个参数都需要名字和类型。 123interface TypeFunc { (source: string, subString: string): boolean;} 这样定义后，我们可以像使用其它接口一样使用这个函数类型的接口。 下例展示了如何创建一个函数类型的变量，并将一个同类型的函数赋值给这个变量。 12345let mySearchFunc: TypeFunc;mySearchFunc = function(source: string, subString: string) { let result = source.search(subString); return result &gt; -1;} 对于函数类型的类型检查来说，函数的参数名不需要与接口定义里的名字相匹配。 函数的参数会逐个进行检查，要求对应位置上的参数类型是兼容的。如果没有指定类型，TypeScript 的类型系统会推断出参数类型，而函数的返回值类型是通过其返回值推断出来的。 可索引的类型与使用接口描述函数类型差不多，我们也可以描述那些能够通过索引得到的类型。可索引类型具有一个索引签名，它描述了对象索引的类型，还有相应的索引返回值类型。 12345678// 表明了当用 number 去索引 StringArr 时会得到 string 类型的返回值interface StringArr { [index: number]: string;}let myArr: StringArr;myArr = [&quot;A&quot;,&quot;B&quot;];let myStr: string = myArr[0]; 索引签名共有两种类型：字符串和数字。可以同时使用这两种类型的索引，但是数字索引的返回值必须是字符串索引返回值类型的子类型。这是因为当使用 number 来索引时，TypeScript 会将它转换为 string 然后再去索引对象。 1234interface StringArray { [index: string]: string; [index: number]: string;} 一般将索引签名设置为只读，这样可以防止给索引赋值。 类类型TypeScript 中的接口也能够用来明确的强制一个类去符合某种协议/契约。 123456789101112interface ClockInterface { currentTime: Date; setTime:(d: Date);}class Clock implements ClockInterface { currentTime: Date; setTime:(d: Date) { this.currentTime = d; } constructor(h: number, m: number) {}} 接口描述了类的公共部分，而不是公共和私有两部分，它不会帮你检查类是否具有某些私有成员。 类静态部分与实例部分的区别类具有两个类型 ：静态部分的类型和实例的类型。 当一个类实现了一个接口时，只对其实例部分进行类型检查。constructor 存在于类的静态部分，不在检查范围内。因此我们应该直接操作类的静态部分。 可以认为类的静态部分指的是类本身，实例部分指的是类实例化出来的对象。 继承接口和类一样，接口也可以相互继承。这让我们能够从一个接口里复制成员到另一个接口里，可以更灵活地将接口分割到可重用的模块里。 1234567891011interface Father { familyName: string;}interface Son extends Father { givenName: string;}let aPerson = &lt;Son&gt;{};aPerson.familyName = 'S';aPerson.givenName = 'T'; 一个接口可以继承多个接口，创建出多个接口的合成接口。 1234567891011interface Shape { color: string;}interface Stroke { penWidth: number;}interface Square extends Shape, Stroke { width: number;} 混合类型接口能够描述 JavaScript 中丰富的类型，可以使用 混合类型 来使某个对象具有多个类型。 1234567891011121314151617interface Counter { (start: number): number; interval: number; reset(): void;}function getCounter(): Counter { let counter = &lt;Counter&gt;function (start: number) {}; counter.interval = 1; counter.reset = function () {}; return counter;}let c = getCounter();c(10);c.reset();c.interval = 2; 接口继承类当接口继承了一个类类型时，它会继承类的成员但不继承其实现。就好像接口声明了所有类中存在的成员，但没有提供具体实现一样。接口同样会继承到类的 private 和 protected 成员。这意味着当你创建了一个接口继承了一个拥有私有或受保护的成员的类时，这个接口类型只能被这个类或其子类所实现。 当你有一个庞大的继承结构时这很有用，但要指出的是你的代码只在子类拥有特定的属性时起作用。 类从 ECMAScript 2015 , 也就是 ECMAScript 6 开始， JavaScript 中也能使用基于类的面向对象的方式。 123456789101112131415// 定义一个类class Person { familyName: string; constructor(familyName: string, givenName: string, age: number) { this.familyName = familyName; } say() { return 'Hello, my name is ' + this.familyName + ' ' + this.givenName; } move(distanceInMeters = 0) { console.log('${this.name} moved ${distanceInMeters}m.'); }}// 创建类实例lei aPerson = new Person('Wang', 'XiaoHong', 22); 在引用任何一个类的成员时都需要使用 this ，它表示我们访问的是类的成员。 继承在 TypeScript 中允许使用继承来扩展现有的类。 12345678class Student extends Person { constructor(familyName: string, givenName: string, age: number) { super(familyName, givenName, age); } move(distanceInMeters = 5) { super.move(distanceInMeters); }} 如果子类包含了构造函数，它必须调用 super() ，它会执行基类的构造函数。在构造函数中访问 this 的属性之前，一定要先调用 super() 。 子类从父类中继承属性和方法 修饰符 public public 是 TypeScript 中类成员的默认属性 private 类成员声明为 private 时，不能在生声明它的类的外部访问 protected 类成员声明为 protected 时，在派生类中仍可访问 构造函数也能被标记为 protected ，这意味着它不能在包含它的类外被实例化，但是能被继承 readonly 通过 readonly 属性将属性设置为只读，只读属性必须在声明时或构造函数里被初始化 参数属性参数属性通过给构造函数参数前添加一个访问限定符来声明。 1234class Student { constructor(public familyName: string, public givenName: string, public age: number){ }} 通过这个特性我们可以方便的在一个地方定义并初始化一个成员。 存取器TypeScript 支持通过 getters/setters 来截取对对象成员的访问，它们可以有效的控制对对象成员的访问。 1234567891011class student { private _familyName: string; get familyName(): string { return this._familyNmae; } set familyName(fName: string) { this._familyName = fName; }} 需要注意的是，存取器只支持 ECMAScript 5 或更高，其次，只带有 getter 存取器被推断为 readonly。 静态属性类的实例成员是那些仅当类被实例化时才会被初始化的属性，而类的静态成员存在于类本身上面而不是类的实例上。实例想要访问静态属性时，需要在其加上类名。 1234567class student { static school = 'ts'; ... getStudentSchool() { return student.school; }} 抽象类抽象类一般作为其它派生类的基类使用，一般不会被实例化。不同于接口，抽象类可以包含成员的实现细节。 使用 abstract 关键字定义抽象类和在抽象类中定义抽象方法。 123abstract class Human { abstract function_name: return_type;} 抽象类中的抽象方法不包含具体实现并且必须在派生类中实现。 抽象方法的语法与接口语法相似，两者都是定义方法签名但不包含方法体。然而，抽象方法必须包含 abstract 关键字并且可以包含访问修饰符。 函数函数是 JavaScript 应用程序的基础。 它帮助你实现抽象层，模拟类，信息隐藏和模块。 在 TypeScript 里，虽然已经支持类，命名空间和模块，但函数仍然是主要的定义行为的地方。 TypeScript 为 JavaScript 函数添加了额外的功能，让我们可以更容易地使用。 函数类型123function fun(arg_1: arg_type, arg_2: arg_type, ...): return_type { ...} TypeScript 能够通过返回语句自动推断出返回值类型，因此函数返回类型一般是省略的。 1let fun_var_name: (arg_1: arg_type, arg_2: arg_type, ...) =&gt; return_type; 函数类型包括两部分，参数类型和返回值类型。而且只要参数类型是匹配的，就认为它是有效的函数类型，而不在乎参数名是否准确。 可选参数和默认参数JavaScript 中函数的每个参数都是可选的，可传可不传，没有传参的时候它的值就是 undefined。而 TypeScript 中函数的每个参数默认情况下都是必须的，编译器检查用户是否为每个参数都传入了值，还会假设只有这些参数被传递进函数-即传递给一个函数的参数个数必须与函数期望的参数个数一致。 123456let myAdd: (x: number, y: number) =&gt; number = function (x: number, y: number) { return x + y;}const sum = myAdd(1); // error: Expected 2 arugements, but got 1const sum1 = myAdd(1, 2, 3); // error: Expected 2 arugements, but got 3 在 TypeScript 中，可以在参数名称旁使用 ? 实现可选参数的功能。 1234567// 可选参数function buildStudent(name: string, grade: number, gender?: string) { return name + ' ' + grade + ' ' + (gender ? gender : '');}const student_1 = buildStudent('Tom', 2);const student_2 = buildStudent('Jerry', 2, 'male'); 需要注意的是，可选参数必须跟在可选参数后面。 在 TypeScript 中，当用户没有传递这个参数或传递的值是 undefined 时，我们可以为参数提供一个默认值。在所有必须参数后面的带默认初始化的参数都是可选的，与可选参数一样，在调用函数的时候可以省略-即可选参数与末尾的默认参数共享参数类型。 需要注意的是，如果带默认值的参数出现在必须参数之前，用户必须明确的传入 undefined 值来获得默认值。 剩余参数如果你想同时操作多个参数或不知道会有多少个参数传递进来，在 JavaScript 中，你可以通过 arguments 来访问所有传入的参数，在 TypeScript 中，你则可以将所有参数收集到一个变量里。 123456// 剩余参数function buildChildren(name: string, age: number, ...restOfProperty: string[]) { return `${name} ${age} ${restOfProperty.join(' ')}`;}const children = buildChildren('Mike', 12, 'male', 'grade 3'); 泛型泛型是程序设计语言的一种特性，是程序员在编写代码时定义的一些可变部分，这些部分在使用前必须做出指明。 1234567// 类型变量 T 会捕获用户传入的类型，之后我们就可以使用者个类型function identity&lt;T&gt;(arg: T): T { return arg;}const strId = identity('JavaScript');const numId = identity(12); 泛型变量使用泛型函数时，编译器要求你在函数体必须正确的使用这个通用的类型-即你必须把这些参数当做是任意或所有类型。 泛型函数1234567function combineFunc&lt;T,K&gt;(x: T, y: K): [T, K] { return [T, K];}let combine: &lt;T,K&gt;(x: T, y: K) =&gt; [T,K] = combineFunc;// orlet combine: { &lt;T,K&gt;(x: T, y: K): [T, K] } = combineFunc; 泛型接口12345interface CombineFunc { &lt;T,K&gt;(x: T, y: K): [T, K];}let combine: CombineFunc = (x, y) =&gt; [x, y]; 泛型类123456class CombineFunC { combine: &lt;T,K&gt;(x: T, y: K) =&gt; [T, K];}let combineC: CombineFunC = new CombineFunC&lt;number, number&gt;();combineC.combine = (x, y) =&gt; [x, y]; 枚举使用枚举可以定义一些带名字的常量，清晰的表达意图或创建一组有区别的用例。TypeScript 支持数字的和基于字符串的枚举。 数字枚举数字枚举默认的枚举值是从 0 开始自增长的，如果你为第一个枚举名字指定了一个数字枚举值，则会从这个数字值开始自增长。 123456enum Status { DELETED = -1, VALID, UNPAID, PAID} 字符串枚举字符串枚举中，每个成员都需要使用字符串字面量或另外一个字符串枚举成员进行初始化。 需要注意的是，字符串枚举没有自增长行为。 123456enum StatusTip { DELETED = 'Order has been deleted.', VALID = 'Order is valid.', UNPAID = 'Order is unpaid.', PAID = 'Order is paid'} 异构枚举枚举可以混合字符串和数字成员。 1234enum HeterogeneousEnum { NO = 0, YES = 'Yes'} 计算的和常量成员每个枚举成员都带有一个值，它可以是常量或计算出来的。当满足如下条件时，枚举成员被当做常量： 它是枚举的第一个成员，且没有初始化器，此时它的值为 0 它不带有初始化器且它之前的枚举成员是一个数字常量，此时它的值为上一个枚举成员的值 + 1 枚举成员使用常量枚举表达式初始化。常量枚举表达式是 TypeScript 表达式的子集，它可以在编译阶段求值。当一个表达式满足以下条件时，它就是一个常量枚举表达式： 一个枚举表达式字面量 一个对之前定义的常量枚举成员的引用 带括号的常量枚举表达式 一元运算符 + - ~ 其中之一应用在了常量枚举表达式 常量枚举表达式作为二元运算符 +, -, *, /, %, &lt;&lt;, &gt;&gt;, &gt;&gt;&gt;, &amp;, |, ^ 的操作对象(若常量枚举表达式求值后为 NaN 或 Infinity，则会在编译时报错) 1234567enum FileAccess { None, Read = 1 &lt;&lt; 1, Write = 1 &lt;&lt; 2, ReadWrite = Read | Write, G = '1024'.length} 联合枚举与枚举成员的类型存在一种特殊的非计算的常量枚举成员的子集：字面量枚举成员。字面量枚举成员是指不带有初始值的常量枚举成员或是被初始化为 任何字符串字面量 任何数字字面量 应用了一元 - 符号的数字字面量 当所有枚举成员都拥有字面量枚举值时，它就带有了一种特殊的语义。 运行时枚举枚举是在运行时真正存在的对象 反向映射数字枚举成员具有从枚举值到枚举名字的反向映射。 12345678enum Status { DELETED = -1, VALID, UNPAID, PAID}console.log(Status[0]); // VALID const 枚举常量枚举只能使用常量枚举表达式，并且不同于常规的枚举，它们在编译阶段会被删除-常量枚举成员会在使用的地方被内联进来，这是因为常量枚举不允许包含计算成员。 12345678const enum Directions { Up, Down, Left, Right}let directions = [ Directions.Up, Directions.Down, Directions.Left, Directions.Right ]; 类型推论类型推论是指能够在编译期间自动推导出值的类型的能力。一般发生在初始化变量和成员，设置默认参数值和决定函数返回值时。 最佳通用类型当需要从几个表达式中推断类型时，会使用这几个表达式的类型来推断出一个最合适的通用类型。 上下文类型当表达式的类型与所处的位置相关时，类型推论按照上下文归类来推论类型。当然，如果表达式包含了明确的类型信息，上下文的类型会被忽略。 类型兼容性TypeScript 中的类型兼容性是基于结构子类型的-结构子类型是一种只使用其成员来描述类型的方式。 原始类型和对象类型的兼容性如果 x 要兼容 y， 那么 y 至少需要具有与 x 相同的属性。 12345// 如果 x 要兼容 y， y 至少要与 x 拥有相同的属性let x = { name: 'x' };let y = { name: 'y', alias: 'Y' };x = y;y = x; // Property 'alias' is missing in type '{ name: string; }' but required in type '{ name: string; alias: string; } 函数的类型兼容性如果函数 x 要兼容函数 y，那么 x 至少要与 y 具有相同的参数并且返回值类型相同。 12345678let funCom = (x: number, y: number) =&gt; x + y;let funAbc = (x: number, y: number) =&gt; [x, y];let funSub = (x: number) =&gt; x;let funDef = (x: number, y: number) =&gt; x * y;funCom = funSub;funSub = funCom; // Type '(x: number, y: number) =&gt; number' is not assignable to type '(x: number) =&gt; number'funCom = funAbc; // Type '(x: number, y: number) =&gt; number[]' is not assignable to type '(x: number, y: number) =&gt; number'.Type 'number[]' is not assignable to type 'number'funCom = funDef; 类的兼容性比较两个类类型的对象时，只有实例的成员会被比较。 静态成员和构造函数不在比较的范围内。 12345678910111213141516class W { static sign: string = 'AAAAA'; pro: string = 'W'; constructor(name: string){}}class Y { pro: string = 'W'; constructor(length: number) {}}let wC = new W('W');let yC = new Y(2);wC = yC; // OKyC = wC; // OK 类的私有成员和受保护成员会影响兼容性。 当检查类实例的兼容时，如果目标类型包含一个私有成员，那么源类型必须包含来自同一个类的这个私有成员。 同样地，这条规则也适用于包含受保护成员实例的类型检查。 这允许子类赋值给父类，但是不能赋值给其它有同样类型的类。 泛型的兼容性123456interface NotEmpty&lt;T&gt; {}let gA: NotEmpty&lt;number&gt;;let gB: NotEmpty&lt;string&gt;;gA = gB; // ok 1234567interface NotEmpty&lt;T&gt; { data: T;}let gA: NotEmpty&lt;number&gt;;let gB: NotEmpty&lt;string&gt;;gA = gB; // Error 高级类型交叉类型交叉类型是将多个类型合并为一个类型。 这让我们可以把现有的多种类型叠加到一起成为一种类型，它包含了所需的所有类型的特性。 联合类型联合类型表示一个值可以是几种类型之一。 12345678/ 联合类型// 联合类型表示一个值可以是几个类型之一function pad(padding: number | string) { return padding;}console.log(pad(1));console.log(pad('A')); 如果一个值是联合类型，我们只能访问联合类型所有类型里共有的成员 123456789101112131415161718interface Elephant { name: string; walk();}interface Shark { name: string; swim();}function getAnimal(): Elephant | Shark { return { name: 'Elephant', walk() { console.log('walk') } } as Elephant;}let aAnimal = getAnimal();console.log(aAnimal.name);aAnimal.walk();aAnimal.swim();","link":"/2019/09/13/typescript-tutorial/"},{"title":"","text":"关于前端工程师成长，需要两个视角。一是立足标准，系统性总结和整理前端知识，建立自己的认知和方法论；二是放眼团队，从业务和工程角度思考前端团队的价值和发展需要。只有这样做，才能够持续发展，在高速发展的技术和工程浪潮中稳稳立足。 方法建立知识架构建立具有逻辑性和完备性的知识目录。 追本溯源","link":"/2020/12/15/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"},{"title":"缓存","text":"强制缓存强缓存策略在请求数据时，如果浏览器缓存中存在未失效的缓存数据，则直接从缓存中获取数据，不与服务器进行交互。只有在缓存中不存在要请求的数据或在缓存中的数据失效时，才会从服务器获取数据。 强缓存由 Expires/Cache-control/Pragma 三个 Header 属性进行控制。 Expires Expires 的值是一个 HTTP 日期，表示资源的过期时间。 在发起请求时，将 Expires 日期与系统时间进行对比，如果系统时间超过了 Expires 日期，则认为资源过期失效。 但由于系统时间和服务器时间可能不一致，会造成判断不准的问题。 Expires 在三个强缓存控制属性中优先级最低。 Cache-control Cache-control 是 HTTP/1.1 中新增的特性，在请求头和响应头中都能使用，可用值如下 max-age max-age 的值是一个秒数，表示从起发起时到缓存过期的时间 max-age=10 no-cache 不使用强缓存，每次请求都需要和服务器验证 no-store 禁止使用缓存(包括协商缓存)，每次请求都向服务器请求最新的资源 private 不允许中间代理、CDN等缓存 public 允许中间代理、CDN等缓存 must-revalidate 缓存过期后必须向服务器验证 Pragma Pragma 只有一个属性值，就是 no-cache ，效果和 Cache-Control 中的 no-cache 一致，不使用强缓存，需要与服务器验证缓存是否新鲜，在 3 个头部属性中的优先级最高。 协商缓存当浏览器的强缓存失效或在请求头中设置了不使用强缓存，并在请求头中设置了 if-modified-since 或 if-none-match 时，会将这两个属性值到服务器验证是否命中协商缓存。 ETag/If-None-Match ETag/If-None-Match 的值是一串 hash 码，代表的是一个资源的标识符，当服务端的文件变化的时候，它的 hash码会随之改变，通过请求头中的 If-None-Match 和当前文件的 hash 值进行比较，如果相等则表示命中协商缓存。 Last-Modified/If-Modified-Since Last-Modified/If-Modified-Since 的值代表的是文件的最后修改时间，第一次请求服务端会把资源的最后修改时间放到 Last-Modified 响应头中，第二次发起请求的时候，请求头会带上上一次响应头中的 Last-Modified 的时间，并放到 If-Modified-Since 请求头属性中，服务端根据文件最后一次修改时间和 If-Modified-Since 的值进行比较，如果相等，返回 304 ，并加载浏览器缓存。 缓存用处 减少了冗余的数据传递，节省宽带流量 减少了服务器的负担，大大提高了网站性能 加快了客户端加载网页的速度 这也正是HTTP缓存属于客户端缓存的原因","link":"/2016/01/06/%E7%BC%93%E5%AD%98/"},{"title":"常用 Git 命令","text":"Git 基础命令与运用从根本上来讲，Git 是一个内容寻址文件系统，并在此之上提供了一个版本控制系统的用户界面。这意味着 Git 的核心部分是一个简单的键值对数据库。 基础命令 配置 Git 123456789101112# 配置全局用户git config --global user.name &quot;Your name&quot;git config --global user.email &quot;Your email&quot;# 配置命令的别名git config --global alias.co checkoutgit config --global alias.ss statusgit config --global alias.cm commitgit config --global alias.br branchgit config --global alias.rg reflog# 删除全局配置git config --global --unset alias.xxxgit config --global --unset user.xxx 查看信息 12345678910111213141516171819202122232425# 查看 git 配置git config --list# 查看用户配置git ~/.gitconfig# 查看当前项目的 git 配置git .git/config# 查看暂存区的文件git ls-files# 查看本地 git 命令历史git reflog# 查看当前 HEAD 指向cat .git/HEAD# git 中 D 向下翻一行 F 向下翻页 B 向上翻页# git 查看提交历史git log --oneline# 查找和关键字有关的 log git log --grep=&quot;关键字&quot;# 图形化显示 loggit log --graph# 查找指定作者的 loggit log --author &quot;username&quot;# 显示最近 num 次提交git log -num# 显示每次更新的文件修改统计信息git log --stat 初始化 git 仓库 1git init 在本地创建一个新的仓库 Clone 1git clone /path/to/repository 创建一个本地仓库的备份 1git clone username@host:/path/to/repository 创建一个服务上仓库的备份 1git clone [url] &lt;custom_name&gt; 为克隆的仓库指定别名 Add 1234567891011121314# 添加一个或多个文件到索引git add [file1] [file2] ...# 将当前目录的所有文件变更提交到暂存区，不包括被删除的文件git add .# 将工作区已经追踪的文件变更提交到暂存区，不会提交新文件(即 untracked file)git add -u# 将工作区的所有文件变更提交到暂存区git add -A# 删除工作区/暂存区的文件git rm [file1] [file2] ...# 停止追踪指定文件，但此文件会保留在工作区git rm --cached [file]# 修改工作区/暂存区的文件的名称git mv [file_original] [file_renames] Commit 1234567891011# 提交变更到本地仓库git commit -m &quot;Commit message&quot;# add 和 commit 的合并的便捷写法git commit -am &quot;Commit message&quot;# 跳过验证继续提交git commit --no-verifygit commit -n# 修改上一次提交的信息git commit --amend# 修复提交并修改提交信息git commit --amend -m &quot;commit message&quot; Push/Pull 12345678910111213141516# 将本地仓库的文件推送到远程分支# 如果远程仓库没有这个分支，会创建一个同名的远程分支# 如果两者同名，则可省略远程分支名称git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;# 如果省略本地分支名称，则表示删除指定的远程分支git push origin :&lt;远程分支名&gt;# 相当于git push origin --delete &lt;远程分支名&gt;# 将当前分支与远程分支进行关联git push -u origin &lt;远程分支名&gt;# 将本地的所有分支推送到远程仓库git push --all origin# 从关联的远程分支拉取更改到当前分支git pull# 拉取其它分支并合并到当前分支git pull origin &lt;远程分支名&gt; Diff 1234# 比较的是工作目录文件与暂存区文件的区别git diff# 比较的是暂存区的文件与仓库分支里的文件的区别git diff --cached Status 1git status 列出你已经更改过但是还没有添加或提交的文件 Remote 12345678# 查看所有远程主机git remote # 查看关联的远程仓库的详细信息git remote -v # 移除与远程仓库的关联git remote rm &lt;仓库名称&gt;# 设置关联的远程仓库git remote set-url origin &lt;远程仓库地址&gt; Branches 123456789101112131415161718192021222324# 查看本地分支git branch | git branch -l # 查看远程分支git branch -r # 查看所有分支git branch -a# 查看所有分支和最新的提交git branch -av # 新建分支，新分支会复制当前分支已经提交到仓库的内容git branch &lt;分支名&gt; # 切换分支git checkout &lt;分支名&gt;# 创建一个新分支并切换到新分支git checkout -b &lt;分支名&gt; # 删除本地分支，会阻止删除包含未合并更改的分支git branch -d &lt;分支名&gt; # 强制删除一个本地分支，即使是包含未合并更改的分支git branch -D &lt;分支名&gt;# 删除远程分支git push origin :&lt;分支名&gt;# 或 git push origin --delete &lt;分支名&gt;# 修改当前分支名称 git branch -m &lt;分支名&gt; Merge 123456# 默认的合并方式，fast-forward，HEAD 指针直接指向被合并的分支git merge # 禁止快进式合并git merge --no-ff #git merge --squash Tags 12345678910111213141516# 在指定的 commit id 上创建一个标签git tag &lt;标签名&gt; &lt;commit_id&gt;# 默认在 HEAD 上创建一个标签git tag &lt;标签名&gt;# 创建带有说明的表亲啊git tag -a &lt;标签名&gt; -m &quot;tag message&quot;# 查看所有标签git tag# 推送一个本地标签git push origin &lt;标签名&gt;# 推送所有本地标签git push origin --tags# 删除本地标签git tag -d &lt;标签名&gt;# 删除一个远程标签git push origin :refs/tags/&lt;标签名&gt; Checkout 12345678910# 恢复暂存区的指定文件到工作区git checkout &lt;filename&gt;# 恢复暂存区的所有文件到工作区git checkout .# 回滚到最近的一次提交git checkout HEAD# 回滚到最近一次提交的上一个版本git checkout HEAD^# 切换到指定 commitgit checkot &lt;commit id&gt; Clean 从当前文件夹开始，通过递归删除的方式删除不在版本控制中的文件。 123456# 从工作区移除没有被追踪的文件git clean -f# 从工作区移除没有被追踪的目录和文件git clean -fd# 查看 clean 命令会删除哪些文件git clean -nfd Reset 12345678910111213141516# 从暂存区撤销指定文件的修改，但并不改变工作区git reset &lt;file&gt;# 重置暂存区最近的一次提交git reset# 相当于git reset HEAD# 重置工作区和暂存区git reset --hard# 将当前分支的指针指向指定的 commit，同时重置暂存区，工作区不变git reset &lt;commit id&gt;# 等价于git reset --mixed &lt;commit id&gt;# 将当前分支的指针指向指定的 commit，不改变暂存区和工作区git reset --soft &lt;commit id&gt;# 将当前分支的指针指向指定的 commit，同时重置暂存区和工作区git reset --hard &lt;commit id&gt; Revert 123456# 生成一个撤销最近一次提交的新提交git revert HEAD# 生成一个撤销最近一次提交的上num次提交的新提交git revert HEAD~num# 生成一个撤销指定提交的新提交git revert &lt;commit id&gt; Cherry-pick 12# 将指定的提交应用于当前分支git cherry-pick &lt;commit id&gt; Search 1git grep &quot;search key word&quot; 在工作目录中查找指定的关键字 一些运用场景 撤销提交到远程的某些提交 12345678910111213# 通过 `git log` 命令来获得指定的某次提交的 `id`git reset [&lt;mode&gt;] [&lt;commit&gt;]# 这个命令将当前分支的 `head` 指针指向指定的 `commit` 而且可能会根据选择的 `mode` 更新索引和工作树# 如果 `mode` 省略，则默认值是 `--mixed`# `--soft` 仅仅只是将 `head` 指向指定的 `commit`# `--mixed` 会重置索引，但不会重置工作区# `--hard` 重置索引和工作区，任何在指定的 `commit` 之后的修改将被丢弃# `--merge`# `--keep`git reset --hard &lt;commit_id&gt;# 然后将重置后的 `branch` 推送到远程仓库# `--force` 会使用本地分支的提交覆盖远程分支的提交git push origin HEAD --force 保存当前未提交修改 123456789101112131415# 将当前未提交的修改保存下来，工作目录的 Head 回到上一提交git stash# orgit stash save 'message'# 列出通过 stash 保存的修改git stash list# 列出 stash 的修改与 上一次提交的 diffgit stash show# 恢复之前通过 stash 保存的修改# 这个命令将第一个 stash 恢复，并从 stash 列表中删除git stash pop# 或者使用 apply 命令将修改恢复，但不从 stash 列表中删除git stash apply# 手动删除指定的 stashgit stash drop stash@{0} 更换远程仓库 123456# 删除远程仓库地址git remote rm origin# 添加远程仓库地址git remote add origin &lt;remote_git_address&gt;# 推送本地所有分支git push --all origin -u fast-forward 与 no-fast-forward 合并 当执行 get merge 命令时，git 会根据当前分支和目标分支(将要合并的分支)的状况不同而选择合适的合并方式。 如果当前分支与目标分支相比没有额外的提交时，执行 fast-foward 合并，fast-foward 合并不会产生新的提交，而是将目标分支的提交直接合并到当前分支 如果当前分支与目标分支相比有目标分支并没有的提交，执行 no-fast-foward 合并，这会产生新的提交，这个提交的父提交既指向当前分支，也指向目标分支。 1git merge dev 变基 git rebase 会将指定分支的","link":"/2016/02/11/%E5%B8%B8%E7%94%A8Git%E5%91%BD%E4%BB%A4/"},{"title":"防抖和节流","text":"防抖和节流处理频繁触发的事件时，如果没有进行限制，每次触发都调用处理函数进行处理不仅会浪费资源，还会降低用户体验，所以需要限制处理函数的调用频率，这便是用到防抖和节流的地方。 函数防抖当持续触发事件时，一定时间段内没有再触发事件，事件处理函数才会执行一次，如果设定的时间到来之前，又一次触发了事件，就重新开始延时。 函数防抖的一个典型应用场景是根据 input 的输入内容搜索相关信息，如果 input 内容每次改变都发起搜索请求，则会在短时间内发次多个请求，这种情况下，对事件处理函数进行防抖处理，在给定的时间段 T 内，input 内容没有改变，才发起搜索请求。 12345678910// 一个简单的防抖函数function debounce(fn, wait) { let timeout = null; return function() { if (timeout !== null) { clearTimeOut(timeout); } timeout = setTimeOut(fn, wait); };} 函数节流当持续触发事件时，保证一定时间段内只调用一次事件处理函数。 函数节流适合的处理的情况是更高频次的触发事件处理函数的情况，比如 resize、mousemove 、scroll 等，强制事件处理函数以固定频率执行。 时间戳实现 12345678910111213141516171819// 利用时间戳实现节流函数function throttle(fn, delay) { let prev = Date.now(); return function() { let context = this; let args = arguments; let now = Data.now(); if (now - prev &gt;= delay) { fn.apply(context, args); prev = Date.now(); } };}// 事件处理函数function handler() {}// 事件监听window.addEventListener('scroll', throttle(handler, 500)) 定时器实现 1234567891011121314151617181920// 利用定时器实现节流函数function throttle(fn, delay) { let timer = null; return function() { let context = this; let args = arguments; if (!timer) { timer = setTimeOut(function() { fn.apply(context, args); timer = null; }, delay) } };}// 事件处理函数function handler() {}// 事件监听window.addEventListener('scroll', throttle(handler, 500)) 混合实现 12345678910111213141516function throttleFun(fun, duration) { let timer = null; let startT = Date.now(); return function() { const context = this; const args = arguments; const remaining = duration - ( startT - Date.now()); clearTimeout(timer); if (remaining &lt;= 0) { fun.apply(context, args); startT = Date.now(); } else { timer = setTimeout(fun, remaining); } }} 防抖和节流的区别防抖将几次操作合并为一次操作，节流则保证一段时间内只触发一次函数。 函数节流不管事件触发有多频繁，都会保证在规定时间内一定会执行一次真正的事件处理函数，而函数防抖只是在最后一次事件后才触发一次函数。","link":"/2018/03/19/%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/"},{"title":"GoLang Basic Knowledge","text":"语言特色 简洁、快速、安全 并行、有趣、开源 内存管理、数据安全、编译迅速 关键字和标识符关键字关键字是一些特殊的用来帮助编译器理解和解析源代码的单词。 12345break default func interface selectcase defer go map structchan else goto package switchconst fallthrough if range typecontinue for import return var 标识符一个标识符是一个以Unicode字母或者_开头并且完全由Unicode字母和Unicode数字组成的单词。 123player_prevnext_1 基本类型、变量和常量基本内置类型Go 支持内置基本类型(预声明类型)有： 布尔类型 bool 整数类型 int8 、uint8 、int16、uint16 、int32、uint32、int64、uint64、int、uint 和 uintptr 浮点数类型 float32 和 float64 复数类型 complex32 和 complex64 字符串类型 string 通常，int 、uint 和 uintptr 的尺寸依赖于具体的编译器实现。 变量Go 中声明变量一般使用 var 关键字。 1var identifier type 声明变量时，如果指定了变量类型但没有初始化，则变量的默认值为指定类型的零值： 123456var numericalVal intprintln(numericalVal) // 0var stringVal stringprintln(stringVal) // ''var booleanVal boolprintln(booleanVal) // false 如果没有指定变量类型，但进行了初始化，Go 会自动推断变量的类型： 12var valF, valS, valT = &quot;&quot;, 100, 100.10fmt.Printf(&quot;valF = %T, valS = %T, valT = %T \\n&quot;, valF, valS, valT) // valF = string, valS = int, valT = float64 还可以使用 := 来声明变量，只能用在函数体重： 12valF := &quot;Anthor var&quot;fmt.Printf(&quot;valF value = %v and type = %T&quot;, valF, valF) // valF value = Anthor var and type = string 声明全局变量： 12345var ( valI int valB bool valS string ) 如果不需要某个值，可以使用 _ 将其抛弃： 12var valA, valB = 1, 2_, valB = 3, 4 常量常量中的数据类型只可以是布尔型、数字型（整数型、浮点型和复数）和字符串型。 12const valBoolean, valInt, valFloat, valString = false, 10, 3.14, &quot;string&quot;fmt.Printf(&quot;%v %v %v %v&quot;, valBoolean, valInt, valFloat, valString) // false 10 3.14 string 特殊常量值 itoa ： 123456const ( a = iota b c)fmt.Printf(&quot;%v %v %v \\n&quot;, a, b, c) // 0 1 2 函数Go 中使用 func 关键字来声明一个函数 1func funcName([params list]) [return types] {} 数组数组是具有相同唯一类型的一组已编号且长度固定的数据项序列，这种类型可以是任意的原始类型例如整型、字符串或者自定义类型。 数组的一般声明方式： 1var arrayName [arraySize] elementType 初始化数组： 12345678var intArray = [3]int{1, 2, 3}fmt.Printf(&quot;%T %v \\n&quot;, intArray, intArray) // [3]int [1 2 3]stringArray := [3]string{&quot;a&quot;, &quot;b&quot;, &quot;c&quot;}fmt.Printf(&quot;%T %v \\n&quot;, stringArray, stringArray) // [3]string [a b c] booleanArray := [...]bool{true, false}fmt.Printf(&quot;%T %v \\n&quot;, booleanArray, booleanArray) // [2]boole [true false] 指针一个指针变量指向了一个值的内存地址。 指针的使用类似于变量和常量，在使用指针之前需要声明它： 1var pointerName *pointerType 举几个例子： 12var intPointer *intvar stringPointer *bool 简单使用： 1234var intPointer *intvar intVal = 99intPointer = &amp;intValfmt.Printf(&quot;%v %v %v&quot;, intPointer, &amp;intPointer, *intPointer) // 0xc0000b2008 0xc0000ac018 99 一个指针变量声明后如果没有被赋值，它的值为 nil ，称为空指针。 结构体Go 语言中数组可以存储同一类型的数据，但在结构体中我们可以为不同项定义不同的数据类型。 结构体是由一系列具有相同类型或不同类型的数据构成的数据集合。 定义结构体： 1234567891011121314151617181920212223package mainimport &quot;fmt&quot;type student struct { name string age int height float32 weight float32}func main() { var studentA = student{&quot;Mike&quot;, 18, 178, 78.9 } fmt.Printf(&quot;%v %T \\n&quot;, studentA, studentA) // {Mike 18 178 78.9} main.student fmt.Printf(&quot;name = %v \\n&quot;, studentA.name) // Mike fmt.Printf(&quot;age = %v \\n&quot;, studentA.age) // 18 // 结构体指针 var studentAPointer = &amp;studentA fmt.Printf(&quot;%v %T \\n&quot;, studentAPointer, studentAPointer) // &amp;{Mike 18 178 78.9} *main.student fmt.Printf(&quot;name = %v \\n&quot;, studentAPointer.name) // Mike fmt.Printf(&quot;age = %v \\n&quot;, studentAPointer.age) // 18} 切片Go 语言切片是对数组的抽象。 Go 数组的长度不可改变，在特定场景中这样的集合就不太适用，Go 中提供了一种灵活，功能强悍的内置类型切片(“动态数组”)，与数组相比切片的长度是不固定的，可以追加元素，在追加时可能使切片的容量增大。 定义切片： 1234567891011var numberSlice []intnumberSlice = make([]int, 3)fmt.Printf(&quot; %v %T \\n&quot;, numberSlice, numberSlice) // [0, 0, 0] []intstringSlice := []string{&quot;a&quot;, &quot;b&quot;, &quot;c&quot;}fmt.Printf(&quot;%v %T \\n&quot;, stringSlice, stringSlice) // [a, b, c] []string// 从数组创建floatArray := [...]float32{1.1, 2.2, 3.3}floatSlice := floatArray[0:2]fmt.Printf(&quot;%v %T \\n&quot;, floatSlice, floatSlice) [1.1, 2.2] []float32 切片的操作： 1234567891011121314151617181920212223 intSlice := []int{1, 2, 3, 4, 5, 6} fmt.Printf(&quot;slice length = %v \\n&quot;, len(intSlice)) // slice length = 6 fmt.Printf(&quot;slice capacity = %v \\n&quot;, cap(intSlice)) // slice capacity = 6 // slice 取值 fmt.Printf(&quot;slice [3] = %v \\n&quot;, intSlice[3]) // slice[3] = 4 fmt.Printf(&quot;slice [0:1] = %v \\n&quot;, intSlice[0:1]) // slice[0:1] = [1] fmt.Printf(&quot;slice [0:2] = %v \\n&quot;, intSlice[0:2]) // slice[0:2] = [1, 2] fmt.Printf(&quot;slice [:3] = %v \\n&quot;, intSlice[:3]) // slice[:3] = [1, 2, 3] fmt.Printf(&quot;slice [3:] = %v \\n&quot;, intSlice[3:]) // slice[3:] = [4, 5, 6]// append() 和 copy() intSlice = append(intSlice, 7) fmt.Printf(&quot;slice = %v \\n&quot;, intSlice) // slice = [1 2 3 4 5 6 7] intSlice = append(intSlice, 8, 9, 10) fmt.Printf(&quot;slice = %v \\n&quot;, intSlice) // slice = [1 2 3 4 5 6 7 8 9 10] anotherSlice := []int{11, 12, 13} intSlice = append(intSlice, anotherSlice...) fmt.Printf(&quot;slice = %v \\n&quot;, intSlice) // slice = [1 2 3 4 5 6 7 8 9 10 11 12 13] thirdSlice := []int{88, 99} copy(intSlice, thirdSlice) fmt.Printf(&quot;slice = %v \\n&quot;, intSlice) // slice = [88 99 3 4 5 6 7 8 9 10 11 12 13] 范围Go 语言中 range 关键字用于 for 循环中迭代数组(array)、切片(slice)、通道(channel)或集合(map)的元素。在数组和切片中它返回元素的索引和索引对应的值，在集合中返回 key-value 对。 12345678910111213141516intSlice := []int{1, 3}for index, num := range intSlice { fmt.Printf(&quot;index = %v num = %v \\n&quot;, index, num)}// index = 0 num = 1 // index = 1 num = 3 stringMap := map[string]string{&quot;a&quot;: &quot;A&quot;, &quot;b&quot;: &quot;B&quot;}for key, val := range stringMap { fmt.Printf(&quot; key = %v val = %v \\n&quot;, key, val)}// key = a val = A // key = b val = B 集合Map 是一种无序的键值对的集合。Map 最重要的一点是通过 key 来快速检索数据，key 类似于索引，指向数据的值。 Map 是一种集合，所以我们可以像迭代数组和切片那样迭代它。不过，Map 是无序的，我们无法决定它的返回顺序，这是因为 Map 是使用 hash 表来实现的。 定义 Map: 1234567891011121314151617var numMap map[string]intnumMap = make(map[string]int)numMap[&quot;a&quot;] = 1fmt.Printf(&quot;map = %v \\n&quot;, numMap) // map = map[a:1]stringMap := make(map[string]string)stringMap[&quot;name&quot;] = &quot;Mike&quot;stringMap[&quot;age&quot;] = &quot;十八&quot;for key, val := range stringMap { fmt.Printf(&quot;key = %v value = %v \\n&quot;, key, val)}// key = name value = Mike // key = age value = 十八delete(stringMap, &quot;age&quot;)fmt.Printf(&quot;map = %v \\n&quot;, stringMap) // map = map[name:Mike]","link":"/2021/05/13/golang-basic/"},{"title":"Vue 3 源码解析","text":"1fun: `createApp(App)` -&gt; ``","link":"/2021/05/17/Vue%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"},{"title":"GoLang Channel and","text":"通道作为 Go 的特性之一，其主要作用是用来实现并发同步。 通道与 Go 的另一个特性协程一起，构成了 Go 的并发编程。 什么是通道？ 一般的理解来看，实现并发同步的两种思路分别是： 通过内存共享通讯 通过通讯共享内存 Go 中的通道即是采用第二种思路设计。 可以把通道看做是一个先进先出的队列，一些协程可以向通道发送数据，另一些协程则可以从通道中接收数据。 通道类型和值","link":"/2021/05/15/golang-channel/"}],"tags":[{"name":"Web","slug":"Web","link":"/tags/Web/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"GoLang","slug":"GoLang","link":"/tags/GoLang/"},{"name":"Git","slug":"Git","link":"/tags/Git/"}],"categories":[{"name":"大前端","slug":"大前端","link":"/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"},{"name":"JavaScript","slug":"JavaScript","link":"/categories/JavaScript/"},{"name":"Mac","slug":"Mac","link":"/categories/Mac/"},{"name":"CS","slug":"CS","link":"/categories/CS/"},{"name":"Web","slug":"Web","link":"/categories/Web/"},{"name":"Vue","slug":"Vue","link":"/categories/Vue/"},{"name":"GoLang","slug":"GoLang","link":"/categories/GoLang/"},{"name":"iOS","slug":"iOS","link":"/categories/iOS/"},{"name":"TypeScript","slug":"TypeScript","link":"/categories/TypeScript/"},{"name":"Git","slug":"Git","link":"/categories/Git/"}]}