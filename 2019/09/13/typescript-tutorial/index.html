<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>TypeScript 概览 - 关于代码的碎碎念</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="LeiTech"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="LeiTech"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="TypeScriptTypeScript 是 JavaScript 类型的超集，它可以编译成纯 JavaScript，可以在任何浏览器、任何计算机和任何操作系统上运行，并且是开源的。 基础类型TypeScript 支持与 JavaScript 几乎相同的数据类型，此外还提供了方便使用的枚举类型。 123456789101112131415161718192021222324252627282930"><meta property="og:type" content="blog"><meta property="og:title" content="TypeScript 概览"><meta property="og:url" content="https://cocoalei.github.io/blogs/2019/09/13/typescript-tutorial/"><meta property="og:site_name" content="关于代码的碎碎念"><meta property="og:description" content="TypeScriptTypeScript 是 JavaScript 类型的超集，它可以编译成纯 JavaScript，可以在任何浏览器、任何计算机和任何操作系统上运行，并且是开源的。 基础类型TypeScript 支持与 JavaScript 几乎相同的数据类型，此外还提供了方便使用的枚举类型。 123456789101112131415161718192021222324252627282930"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://cocoalei.github.io/img/og_image.png"><meta property="article:published_time" content="2019-09-12T16:00:00.000Z"><meta property="article:modified_time" content="2021-09-01T07:00:39.648Z"><meta property="article:author" content="Y2hlbmdsZWk="><meta property="article:tag" content="TypeScript"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://cocoalei.github.io/blogs/2019/09/13/typescript-tutorial/"},"headline":"TypeScript 概览","image":["https://cocoalei.github.io/img/og_image.png"],"datePublished":"2019-09-12T16:00:00.000Z","dateModified":"2021-09-01T07:00:39.648Z","author":{"@type":"Person","name":"Y2hlbmdsZWk="},"publisher":{"@type":"Organization","name":"关于代码的碎碎念","logo":{"@type":"ImageObject","url":"https://cocoalei.github.io/img/logo.svg"}},"description":"TypeScriptTypeScript 是 JavaScript 类型的超集，它可以编译成纯 JavaScript，可以在任何浏览器、任何计算机和任何操作系统上运行，并且是开源的。 基础类型TypeScript 支持与 JavaScript 几乎相同的数据类型，此外还提供了方便使用的枚举类型。 123456789101112131415161718192021222324252627282930"}</script><link rel="canonical" href="https://cocoalei.github.io/blogs/2019/09/13/typescript-tutorial/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-dark.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.4.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="关于代码的碎碎念" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2019-09-12T16:00:00.000Z" title="2019/9/13 上午12:00:00">2019-09-13</time>发表</span><span class="level-item"><a class="link-muted" href="/categories/Web/">Web</a></span><span class="level-item">39 分钟读完 (大约5790个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">TypeScript 概览</h1><div class="content"><h1 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h1><p>TypeScript 是 JavaScript 类型的超集，它可以编译成纯 JavaScript，可以在任何浏览器、任何计算机和任何操作系统上运行，并且是开源的。</p>
<h2 id="基础类型"><a href="#基础类型" class="headerlink" title="基础类型"></a>基础类型</h2><p>TypeScript 支持与 JavaScript 几乎相同的数据类型，此外还提供了方便使用的枚举类型。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// boolean</span></span><br><span class="line"><span class="keyword">let</span> isDone: <span class="built_in">boolean</span> = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">// number</span></span><br><span class="line"><span class="comment">// JavaScript 和 TypeScript 中的数字不是浮点类型 floating point 就是大整数类型 BigInteger</span></span><br><span class="line"><span class="keyword">let</span> decLiteral: <span class="built_in">number</span> = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">let</span> bigLiteral: <span class="built_in">number</span> = <span class="number">100n</span>;</span><br><span class="line"><span class="comment">// string</span></span><br><span class="line"><span class="keyword">let</span> name: <span class="built_in">string</span> = <span class="string">&#x27;bob&#x27;</span>;</span><br><span class="line"><span class="comment">// Array</span></span><br><span class="line"><span class="keyword">let</span> list: <span class="built_in">number</span>[] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> list: <span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="comment">// Tuple</span></span><br><span class="line"><span class="comment">// 元组类型要求值类型、顺序和个数一一对应</span></span><br><span class="line"><span class="keyword">let</span> tuple: [<span class="built_in">string</span>, <span class="built_in">string</span>] = [<span class="string">&#x27;string&#x27;</span>, <span class="string">&#x27;string&#x27;</span>];</span><br><span class="line"><span class="comment">// enum</span></span><br><span class="line"><span class="built_in">enum</span> Color &#123;Red = <span class="number">0</span>, Green, Blue&#125;</span><br><span class="line"><span class="keyword">let</span> c: Color = Color.Green;</span><br><span class="line"><span class="comment">// Any</span></span><br><span class="line"><span class="keyword">let</span> source: <span class="built_in">any</span> = <span class="number">4</span></span><br><span class="line"><span class="comment">// Void</span></span><br><span class="line"><span class="keyword">let</span> unusable: <span class="built_in">void</span> = <span class="literal">undefined</span>;</span><br><span class="line"><span class="comment">// Null &amp; Undefined</span></span><br><span class="line"><span class="keyword">let</span> u: <span class="literal">undefined</span> = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">let</span> n: <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="comment">// Never</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">error</span>(<span class="params">message: <span class="built_in">string</span></span>): <span class="title">never</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(message);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 类型断言</span></span><br><span class="line"><span class="comment">// 明确知道值的类型时可使用类型断言</span></span><br><span class="line"><span class="keyword">let</span> strValue: <span class="built_in">any</span> = <span class="string">&#x27;str&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> length: <span class="built_in">number</span> = (&lt;<span class="built_in">string</span>&gt;strValue).length;</span><br><span class="line"><span class="keyword">let</span> length: <span class="built_in">number</span> = (strValue <span class="keyword">as</span> <span class="built_in">string</span>).length</span><br></pre></td></tr></table></figure>



<h2 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h2><ul>
<li><p><code>var</code></p>
<p>可以通过 <code>var</code> 关键字定义变量，但是 <code>var</code> 声明可以在包含它的函数、模块、命名空间或全局作用域内部任何位置被访问，包含它的代码块对此没有影响，这可能会引发一些错误，比如多次声明同一个变量并不会报错。</p>
</li>
<li><p><code>let</code></p>
<p>当用 <code>let</code> 声明一个变量，它使用的是词法作用域或块作用域。不同于使用 <code>var</code> 声明的变量那样可以在包含它们的函数外访问，块作用域变量在包含它们的块之外是不能访问的。</p>
</li>
<li><p><code>const</code></p>
<p><code>const</code> 拥有与 <code>let</code> 相同的作用域规则，但是声明的变量被赋值后不能再改变。</p>
</li>
</ul>
<p>每次进入一个作用域时，它创建了一个变量的环境，就算作用域内代码已经执行完毕，这个环境与其捕获的变量依然存在。当 <code>let</code> 声明出现在循环体里时拥有完全不同的行为，不仅是在循环里引入了一个新的变量环境，而是针对每次迭代都会创建这样一个新作用域。</p>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p><strong>TypeScript 的核心原则之一是对值所具有的结构进行类型检查</strong>。 它有时被称做 “鸭式辨型法”或”结构性子类型化”。 在 TypeScript 里，接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约。</p>
<p>JavaScript 为开发者提供了非常大的灵活性：比如你可以为一个初始化为整数的变量赋值一个函数。但同时这种不确定性也会带来很多的麻烦，TypeScript 内置的接口就可以用来解决这个问题。 </p>
<p><em>接口帮助我们在赋值和传递参数时进行类型检查，确保我们给变量的赋值符合变量的类型或接收参数正确(接口在某种程度上表示了变量或函数对于赋值给它的值或传递给它的参数的一种期望和要求)。</em></p>
<h3 id="可选属性"><a href="#可选属性" class="headerlink" title="可选属性"></a>可选属性</h3><p>接口里的属性不全都是必需的，有些是只在某些条件下存在，或者根本不存在，可以为接口定义可选属性来实现这些需求。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> OptionAttribute &#123;</span><br><span class="line">    optionNum?: <span class="built_in">number</span>;</span><br><span class="line">    optionStr?: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可选属性的好处之一是可以对可能存在的属性进行预定义，好处之二是可以捕获引用了不存在的属性时的错误。 </p>
<h3 id="只读属性"><a href="#只读属性" class="headerlink" title="只读属性"></a>只读属性</h3><p>如果希望对象的某些属性只有在刚创建的时候修改其值，可以通过在属性名前用 readonly 来指定属性为只读属性。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> ReadonlyAttribute &#123;</span><br><span class="line">    <span class="keyword">readonly</span> num: <span class="built_in">number</span>;</span><br><span class="line">    <span class="keyword">readonly</span> str: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>TypeScript</code> 具有 <code>ReadonlyArray&lt;T&gt;</code> 类型，它与 <code>Array&lt;T&gt;</code> 类似，只是把所有可变方法去掉了，因此可以保证数组创建后再也不能被修改。</p>
<blockquote>
<p><strong>readonly</strong> vs <strong>const</strong></p>
<p>使用 <code>const</code> 来修饰变量，使用 <code>readonly</code> 来修饰属性</p>
</blockquote>
<h3 id="额外的类型检查"><a href="#额外的类型检查" class="headerlink" title="额外的类型检查"></a>额外的类型检查</h3><p>在 <code>TypeScript</code> 中，对象字面量赋值给变量或作为参数进行传递的时候，会经过 “额外属性检查”，如果一个对象字面量存在任何 “目标类型” 不包含的属性时，会发生错误。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> SquareConfig &#123; </span><br><span class="line">  <span class="attr">width</span>: <span class="built_in">number</span>;</span><br><span class="line">  color?: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createSquare</span>(<span class="params">config: SquareConfig</span>): </span>&#123; color: <span class="built_in">string</span>, <span class="attr">area</span>: <span class="built_in">number</span> &#125; &#123;</span><br><span class="line">  <span class="keyword">let</span> newSquare = &#123; <span class="attr">color</span>: <span class="string">&#x27;blue&#x27;</span>, <span class="attr">area</span>: <span class="number">0</span> &#125;;</span><br><span class="line">  <span class="keyword">if</span> (config.width) newSquare.area = config.width * config.width;</span><br><span class="line">  <span class="keyword">if</span> (config.color) newSquare.color = config.color;</span><br><span class="line">  <span class="keyword">return</span> newSquare;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// error: height not expected in type SquareConfig</span></span><br><span class="line"><span class="keyword">let</span> mySquare = createSquare(&#123; <span class="attr">color</span>: <span class="string">&#x27;green&#x27;</span>, <span class="attr">width</span>: <span class="number">10</span>, <span class="attr">height</span>: <span class="number">10</span> &#125;);</span><br></pre></td></tr></table></figure>

<p>使用 ‘类型断言’ 可以绕开额外属性检查</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mySquare = createSquare(&#123; <span class="attr">color</span>: <span class="string">&#x27;green&#x27;</span>, <span class="attr">width</span>: <span class="number">10</span>, <span class="attr">height</span>: <span class="number">10</span> &#125; <span class="keyword">as</span> SquareConfig);</span><br></pre></td></tr></table></figure>

<p>但是更好的做法是在接口中提供一个字符串索引签名</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> SquareConfig &#123; </span><br><span class="line">  <span class="attr">width</span>: <span class="built_in">number</span>;</span><br><span class="line">  color?: <span class="built_in">string</span>;</span><br><span class="line">  [propName: <span class="built_in">string</span>]: <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h3><p>接口能够描述 <code>JavaScript</code> 中对象拥有的各种各样的外形。 除了描述带有属性的普通对象外，接口也可以描述函数类型。</p>
<p>为了使用接口表示函数类型，我们需要给接口定义一个调用签名。 它就像是一个只有参数列表和返回值类型的函数定义。</p>
<p>参数列表里的每个参数都需要名字和类型。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> TypeFunc &#123;</span><br><span class="line">    (source: <span class="built_in">string</span>, <span class="attr">subString</span>: <span class="built_in">string</span>): <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样定义后，我们可以像使用其它接口一样使用这个函数类型的接口。 下例展示了如何创建一个函数类型的变量，并将一个同类型的函数赋值给这个变量。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mySearchFunc: TypeFunc;</span><br><span class="line">mySearchFunc = <span class="function"><span class="keyword">function</span>(<span class="params">source: <span class="built_in">string</span>, subString: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = source.search(subString);</span><br><span class="line">    <span class="keyword">return</span> result &gt; -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于函数类型的类型检查来说，函数的参数名不需要与接口定义里的名字相匹配。</p>
<p>函数的参数会逐个进行检查，要求对应位置上的参数类型是兼容的。如果没有指定类型，<code>TypeScript</code> 的类型系统会推断出参数类型，而函数的返回值类型是通过其返回值推断出来的。</p>
<h3 id="可索引的类型"><a href="#可索引的类型" class="headerlink" title="可索引的类型"></a>可索引的类型</h3><p>与使用接口描述函数类型差不多，我们也可以描述那些能够通过索引得到的类型。可索引类型具有一个索引签名，它描述了对象索引的类型，还有相应的索引返回值类型。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 表明了当用 number 去索引 StringArr 时会得到 string 类型的返回值</span></span><br><span class="line"><span class="keyword">interface</span> StringArr &#123;</span><br><span class="line">    [index: <span class="built_in">number</span>]: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myArr: StringArr;</span><br><span class="line">myArr = [<span class="string">&quot;A&quot;</span>,<span class="string">&quot;B&quot;</span>];</span><br><span class="line"><span class="keyword">let</span> myStr: <span class="built_in">string</span> = myArr[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>

<p>索引签名共有两种类型：字符串和数字。可以同时使用这两种类型的索引，但是数字索引的返回值必须是字符串索引返回值类型的子类型。这是因为当使用 <code>number</code> 来索引时，<code>TypeScript</code> 会将它转换为 <code>string</code> 然后再去索引对象。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> StringArray &#123; </span><br><span class="line">  [index: <span class="built_in">string</span>]: <span class="built_in">string</span>;</span><br><span class="line">  [index: <span class="built_in">number</span>]: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一般将索引签名设置为只读，这样可以防止给索引赋值。</p>
<h3 id="类类型"><a href="#类类型" class="headerlink" title="类类型"></a>类类型</h3><p><code>TypeScript</code> 中的接口也能够用来明确的强制一个类去符合某种协议/契约。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> ClockInterface &#123;</span><br><span class="line">    <span class="attr">currentTime</span>: <span class="built_in">Date</span>;</span><br><span class="line">    setTime:(d: <span class="built_in">Date</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="title">implements</span> <span class="title">ClockInterface</span> </span>&#123;</span><br><span class="line">    <span class="attr">currentTime</span>: <span class="built_in">Date</span>;</span><br><span class="line">    setTime:(d: <span class="built_in">Date</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.currentTime = d;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">h: <span class="built_in">number</span>, m: <span class="built_in">number</span></span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口描述了类的公共部分，而不是公共和私有两部分，它不会帮你检查类是否具有某些私有成员。</p>
<h3 id="类静态部分与实例部分的区别"><a href="#类静态部分与实例部分的区别" class="headerlink" title="类静态部分与实例部分的区别"></a>类静态部分与实例部分的区别</h3><p>类具有两个类型 ：静态部分的类型和实例的类型。</p>
<p>当一个类实现了一个接口时，只对其实例部分进行类型检查。<code>constructor</code> 存在于类的静态部分，不在检查范围内。因此我们应该直接操作类的静态部分。</p>
<blockquote>
<p>可以认为类的静态部分指的是类本身，实例部分指的是类实例化出来的对象。</p>
</blockquote>
<h3 id="继承接口"><a href="#继承接口" class="headerlink" title="继承接口"></a>继承接口</h3><p>和类一样，接口也可以相互继承。这让我们能够从一个接口里复制成员到另一个接口里，可以更灵活地将接口分割到可重用的模块里。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Father &#123;</span><br><span class="line">    <span class="attr">familyName</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Son <span class="keyword">extends</span> Father &#123;</span><br><span class="line">    <span class="attr">givenName</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> aPerson = &lt;Son&gt;&#123;&#125;;</span><br><span class="line">aPerson.familyName = <span class="string">&#x27;S&#x27;</span>;</span><br><span class="line">aPerson.givenName = <span class="string">&#x27;T&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>一个接口可以继承多个接口，创建出多个接口的合成接口。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Shape &#123;</span><br><span class="line">  <span class="attr">color</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Stroke &#123;</span><br><span class="line">  <span class="attr">penWidth</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Square <span class="keyword">extends</span> Shape, Stroke &#123;</span><br><span class="line">  <span class="attr">width</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="混合类型"><a href="#混合类型" class="headerlink" title="混合类型"></a>混合类型</h3><p>接口能够描述 <code>JavaScript</code> 中丰富的类型，可以使用 混合类型 来使某个对象具有多个类型。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Counter &#123;</span><br><span class="line">  (start: <span class="built_in">number</span>): <span class="built_in">number</span>;</span><br><span class="line">	interval: <span class="built_in">number</span>;</span><br><span class="line">	reset(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCounter</span>(<span class="params"></span>): <span class="title">Counter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> counter = &lt;Counter&gt;<span class="function"><span class="keyword">function</span> (<span class="params">start: <span class="built_in">number</span></span>) </span>&#123;&#125;;</span><br><span class="line">  counter.interval = <span class="number">1</span>;</span><br><span class="line">  counter.reset = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">  <span class="keyword">return</span> counter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = getCounter();</span><br><span class="line">c(<span class="number">10</span>);</span><br><span class="line">c.reset();</span><br><span class="line">c.interval = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>



<h3 id="接口继承类"><a href="#接口继承类" class="headerlink" title="接口继承类"></a>接口继承类</h3><p>当接口继承了一个类类型时，它会继承类的成员但不继承其实现。就好像接口声明了所有类中存在的成员，但没有提供具体实现一样。接口同样会继承到类的 <code>private</code> 和 <code>protected</code> 成员。这意味着当你创建了一个接口继承了一个拥有私有或受保护的成员的类时，这个接口类型只能被这个类或其子类所实现。</p>
<p>当你有一个庞大的继承结构时这很有用，但要指出的是你的代码只在子类拥有特定的属性时起作用。</p>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>从 <code>ECMAScript 2015</code> , 也就是 <code>ECMAScript 6</code> 开始， <code>JavaScript</code> 中也能使用基于类的面向对象的方式。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="attr">familyName</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">familyName: <span class="built_in">string</span>, givenName: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.familyName = familyName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">say</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Hello, my name is &#x27;</span> + <span class="built_in">this</span>.familyName + <span class="string">&#x27; &#x27;</span> + <span class="built_in">this</span>.givenName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">move</span>(<span class="params">distanceInMeters = <span class="number">0</span></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;$&#123;this.name&#125; moved $&#123;distanceInMeters&#125;m.&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建类实例</span></span><br><span class="line">lei aPerson = <span class="keyword">new</span> Person(<span class="string">&#x27;Wang&#x27;</span>, <span class="string">&#x27;XiaoHong&#x27;</span>, <span class="number">22</span>);</span><br></pre></td></tr></table></figure>

<p>在引用任何一个类的成员时都需要使用 <code>this</code> ，它表示我们访问的是类的成员。</p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>在 <code>TypeScript</code> 中允许使用继承来扩展现有的类。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">familyName: <span class="built_in">string</span>, givenName: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(familyName, givenName, age);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">move</span>(<span class="params">distanceInMeters = <span class="number">5</span></span>)</span> &#123;</span><br><span class="line">			<span class="built_in">super</span>.move(distanceInMeters);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果子类包含了构造函数，它必须调用 <code>super()</code> ，它会执行基类的构造函数。在构造函数中访问 <code>this</code> 的属性之前，一定要先调用 <code>super()</code> 。</p>
<p>子类从父类中继承属性和方法</p>
<h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><ul>
<li><p><code>public</code></p>
<p><code>public</code> 是 <code>TypeScript</code> 中类成员的默认属性</p>
</li>
<li><p><code>private</code></p>
<p>类成员声明为 <code>private</code> 时，不能在生声明它的类的外部访问</p>
</li>
<li><p><code>protected</code></p>
<p>类成员声明为 <code>protected</code> 时，在派生类中仍可访问</p>
<p>构造函数也能被标记为 <code>protected</code> ，这意味着它不能在包含它的类外被实例化，但是能被继承</p>
</li>
<li><p><code>readonly</code></p>
<p>通过 <code>readonly</code> 属性将属性设置为只读，只读属性必须在声明时或构造函数里被初始化</p>
</li>
</ul>
<h4 id="参数属性"><a href="#参数属性" class="headerlink" title="参数属性"></a>参数属性</h4><p>参数属性通过给构造函数参数前添加一个访问限定符来声明。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"><span class="keyword">public</span> familyName: <span class="built_in">string</span>, <span class="keyword">public</span> givenName: <span class="built_in">string</span>, <span class="keyword">public</span> age: <span class="built_in">number</span></span>)</span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过这个特性我们可以方便的在一个地方定义并初始化一个成员。</p>
<h3 id="存取器"><a href="#存取器" class="headerlink" title="存取器"></a>存取器</h3><p><code>TypeScript</code> 支持通过 <code>getters/setters</code> 来截取对对象成员的访问，它们可以有效的控制对对象成员的访问。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">student</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> _familyName: <span class="built_in">string</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">get</span> <span class="title">familyName</span>(): <span class="title">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._familyNmae;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">set</span> <span class="title">familyName</span>(<span class="params">fName: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">		<span class="built_in">this</span>._familyName = fName;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，存取器只支持 <code>ECMAScript 5</code> 或更高，其次，只带有 <code>getter</code> 存取器被推断为 <code>readonly</code>。</p>
<h3 id="静态属性"><a href="#静态属性" class="headerlink" title="静态属性"></a>静态属性</h3><p>类的实例成员是那些仅当类被实例化时才会被初始化的属性，而类的静态成员存在于类本身上面而不是类的实例上。实例想要访问静态属性时，需要在其加上类名。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">student</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> school = <span class="string">&#x27;ts&#x27;</span>;</span><br><span class="line">  ...</span><br><span class="line">  <span class="function"><span class="title">getStudentSchool</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> student.school;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>抽象类一般作为其它派生类的基类使用，一般不会被实例化。不同于接口，抽象类可以包含成员的实现细节。</p>
<p>使用 <code>abstract</code> 关键字定义抽象类和在抽象类中定义抽象方法。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">  <span class="keyword">abstract</span> function_name: return_type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>抽象类中的抽象方法不包含具体实现并且必须在派生类中实现。</p>
<p>抽象方法的语法与接口语法相似，两者都是定义方法签名但不包含方法体。然而，抽象方法必须包含 <code>abstract</code> 关键字并且可以包含访问修饰符。</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>函数是 <code>JavaScript</code> 应用程序的基础。 它帮助你实现抽象层，模拟类，信息隐藏和模块。 在 <code>TypeScript</code> 里，虽然已经支持类，命名空间和模块，但函数仍然是主要的定义行为的地方。 <code>TypeScript</code> 为 <code>JavaScript</code> 函数添加了额外的功能，让我们可以更容易地使用。</p>
<h3 id="函数类型-1"><a href="#函数类型-1" class="headerlink" title="函数类型"></a>函数类型</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params">arg_1: arg_type, arg_2: arg_type, ...</span>): <span class="title">return_type</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>TypeScript</code> 能够通过返回语句自动推断出返回值类型，因此函数返回类型一般是省略的。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fun_var_name: <span class="function">(<span class="params">arg_1: arg_type, arg_2: arg_type, ...</span>) =&gt;</span> return_type;</span><br></pre></td></tr></table></figure>

<p>函数类型包括两部分，参数类型和返回值类型。而且只要参数类型是匹配的，就认为它是有效的函数类型，而不在乎参数名是否准确。</p>
<h3 id="可选参数和默认参数"><a href="#可选参数和默认参数" class="headerlink" title="可选参数和默认参数"></a>可选参数和默认参数</h3><p><code>JavaScript</code> 中函数的每个参数都是可选的，可传可不传，没有传参的时候它的值就是 <code>undefined</code>。而 <code>TypeScript</code> 中函数的每个参数默认情况下都是必须的，编译器检查用户是否为每个参数都传入了值，还会假设只有这些参数被传递进函数-即传递给一个函数的参数个数必须与函数期望的参数个数一致。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myAdd: <span class="function">(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span> = <span class="function"><span class="keyword">function</span> (<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) </span>&#123; </span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sum = myAdd(<span class="number">1</span>); <span class="comment">// error: Expected 2 arugements, but got 1</span></span><br><span class="line"><span class="keyword">const</span> sum1 = myAdd(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// error: Expected 2 arugements, but got 3</span></span><br></pre></td></tr></table></figure>

<p>在 <code>TypeScript</code> 中，可以在参数名称旁使用 <code>?</code> 实现可选参数的功能。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可选参数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildStudent</span>(<span class="params">name: <span class="built_in">string</span>, grade: <span class="built_in">number</span>, gender?: <span class="built_in">string</span></span>) </span>&#123; </span><br><span class="line">  <span class="keyword">return</span> name + <span class="string">&#x27; &#x27;</span> + grade + <span class="string">&#x27; &#x27;</span> + (gender ? gender : <span class="string">&#x27;&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> student_1 = buildStudent(<span class="string">&#x27;Tom&#x27;</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">const</span> student_2 = buildStudent(<span class="string">&#x27;Jerry&#x27;</span>, <span class="number">2</span>, <span class="string">&#x27;male&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>需要注意的是，可选参数必须跟在可选参数后面。</p>
<p>在 <code>TypeScript</code> 中，当用户没有传递这个参数或传递的值是 <code>undefined</code> 时，我们可以为参数提供一个默认值。在所有必须参数后面的带默认初始化的参数都是可选的，与可选参数一样，在调用函数的时候可以省略-即可选参数与末尾的默认参数共享参数类型。</p>
<p>需要注意的是，如果带默认值的参数出现在必须参数之前，用户必须明确的传入 <code>undefined</code> 值来获得默认值。</p>
<h3 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a>剩余参数</h3><p>如果你想同时操作多个参数或不知道会有多少个参数传递进来，在 <code>JavaScript</code> 中，你可以通过 <code>arguments</code> 来访问所有传入的参数，在 <code>TypeScript</code> 中，你则可以将所有参数收集到一个变量里。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 剩余参数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildChildren</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span>, ...restOfProperty: <span class="built_in">string</span>[]</span>) </span>&#123; </span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;name&#125;</span> <span class="subst">$&#123;age&#125;</span> <span class="subst">$&#123;restOfProperty.join(<span class="string">&#x27; &#x27;</span>)&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> children = buildChildren(<span class="string">&#x27;Mike&#x27;</span>, <span class="number">12</span>, <span class="string">&#x27;male&#x27;</span>, <span class="string">&#x27;grade 3&#x27;</span>);</span><br></pre></td></tr></table></figure>



<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>泛型是程序设计语言的一种特性，是程序员在编写代码时定义的一些可变部分，这些部分在使用前必须做出指明。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类型变量 T 会捕获用户传入的类型，之后我们就可以使用者个类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123; </span><br><span class="line">  <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> strId = identity(<span class="string">&#x27;JavaScript&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> numId = identity(<span class="number">12</span>);</span><br></pre></td></tr></table></figure>



<h3 id="泛型变量"><a href="#泛型变量" class="headerlink" title="泛型变量"></a>泛型变量</h3><p>使用泛型函数时，编译器要求你在函数体必须正确的使用这个通用的类型-即你必须把这些参数当做是任意或所有类型。</p>
<h3 id="泛型函数"><a href="#泛型函数" class="headerlink" title="泛型函数"></a>泛型函数</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">combineFunc</span>&lt;<span class="title">T</span>,<span class="title">K</span>&gt;(<span class="params">x: T, y: K</span>): [<span class="title">T</span>, <span class="title">K</span>] </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [T, K];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> combine: &lt;T,K&gt;(x: T, y: K) =&gt; [T,K] = combineFunc;</span><br><span class="line">// or</span><br><span class="line">let combine: &#123; &lt;T,K&gt;(x: T, y: K): [T, K] &#125; = combineFunc;</span><br></pre></td></tr></table></figure>



<h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> CombineFunc &#123;</span><br><span class="line">  &lt;T,K&gt;(x: T, <span class="attr">y</span>: K): [T, K];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> combine: CombineFunc = <span class="function">(<span class="params">x, y</span>) =&gt;</span> [x, y];</span><br></pre></td></tr></table></figure>



<h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CombineFunC</span> </span>&#123;</span><br><span class="line">  <span class="attr">combine</span>: &lt;T,K&gt;(x: T, y: K) =&gt; [T, K];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let combineC: CombineFunC = new CombineFunC&lt;number, number&gt;();</span><br><span class="line">combineC.combine = (x, y) =&gt; [x, y];</span><br></pre></td></tr></table></figure>





<h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>使用枚举可以定义一些带名字的常量，清晰的表达意图或创建一组有区别的用例。<code>TypeScript</code> 支持数字的和基于字符串的枚举。</p>
<h3 id="数字枚举"><a href="#数字枚举" class="headerlink" title="数字枚举"></a>数字枚举</h3><p>数字枚举默认的枚举值是从 0 开始自增长的，如果你为第一个枚举名字指定了一个数字枚举值，则会从这个数字值开始自增长。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">enum</span> Status &#123;</span><br><span class="line">  DELETED = -<span class="number">1</span>,</span><br><span class="line">  VALID,</span><br><span class="line">  UNPAID,</span><br><span class="line">  PAID</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="字符串枚举"><a href="#字符串枚举" class="headerlink" title="字符串枚举"></a>字符串枚举</h3><p>字符串枚举中，每个成员都需要使用字符串字面量或另外一个字符串枚举成员进行初始化。</p>
<p>需要注意的是，字符串枚举没有自增长行为。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">enum</span> StatusTip &#123;</span><br><span class="line">  DELETED = <span class="string">&#x27;Order has been deleted.&#x27;</span>,</span><br><span class="line">  VALID = <span class="string">&#x27;Order is valid.&#x27;</span>,</span><br><span class="line">  UNPAID = <span class="string">&#x27;Order is unpaid.&#x27;</span>,</span><br><span class="line">  PAID = <span class="string">&#x27;Order is paid&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="异构枚举"><a href="#异构枚举" class="headerlink" title="异构枚举"></a>异构枚举</h3><p>枚举可以混合字符串和数字成员。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">enum</span> HeterogeneousEnum &#123;</span><br><span class="line">  NO = <span class="number">0</span>,</span><br><span class="line">  YES = <span class="string">&#x27;Yes&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="计算的和常量成员"><a href="#计算的和常量成员" class="headerlink" title="计算的和常量成员"></a>计算的和常量成员</h3><p>每个枚举成员都带有一个值，它可以是常量或计算出来的。当满足如下条件时，枚举成员被当做常量：</p>
<ul>
<li><p>它是枚举的第一个成员，且没有初始化器，此时它的值为 0</p>
</li>
<li><p>它不带有初始化器且它之前的枚举成员是一个数字常量，此时它的值为上一个枚举成员的值 + 1</p>
</li>
<li><p>枚举成员使用常量枚举表达式初始化。常量枚举表达式是 <code>TypeScript</code> 表达式的子集，它可以在编译阶段求值。当一个表达式满足以下条件时，它就是一个常量枚举表达式：</p>
<ul>
<li><p>一个枚举表达式字面量</p>
</li>
<li><p>一个对之前定义的常量枚举成员的引用</p>
</li>
<li><p>带括号的常量枚举表达式</p>
</li>
<li><p>一元运算符 <code>+ - ~</code> 其中之一应用在了常量枚举表达式</p>
</li>
<li><p>常量枚举表达式作为二元运算符 <code>+, -, *, /, %, &lt;&lt;, &gt;&gt;, &gt;&gt;&gt;, &amp;, |, ^</code> 的操作对象(若常量枚举表达式求值后为 <code>NaN</code> 或 <code>Infinity</code>，则会在编译时报错)</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">enum</span> FileAccess &#123;</span><br><span class="line">  None,</span><br><span class="line">  Read = <span class="number">1</span> &lt;&lt; <span class="number">1</span>,</span><br><span class="line">  Write = <span class="number">1</span> &lt;&lt; <span class="number">2</span>,</span><br><span class="line">  ReadWrite = Read | Write,</span><br><span class="line">  G = <span class="string">&#x27;1024&#x27;</span>.length</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ul>
<h3 id="联合枚举与枚举成员的类型"><a href="#联合枚举与枚举成员的类型" class="headerlink" title="联合枚举与枚举成员的类型"></a>联合枚举与枚举成员的类型</h3><p>存在一种特殊的非计算的常量枚举成员的子集：字面量枚举成员。字面量枚举成员是指不带有初始值的常量枚举成员或是被初始化为</p>
<ul>
<li>任何字符串字面量</li>
<li>任何数字字面量</li>
<li>应用了一元 <code>-</code> 符号的数字字面量</li>
</ul>
<p>当所有枚举成员都拥有字面量枚举值时，它就带有了一种特殊的语义。</p>
<h3 id="运行时枚举"><a href="#运行时枚举" class="headerlink" title="运行时枚举"></a>运行时枚举</h3><p>枚举是在运行时真正存在的对象</p>
<h3 id="反向映射"><a href="#反向映射" class="headerlink" title="反向映射"></a>反向映射</h3><p>数字枚举成员具有从枚举值到枚举名字的反向映射。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">enum</span> Status &#123;</span><br><span class="line">  DELETED = -<span class="number">1</span>,</span><br><span class="line">  VALID,</span><br><span class="line">  UNPAID,</span><br><span class="line">  PAID</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Status[<span class="number">0</span>]); <span class="comment">// VALID</span></span><br></pre></td></tr></table></figure>



<h3 id="const-枚举"><a href="#const-枚举" class="headerlink" title="const 枚举"></a><code>const</code> 枚举</h3><p>常量枚举只能使用常量枚举表达式，并且不同于常规的枚举，它们在编译阶段会被删除-常量枚举成员会在使用的地方被内联进来，这是因为常量枚举不允许包含计算成员。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">enum</span> Directions &#123;</span><br><span class="line">  Up,</span><br><span class="line">  Down,</span><br><span class="line">  Left,</span><br><span class="line">  Right</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> directions = [ Directions.Up, Directions.Down, Directions.Left, Directions.Right ];</span><br></pre></td></tr></table></figure>



<h2 id="类型推论"><a href="#类型推论" class="headerlink" title="类型推论"></a>类型推论</h2><p>类型推论是指能够在编译期间自动推导出值的类型的能力。一般发生在初始化变量和成员，设置默认参数值和决定函数返回值时。</p>
<h3 id="最佳通用类型"><a href="#最佳通用类型" class="headerlink" title="最佳通用类型"></a>最佳通用类型</h3><p>当需要从几个表达式中推断类型时，会使用这几个表达式的类型来推断出一个最合适的通用类型。</p>
<h3 id="上下文类型"><a href="#上下文类型" class="headerlink" title="上下文类型"></a>上下文类型</h3><p>当表达式的类型与所处的位置相关时，类型推论按照上下文归类来推论类型。当然，如果表达式包含了明确的类型信息，上下文的类型会被忽略。</p>
<h2 id="类型兼容性"><a href="#类型兼容性" class="headerlink" title="类型兼容性"></a>类型兼容性</h2><p><code>TypeScript</code> 中的类型兼容性是基于结构子类型的-结构子类型是一种只使用其成员来描述类型的方式。</p>
<h3 id="原始类型和对象类型的兼容性"><a href="#原始类型和对象类型的兼容性" class="headerlink" title="原始类型和对象类型的兼容性"></a>原始类型和对象类型的兼容性</h3><p>如果 x 要兼容 y， 那么 y 至少需要具有与 x 相同的属性。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果 x 要兼容 y， y 至少要与 x 拥有相同的属性</span></span><br><span class="line"><span class="keyword">let</span> x = &#123; <span class="attr">name</span>: <span class="string">&#x27;x&#x27;</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> y = &#123; <span class="attr">name</span>: <span class="string">&#x27;y&#x27;</span>, <span class="attr">alias</span>: <span class="string">&#x27;Y&#x27;</span> &#125;;</span><br><span class="line">x = y;</span><br><span class="line">y = x; <span class="comment">// Property &#x27;alias&#x27; is missing in type &#x27;&#123; name: string; &#125;&#x27; but required in type &#x27;&#123; name: string; alias: string; &#125;</span></span><br></pre></td></tr></table></figure>



<h3 id="函数的类型兼容性"><a href="#函数的类型兼容性" class="headerlink" title="函数的类型兼容性"></a>函数的类型兼容性</h3><p>如果函数 x 要兼容函数 y，那么 x 至少要与 y 具有相同的参数并且返回值类型相同。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> funCom = <span class="function">(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) =&gt;</span> x + y;</span><br><span class="line"><span class="keyword">let</span> funAbc = <span class="function">(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) =&gt;</span> [x, y];</span><br><span class="line"><span class="keyword">let</span> funSub = <span class="function">(<span class="params">x: <span class="built_in">number</span></span>) =&gt;</span> x;</span><br><span class="line"><span class="keyword">let</span> funDef = <span class="function">(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) =&gt;</span> x * y;</span><br><span class="line">funCom = funSub;</span><br><span class="line">funSub = funCom; <span class="comment">// Type &#x27;(x: number, y: number) =&gt; number&#x27; is not assignable to type &#x27;(x: number) =&gt; number&#x27;</span></span><br><span class="line">funCom = funAbc; <span class="comment">// Type &#x27;(x: number, y: number) =&gt; number[]&#x27; is not assignable to type &#x27;(x: number, y: number) =&gt; number&#x27;.Type &#x27;number[]&#x27; is not assignable to type &#x27;number&#x27;</span></span><br><span class="line">funCom = funDef;</span><br></pre></td></tr></table></figure>



<h3 id="类的兼容性"><a href="#类的兼容性" class="headerlink" title="类的兼容性"></a>类的兼容性</h3><p>比较两个类类型的对象时，只有实例的成员会被比较。 静态成员和构造函数不在比较的范围内。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">W</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> sign: <span class="built_in">string</span> = <span class="string">&#x27;AAAAA&#x27;</span>;</span><br><span class="line">  pro: <span class="built_in">string</span> = <span class="string">&#x27;W&#x27;</span>;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Y</span> </span>&#123;</span><br><span class="line">  <span class="attr">pro</span>: <span class="built_in">string</span> = <span class="string">&#x27;W&#x27;</span>;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">length: <span class="built_in">number</span></span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> wC = <span class="keyword">new</span> W(<span class="string">&#x27;W&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> yC = <span class="keyword">new</span> Y(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">wC = yC; <span class="comment">// OK</span></span><br><span class="line">yC = wC; <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>

<p>类的私有成员和受保护成员会影响兼容性。 当检查类实例的兼容时，如果目标类型包含一个私有成员，那么源类型必须包含来自同一个类的这个私有成员。 同样地，这条规则也适用于包含受保护成员实例的类型检查。 这允许子类赋值给父类，但是不能赋值给其它有同样类型的类。</p>
<h3 id="泛型的兼容性"><a href="#泛型的兼容性" class="headerlink" title="泛型的兼容性"></a>泛型的兼容性</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> NotEmpty&lt;T&gt; &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> gA: NotEmpty&lt;<span class="built_in">number</span>&gt;;</span><br><span class="line"><span class="keyword">let</span> gB: NotEmpty&lt;<span class="built_in">string</span>&gt;;</span><br><span class="line">gA = gB; <span class="comment">// ok</span></span><br></pre></td></tr></table></figure>



<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> NotEmpty&lt;T&gt; &#123;</span><br><span class="line">  <span class="attr">data</span>: T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> gA: NotEmpty&lt;<span class="built_in">number</span>&gt;;</span><br><span class="line"><span class="keyword">let</span> gB: NotEmpty&lt;<span class="built_in">string</span>&gt;;</span><br><span class="line">gA = gB; <span class="comment">// Error</span></span><br></pre></td></tr></table></figure>



<h2 id="高级类型"><a href="#高级类型" class="headerlink" title="高级类型"></a>高级类型</h2><h3 id="交叉类型"><a href="#交叉类型" class="headerlink" title="交叉类型"></a>交叉类型</h3><p>交叉类型是将多个类型合并为一个类型。 这让我们可以把现有的多种类型叠加到一起成为一种类型，它包含了所需的所有类型的特性。</p>
<h3 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h3><p>联合类型表示一个值可以是几种类型之一。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/ 联合类型</span><br><span class="line"><span class="comment">// 联合类型表示一个值可以是几个类型之一</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pad</span>(<span class="params">padding: <span class="built_in">number</span> | <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> padding;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(pad(<span class="number">1</span>));</span><br><span class="line"><span class="built_in">console</span>.log(pad(<span class="string">&#x27;A&#x27;</span>));</span><br></pre></td></tr></table></figure>

<p>如果一个值是联合类型，我们只能访问联合类型所有类型里共有的成员</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Elephant &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  walk();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Shark &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  swim();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAnimal</span>(<span class="params"></span>): <span class="title">Elephant</span> | <span class="title">Shark</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">name</span>: <span class="string">&#x27;Elephant&#x27;</span>, <span class="function"><span class="title">walk</span>(<span class="params"></span>)</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;walk&#x27;</span>) &#125; &#125; <span class="keyword">as</span> Elephant;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> aAnimal = getAnimal();</span><br><span class="line"><span class="built_in">console</span>.log(aAnimal.name);</span><br><span class="line">aAnimal.walk();</span><br><span class="line">aAnimal.swim();</span><br></pre></td></tr></table></figure>



</div><div class="article-licensing box"><div class="licensing-title"><p>TypeScript 概览</p><p><a href="https://cocoalei.github.io/blogs/2019/09/13/typescript-tutorial/">https://cocoalei.github.io/blogs/2019/09/13/typescript-tutorial/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>Y2hlbmdsZWk=</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2019-09-13</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2021-09-01</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2020/06/16/Vue3%20%E6%95%B0%E6%8D%AE%E4%BE%A6%E6%B5%8B%E5%8E%9F%E7%90%86/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Vue 3 原理解析 - 数据侦测原理</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2019/06/26/JavaScript%20%E6%93%8D%E4%BD%9C%E7%AC%A6/"><span class="level-item">JavaScript 操作符</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="LeiTech"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">LeiTech</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>China</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">51</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">10</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">4</p></a></div></div></nav><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="/"><i class="fab fa-github"></i></a></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/CS/"><span class="level-start"><span class="level-item">CS</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/Git/"><span class="level-start"><span class="level-item">Git</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/GoLang/"><span class="level-start"><span class="level-item">GoLang</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/JavaScript/"><span class="level-start"><span class="level-item">JavaScript</span></span><span class="level-end"><span class="level-item tag">19</span></span></a></li><li><a class="level is-mobile" href="/categories/Mac/"><span class="level-start"><span class="level-item">Mac</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/TypeScript/"><span class="level-start"><span class="level-item">TypeScript</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Vue/"><span class="level-start"><span class="level-item">Vue</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Web/"><span class="level-start"><span class="level-item">Web</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/iOS/"><span class="level-start"><span class="level-item">iOS</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"><span class="level-start"><span class="level-item">大前端</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></div></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2021/05/"><span class="level-start"><span class="level-item">五月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/01/"><span class="level-start"><span class="level-item">一月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/12/"><span class="level-start"><span class="level-item">十二月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/06/"><span class="level-start"><span class="level-item">六月 2020</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/09/"><span class="level-start"><span class="level-item">九月 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/06/"><span class="level-start"><span class="level-item">六月 2019</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/04/"><span class="level-start"><span class="level-item">四月 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/03/"><span class="level-start"><span class="level-item">三月 2019</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/02/"><span class="level-start"><span class="level-item">二月 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/12/"><span class="level-start"><span class="level-item">十二月 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/09/"><span class="level-start"><span class="level-item">九月 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/07/"><span class="level-start"><span class="level-item">七月 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/06/"><span class="level-start"><span class="level-item">六月 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/05/"><span class="level-start"><span class="level-item">五月 2018</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/04/"><span class="level-start"><span class="level-item">四月 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/03/"><span class="level-start"><span class="level-item">三月 2018</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/02/"><span class="level-start"><span class="level-item">二月 2018</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/01/"><span class="level-start"><span class="level-item">一月 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/05/"><span class="level-start"><span class="level-item">五月 2017</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/04/"><span class="level-start"><span class="level-item">四月 2017</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2016/06/"><span class="level-start"><span class="level-item">六月 2016</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2016/04/"><span class="level-start"><span class="level-item">四月 2016</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2016/03/"><span class="level-start"><span class="level-item">三月 2016</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2016/02/"><span class="level-start"><span class="level-item">二月 2016</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2016/01/"><span class="level-start"><span class="level-item">一月 2016</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/archives/2015/12/"><span class="level-start"><span class="level-item">十二月 2015</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2015/11/"><span class="level-start"><span class="level-item">十一月 2015</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2015/10/"><span class="level-start"><span class="level-item">十月 2015</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2015/09/"><span class="level-start"><span class="level-item">九月 2015</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Git/"><span class="tag">Git</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/GoLang/"><span class="tag">GoLang</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/JavaScript/"><span class="tag">JavaScript</span><span class="tag">12</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Web/"><span class="tag">Web</span><span class="tag">3</span></a></div></div></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#TypeScript"><span class="level-left"><span class="level-item">1</span><span class="level-item">TypeScript</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#基础类型"><span class="level-left"><span class="level-item">1.1</span><span class="level-item">基础类型</span></span></a></li><li><a class="level is-mobile" href="#变量声明"><span class="level-left"><span class="level-item">1.2</span><span class="level-item">变量声明</span></span></a></li><li><a class="level is-mobile" href="#接口"><span class="level-left"><span class="level-item">1.3</span><span class="level-item">接口</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#可选属性"><span class="level-left"><span class="level-item">1.3.1</span><span class="level-item">可选属性</span></span></a></li><li><a class="level is-mobile" href="#只读属性"><span class="level-left"><span class="level-item">1.3.2</span><span class="level-item">只读属性</span></span></a></li><li><a class="level is-mobile" href="#额外的类型检查"><span class="level-left"><span class="level-item">1.3.3</span><span class="level-item">额外的类型检查</span></span></a></li><li><a class="level is-mobile" href="#函数类型"><span class="level-left"><span class="level-item">1.3.4</span><span class="level-item">函数类型</span></span></a></li><li><a class="level is-mobile" href="#可索引的类型"><span class="level-left"><span class="level-item">1.3.5</span><span class="level-item">可索引的类型</span></span></a></li><li><a class="level is-mobile" href="#类类型"><span class="level-left"><span class="level-item">1.3.6</span><span class="level-item">类类型</span></span></a></li><li><a class="level is-mobile" href="#类静态部分与实例部分的区别"><span class="level-left"><span class="level-item">1.3.7</span><span class="level-item">类静态部分与实例部分的区别</span></span></a></li><li><a class="level is-mobile" href="#继承接口"><span class="level-left"><span class="level-item">1.3.8</span><span class="level-item">继承接口</span></span></a></li><li><a class="level is-mobile" href="#混合类型"><span class="level-left"><span class="level-item">1.3.9</span><span class="level-item">混合类型</span></span></a></li><li><a class="level is-mobile" href="#接口继承类"><span class="level-left"><span class="level-item">1.3.10</span><span class="level-item">接口继承类</span></span></a></li></ul></li><li><a class="level is-mobile" href="#类"><span class="level-left"><span class="level-item">1.4</span><span class="level-item">类</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#继承"><span class="level-left"><span class="level-item">1.4.1</span><span class="level-item">继承</span></span></a></li><li><a class="level is-mobile" href="#修饰符"><span class="level-left"><span class="level-item">1.4.2</span><span class="level-item">修饰符</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#参数属性"><span class="level-left"><span class="level-item">1.4.2.1</span><span class="level-item">参数属性</span></span></a></li></ul></li><li><a class="level is-mobile" href="#存取器"><span class="level-left"><span class="level-item">1.4.3</span><span class="level-item">存取器</span></span></a></li><li><a class="level is-mobile" href="#静态属性"><span class="level-left"><span class="level-item">1.4.4</span><span class="level-item">静态属性</span></span></a></li><li><a class="level is-mobile" href="#抽象类"><span class="level-left"><span class="level-item">1.4.5</span><span class="level-item">抽象类</span></span></a></li></ul></li><li><a class="level is-mobile" href="#函数"><span class="level-left"><span class="level-item">1.5</span><span class="level-item">函数</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#函数类型-1"><span class="level-left"><span class="level-item">1.5.1</span><span class="level-item">函数类型</span></span></a></li><li><a class="level is-mobile" href="#可选参数和默认参数"><span class="level-left"><span class="level-item">1.5.2</span><span class="level-item">可选参数和默认参数</span></span></a></li><li><a class="level is-mobile" href="#剩余参数"><span class="level-left"><span class="level-item">1.5.3</span><span class="level-item">剩余参数</span></span></a></li></ul></li><li><a class="level is-mobile" href="#泛型"><span class="level-left"><span class="level-item">1.6</span><span class="level-item">泛型</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#泛型变量"><span class="level-left"><span class="level-item">1.6.1</span><span class="level-item">泛型变量</span></span></a></li><li><a class="level is-mobile" href="#泛型函数"><span class="level-left"><span class="level-item">1.6.2</span><span class="level-item">泛型函数</span></span></a></li><li><a class="level is-mobile" href="#泛型接口"><span class="level-left"><span class="level-item">1.6.3</span><span class="level-item">泛型接口</span></span></a></li><li><a class="level is-mobile" href="#泛型类"><span class="level-left"><span class="level-item">1.6.4</span><span class="level-item">泛型类</span></span></a></li></ul></li><li><a class="level is-mobile" href="#枚举"><span class="level-left"><span class="level-item">1.7</span><span class="level-item">枚举</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#数字枚举"><span class="level-left"><span class="level-item">1.7.1</span><span class="level-item">数字枚举</span></span></a></li><li><a class="level is-mobile" href="#字符串枚举"><span class="level-left"><span class="level-item">1.7.2</span><span class="level-item">字符串枚举</span></span></a></li><li><a class="level is-mobile" href="#异构枚举"><span class="level-left"><span class="level-item">1.7.3</span><span class="level-item">异构枚举</span></span></a></li><li><a class="level is-mobile" href="#计算的和常量成员"><span class="level-left"><span class="level-item">1.7.4</span><span class="level-item">计算的和常量成员</span></span></a></li><li><a class="level is-mobile" href="#联合枚举与枚举成员的类型"><span class="level-left"><span class="level-item">1.7.5</span><span class="level-item">联合枚举与枚举成员的类型</span></span></a></li><li><a class="level is-mobile" href="#运行时枚举"><span class="level-left"><span class="level-item">1.7.6</span><span class="level-item">运行时枚举</span></span></a></li><li><a class="level is-mobile" href="#反向映射"><span class="level-left"><span class="level-item">1.7.7</span><span class="level-item">反向映射</span></span></a></li><li><a class="level is-mobile" href="#const-枚举"><span class="level-left"><span class="level-item">1.7.8</span><span class="level-item">const 枚举</span></span></a></li></ul></li><li><a class="level is-mobile" href="#类型推论"><span class="level-left"><span class="level-item">1.8</span><span class="level-item">类型推论</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#最佳通用类型"><span class="level-left"><span class="level-item">1.8.1</span><span class="level-item">最佳通用类型</span></span></a></li><li><a class="level is-mobile" href="#上下文类型"><span class="level-left"><span class="level-item">1.8.2</span><span class="level-item">上下文类型</span></span></a></li></ul></li><li><a class="level is-mobile" href="#类型兼容性"><span class="level-left"><span class="level-item">1.9</span><span class="level-item">类型兼容性</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#原始类型和对象类型的兼容性"><span class="level-left"><span class="level-item">1.9.1</span><span class="level-item">原始类型和对象类型的兼容性</span></span></a></li><li><a class="level is-mobile" href="#函数的类型兼容性"><span class="level-left"><span class="level-item">1.9.2</span><span class="level-item">函数的类型兼容性</span></span></a></li><li><a class="level is-mobile" href="#类的兼容性"><span class="level-left"><span class="level-item">1.9.3</span><span class="level-item">类的兼容性</span></span></a></li><li><a class="level is-mobile" href="#泛型的兼容性"><span class="level-left"><span class="level-item">1.9.4</span><span class="level-item">泛型的兼容性</span></span></a></li></ul></li><li><a class="level is-mobile" href="#高级类型"><span class="level-left"><span class="level-item">1.10</span><span class="level-item">高级类型</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#交叉类型"><span class="level-left"><span class="level-item">1.10.1</span><span class="level-item">交叉类型</span></span></a></li><li><a class="level is-mobile" href="#联合类型"><span class="level-left"><span class="level-item">1.10.2</span><span class="level-item">联合类型</span></span></a></li></ul></li></ul></li></ul></div></div><script src="/js/toc.js" defer></script></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="关于代码的碎碎念" height="28"></a><p class="is-size-7"><span>&copy; 2021 Y2hlbmdsZWk=</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>